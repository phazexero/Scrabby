<html><head><title>cuSOLVER</title></head><body><body class="wy-body-for-nav">
 <a href="https://docs.nvidia.com/cuda/cusolver/contents.html">
 </a>
 <ul class="current">
  <li class="toctree-l1 current">
   <a class="current reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html">
    1. Introduction
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-dense-lapack">
      1.1. cuSolverDN: Dense LAPACK
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolversp-sparse-lapack">
      1.2. cuSolverSP: Sparse LAPACK
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrf-refactorization">
      1.3. cuSolverRF: Refactorization
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#naming-conventions">
      1.4. Naming Conventions
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#asynchronous-execution">
      1.5. Asynchronous Execution
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#library-property">
      1.6. Library Property
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#high-precision-package">
      1.7. High Precision Package
     </a>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#using-the-cusolver-api">
    2. Using the CUSOLVER API
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#general-description">
      2.1. General Description
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#thread-safety">
        2.1.1. Thread Safety
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#scalar-parameters">
        2.1.2. Scalar Parameters
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#parallelism-with-streams">
        2.1.3. Parallelism with Streams
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#how-to-link-cusolver-library">
        2.1.4. How to Link cusolver Library
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#link-third-party-lapack-library">
        2.1.5. Link Third-party LAPACK Library
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#convention-of-info">
        2.1.6. Convention of info
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#usage-of-buffersize">
        2.1.7. Usage of _bufferSize
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-logging">
        2.1.8. cuSOLVERDn Logging
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#deterministic-results">
        2.1.9. Deterministic Results
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolver-types-reference">
      2.2. cuSolver Types Reference
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-types">
        2.2.1. cuSolverDN Types
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnhandle-t">
          2.2.1.1. cusolverDnHandle_t
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cublasfillmode-t">
          2.2.1.2. cublasFillMode_t
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cublasoperation-t">
          2.2.1.3. cublasOperation_t
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvereigtype-t">
          2.2.1.4. cusolverEigType_t
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvereigmode-t">
          2.2.1.5. cusolverEigMode_t
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverirsrefinement-t">
          2.2.1.6. cusolverIRSRefinement_t
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsparams-t">
          2.2.1.7. cusolverDnIRSParams_t
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsinfos-t">
          2.2.1.8. cusolverDnIRSInfos_t
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnfunction-t">
          2.2.1.9. cusolverDnFunction_t
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolveralgmode-t">
          2.2.1.10. cusolverAlgMode_t
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverstatus-t">
          2.2.1.11. cusolverStatus_t
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnloggercallback-t">
          2.2.1.12. cusolverDnLoggerCallback_t
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdeterministicmode-t">
          2.2.1.13. cusolverDeterministicMode_t
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverstorevmode-t">
          2.2.1.14. cusolverStorevMode_t
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdirectmode-t">
          2.2.1.15. cusolverDirectMode_t
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolversp-types">
        2.2.2. cuSolverSP Types
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolversphandle-t">
          2.2.2.1. cusolverSpHandle_t
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusparsematdescr-t">
          2.2.2.2. cusparseMatDescr_t
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#id5">
          2.2.2.3. cusolverStatus_t
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrf-types">
        2.2.3. cuSolverRF Types
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfhandle-t">
          2.2.3.1. cusolverRfHandle_t
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfmatrixformat-t">
          2.2.3.2. cusolverRfMatrixFormat_t
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfnumericboostreport-t">
          2.2.3.3. cusolverRfNumericBoostReport_t
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfresetvaluesfastmode-t">
          2.2.3.4. cusolverRfResetValuesFastMode_t
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrffactorization-t">
          2.2.3.5. cusolverRfFactorization_t
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrftriangularsolve-t">
          2.2.3.6. cusolverRfTriangularSolve_t
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfunitdiagonal-t">
          2.2.3.7. cusolverRfUnitDiagonal_t
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#id7">
          2.2.3.8. cusolverStatus_t
         </a>
        </li>
       </ul>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolver-formats-reference">
      2.3. cuSolver Formats Reference
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#index-base-format">
        2.3.1. Index Base Format
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#vector-dense-format">
        2.3.2. Vector (Dense) Format
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#matrix-dense-format">
        2.3.3. Matrix (Dense) Format
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#matrix-csr-format">
        2.3.4. Matrix (CSR) Format
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#matrix-csc-format">
        2.3.5. Matrix (CSC) Format
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-dense-lapack-function-reference">
      2.4. cuSolverDN: dense LAPACK Function Reference
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-helper-function-reference">
        2.4.1. cuSolverDN Helper Function Reference
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdncreate">
          2.4.1.1. cusolverDnCreate()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdndestroy">
          2.4.1.2. cusolverDnDestroy()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnsetstream">
          2.4.1.3. cusolverDnSetStream()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdngetstream">
          2.4.1.4. cusolverDnGetStream()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnloggersetcallback">
          2.4.1.5. cusolverDnLoggerSetCallback()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnloggersetfile">
          2.4.1.6. cusolverDnLoggerSetFile()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnloggeropenfile">
          2.4.1.7. cusolverDnLoggerOpenFile()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnloggersetlevel">
          2.4.1.8. cusolverDnLoggerSetLevel()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnloggersetmask">
          2.4.1.9. cusolverDnLoggerSetMask()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnloggerforcedisable">
          2.4.1.10. cusolverDnLoggerForceDisable()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnsetdeterministicmode">
          2.4.1.11. cusolverDnSetDeterministicMode()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdngetdeterministicmode">
          2.4.1.12. cusolverDnGetDeterministicMode()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdncreatesyevjinfo">
          2.4.1.13. cusolverDnCreateSyevjInfo()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdndestroysyevjinfo">
          2.4.1.14. cusolverDnDestroySyevjInfo()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxsyevjsettolerance">
          2.4.1.15. cusolverDnXsyevjSetTolerance()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxsyevjsetmaxsweeps">
          2.4.1.16. cusolverDnXsyevjSetMaxSweeps()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxsyevjsetsorteig">
          2.4.1.17. cusolverDnXsyevjSetSortEig()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxsyevjgetresidual">
          2.4.1.18. cusolverDnXsyevjGetResidual()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxsyevjgetsweeps">
          2.4.1.19. cusolverDnXsyevjGetSweeps()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdncreategesvdjinfo">
          2.4.1.20. cusolverDnCreateGesvdjInfo()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdndestroygesvdjinfo">
          2.4.1.21. cusolverDnDestroyGesvdjInfo()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxgesvdjsettolerance">
          2.4.1.22. cusolverDnXgesvdjSetTolerance()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxgesvdjsetmaxsweeps">
          2.4.1.23. cusolverDnXgesvdjSetMaxSweeps()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxgesvdjsetsorteig">
          2.4.1.24. cusolverDnXgesvdjSetSortEig()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxgesvdjgetresidual">
          2.4.1.25. cusolverDnXgesvdjGetResidual()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxgesvdjgetsweeps">
          2.4.1.26. cusolverDnXgesvdjGetSweeps()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsparamscreate">
          2.4.1.27. cusolverDnIRSParamsCreate()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsparamsdestroy">
          2.4.1.28. cusolverDnIRSParamsDestroy()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsparamssetsolverprecisions">
          2.4.1.29. cusolverDnIRSParamsSetSolverPrecisions()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsparamssetsolvermainprecision">
          2.4.1.30. cusolverDnIRSParamsSetSolverMainPrecision()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsparamssetsolverlowestprecision">
          2.4.1.31. cusolverDnIRSParamsSetSolverLowestPrecision()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsparamssetrefinementsolver">
          2.4.1.32. cusolverDnIRSParamsSetRefinementSolver()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsparamssettol">
          2.4.1.33. cusolverDnIRSParamsSetTol()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsparamssettolinner">
          2.4.1.34. cusolverDnIRSParamsSetTolInner()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsparamssetmaxiters">
          2.4.1.35. cusolverDnIRSParamsSetMaxIters()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsparamssetmaxitersinner">
          2.4.1.36. cusolverDnIRSParamsSetMaxItersInner()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsparamsenablefallback">
          2.4.1.37. cusolverDnIRSParamsEnableFallback()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsparamsdisablefallback">
          2.4.1.38. cusolverDnIRSParamsDisableFallback()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsparamsgetmaxiters">
          2.4.1.39. cusolverDnIRSParamsGetMaxIters()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsinfoscreate">
          2.4.1.40. cusolverDnIRSInfosCreate()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsinfosdestroy">
          2.4.1.41. cusolverDnIRSInfosDestroy()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsinfosgetmaxiters">
          2.4.1.42. cusolverDnIRSInfosGetMaxIters()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsinfosgetniters">
          2.4.1.43. cusolverDnIRSInfosGetNiters()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsinfosgetouterniters">
          2.4.1.44. cusolverDnIRSInfosGetOuterNiters()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsinfosrequestresidual">
          2.4.1.45. cusolverDnIRSInfosRequestResidual()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsinfosgetresidualhistory">
          2.4.1.46. cusolverDnIRSInfosGetResidualHistory()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdncreateparams">
          2.4.1.47. cusolverDnCreateParams()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdndestroyparams">
          2.4.1.48. cusolverDnDestroyParams()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnsetadvoptions">
          2.4.1.49. cusolverDnSetAdvOptions()
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#dense-linear-solver-reference-legacy">
        2.4.2. Dense Linear Solver Reference (legacy)
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-potrf">
          2.4.2.1. cusolverDn&lt;t&gt;potrf()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnpotrf-deprecated">
          2.4.2.2. cusolverDnPotrf()[DEPRECATED]
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-potrs">
          2.4.2.3. cusolverDn&lt;t&gt;potrs()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnpotrs-deprecated">
          2.4.2.4. cusolverDnPotrs()[DEPRECATED]
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-potri">
          2.4.2.5. cusolverDn&lt;t&gt;potri()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-getrf">
          2.4.2.6. cusolverDn&lt;t&gt;getrf()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdngetrf-deprecated">
          2.4.2.7. cusolverDnGetrf()[DEPRECATED]
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-getrs">
          2.4.2.8. cusolverDn&lt;t&gt;getrs()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdngetrs-deprecated">
          2.4.2.9. cusolverDnGetrs()[DEPRECATED]
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t1-t2-gesv">
          2.4.2.10. cusolverDn&lt;t1&gt;&lt;t2&gt;gesv()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsxgesv">
          2.4.2.11. cusolverDnIRSXgesv()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-geqrf">
          2.4.2.12. cusolverDn&lt;t&gt;geqrf()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdngeqrf-deprecated">
          2.4.2.13. cusolverDnGeqrf()[DEPRECATED]
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t1-t2-gels">
          2.4.2.14. cusolverDn&lt;t1&gt;&lt;t2&gt;gels()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsxgels">
          2.4.2.15. cusolverDnIRSXgels()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-ormqr">
          2.4.2.16. cusolverDn&lt;t&gt;ormqr()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-orgqr">
          2.4.2.17. cusolverDn&lt;t&gt;orgqr()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-sytrf">
          2.4.2.18. cusolverDn&lt;t&gt;sytrf()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-potrfbatched">
          2.4.2.19. cusolverDn&lt;t&gt;potrfBatched()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-potrsbatched">
          2.4.2.20. cusolverDn&lt;t&gt;potrsBatched()
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#dense-eigenvalue-solver-reference-legacy">
        2.4.3. Dense Eigenvalue Solver Reference (legacy)
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-gebrd">
          2.4.3.1. cusolverDn&lt;t&gt;gebrd()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-orgbr">
          2.4.3.2. cusolverDn&lt;t&gt;orgbr()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-sytrd">
          2.4.3.3. cusolverDn&lt;t&gt;sytrd()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-ormtr">
          2.4.3.4. cusolverDn&lt;t&gt;ormtr()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-orgtr">
          2.4.3.5. cusolverDn&lt;t&gt;orgtr()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-gesvd">
          2.4.3.6. cusolverDn&lt;t&gt;gesvd()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdngesvd-deprecated">
          2.4.3.7. cusolverDnGesvd()[DEPRECATED]
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-gesvdj">
          2.4.3.8. cusolverDn&lt;t&gt;gesvdj()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-gesvdjbatched">
          2.4.3.9. cusolverDn&lt;t&gt;gesvdjBatched()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-gesvdastridedbatched">
          2.4.3.10. cusolverDn&lt;t&gt;gesvdaStridedBatched()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-syevd">
          2.4.3.11. cusolverDn&lt;t&gt;syevd()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnsyevd-deprecated">
          2.4.3.12. cusolverDnSyevd()[DEPRECATED]
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-syevdx">
          2.4.3.13. cusolverDn&lt;t&gt;syevdx()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnsyevdx-deprecated">
          2.4.3.14. cusolverDnSyevdx()[DEPRECATED]
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-sygvd">
          2.4.3.15. cusolverDn&lt;t&gt;sygvd()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-sygvdx">
          2.4.3.16. cusolverDn&lt;t&gt;sygvdx()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-syevj">
          2.4.3.17. cusolverDn&lt;t&gt;syevj()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-sygvj">
          2.4.3.18. cusolverDn&lt;t&gt;sygvj()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-syevjbatched">
          2.4.3.19. cusolverDn&lt;t&gt;syevjBatched()
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#dense-linear-solver-reference-64-bit-api">
        2.4.4. Dense Linear Solver Reference (64-bit API)
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxpotrf">
          2.4.4.1. cusolverDnXpotrf()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxpotrs">
          2.4.4.2. cusolverDnXpotrs()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxgetrf">
          2.4.4.3. cusolverDnXgetrf()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxgetrs">
          2.4.4.4. cusolverDnXgetrs()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxgeqrf">
          2.4.4.5. cusolverDnXgeqrf()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxsytrs">
          2.4.4.6. cusolverDnXsytrs()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxtrtri">
          2.4.4.7. cusolverDnXtrtri()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxlarft">
          2.4.4.8. cusolverDnXlarft()
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#dense-eigenvalue-solver-reference-64-bit-api">
        2.4.5. Dense Eigenvalue Solver Reference (64-bit API)
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxgesvd">
          2.4.5.1. cusolverDnXgesvd()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxgesvdp">
          2.4.5.2. cusolverDnXgesvdp()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxgesvdr">
          2.4.5.3. cusolverDnXgesvdr()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxsyevd">
          2.4.5.4. cusolverDnXsyevd()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxsyevdx">
          2.4.5.5. cusolverDnXsyevdx()
         </a>
        </li>
       </ul>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolversp-sparse-lapack-function-reference">
      2.5. cuSolverSP: sparse LAPACK Function Reference
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#helper-function-reference">
        2.5.1. Helper Function Reference
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverspcreate">
          2.5.1.1. cusolverSpCreate()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverspdestroy">
          2.5.1.2. cusolverSpDestroy()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverspsetstream">
          2.5.1.3. cusolverSpSetStream()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverspxcsrissym">
          2.5.1.4. cusolverSpXcsrissym()
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#high-level-function-reference">
        2.5.2. High Level Function Reference
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolversp-t-csrlsvlu">
          2.5.2.1. cusolverSp&lt;t&gt;csrlsvlu()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolversp-t-csrlsvqr">
          2.5.2.2. cusolverSp&lt;t&gt;csrlsvqr()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolversp-t-csrlsvchol">
          2.5.2.3. cusolverSp&lt;t&gt;csrlsvchol()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolversp-t-csrlsqvqr">
          2.5.2.4. cusolverSp&lt;t&gt;csrlsqvqr()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolversp-t-csreigvsi">
          2.5.2.5. cusolverSp&lt;t&gt;csreigvsi()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolversp-t-csreigs">
          2.5.2.6. cusolverSp&lt;t&gt;csreigs()
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#low-level-function-reference">
        2.5.3. Low Level Function Reference
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverspxcsrsymrcm">
          2.5.3.1. cusolverSpXcsrsymrcm()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverspxcsrsymmdq">
          2.5.3.2. cusolverSpXcsrsymmdq()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverspxcsrsymamd">
          2.5.3.3. cusolverSpXcsrsymamd()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverspxcsrmetisnd">
          2.5.3.4. cusolverSpXcsrmetisnd()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverspxcsrzfd">
          2.5.3.5. cusolverSpXcsrzfd()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverspxcsrperm">
          2.5.3.6. cusolverSpXcsrperm()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverspxcsrqrbatched">
          2.5.3.7. cusolverSpXcsrqrBatched()
         </a>
        </li>
       </ul>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrf-refactorization-reference">
      2.6. cuSolverRF: Refactorization Reference
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfaccessbundledfactors">
        2.6.1. cusolverRfAccessBundledFactors()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfanalyze">
        2.6.2. cusolverRfAnalyze()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfsetupdevice">
        2.6.3. cusolverRfSetupDevice()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfsetuphost">
        2.6.4. cusolverRfSetupHost()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfcreate">
        2.6.5. cusolverRfCreate()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfextractbundledfactorshost">
        2.6.6. cusolverRfExtractBundledFactorsHost()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfextractsplitfactorshost">
        2.6.7. cusolverRfExtractSplitFactorsHost()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfdestroy">
        2.6.8. cusolverRfDestroy()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfgetmatrixformat">
        2.6.9. cusolverRfGetMatrixFormat()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfgetnumericproperties">
        2.6.10. cusolverRfGetNumericProperties()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfgetnumericboostreport">
        2.6.11. cusolverRfGetNumericBoostReport()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfgetresetvaluesfastmode">
        2.6.12. cusolverRfGetResetValuesFastMode()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfget-algs">
        2.6.13. cusolverRfGet_Algs()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfrefactor">
        2.6.14. cusolverRfRefactor()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfresetvalues">
        2.6.15. cusolverRfResetValues()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfsetmatrixformat">
        2.6.16. cusolverRfSetMatrixFormat()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfsetnumericproperties">
        2.6.17. cusolverRfSetNumericProperties()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfsetresetvaluesfastmode">
        2.6.18. cusolverRfSetResetValuesFastMode()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfsetalgs">
        2.6.19. cusolverRfSetAlgs()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfsolve">
        2.6.20. cusolverRfSolve()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfbatchsetuphost">
        2.6.21. cusolverRfBatchSetupHost()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfbatchanalyze">
        2.6.22. cusolverRfBatchAnalyze()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfbatchresetvalues">
        2.6.23. cusolverRfBatchResetValues()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfbatchrefactor">
        2.6.24. cusolverRfBatchRefactor()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfbatchsolve">
        2.6.25. cusolverRfBatchSolve()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfbatchzeropivot">
        2.6.26. cusolverRfBatchZeroPivot()
       </a>
      </li>
     </ul>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#using-the-cusolvermg-api">
    3. Using the CUSOLVERMG API
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#id17">
      3.1. General Description
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#id18">
        3.1.1. Thread Safety
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#determinism">
        3.1.2. Determinism
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#tile-strategy">
        3.1.3. Tile Strategy
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#global-matrix-versus-local-matrix">
        3.1.4. Global Matrix Versus Local Matrix
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#id19">
        3.1.5. Usage of _bufferSize
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#synchronization">
        3.1.6. Synchronization
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#context-switch">
        3.1.7. Context Switch
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#nvlink">
        3.1.8. NVLINK
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermg-types-reference">
      3.2. cuSolverMG Types Reference
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermg-types">
        3.2.1. cuSolverMG Types
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermghandle-t">
        3.2.2. cusolverMgHandle_t
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermggridmapping-t">
        3.2.3. cusolverMgGridMapping_t
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cudalibmggrid-t">
        3.2.4. cudaLibMgGrid_t
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cudalibmgmatrixdesc-t">
        3.2.5. cudaLibMgMatrixDesc_t
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#id20">
      3.3. Helper Function Reference
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermgcreate">
        3.3.1. cusolverMgCreate()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermgdestroy">
        3.3.2. cusolverMgDestroy()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermgdeviceselect">
        3.3.3. cusolverMgDeviceSelect()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermgcreatedevicegrid">
        3.3.4. cusolverMgCreateDeviceGrid()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermgdestroygrid">
        3.3.5. cusolverMgDestroyGrid()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermgcreatematdescr">
        3.3.6. cusolverMgCreateMatDescr()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermgdestroymatrixdesc">
        3.3.7. cusolverMgDestroyMatrixDesc()
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#dense-linear-solver-reference">
      3.4. Dense Linear Solver Reference
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermgpotrf">
        3.4.1. cusolverMgPotrf()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermgpotrs">
        3.4.2. cusolverMgPotrs()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermgpotri">
        3.4.3. cusolverMgPotri()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermggetrf">
        3.4.4. cusolverMgGetrf()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermggetrs">
        3.4.5. cusolverMgGetrs()
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#dense-eigenvalue-solver-reference">
      3.5. Dense Eigenvalue Solver Reference
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermgsyevd">
        3.5.1. cusolverMgSyevd()
       </a>
      </li>
     </ul>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#acknowledgements">
    4. Acknowledgements
   </a>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#bibliography">
    5. Bibliography
   </a>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#notices">
    6. Notices
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#notice">
      6.1. Notice
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#opencl">
      6.2. OpenCL
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#trademarks">
      6.3. Trademarks
     </a>
    </li>
   </ul>
  </li>
 </ul>
 <a href="https://docs.nvidia.com/cuda/cusolver/contents.html">
  cuSOLVER
 </a>
 <ul class="wy-breadcrumbs">
  <li>
   <a class="icon icon-home" href="https://docs.nvidia.com/cuda/index.html">
   </a>
   Â»
  </li>
  <li>
   <span class="section-number">
    1.
   </span>
   Introduction
  </li>
  <li class="wy-breadcrumbs-aside">
   <span>
    v12.5 |
   </span>
   <a class="reference external" href="https://docs.nvidia.com/cuda/pdf/CUSOLVER_Library.pdf">
    PDF
   </a>
   <span>
    |
   </span>
   <a class="reference external" href="https://developer.nvidia.com/cuda-toolkit-archive">
    Archive
   </a>
   <span>
    Â
   </span>
  </li>
 </ul>
 <p class="rubric-h1 rubric">
  cuSOLVER API Reference
 </p>
 <p>
  The API reference guide for cuSOLVER, a GPU accelerated library for decompositions and linear system solutions for both dense and sparse matrices.
 </p>
 <h1>
  <span class="section-number">
   1.
  </span>
  Introduction
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#introduction" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <p>
  The cuSolver library is a high-level package based on the cuBLAS and cuSPARSE libraries. It consists of two modules corresponding to two sets of API:
 </p>
 <ol class="arabic simple">
  <li>
   <p>
    The cuSolver API on a single GPU
   </p>
  </li>
  <li>
   <p>
    The cuSolverMG API on a single node multiGPU
   </p>
  </li>
 </ol>
 <p>
  Each of these can be used independently or in concert with other toolkit libraries. To simplify the notation, cuSolver denotes single GPU API and cuSolverMg denotes multiGPU API.
 </p>
 <p>
  The intent of cuSolver is to provide useful LAPACK-like features, such as common matrix factorization and triangular solve routines for dense matrices, a sparse least-squares solver and an eigenvalue solver. In addition cuSolver provides a new refactorization library useful for solving sequences of matrices with a shared sparsity pattern.
 </p>
 <p>
  cuSolver combines three separate components under a single umbrella. The first part of cuSolver is called cuSolverDN, and deals with dense matrix factorization and solve routines such as LU, QR, SVD and LDLT, as well as useful utilities such as matrix and vector permutations.
 </p>
 <p>
  Next, cuSolverSP provides a new set of sparse routines based on a sparse QR factorization. Not all matrices have a good sparsity pattern for parallelism in factorization, so the cuSolverSP library also provides a CPU path to handle those sequential-like matrices. For those matrices with abundant parallelism, the GPU path will deliver higher performance. The library is designed to be called from C and C++.
 </p>
 <p>
  The final part is cuSolverRF, a sparse re-factorization package that can provide very good performance when solving a sequence of matrices where only the coefficients are changed but the sparsity pattern remains the same.
 </p>
 <p>
  The GPU path of the cuSolver library assumes data is already in the device memory. It is the responsibility of the developer to allocate memory and to copy data between GPU memory and CPU memory using standard CUDA runtime API routines, such as
  <span class="pre">
   cudaMalloc()
  </span>
  ,
  <span class="pre">
   cudaFree()
  </span>
  ,
  <span class="pre">
   cudaMemcpy()
  </span>
  , and
  <span class="pre">
   cudaMemcpyAsync()
  </span>
  .
 </p>
 <p>
  cuSolverMg is GPU-accelerated ScaLAPACK. By now, cuSolverMg supports 1-D column block cyclic layout and provides symmetric eigenvalue solver.
 </p>
 <p class="admonition-title">
  Note
 </p>
 <p>
  The cuSolver library requires hardware with a CUDA Compute Capability (CC) of 5.0 or higher. Please see the
  CUDA C++ Programming Guide
  for a list of the
  <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#compute-capabilities">
   Compute Capabilities
  </a>
  corresponding to all NVIDIA GPUs.
 </p>
 <h2>
  <span class="section-number">
   1.1.
  </span>
  cuSolverDN: Dense LAPACK
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-dense-lapack" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  The cuSolverDN library was designed to solve dense linear systems of the form
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(Ax = b\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where the coefficient matrix
  <span class="math notranslate nohighlight">
   \(A\in R^{nxn}\)
  </span>
  , right-hand-side vector
  <span class="math notranslate nohighlight">
   \(b\in R^{n}\)
  </span>
  and solution vector
  <span class="math notranslate nohighlight">
   \(x\in R^{n}\)
  </span>
 </p>
 <p>
  The cuSolverDN library provides QR factorization and LU with partial pivoting to handle a general matrix
  <span class="pre">
   A
  </span>
  , which may be non-symmetric. Cholesky factorization is also provided for symmetric/Hermitian matrices. For symmetric indefinite matrices, we provide Bunch-Kaufman (LDL) factorization.
 </p>
 <p>
  The cuSolverDN library also provides a helpful bidiagonalization routine and singular value decomposition (SVD).
 </p>
 <p>
  The cuSolverDN library targets computationally-intensive and popular routines in LAPACK, and provides an API compatible with LAPACK. The user can accelerate these time-consuming routines with cuSolverDN and keep others in LAPACK without a major change to existing code.
 </p>
 <h2>
  <span class="section-number">
   1.2.
  </span>
  cuSolverSP: Sparse LAPACK
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolversp-sparse-lapack" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  The cuSolverSP library was mainly designed to a solve sparse linear system
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(Ax = b\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  and the least-squares problem
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(x = {argmin}{||}A*z - b{||}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where sparse matrix
  <span class="math notranslate nohighlight">
   \(A\in R^{mxn}\)
  </span>
  , right-hand-side vector
  <span class="math notranslate nohighlight">
   \(b\in R^{m}\)
  </span>
  and solution vector
  <span class="math notranslate nohighlight">
   \(x\in R^{n}\)
  </span>
  . For a linear system, we require
  <span class="pre">
   m=n
  </span>
  .
 </p>
 <p>
  The core algorithm is based on sparse QR factorization. The matrix
  <span class="pre">
   A
  </span>
  is accepted in CSR format. If matrix
  <span class="pre">
   A
  </span>
  is symmetric/Hermitian, the user has to provide a full matrix, ie fill missing lower or upper part.
 </p>
 <p>
  If matrix
  <span class="pre">
   A
  </span>
  is symmetric positive definite and the user only needs to solve
  <span class="math notranslate nohighlight">
   \(Ax = b\)
  </span>
  , Cholesky factorization can work and the user only needs to provide the lower triangular part of
  <span class="pre">
   A
  </span>
  .
 </p>
 <p>
  On top of the linear and least-squares solvers, the
  <span class="pre">
   cuSolverSP
  </span>
  library provides a simple eigenvalue solver based on shift-inverse power method, and a function to count the number of eigenvalues contained in a box in the complex plane.
 </p>
 <h2>
  <span class="section-number">
   1.3.
  </span>
  cuSolverRF: Refactorization
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrf-refactorization" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  The cuSolverRF library was designed to accelerate solution of sets of linear systems by fast re-factorization when given new coefficients in the same sparsity pattern
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A_{i}x_{i} = f_{i}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where a sequence of coefficient matrices
  <span class="math notranslate nohighlight">
   \(A_{i}\in R^{nxn}\)
  </span>
  , right-hand-sides
  <span class="math notranslate nohighlight">
   \(f_{i}\in R^{n}\)
  </span>
  and solutions
  <span class="math notranslate nohighlight">
   \(x_{i}\in R^{n}\)
  </span>
  are given for
  <span class="pre">
   i=1,...,k
  </span>
  .
 </p>
 <p>
  The cuSolverRF library is applicable when the sparsity pattern of the coefficient matrices
  <span class="math notranslate nohighlight">
   \(A_{i}\)
  </span>
  as well as the reordering to minimize fill-in and the pivoting used during the LU factorization remain the same across these linear systems. In that case, the first linear system (
  <span class="pre">
   i=1
  </span>
  ) requires a full LU factorization, while the subsequent linear systems (
  <span class="pre">
   i=2,...,k
  </span>
  ) require only the LU re-factorization. The later can be performed using the cuSolverRF library.
 </p>
 <p>
  Notice that because the sparsity pattern of the coefficient matrices, the reordering and pivoting remain the same, the sparsity pattern of the resulting triangular factors
  <span class="math notranslate nohighlight">
   \(L_{i}\)
  </span>
  and
  <span class="math notranslate nohighlight">
   \(U_{i}\)
  </span>
  also remains the same. Therefore, the real difference between the full LU factorization and LU re-factorization is that the required memory is known ahead of time.
 </p>
 <h2>
  <span class="section-number">
   1.4.
  </span>
  Naming Conventions
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#naming-conventions" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  The cuSolverDN library provides two different APIs;
  <span class="pre">
   legacy
  </span>
  and
  <span class="pre">
   generic
  </span>
  .
 </p>
 <p>
  The functions in the legacy API are available for data types
  <span class="pre">
   float
  </span>
  ,
  <span class="pre">
   double
  </span>
  ,
  <span class="pre">
   cuComplex
  </span>
  , and
  <span class="pre">
   cuDoubleComplex
  </span>
  . The naming convention for the legacy API is as follows:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cusolverDn
     </span>
     &lt;
     <span class="pre">
      t
     </span>
     &gt;&lt;
     <span class="pre">
      operation
     </span>
     &gt;
    </p>
   </td>
  </tr>
 </table>
 <p>
  where &lt;
  <span class="pre">
   t
  </span>
  &gt; can be
  <span class="pre">
   S
  </span>
  ,
  <span class="pre">
   D
  </span>
  ,
  <span class="pre">
   C
  </span>
  ,
  <span class="pre">
   Z
  </span>
  , or
  <span class="pre">
   X
  </span>
  , corresponding to the data types
  <span class="pre">
   float
  </span>
  ,
  <span class="pre">
   double
  </span>
  ,
  <span class="pre">
   cuComplex
  </span>
  ,
  <span class="pre">
   cuDoubleComplex
  </span>
  , and the generic type, respectively. &lt;
  <span class="pre">
   operation
  </span>
  &gt; can be Cholesky factorization (
  <span class="pre">
   potrf
  </span>
  ), LU with partial pivoting (
  <span class="pre">
   getrf
  </span>
  ), QR factorization (
  <span class="pre">
   geqrf
  </span>
  ) and Bunch-Kaufman factorization (
  <span class="pre">
   sytrf
  </span>
  ).
 </p>
 <p>
  The functions in the generic API provide a single entry point for each routine and support for 64-bit integers to define matrix and vector dimensions. The naming convention for the generic API is data-agnostic and is as follows:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cusolverDn
     </span>
     &lt;
     <span class="pre">
      operation
     </span>
     &gt;
    </p>
   </td>
  </tr>
 </table>
 <p>
  where &lt;
  <span class="pre">
   operation
  </span>
  &gt; can be Cholesky factorization (
  <span class="pre">
   potrf
  </span>
  ), LU with partial pivoting (
  <span class="pre">
   getrf
  </span>
  ) and QR factorization (
  <span class="pre">
   geqrf
  </span>
  ).
 </p>
 <p>
  The cuSolverSP library functions are available for data types
  <span class="pre">
   float
  </span>
  ,
  <span class="pre">
   double
  </span>
  ,
  <span class="pre">
   cuComplex
  </span>
  , and
  <span class="pre">
   cuDoubleComplex
  </span>
  . The naming convention is as follows:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cusolverSp[Host]
     </span>
     &lt;
     <span class="pre">
      t
     </span>
     &gt;[&lt;
     <span class="pre">
      matrix
     </span>
     <span class="pre">
      data
     </span>
     <span class="pre">
      format
     </span>
     &gt;]&lt;
     <span class="pre">
      operation
     </span>
     &gt;[&lt;
     <span class="pre">
      output
     </span>
     <span class="pre">
      matrix
     </span>
     <span class="pre">
      data
     </span>
     <span class="pre">
      format
     </span>
     &gt;]&lt;
     <span class="pre">
      based
     </span>
     <span class="pre">
      on
     </span>
     &gt;
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   cuSolverSp
  </span>
  is the GPU path and
  <span class="pre">
   cusolverSpHost
  </span>
  is the corresponding CPU path. &lt;
  <span class="pre">
   t
  </span>
  &gt; can be
  <span class="pre">
   S
  </span>
  ,
  <span class="pre">
   D
  </span>
  ,
  <span class="pre">
   C
  </span>
  ,
  <span class="pre">
   Z
  </span>
  , or
  <span class="pre">
   X
  </span>
  , corresponding to the data types
  <span class="pre">
   float
  </span>
  ,
  <span class="pre">
   double
  </span>
  ,
  <span class="pre">
   cuComplex
  </span>
  ,
  <span class="pre">
   cuDoubleComplex
  </span>
  , and the generic type, respectively.
 </p>
 <p>
  The &lt;
  <span class="pre">
   matrix
  </span>
  <span class="pre">
   data
  </span>
  <span class="pre">
   format
  </span>
  &gt; is
  <span class="pre">
   csr
  </span>
  , compressed sparse row format.
 </p>
 <p>
  The &lt;
  <span class="pre">
   operation
  </span>
  &gt; can be
  <span class="pre">
   ls
  </span>
  ,
  <span class="pre">
   lsq
  </span>
  ,
  <span class="pre">
   eig
  </span>
  ,
  <span class="pre">
   eigs
  </span>
  , corresponding to linear solver, least-square solver, eigenvalue solver and number of eigenvalues in a box, respectively.
 </p>
 <p>
  The &lt;
  <span class="pre">
   output
  </span>
  <span class="pre">
   matrix
  </span>
  <span class="pre">
   data
  </span>
  <span class="pre">
   format
  </span>
  &gt; can be
  <span class="pre">
   v
  </span>
  or
  <span class="pre">
   m
  </span>
  , corresponding to a vector or a matrix.
 </p>
 <p>
  &lt;
  <span class="pre">
   based
  </span>
  <span class="pre">
   on
  </span>
  &gt; describes which algorithm is used. For example,
  <span class="pre">
   qr
  </span>
  (sparse QR factorization) is used in linear solver and least-square solver.
 </p>
 <p>
  All of the functions have the return type
  <span class="pre">
   cusolverStatus_t
  </span>
  and are explained in more detail in the chapters that follow.
 </p>
 <table class="table-no-stripes docutils align-default" id="id21">
  <span class="caption-text">
   Table 1. cuSolverSP API
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#id21" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Routine
    </p>
   </th>
   <th class="head">
    <p>
     Data format
    </p>
   </th>
   <th class="head">
    <p>
     Operation
    </p>
   </th>
   <th class="head">
    <p>
     Output format
    </p>
   </th>
   <th class="head">
    <p>
     Based on
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrlsvlu
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      csr
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      linear
     </span>
     <span class="pre">
      solver
     </span>
     <span class="pre">
      (ls)
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      vector
     </span>
     <span class="pre">
      (v)
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      LU
     </span>
     <span class="pre">
      (lu)
     </span>
     <span class="pre">
      with
     </span>
     <span class="pre">
      partial
     </span>
     <span class="pre">
      pivoting
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrlsvqr
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      csr
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      linear
     </span>
     <span class="pre">
      solver
     </span>
     <span class="pre">
      (ls)
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      vector
     </span>
     <span class="pre">
      (v)
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      QR
     </span>
     <span class="pre">
      factorization
     </span>
     <span class="pre">
      (qr)
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrlsvchol
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      csr
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      linear
     </span>
     <span class="pre">
      solver
     </span>
     <span class="pre">
      (ls)
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      vector
     </span>
     <span class="pre">
      (v)
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      Cholesky
     </span>
     <span class="pre">
      factorization
     </span>
     <span class="pre">
      (chol)
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrlsqvqr
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      csr
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      least-square
     </span>
     <span class="pre">
      solver
     </span>
     <span class="pre">
      (lsq)
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      vector
     </span>
     <span class="pre">
      (v)
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      QR
     </span>
     <span class="pre">
      factorization
     </span>
     <span class="pre">
      (qr)
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csreigvsi
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      csr
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      eigenvalue
     </span>
     <span class="pre">
      solver
     </span>
     <span class="pre">
      (eig)
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      vector
     </span>
     <span class="pre">
      (v)
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      shift-inverse
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csreigs
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      csr
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      number
     </span>
     <span class="pre">
      of
     </span>
     <span class="pre">
      eigenvalues
     </span>
     <span class="pre">
      in
     </span>
     <span class="pre">
      a
     </span>
     <span class="pre">
      box
     </span>
     <span class="pre">
      (eigs)
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrsymrcm
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      csr
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      Symmetric
     </span>
     <span class="pre">
      Reverse
     </span>
     <span class="pre">
      Cuthill-McKee
     </span>
     <span class="pre">
      (symrcm)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The cuSolverRF library routines are available for data type
  <span class="pre">
   double
  </span>
  . Most of the routines follow the naming convention:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cusolverRf
     </span>
     _&lt;
     <span class="pre">
      operation
     </span>
     &gt;_[
     <span class="pre">
      [Host]
     </span>
     ](â¦)
    </p>
   </td>
  </tr>
 </table>
 <p>
  where the trailing optional Host qualifier indicates the data is accessed on the host versus on the device, which is the default. The &lt;
  <span class="pre">
   operation
  </span>
  &gt; can be
  <span class="pre">
   Setup
  </span>
  ,
  <span class="pre">
   Analyze
  </span>
  ,
  <span class="pre">
   Refactor
  </span>
  ,
  <span class="pre">
   Solve
  </span>
  ,
  <span class="pre">
   ResetValues
  </span>
  ,
  <span class="pre">
   AccessBundledFactors
  </span>
  and
  <span class="pre">
   ExtractSplitFactors
  </span>
  .
 </p>
 <p>
  Finally, the return type of the cuSolverRF library routines is
  <span class="pre">
   cusolverStatus_t
  </span>
  .
 </p>
 <h2>
  <span class="section-number">
   1.5.
  </span>
  Asynchronous Execution
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#asynchronous-execution" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  The cuSolver library functions prefer to keep asynchronous execution as much as possible. Developers can always use the
  <span class="pre">
   cudaDeviceSynchronize()
  </span>
  function to ensure that the execution of a particular cuSolver library routine has completed.
 </p>
 <p>
  A developer can also use the
  <span class="pre">
   cudaMemcpy()
  </span>
  routine to copy data from the device to the host and vice versa, using the
  <span class="pre">
   cudaMemcpyDeviceToHost
  </span>
  and
  <span class="pre">
   cudaMemcpyHostToDevice
  </span>
  parameters, respectively. In this case there is no need to add a call to
  <span class="pre">
   cudaDeviceSynchronize()
  </span>
  because the call to
  <span class="pre">
   cudaMemcpy()
  </span>
  with the above parameters is blocking and completes only when the results are ready on the host.
 </p>
 <h2>
  <span class="section-number">
   1.6.
  </span>
  Library Property
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#library-property" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  The
  <span class="pre">
   libraryPropertyType
  </span>
  data type is an enumeration of library property types. (ie. CUDA version X.Y.Z would yield
  <span class="pre">
   MAJOR_VERSION=X
  </span>
  ,
  <span class="pre">
   MINOR_VERSION=Y
  </span>
  ,
  <span class="pre">
   PATCH_LEVEL=Z
  </span>
  )
 </p>
 <pre><span class="k">typedef</span><span class="k">enum</span><span class="nc">libraryPropertyType_t</span>
<span class="p">{</span>
<span class="n">MAJOR_VERSION</span><span class="p">,</span>
<span class="n">MINOR_VERSION</span><span class="p">,</span>
<span class="n">PATCH_LEVEL</span>
<span class="p">}</span><span class="n">libraryPropertyType</span><span class="p">;</span>
</pre>
 <p>
  The following code can show the version of cusolver library.
 </p>
 <pre><span class="kt">int</span><span class="n">major</span><span class="o">=</span><span class="mi">-1</span><span class="p">,</span><span class="n">minor</span><span class="o">=</span><span class="mi">-1</span><span class="p">,</span><span class="n">patch</span><span class="o">=</span><span class="mi">-1</span><span class="p">;</span>
<span class="n">cusolverGetProperty</span><span class="p">(</span><span class="n">MAJOR_VERSION</span><span class="p">,</span><span class="o">&amp;</span><span class="n">major</span><span class="p">);</span>
<span class="n">cusolverGetProperty</span><span class="p">(</span><span class="n">MINOR_VERSION</span><span class="p">,</span><span class="o">&amp;</span><span class="n">minor</span><span class="p">);</span>
<span class="n">cusolverGetProperty</span><span class="p">(</span><span class="n">PATCH_LEVEL</span><span class="p">,</span><span class="o">&amp;</span><span class="n">patch</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"CUSOLVER Version (Major,Minor,PatchLevel): %d.%d.%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">major</span><span class="p">,</span><span class="n">minor</span><span class="p">,</span><span class="n">patch</span><span class="p">);</span>
</pre>
 <h2>
  <span class="section-number">
   1.7.
  </span>
  High Precision Package
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#high-precision-package" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  The
  <span class="pre">
   cusolver
  </span>
  library uses high precision for iterative refinement when necessary.
 </p>
 <h1>
  <span class="section-number">
   2.
  </span>
  Using the CUSOLVER API
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#using-the-cusolver-api" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <h2>
  <span class="section-number">
   2.1.
  </span>
  General Description
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#general-description" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  This chapter describes how to use the cuSolver library API. It is not a reference for the cuSolver API data types and functions; that is provided in subsequent chapters.
 </p>
 <h3>
  <span class="section-number">
   2.1.1.
  </span>
  Thread Safety
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#thread-safety" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The library is thread-safe, and its functions can be called from multiple host threads.
 </p>
 <h3>
  <span class="section-number">
   2.1.2.
  </span>
  Scalar Parameters
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#scalar-parameters" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  In the cuSolver API, the scalar parameters can be passed by reference on the host.
 </p>
 <h3>
  <span class="section-number">
   2.1.3.
  </span>
  Parallelism with Streams
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#parallelism-with-streams" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  If the application performs several small independent computations, or if it makes data transfers in parallel with the computation, then CUDA streams can be used to overlap these tasks.
 </p>
 <p>
  The application can conceptually associate a stream with each task. To achieve the overlap of computation between the tasks, the developer should:
 </p>
 <ol class="arabic simple">
  <li>
   <p>
    Create CUDA streams using the function
    <span class="pre">
     cudaStreamCreate()
    </span>
    , and
   </p>
  </li>
  <li>
   <p>
    Set the stream to be used by each individual cuSolver library routine by calling, for example,
    <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnsetstream">
     <span class="std std-ref">
      cusolverDnSetStream()
     </span>
    </a>
    , just prior to calling the actual cuSolverDN routine.
   </p>
  </li>
 </ol>
 <p>
  The computations performed in separate streams would then be overlapped automatically on the GPU, when possible. This approach is especially useful when the computation performed by a single task is relatively small, and is not enough to fill the GPU with work, or when there is a data transfer that can be performed in parallel with the computation.
 </p>
 <h3>
  <span class="section-number">
   2.1.4.
  </span>
  How to Link cusolver Library
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#how-to-link-cusolver-library" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  <span class="pre">
   cusolver
  </span>
  library provides dynamic library
  <span class="pre">
   libcusolver.so
  </span>
  and static library
  <span class="pre">
   libcusolver_static.a
  </span>
  . If the user links the application with
  <span class="pre">
   libcusolver.so
  </span>
  ,
  <span class="pre">
   libcublas.so
  </span>
  ,
  <span class="pre">
   libcublasLt.so
  </span>
  and
  <span class="pre">
   libcusparse.so
  </span>
  are also required. If the user links the application with
  <span class="pre">
   libcusolver_static.a
  </span>
  , the following libraries are also needed,
  <span class="pre">
   libcudart_static.a
  </span>
  ,
  <span class="pre">
   libculibos.a
  </span>
  ,
  <span class="pre">
   libcusolver_lapack_static.a
  </span>
  ,
  <span class="pre">
   libcusolver_metis_static.a
  </span>
  ,
  <span class="pre">
   libcublas_static.a
  </span>
  and
  <span class="pre">
   libcusparse_static.a
  </span>
  .
 </p>
 <h3>
  <span class="section-number">
   2.1.5.
  </span>
  Link Third-party LAPACK Library
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#link-third-party-lapack-library" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Starting with CUDA 10.1 update 2, NVIDIA LAPACK library
  <span class="pre">
   libcusolver_lapack_static.a
  </span>
  is a subset of LAPACK and only contains GPU accelerated
  <span class="pre">
   stedc
  </span>
  and
  <span class="pre">
   bdsqr
  </span>
  . The user has to link
  <span class="pre">
   libcusolver_static.a
  </span>
  with
  <span class="pre">
   libcusolver_lapack_static.a
  </span>
  in order to build the application successfully. Prior to CUDA 10.1 update 2, the user can replace
  <span class="pre">
   libcusolver_lapack_static.a
  </span>
  with a third-party LAPACK library, for example, MKL. In CUDA 10.1 update 2, the third-party LAPACK library no longer affects the behavior of cusolver library, neither functionality nor performance. Furthermore the user cannot use
  <span class="pre">
   libcusolver_lapack_static.a
  </span>
  as a standalone LAPACK library because it is only a subset of LAPACK.
 </p>
 <ul class="simple">
  <li>
   <p>
    If you use
    <span class="pre">
     libcusolver_static.a
    </span>
    , then you must link with
    <span class="pre">
     libcusolver_lapack_static.a
    </span>
    explicitly, otherwise the linker will report missing symbols. There are no symbol conflicts between
    <span class="pre">
     libcusolver_lapack_static.a
    </span>
    and other third-party LAPACK libraries, which allows linking the same application to
    <span class="pre">
     libcusolver_lapack_static.a
    </span>
    and another third-party LAPACK library.
   </p>
  </li>
  <li>
   <p>
    The
    <span class="pre">
     libcusolver_lapack_static.a
    </span>
    is built inside
    <span class="pre">
     libcusolver.so
    </span>
    . Hence, if you use
    <span class="pre">
     libcusolver.so
    </span>
    , then you donât need to specify a LAPACK library. The
    <span class="pre">
     libcusolver.so
    </span>
    will not pick up any routines from the third-party LAPACK library even if you link the application with it.
   </p>
  </li>
 </ul>
 <h3>
  <span class="section-number">
   2.1.6.
  </span>
  Convention of info
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#convention-of-info" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Each LAPACK routine returns an
  <span class="pre">
   info
  </span>
  which indicates the position of invalid parameter. If
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  , then i-th parameter is invalid. To be consistent with base-1 in LAPACK,
  <span class="pre">
   cusolver
  </span>
  does not report invalid
  <span class="pre">
   handle
  </span>
  into
  <span class="pre">
   info
  </span>
  . Instead,
  <span class="pre">
   cusolver
  </span>
  returns
  <span class="pre">
   CUSOLVER_STATUS_NOT_INITIALIZED
  </span>
  for invalid
  <span class="pre">
   handle
  </span>
  .
 </p>
 <h3>
  <span class="section-number">
   2.1.7.
  </span>
  Usage of _bufferSize
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#usage-of-buffersize" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  There is no cudaMalloc inside
  <span class="pre">
   cuSolver
  </span>
  library, the user must allocate the device workspace explicitly. The routine
  <span class="pre">
   xyz_bufferSize
  </span>
  is to query the size of workspace of the routine
  <span class="pre">
   xyz
  </span>
  , for example
  <span class="pre">
   xyz
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   potrf
  </span>
  . To make the API simple,
  <span class="pre">
   xyz_bufferSize
  </span>
  follows almost the same signature of
  <span class="pre">
   xyz
  </span>
  even it only depends on some parameters, for example, device pointer is not used to decide the size of workspace. In most cases,
  <span class="pre">
   xyz_bufferSize
  </span>
  is called in the beginning before actual device data (pointing by a device pointer) is prepared or before the device pointer is allocated. In such case, the user can pass null pointer to
  <span class="pre">
   xyz_bufferSize
  </span>
  without breaking the functionality.
 </p>
 <h3>
  <span class="section-number">
   2.1.8.
  </span>
  cuSOLVERDn Logging
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-logging" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  cuSOLVERDn logging mechanism can be enabled by setting the following environment variables before launching the target application:
 </p>
 <ul>
  <li>
   <p>
    <span class="pre">
     CUSOLVERDN_LOG_LEVEL=&lt;level&gt;
    </span>
    - where
    <span class="pre">
     &lt;level&gt;
    </span>
    is one of the following levels:
   </p>
   <ul class="simple">
    <li>
     <p>
      <span class="pre">
       0
      </span>
      - Off - logging is disabled (default)
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       1
      </span>
      - Error - only errors will be logged
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       2
      </span>
      - Trace - API calls that launch CUDA kernels will log their parameters and important information
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       3
      </span>
      - Hints - hints that can potentially improve the applicationâs performance
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       4
      </span>
      - Info - provides general information about the library execution, may contain details about heuristic status
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       5
      </span>
      - API Trace - API calls will log their parameter and important information
     </p>
    </li>
   </ul>
  </li>
  <li>
   <p>
    <span class="pre">
     CUSOLVERDN_LOG_MASK=&lt;mask&gt;
    </span>
    - where mask is a combination of the following masks:
   </p>
   <ul class="simple">
    <li>
     <p>
      <span class="pre">
       0
      </span>
      - Off
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       1
      </span>
      - Error
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       2
      </span>
      - Trace
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       4
      </span>
      - Hints
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       8
      </span>
      - Info
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       16
      </span>
      - API Trace
     </p>
    </li>
   </ul>
  </li>
  <li>
   <p>
    <span class="pre">
     CUSOLVERDN_LOG_FILE=&lt;file_name&gt;
    </span>
    - where file name is a path to a log file. File name may contain
    <span class="pre">
     %i
    </span>
    , that will be replaced with the process id, e.g.
    <span class="pre">
     &lt;file_name&gt;_%i.log
    </span>
    . If
    <span class="pre">
     CUSOLVERDN_LOG_FILE
    </span>
    is not defined, the log messages are printed to stdout.
   </p>
  </li>
 </ul>
 <p>
  Another option is to use the experimental cusolverDn logging API. See:
  <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnloggersetcallback">
   <span class="std std-ref">
    cusolverDnLoggerSetCallback()
   </span>
  </a>
  ,
  <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnloggersetfile">
   <span class="std std-ref">
    cusolverDnLoggerSetFile()
   </span>
  </a>
  ,
  <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnloggeropenfile">
   <span class="std std-ref">
    cusolverDnLoggerOpenFile()
   </span>
  </a>
  ,
  <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnloggersetlevel">
   <span class="std std-ref">
    cusolverDnLoggerSetLevel()
   </span>
  </a>
  ,
  <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnloggersetmask">
   <span class="std std-ref">
    cusolverDnLoggerSetMask()
   </span>
  </a>
  ,
  <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnloggerforcedisable">
   <span class="std std-ref">
    cusolverDnLoggerForceDisable()
   </span>
  </a>
  .
 </p>
 <h3>
  <span class="section-number">
   2.1.9.
  </span>
  Deterministic Results
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#deterministic-results" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Throughout this documentation, a function is declared as
  deterministic
  if it computes the exact same bitwise results for every execution with the same input parameters, hard- and software environment. Conversely, a
  non-deterministic
  function might compute bitwise different results due to a varying order of floating point operations, e.g., a sum
  <span class="pre">
   s
  </span>
  of four values
  <span class="pre">
   a
  </span>
  ,
  <span class="pre">
   b
  </span>
  ,
  <span class="pre">
   c
  </span>
  ,
  <span class="pre">
   d
  </span>
  can be computed in different orders:
 </p>
 <ol class="arabic simple">
  <li>
   <p>
    <span class="pre">
     s
    </span>
    <span class="pre">
     =
    </span>
    <span class="pre">
     (a
    </span>
    <span class="pre">
     +
    </span>
    <span class="pre">
     b)
    </span>
    <span class="pre">
     +
    </span>
    <span class="pre">
     (c
    </span>
    <span class="pre">
     +
    </span>
    <span class="pre">
     d)
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     s
    </span>
    <span class="pre">
     =
    </span>
    <span class="pre">
     (a
    </span>
    <span class="pre">
     +
    </span>
    <span class="pre">
     (b
    </span>
    <span class="pre">
     +
    </span>
    <span class="pre">
     c))
    </span>
    <span class="pre">
     +
    </span>
    <span class="pre">
     d
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     s
    </span>
    <span class="pre">
     =
    </span>
    <span class="pre">
     a
    </span>
    <span class="pre">
     +
    </span>
    <span class="pre">
     (b
    </span>
    <span class="pre">
     +
    </span>
    <span class="pre">
     (c
    </span>
    <span class="pre">
     +
    </span>
    <span class="pre">
     d))
    </span>
   </p>
  </li>
  <li>
   <p>
    â¦
   </p>
  </li>
 </ol>
 <p>
  Due to the non-associativity of floating point arithmetic, all results might be bitwise different.
 </p>
 <p>
  By default, cuSolverDN computes deterministic results. For improved performance of some functions, it is possible to allow non-deterministic results with
  <span class="pre">
   cusolverDnSetDeterministicMode()
  </span>
  .
 </p>
 <h2>
  <span class="section-number">
   2.2.
  </span>
  cuSolver Types Reference
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolver-types-reference" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <h3>
  <span class="section-number">
   2.2.1.
  </span>
  cuSolverDN Types
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-types" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The
  <span class="pre">
   float
  </span>
  ,
  <span class="pre">
   double
  </span>
  ,
  <span class="pre">
   cuComplex
  </span>
  , and
  <span class="pre">
   cuDoubleComplex
  </span>
  data types are supported. The first two are standard C data types, while the last two are exported from
  <span class="pre">
   cuComplex.h
  </span>
  . In addition, cuSolverDN uses some familiar types from cuBLAS.
 </p>
 <h4>
  <span class="section-number">
   2.2.1.1.
  </span>
  cusolverDnHandle_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnhandle-t" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  This is a pointer type to an opaque cuSolverDN context, which the user must initialize by calling
  <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdncreate">
   <span class="std std-ref">
    cusolverDnCreate()
   </span>
  </a>
  prior to calling any other library function. An un-initialized Handle object will lead to unexpected behavior, including crashes of cuSolverDN. The handle created and returned by
  <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdncreate">
   <span class="std std-ref">
    cusolverDnCreate()
   </span>
  </a>
  must be passed to every cuSolverDN function.
 </p>
 <h4>
  <span class="section-number">
   2.2.1.2.
  </span>
  cublasFillMode_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cublasfillmode-t" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The type indicates which part (lower or upper) of the dense matrix was filled and consequently should be used by the function.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
    </p>
   </td>
   <td>
    <p>
     The lower part of the matrix is filled.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
    </p>
   </td>
   <td>
    <p>
     The upper part of the matrix is filled.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUBLAS_FILL_MODE_FULL
     </span>
    </p>
   </td>
   <td>
    <p>
     The full matrix is filled.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Notice that BLAS implementations often use Fortran characters
  <span class="pre">
   âLâ
  </span>
  or
  <span class="pre">
   âlâ
  </span>
  (lower) and
  <span class="pre">
   âUâ
  </span>
  or
  <span class="pre">
   âuâ
  </span>
  (upper) to describe which part of the matrix is filled.
 </p>
 <h4>
  <span class="section-number">
   2.2.1.3.
  </span>
  cublasOperation_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cublasoperation-t" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The
  <span class="pre">
   cublasOperation_t
  </span>
  type indicates which operation needs to be performed with the dense matrix.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUBLAS_OP_N
     </span>
    </p>
   </td>
   <td>
    <p>
     The non-transpose operation is selected.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUBLAS_OP_T
     </span>
    </p>
   </td>
   <td>
    <p>
     The transpose operation is selected.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUBLAS_OP_C
     </span>
    </p>
   </td>
   <td>
    <p>
     The conjugate transpose operation is selected.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Notice that BLAS implementations often use Fortran characters
  <span class="pre">
   âNâ
  </span>
  or
  <span class="pre">
   ânâ
  </span>
  (non-transpose),
  <span class="pre">
   âTâ
  </span>
  or
  <span class="pre">
   âtâ
  </span>
  (transpose) and
  <span class="pre">
   âCâ
  </span>
  or
  <span class="pre">
   âcâ
  </span>
  (conjugate transpose) to describe which operations needs to be performed     with the dense matrix.
 </p>
 <h4>
  <span class="section-number">
   2.2.1.4.
  </span>
  cusolverEigType_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvereigtype-t" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The
  <span class="pre">
   cusolverEigType_t
  </span>
  type indicates which type of eigenvalue the solver is.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_EIG_TYPE_1
     </span>
    </p>
   </td>
   <td>
    <p>
     A*x = lambda*B*x
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_EIG_TYPE_2
     </span>
    </p>
   </td>
   <td>
    <p>
     A*B*x = lambda*x
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_EIG_TYPE_3
     </span>
    </p>
   </td>
   <td>
    <p>
     B*A*x = lambda*x
    </p>
   </td>
  </tr>
 </table>
 <p>
  Notice that LAPACK implementations often use Fortran integer
  <span class="pre">
   1
  </span>
  (A*x = lambda*B*x),
  <span class="pre">
   2
  </span>
  (A*B*x = lambda*x),
  <span class="pre">
   3
  </span>
  (B*A*x = lambda*x) to indicate which type of eigenvalue the solver is.
 </p>
 <h4>
  <span class="section-number">
   2.2.1.5.
  </span>
  cusolverEigMode_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvereigmode-t" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The
  <span class="pre">
   cusolverEigMode_t
  </span>
  type indicates whether or not eigenvectors are computed.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
    </p>
   </td>
   <td>
    <p>
     Only eigenvalues are computed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
    </p>
   </td>
   <td>
    <p>
     Both eigenvalues and eigenvectors are computed.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Notice that LAPACK implementations often use Fortran character
  <span class="pre">
   'N'
  </span>
  (only eigenvalues are computed),
  <span class="pre">
   'V'
  </span>
  (both eigenvalues and eigenvectors are computed) to indicate whether or not eigenvectors        are computed.
 </p>
 <h4>
  <span class="section-number">
   2.2.1.6.
  </span>
  cusolverIRSRefinement_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverirsrefinement-t" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The
  <span class="pre">
   cusolverIRSRefinement_t
  </span>
  type indicates which solver type would be used for the specific cusolver function. Most of our experimentation shows that CUSOLVER_IRS_REFINE_GMRES is the best option.
 </p>
 <p>
  More details about the refinement process can be found in Azzam Haidar, Stanimire Tomov, Jack Dongarra, and Nicholas J. Higham. 2018. Harnessing GPU tensor cores for fast FP16 arithmetic to speed up mixed-precision iterative refinement solvers. In Proceedings of the International Conference for High Performance Computing, Networking, Storage, and Analysis (SC â18). IEEE Press, Piscataway, NJ, USA, Article 47, 11 pages.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_IRS_REFINE_NOT_SET
     </span>
    </p>
   </td>
   <td>
    <p>
     Solver is not set; this value is what is set when creating the
     <span class="pre">
      params
     </span>
     structure. IRS solver will return an error.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_IRS_REFINE_NONE
     </span>
    </p>
   </td>
   <td>
    <p>
     No refinement solver, the IRS solver performs a factorization followed by a solve without any refinement. For example if the IRS solver was
     <span class="pre">
      cusolverDnIRSXgesv()
     </span>
     , this is equivalent to a Xgesv routine without refinement and where the factorization is carried out in the lowest precision. If for example the main precision was CUSOLVER_R_64F and the lowest was CUSOLVER_R_64F as well, then this is equivalent to a call to
     <span class="pre">
      cusolverDnDgesv()
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_IRS_REFINE_CLASSICAL
     </span>
    </p>
   </td>
   <td>
    <p>
     Classical iterative refinement solver. Similar to the one used in LAPACK routines.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_IRS_REFINE_GMRES
     </span>
    </p>
   </td>
   <td>
    <p>
     GMRES (Generalized Minimal Residual) based iterative refinement solver. In recent study, the GMRES method has drawn the scientific community attention for its ability to be used as refinement solver that outperforms the classical iterative refinement method. Based on our experimentation, we recommend this setting.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_IRS_REFINE_CLASSICAL_GMRES
     </span>
    </p>
   </td>
   <td>
    <p>
     Classical iterative refinement solver that uses the GMRES (Generalized Minimal Residual) internally to solve the correction equation at each iteration. We call the
     classical refinement iteration
     the outer iteration while the
     GMRES
     is called inner iteration. Note that if the tolerance of the inner GMRES is set very low, lets say to machine precision, then the outer
     classical refinement iteration
     will performs only one iteration and thus this option will behave like
     <span class="pre">
      CUSOLVER_IRS_REFINE_GMRES
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_IRS_REFINE_GMRES_GMRES
     </span>
    </p>
   </td>
   <td>
    <p>
     Similar to
     <span class="pre">
      CUSOLVER_IRS_REFINE_CLASSICAL_GMRES
     </span>
     which consists of classical refinement process that uses GMRES to solve the inner correction system; here it is a GMRES (Generalized Minimal Residual) based iterative refinement solver that uses another GMRES internally to solve the preconditioned system.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.2.1.7.
  </span>
  cusolverDnIRSParams_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsparams-t" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  This is a pointer type to an opaque
  <span class="pre">
   cusolverDnIRSParams_t
  </span>
  structure, which holds parameters for the iterative refinement linear solvers such as
  <span class="pre">
   cusolverDnXgesv()
  </span>
  . Use corresponding helper functions described below to either Create/Destroy this structure or Set/Get solver parameters.
 </p>
 <h4>
  <span class="section-number">
   2.2.1.8.
  </span>
  cusolverDnIRSInfos_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsinfos-t" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  This is a pointer type to an opaque
  <span class="pre">
   cusolverDnIRSInfos_t
  </span>
  structure, which holds information about the performed call to an iterative refinement linear solver (e.g.,
  <span class="pre">
   cusolverDnXgesv()
  </span>
  ). Use corresponding helper functions described below to either Create/Destroy this structure or retrieve solve information.
 </p>
 <h4>
  <span class="section-number">
   2.2.1.9.
  </span>
  cusolverDnFunction_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnfunction-t" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The
  <span class="pre">
   cusolverDnFunction_t
  </span>
  type indicates which routine needs to be configured by
  <span class="pre">
   cusolverDnSetAdvOptions()
  </span>
  . The value
  <span class="pre">
   CUSOLVERDN_GETRF
  </span>
  corresponds to the routine
  <span class="pre">
   Getrf
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVERDN_GETRF
     </span>
    </p>
   </td>
   <td>
    <p>
     Corresponds to
     <span class="pre">
      Getrf
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.2.1.10.
  </span>
  cusolverAlgMode_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolveralgmode-t" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The
  <span class="pre">
   cusolverAlgMode_t
  </span>
  type indicates which algorithm is selected by
  <span class="pre">
   cusolverDnSetAdvOptions()
  </span>
  . The set of algorithms supported for each routine is described in detail along with the routineâs documentation.
 </p>
 <p>
  The default algorithm is
  <span class="pre">
   CUSOLVER_ALG_0
  </span>
  . The user can also provide
  <span class="pre">
   NULL
  </span>
  to use the default algorithm.
 </p>
 <h4>
  <span class="section-number">
   2.2.1.11.
  </span>
  cusolverStatus_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverstatus-t" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  This is the same as
  <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#id5">
   <span class="std std-ref">
    cusolverStatus_t
   </span>
  </a>
  in the sparse LAPACK section.
 </p>
 <h4>
  <span class="section-number">
   2.2.1.12.
  </span>
  cusolverDnLoggerCallback_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnloggercallback-t" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  cusolverDnLoggerCallback_t
  is a callback function pointer type.
 </p>
 <p>
  Parameters
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      logLevel
     </span>
    </p>
   </td>
   <td>
    <p>
     output
    </p>
   </td>
   <td>
    <p>
     See
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-logging">
      <span class="std std-ref">
       cuSOLVERDn Logging
      </span>
     </a>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      functionName
     </span>
    </p>
   </td>
   <td>
    <p>
     output
    </p>
   </td>
   <td>
    <p>
     The name of the API that logged this message.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      message
     </span>
    </p>
   </td>
   <td>
    <p>
     output
    </p>
   </td>
   <td>
    <p>
     The log message.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Use the below function to set the callback function:
  <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnloggersetcallback">
   <span class="std std-ref">
    cusolverDnLoggerSetCallback()
   </span>
  </a>
  .
 </p>
 <h4>
  <span class="section-number">
   2.2.1.13.
  </span>
  cusolverDeterministicMode_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdeterministicmode-t" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The
  <span class="pre">
   cusolverDeterministicMode_t
  </span>
  type indicates whether multiple cuSolver function executions with the same input have the same bitwise equal result (deterministic) or might have bitwise different results (non-deterministic). In comparison to
  <a class="reference external" href="https://docs.nvidia.com/cuda/cublas/#cublasatomicsmode-t">
   cublasAtomicsMode_t
  </a>
  , which only includes the usage of atomic functions,
  <span class="pre">
   cusolverDeterministicMode_t
  </span>
  includes all non-deterministic programming patterns.  The deterministic mode can be set and queried using
  <span class="pre">
   cusolverDnSetDeterministicMode()
  </span>
  and
  <span class="pre">
   cusolverDnGetDeterministicMode()
  </span>
  routines, respectively.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_DETERMINISTIC_RESULTS
     </span>
    </p>
   </td>
   <td>
    <p>
     Compute deterministic results.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_ALLOW_NON_DETERMINISTIC_RESULTS
     </span>
    </p>
   </td>
   <td>
    <p>
     Allow non-deterministic results.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.2.1.14.
  </span>
  cusolverStorevMode_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverstorevmode-t" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  Specifies how the vectors which define the elementary reflectors are stored.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUBLAS_STOREV_COLUMNWISE
     </span>
    </p>
   </td>
   <td>
    <p>
     Columnwise.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUBLAS_STOREV_ROWWISE
     </span>
    </p>
   </td>
   <td>
    <p>
     Rowwise.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.2.1.15.
  </span>
  cusolverDirectMode_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdirectmode-t" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  Specifies the order in which the elementary reflectors are multiplied to form the block reflector.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUBLAS_DIRECT_FORWARD
     </span>
    </p>
   </td>
   <td>
    <p>
     Forward.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUBLAS_DIRECT_BACKWARD
     </span>
    </p>
   </td>
   <td>
    <p>
     Backward.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.2.2.
  </span>
  cuSolverSP Types
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolversp-types" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The
  <span class="pre">
   float
  </span>
  ,
  <span class="pre">
   double
  </span>
  ,
  <span class="pre">
   cuComplex
  </span>
  , and
  <span class="pre">
   cuDoubleComplex
  </span>
  data types are supported. The first two are standard C data types, while the last two are exported from
  <span class="pre">
   cuComplex.h
  </span>
  .
 </p>
 <h4>
  <span class="section-number">
   2.2.2.1.
  </span>
  cusolverSpHandle_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolversphandle-t" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  This is a pointer type to an opaque cuSolverSP context, which the user must initialize by calling
  <span class="pre">
   cusolverSpCreate()
  </span>
  prior to calling any other library function. An un-initialized Handle object will lead to unexpected behavior, including crashes of cuSolverSP. The handle created and returned by
  <span class="pre">
   cusolverSpCreate()
  </span>
  must be passed to every cuSolverSP function.
 </p>
 <h4>
  <span class="section-number">
   2.2.2.2.
  </span>
  cusparseMatDescr_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusparsematdescr-t" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  We have chosen to keep the same structure as exists in cuSPARSE to describe the shape and properties of a matrix. This enables calls to either cuSPARSE or cuSOLVER using the same matrix description.
 </p>
 <pre><span class="k">typedef</span><span class="k">struct</span><span class="p">{</span>
<span class="n">cusparseMatrixType_t</span><span class="n">MatrixType</span><span class="p">;</span>
<span class="n">cusparseFillMode_t</span><span class="n">FillMode</span><span class="p">;</span>
<span class="n">cusparseDiagType_t</span><span class="n">DiagType</span><span class="p">;</span>
<span class="n">cusparseIndexBase_t</span><span class="n">IndexBase</span><span class="p">;</span>
<span class="p">}</span><span class="n">cusparseMatDescr_t</span><span class="p">;</span>
</pre>
 <p>
  Please read documentation of the cuSPARSE Library to understand each field of
  <span class="pre">
   cusparseMatDescr_t
  </span>
  .
 </p>
 <h4>
  <span class="section-number">
   2.2.2.3.
  </span>
  cusolverStatus_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#id5" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  This is a status type returned by the library functions and it can have the following values.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The cuSolver library was not initialized. This is usually caused by the lack of a prior call, an error in the CUDA Runtime API called by the cuSolver routine, or an error in the hardware setup.
    </p>
    <p>
     To correct:
     call
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdncreate">
      <span class="std std-ref">
       cusolverDnCreate()
      </span>
     </a>
     prior to the function call; and check that the hardware, an appropriate version of the driver, and the cuSolver library are correctly installed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     Resource allocation failed inside the cuSolver library. This is usually caused by a
     <span class="pre">
      cudaMalloc()
     </span>
     failure.
    </p>
    <p>
     To correct:
     prior to the function call, deallocate previously allocated memory as much as possible.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     An unsupported value or parameter was passed to the function (a negative vector size, for example).
    </p>
    <p>
     To correct:
     ensure that all the parameters being passed have valid values.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The function requires a feature absent from the device architecture; usually caused by the lack of support for atomic operations or double precision.
    </p>
    <p>
     To correct:
     compile and run the application on a device with compute capability 5.0 or above.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_EXECUTION_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     The GPU program failed to execute. This is often caused by a launch failure of the kernel on the GPU, which can be caused by multiple reasons.
    </p>
    <p>
     To correct:
     check that the hardware, an appropriate version of the driver, and the cuSolver library are correctly installed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal cuSolver operation failed. This error is usually caused by a
     <span class="pre">
      cudaMemcpyAsync()
     </span>
     failure.
    </p>
    <p>
     To correct:
     check that the hardware, an appropriate version of the driver, and the cuSolver library are correctly installed. Also, check that the memory passed as a parameter to the routine is not being deallocated prior to the routineâs completion.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix type is not supported by this function. This is usually caused by passing an invalid matrix descriptor to the function.
    </p>
    <p>
     To correct:
     check that the fields in
     <span class="pre">
      descrA
     </span>
     were set correctly.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_SUPPORTED
     </span>
    </p>
   </td>
   <td>
    <p>
     The parameter combination is not supported, e.g. batched version is not supported or
     <span class="pre">
      M
     </span>
     <span class="pre">
      &lt;
     </span>
     <span class="pre">
      N
     </span>
     is not supported.
    </p>
    <p>
     To correct:
     consult the documentation, and use a supported configuration.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.2.3.
  </span>
  cuSolverRF Types
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrf-types" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  cuSolverRF only supports
  <span class="pre">
   double
  </span>
  .
 </p>
 <h4>
  <span class="section-number">
   2.2.3.1.
  </span>
  cusolverRfHandle_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfhandle-t" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The
  <span class="pre">
   cusolverRfHandle_t
  </span>
  is a pointer to an opaque data structure that contains the cuSolverRF library handle. The user must initialize the handle by calling
  <span class="pre">
   cusolverRfCreate()
  </span>
  prior to any other cuSolverRF library calls. The handle is passed to all other cuSolverRF library calls.
 </p>
 <h4>
  <span class="section-number">
   2.2.3.2.
  </span>
  cusolverRfMatrixFormat_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfmatrixformat-t" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The
  <span class="pre">
   cusolverRfMatrixFormat_t
  </span>
  is an enum that indicates the input/output matrix format assumed by the
  <span class="pre">
   cusolverRfSetupDevice()
  </span>
  ,
  <span class="pre">
   cusolverRfSetupHost()
  </span>
  ,
  <span class="pre">
   cusolverRfResetValues()
  </span>
  ,
  <span class="pre">
   cusolveRfExtractBundledFactorsHost()
  </span>
  and
  <span class="pre">
   cusolverRfExtractSplitFactorsHost()
  </span>
  routines.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_MATRIX_FORMAT_CSR
     </span>
    </p>
   </td>
   <td>
    <p>
     Matrix format CSR is assumed. (default)
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_MATRIX_FORMAT_CSC
     </span>
    </p>
   </td>
   <td>
    <p>
     Matrix format CSC is assumed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.2.3.3.
  </span>
  cusolverRfNumericBoostReport_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfnumericboostreport-t" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The
  <span class="pre">
   cusolverRfNumericBoostReport_t
  </span>
  is an enum that indicates whether numeric boosting (of the pivot) was used during the
  <span class="pre">
   cusolverRfRefactor()
  </span>
  and
  <span class="pre">
   cusolverRfSolve()
  </span>
  routines. The numeric boosting is disabled by default.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_NUMERIC_BOOST_NOT_USED
     </span>
    </p>
   </td>
   <td>
    <p>
     Numeric boosting not used. (default)
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_NUMERIC_BOOST_USED
     </span>
    </p>
   </td>
   <td>
    <p>
     Numeric boosting used.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.2.3.4.
  </span>
  cusolverRfResetValuesFastMode_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfresetvaluesfastmode-t" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The
  <span class="pre">
   cusolverRfResetValuesFastMode_t
  </span>
  is an enum that indicates the mode used for the
  <span class="pre">
   cusolverRfResetValues()
  </span>
  routine. The fast mode requires extra memory and is recommended only if very fast calls to
  <span class="pre">
   cusolverRfResetValues()
  </span>
  are needed.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_RESET_VALUES_FAST_MODE_OFF
     </span>
    </p>
   </td>
   <td>
    <p>
     Fast mode disabled. (default)
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_RESET_VALUES_FAST_MODE_ON
     </span>
    </p>
   </td>
   <td>
    <p>
     Fast mode enabled.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.2.3.5.
  </span>
  cusolverRfFactorization_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrffactorization-t" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The
  <span class="pre">
   cusolverRfFactorization_t
  </span>
  is an enum that indicates which (internal) algorithm is used for refactorization in the
  <span class="pre">
   cusolverRfRefactor()
  </span>
  routine.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_FACTORIZATION_ALG0
     </span>
    </p>
   </td>
   <td>
    <p>
     Algorithm 0. (default)
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_FACTORIZATION_ALG1
     </span>
    </p>
   </td>
   <td>
    <p>
     Algorithm 1.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_FACTORIZATION_ALG2
     </span>
    </p>
   </td>
   <td>
    <p>
     Algorithm 2. Domino-based scheme.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.2.3.6.
  </span>
  cusolverRfTriangularSolve_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrftriangularsolve-t" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The
  <span class="pre">
   cusolverRfTriangularSolve_t
  </span>
  is an enum that indicates which (internal) algorithm is used for triangular solve in the
  <span class="pre">
   cusolverRfSolve()
  </span>
  routine.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_TRIANGULAR_SOLVE_ALG1
     </span>
    </p>
   </td>
   <td>
    <p>
     Algorithm 1. (default)
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_TRIANGULAR_SOLVE_ALG2
     </span>
    </p>
   </td>
   <td>
    <p>
     Algorithm 2. Domino-based scheme.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_TRIANGULAR_SOLVE_ALG3
     </span>
    </p>
   </td>
   <td>
    <p>
     Algorithm 3. Domino-based scheme.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.2.3.7.
  </span>
  cusolverRfUnitDiagonal_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfunitdiagonal-t" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The
  <span class="pre">
   cusolverRfUnitDiagonal_t
  </span>
  is an enum that indicates whether and where the unit diagonal is stored in the input/output triangular factors in the
  <span class="pre">
   cusolverRfSetupDevice()
  </span>
  ,
  <span class="pre">
   cusolverRfSetupHost()
  </span>
  and
  <span class="pre">
   cusolverRfExtractSplitFactorsHost()
  </span>
  routines.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_UNIT_DIAGONAL_STORED_L
     </span>
    </p>
   </td>
   <td>
    <p>
     Unit diagonal is stored in lower triangular factor. (default)
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_UNIT_DIAGONAL_STORED_U
     </span>
    </p>
   </td>
   <td>
    <p>
     Unit diagonal is stored in upper triangular factor.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_UNIT_DIAGONAL_ASSUMED_L
     </span>
    </p>
   </td>
   <td>
    <p>
     Unit diagonal is assumed in lower triangular factor.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_UNIT_DIAGONAL_ASSUMED_U
     </span>
    </p>
   </td>
   <td>
    <p>
     Unit diagonal is assumed in upper triangular factor.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.2.3.8.
  </span>
  cusolverStatus_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#id7" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The
  <span class="pre">
   cusolverStatus_t
  </span>
  is an enum that indicates success or failure of the cuSolverRF library call. It is returned by all the cuSolver library routines, and it uses the same enumerated values as the sparse and dense Lapack routines.
 </p>
 <h2>
  <span class="section-number">
   2.3.
  </span>
  cuSolver Formats Reference
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolver-formats-reference" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <h3>
  <span class="section-number">
   2.3.1.
  </span>
  Index Base Format
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#index-base-format" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Both one-based and zero-based indexing are supported in cuSolver.
 </p>
 <h3>
  <span class="section-number">
   2.3.2.
  </span>
  Vector (Dense) Format
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#vector-dense-format" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The vectors are assumed to be stored linearly in memory. For example, the vector
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(x = \begin{pmatrix}
x_{1} \\
x_{2} \\
\vdots \\
x_{n} \\
\end{pmatrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  is represented as
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\begin{pmatrix}
x_{1} &amp; x_{2} &amp; \ldots &amp; x_{n} \\
\end{pmatrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.3.3.
  </span>
  Matrix (Dense) Format
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#matrix-dense-format" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The dense matrices are assumed to be stored in column-major order in memory. The sub-matrix can be accessed using the leading dimension of the original matrix. For example, the
  <span class="pre">
   m*n
  </span>
  (sub-)matrix
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\begin{pmatrix}
a_{1,1} &amp; \ldots &amp; a_{1,n} \\
a_{2,1} &amp; \ldots &amp; a_{2,n} \\
\vdots &amp; &amp; \\
a_{m,1} &amp; \ldots &amp; a_{m,n} \\
\end{pmatrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  is represented as
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\begin{pmatrix}
a_{1,1} &amp; \ldots &amp; a_{1,n} \\
a_{2,1} &amp; \ldots &amp; a_{2,n} \\
\vdots &amp; \ddots &amp; \vdots \\
a_{m,1} &amp; \ldots &amp; a_{m,n} \\
\vdots &amp; \ddots &amp; \vdots \\
a_{{lda},1} &amp; \ldots &amp; a_{{lda},n} \\
\end{pmatrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  with its elements arranged linearly in memory as
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\begin{pmatrix}
a_{1,1} &amp; a_{2,1} &amp; \ldots &amp; a_{m,1} &amp; \ldots &amp; a_{{lda},1} &amp; \ldots &amp; a_{1,n} &amp; a_{2,n} &amp; \ldots &amp; a_{m,n} &amp; \ldots &amp; a_{{lda},n} \\
\end{pmatrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   lda
  </span>
  â¥
  <span class="pre">
   m
  </span>
  is the leading dimension of
  <span class="pre">
   A
  </span>
  .
 </p>
 <h3>
  <span class="section-number">
   2.3.4.
  </span>
  Matrix (CSR) Format
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#matrix-csr-format" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  In CSR format the matrix is represented by the following parameters:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Type
    </p>
   </th>
   <th class="head">
    <p>
     Size
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      (int)
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of rows (and columns) in the matrix.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      (int)
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of non-zero elements in the matrix.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowPtr
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      (int
     </span>
     <span class="pre">
      *)
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      n+1
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of offsets corresponding to the start of each row in the arrays
     <span class="pre">
      csrColInd
     </span>
     and
     <span class="pre">
      csrVal
     </span>
     . This array has also an extra entry at the end that stores the number of non-zero elements in the matrix.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColInd
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      (int
     </span>
     <span class="pre">
      *)
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of column indices corresponding to the non-zero elements in the matrix.
     It is assumed that this array is sorted by row and by column within each row.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrVal
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      (S|D|C|Z)*
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of values corresponding to the non-zero elements in the matrix.
     It is assumed that this array is sorted by row and by column within each row.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Note that in our CSR format, sparse matrices are assumed to be stored in row-major order, in other words, the index arrays are first sorted by row indices and then within each row by column indices. Also it is assumed that each pair of row and column indices appears only once.
 </p>
 <p>
  For example, the
  <span class="pre">
   4x4
  </span>
  matrix
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = \begin{pmatrix}
{1.0} &amp; {3.0} &amp; {0.0} &amp; {0.0} \\
{0.0} &amp; {4.0} &amp; {6.0} &amp; {0.0} \\
{2.0} &amp; {5.0} &amp; {7.0} &amp; {8.0} \\
{0.0} &amp; {0.0} &amp; {0.0} &amp; {9.0} \\
\end{pmatrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  is represented as
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \({csrRowPtr} = \begin{pmatrix}
0 &amp; 2 &amp; 4 &amp; 8 &amp; 9 \\
\end{pmatrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \({csrColInd} = \begin{pmatrix}
0 &amp; 1 &amp; 1 &amp; 2 &amp; 0 &amp; 1 &amp; 2 &amp; 3 &amp; 3 \\
\end{pmatrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \({csrVal} = \begin{pmatrix}
1.0 &amp; 3.0 &amp; 4.0 &amp; 6.0 &amp; 2.0 &amp; 5.0 &amp; 7.0 &amp; 8.0 &amp; 9.0 \\
\end{pmatrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.3.5.
  </span>
  Matrix (CSC) Format
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#matrix-csc-format" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  In CSC format the matrix is represented by the following parameters:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Type
    </p>
   </th>
   <th class="head">
    <p>
     Size
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      (int)
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of rows (and columns) in the matrix.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      (int)
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of non-zero elements in the matrix.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cscColPtr
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      (int
     </span>
     <span class="pre">
      *)
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      n+1
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of offsets corresponding to the start of each column in the arrays
     <span class="pre">
      cscRowInd
     </span>
     and
     <span class="pre">
      cscVal
     </span>
     . This array has also an extra entry at the end that stores the number of non-zero elements in the matrix.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cscRowInd
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      (int
     </span>
     <span class="pre">
      *)
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of row indices corresponding to the non-zero elements in the matrix.
     It is assumed that this array is sorted by column and by row within each column.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cscVal
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      (S|D|C|Z)*
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of values corresponding to the non-zero elements in the matrix.
     It is assumed that this array is sorted by column and by row within each column.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Note that in our CSC format, sparse matrices are assumed to be stored in column-major order, in other words, the index arrays are first sorted by column indices and then within each column by row indices. Also it is assumed that each pair of row and column indices appears only once.
 </p>
 <p>
  For example, the
  <span class="pre">
   4x4
  </span>
  matrix
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = \begin{pmatrix}
{1.0} &amp; {3.0} &amp; {0.0} &amp; {0.0} \\
{0.0} &amp; {4.0} &amp; {6.0} &amp; {0.0} \\
{2.0} &amp; {5.0} &amp; {7.0} &amp; {8.0} \\
{0.0} &amp; {0.0} &amp; {0.0} &amp; {9.0} \\
\end{pmatrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  is represented as
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \({cscColPtr} = \begin{pmatrix}
0 &amp; 2 &amp; 5 &amp; 7 &amp; 9 \\
\end{pmatrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \({cscRowInd} = \begin{pmatrix}
0 &amp; 2 &amp; 0 &amp; 1 &amp; 2 &amp; 1 &amp; 2 &amp; 2 &amp; 3 \\
\end{pmatrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \({cscVal} = \begin{pmatrix}
1.0 &amp; 2.0 &amp; 3.0 &amp; 4.0 &amp; 5.0 &amp; 6.0 &amp; 7.0 &amp; 8.0 &amp; 9.0 \\
\end{pmatrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <h2>
  <span class="section-number">
   2.4.
  </span>
  cuSolverDN: dense LAPACK Function Reference
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-dense-lapack-function-reference" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  This section describes the API of cuSolverDN, which provides a subset of dense LAPACK functions.
 </p>
 <h3>
  <span class="section-number">
   2.4.1.
  </span>
  cuSolverDN Helper Function Reference
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-helper-function-reference" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The cuSolverDN helper functions are described in this section.
 </p>
 <h4>
  <span class="section-number">
   2.4.1.1.
  </span>
  cusolverDnCreate()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdncreate" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCreate</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="o">*</span><span class="n">handle</span><span class="p">);</span>
</pre>
 <p>
  This function initializes the cuSolverDN library and creates a handle on the cuSolverDN context. It must be called before any other cuSolverDN API function is invoked. It allocates hardware resources necessary for accessing the GPU.
This function allocates 4 MiB or 32 MiB of memory (for GPUs with Compute Capability of 9.0 and higher), which will be used as the cuBLAS workspace for the first user-defined stream on which
  <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnsetstream">
   <span class="std std-ref">
    cusolverDnSetStream()
   </span>
  </a>
  is called.
For the default stream and in all the other cases, cuBLAS will manage its own workspace.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The pointer to the handle to the cuSolverDN context.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The initialization succeeded.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The CUDA Runtime initialization failed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     The resources could not be allocated.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.2.
  </span>
  cusolverDnDestroy()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdndestroy" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDestroy</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">);</span>
</pre>
 <p>
  This function releases CPU-side resources used by the cuSolverDN library.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The shutdown succeeded.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.3.
  </span>
  cusolverDnSetStream()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnsetstream" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnSetStream</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span><span class="n">cudaStream_t</span><span class="n">streamId</span><span class="p">)</span>
</pre>
 <p>
  This function sets the stream to be used by the cuSolverDN library to execute its routines.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      streamId
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The stream to be used by the library.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The stream was set successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.4.
  </span>
  cusolverDnGetStream()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdngetstream" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnGetStream</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span><span class="n">cudaStream_t</span><span class="o">*</span><span class="n">streamId</span><span class="p">)</span>
</pre>
 <p>
  This function queries the stream to be used by the cuSolverDN library to execute its routines.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      streamId
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The stream which is used by
     <span class="pre">
      handle
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The stream was set successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.5.
  </span>
  cusolverDnLoggerSetCallback()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnloggersetcallback" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span><span class="nf">cusolverDnLoggerSetCallback</span><span class="p">(</span><span class="n">cusolverDnLoggerCallback_t</span><span class="n">callback</span><span class="p">);</span>
</pre>
 <p>
  This function sets the logging callback function.
 </p>
 <p>
  Parameters
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      callback
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Pointer to a callback function. See
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnloggercallback-t">
      <span class="std std-ref">
       cusolverDnLoggerCallback_t
      </span>
     </a>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     If the callback function was successfully set.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#id5">
   <span class="std std-ref">
    cusolverStatus_t
   </span>
  </a>
  for a complete list of valid return codes.
 </p>
 <h4>
  <span class="section-number">
   2.4.1.6.
  </span>
  cusolverDnLoggerSetFile()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnloggersetfile" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span><span class="nf">cusolverDnLoggerSetFile</span><span class="p">(</span><span class="kt">FILE</span><span class="o">*</span><span class="n">file</span><span class="p">);</span>
</pre>
 <p>
  This function sets the logging output file. Note: once registered using this function call, the provided file handle must not be closed unless the function is called again to switch to a different file handle.
 </p>
 <p>
  Parameters
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      file
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Pointer to an open file. File should have write permission.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     If logging file was successfully set.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#id5">
   <span class="std std-ref">
    cusolverStatus_t
   </span>
  </a>
  for a complete list of valid return codes.
 </p>
 <h4>
  <span class="section-number">
   2.4.1.7.
  </span>
  cusolverDnLoggerOpenFile()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnloggeropenfile" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span><span class="nf">cusolverDnLoggerOpenFile</span><span class="p">(</span><span class="k">const</span><span class="kt">char</span><span class="o">*</span><span class="n">logFile</span><span class="p">);</span>
</pre>
 <p>
  This function opens a logging output file in the given path.
 </p>
 <p>
  Parameters
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      logFile
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Path of the logging output file.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     If the logging file was successfully opened.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#id5">
   <span class="std std-ref">
    cusolverStatus_t
   </span>
  </a>
  for a complete list of valid return codes.
 </p>
 <h4>
  <span class="section-number">
   2.4.1.8.
  </span>
  cusolverDnLoggerSetLevel()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnloggersetlevel" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span><span class="nf">cusolverDnLoggerSetLevel</span><span class="p">(</span><span class="kt">int</span><span class="n">level</span><span class="p">);</span>
</pre>
 <p>
  This function sets the value of the logging level.
 </p>
 <p>
  Parameters
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      level
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Value of the logging level. See
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-logging">
      <span class="std std-ref">
       cuSOLVERDn Logging
      </span>
     </a>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     If the value was not a valid logging level. See
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-logging">
      <span class="std std-ref">
       cuSOLVERDn Logging
      </span>
     </a>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     If the logging level was successfully set.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#id5">
   <span class="std std-ref">
    cusolverStatus_t
   </span>
  </a>
  for a complete list of valid return codes.
 </p>
 <h4>
  <span class="section-number">
   2.4.1.9.
  </span>
  cusolverDnLoggerSetMask()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnloggersetmask" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span><span class="nf">cusolverDnLoggerSetMask</span><span class="p">(</span><span class="kt">int</span><span class="n">mask</span><span class="p">);</span>
</pre>
 <p>
  This function sets the value of the logging mask.
 </p>
 <p>
  Parameters
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      mask
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Value of the logging mask. See
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-logging">
      <span class="std std-ref">
       cuSOLVERDn Logging
      </span>
     </a>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     If the logging mask was successfully set.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#id5">
   <span class="std std-ref">
    cusolverStatus_t
   </span>
  </a>
  for a complete list of valid return codes.
 </p>
 <h4>
  <span class="section-number">
   2.4.1.10.
  </span>
  cusolverDnLoggerForceDisable()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnloggerforcedisable" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span><span class="nf">cusolverDnLoggerForceDisable</span><span class="p">();</span>
</pre>
 <p>
  This function disables logging for the entire run.
 </p>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     If logging was successfully disabled.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference internal" href="https://docs.nvidia.com/cuda/cusolver/index.html#id5">
   <span class="std std-ref">
    cusolverStatus_t
   </span>
  </a>
  for a complete list of valid return codes.
 </p>
 <h4>
  <span class="section-number">
   2.4.1.11.
  </span>
  cusolverDnSetDeterministicMode()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnsetdeterministicmode" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnSetDeterministicMode</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span><span class="n">cusolverDeterministicMode_t</span><span class="n">mode</span><span class="p">)</span>
</pre>
 <p>
  This function sets the deterministic mode of all cuSolverDN functions for
  <span class="pre">
   handle
  </span>
  . For improved performance,
non-deterministic results can be allowed. Affected functions are
  <span class="pre">
   cusolverDn&lt;t&gt;geqrf()
  </span>
  ,
  <span class="pre">
   cusolverDn&lt;t&gt;syevd()
  </span>
  ,
  <span class="pre">
   cusolverDn&lt;t&gt;syevdx()
  </span>
  ,
  <span class="pre">
   cusolverDn&lt;t&gt;gesvd()
  </span>
  (if
  <span class="pre">
   m
  </span>
  <span class="pre">
   &gt;
  </span>
  <span class="pre">
   n
  </span>
  ),
  <span class="pre">
   cusolverDn&lt;t&gt;gesvdj()
  </span>
  ,
  <span class="pre">
   cusolverDnXgeqrf()
  </span>
  ,
  <span class="pre">
   cusolverDnXsyevd()
  </span>
  ,
  <span class="pre">
   cusolverDnXsyevdx()
  </span>
  ,
  <span class="pre">
   cusolverDnXgesvd()
  </span>
  (if
  <span class="pre">
   m
  </span>
  <span class="pre">
   &gt;
  </span>
  <span class="pre">
   n
  </span>
  ),
  <span class="pre">
   cusolverDnXgesvdr()
  </span>
  and
  <span class="pre">
   cusolverDnXgesvdp()
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      mode
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The deterministic mode to be used with
     <span class="pre">
      handle
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The mode was set successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal error occurred.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.12.
  </span>
  cusolverDnGetDeterministicMode()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdngetdeterministicmode" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnGetDeterministicMode</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span><span class="n">cusolverDeterministicMode_t</span><span class="o">*</span><span class="n">mode</span><span class="p">)</span>
</pre>
 <p>
  This function queries the deterministic mode which is set for
  <span class="pre">
   handle
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      mode
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The deterministic mode of
     <span class="pre">
      handle
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The mode was set successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      mode
     </span>
     is a
     <span class="pre">
      NULL
     </span>
     pointer.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.13.
  </span>
  cusolverDnCreateSyevjInfo()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdncreatesyevjinfo" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCreateSyevjInfo</span><span class="p">(</span>
<span class="n">syevjInfo_t</span><span class="o">*</span><span class="n">info</span><span class="p">);</span>
</pre>
 <p>
  This function creates and initializes the structure of
  <span class="pre">
   syevj
  </span>
  ,
  <span class="pre">
   syevjBatched
  </span>
  and
  <span class="pre">
   sygvj
  </span>
  to default values.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The pointer to the structure of
     <span class="pre">
      syevj
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The structure was initialized successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     The resources could not be allocated.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.14.
  </span>
  cusolverDnDestroySyevjInfo()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdndestroysyevjinfo" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDestroySyevjInfo</span><span class="p">(</span>
<span class="n">syevjInfo_t</span><span class="n">info</span><span class="p">);</span>
</pre>
 <p>
  This function destroys and releases any memory required by the structure.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The structure of
     <span class="pre">
      syevj
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The resources were released successfully.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.15.
  </span>
  cusolverDnXsyevjSetTolerance()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxsyevjsettolerance" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnXsyevjSetTolerance</span><span class="p">(</span>
<span class="n">syevjInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">double</span><span class="n">tolerance</span><span class="p">)</span>
</pre>
 <p>
  This function configures tolerance of
  <span class="pre">
   syevj
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     The pointer to the structure of
     <span class="pre">
      syevj
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      tolerance
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Accuracy of numerical eigenvalues.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.16.
  </span>
  cusolverDnXsyevjSetMaxSweeps()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxsyevjsetmaxsweeps" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnXsyevjSetMaxSweeps</span><span class="p">(</span>
<span class="n">syevjInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="n">max_sweeps</span><span class="p">)</span>
</pre>
 <p>
  This function configures maximum number of sweeps in
  <span class="pre">
   syevj
  </span>
  . The default value is 100.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     The pointer to the structure of
     <span class="pre">
      syevj
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      max_sweeps
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Maximum number of sweeps.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.17.
  </span>
  cusolverDnXsyevjSetSortEig()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxsyevjsetsorteig" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnXsyevjSetSortEig</span><span class="p">(</span>
<span class="n">syevjInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="n">sort_eig</span><span class="p">)</span>
</pre>
 <p>
  If
  <span class="pre">
   sort_eig
  </span>
  is zero, the eigenvalues are not sorted. This function only works for
  <span class="pre">
   syevjBatched
  </span>
  .
  <span class="pre">
   syevj
  </span>
  and
  <span class="pre">
   sygvj
  </span>
  always sort eigenvalues in ascending order. By default, eigenvalues are always sorted in ascending order.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     The pointer to the structure of syevj.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      sort_eig
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      sort_eig
     </span>
     is zero, the eigenvalues are not sorted.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.18.
  </span>
  cusolverDnXsyevjGetResidual()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxsyevjgetresidual" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnXsyevjGetResidual</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">syevjInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">residual</span><span class="p">)</span>
</pre>
 <p>
  This function reports residual of
  <span class="pre">
   syevj
  </span>
  or
  <span class="pre">
   sygvj
  </span>
  . It does not support
  <span class="pre">
   syevjBatched
  </span>
  . If the user calls this function after
  <span class="pre">
   syevjBatched
  </span>
  , the error
  <span class="pre">
   CUSOLVER_STATUS_NOT_SUPPORTED
  </span>
  is returned.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The pointer to the structure of
     <span class="pre">
      syevj
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      residual
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Residual of
     <span class="pre">
      syevj
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_SUPPORTED
     </span>
    </p>
   </td>
   <td>
    <p>
     Does not support batched version.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.19.
  </span>
  cusolverDnXsyevjGetSweeps()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxsyevjgetsweeps" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnXsyevjGetSweeps</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">syevjInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">executed_sweeps</span><span class="p">)</span>
</pre>
 <p>
  This function reports number of executed sweeps of
  <span class="pre">
   syevj
  </span>
  or
  <span class="pre">
   sygvj
  </span>
  . It does not support
  <span class="pre">
   syevjBatched
  </span>
  . If the user calls this function after
  <span class="pre">
   syevjBatched
  </span>
  , the error
  <span class="pre">
   CUSOLVER_STATUS_NOT_SUPPORTED
  </span>
  is returned.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The pointer to the structure of
     <span class="pre">
      syevj
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      executed_sweeps
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of executed sweeps.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_SUPPORTED
     </span>
    </p>
   </td>
   <td>
    <p>
     Does not support batched version.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.20.
  </span>
  cusolverDnCreateGesvdjInfo()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdncreategesvdjinfo" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCreateGesvdjInfo</span><span class="p">(</span>
<span class="n">gesvdjInfo_t</span><span class="o">*</span><span class="n">info</span><span class="p">);</span>
</pre>
 <p>
  This function creates and initializes the structure of
  <span class="pre">
   gesvdj
  </span>
  and
  <span class="pre">
   gesvdjBatched
  </span>
  to default values.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The pointer to the structure of
     <span class="pre">
      gesvdj
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The structure was initialized successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     The resources could not be allocated.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.21.
  </span>
  cusolverDnDestroyGesvdjInfo()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdndestroygesvdjinfo" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDestroyGesvdjInfo</span><span class="p">(</span>
<span class="n">gesvdjInfo_t</span><span class="n">info</span><span class="p">);</span>
</pre>
 <p>
  This function destroys and releases any memory required by the structure.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The structure of
     <span class="pre">
      gesvdj
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The resources were released successfully.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.22.
  </span>
  cusolverDnXgesvdjSetTolerance()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxgesvdjsettolerance" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnXgesvdjSetTolerance</span><span class="p">(</span>
<span class="n">gesvdjInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">double</span><span class="n">tolerance</span><span class="p">)</span>
</pre>
 <p>
  This function configures tolerance of
  <span class="pre">
   gesvdj
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     The pointer to the structure of
     <span class="pre">
      gesvdj
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      tolerance
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Accuracy of numerical singular values.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.23.
  </span>
  cusolverDnXgesvdjSetMaxSweeps()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxgesvdjsetmaxsweeps" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnXgesvdjSetMaxSweeps</span><span class="p">(</span>
<span class="n">gesvdjInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="n">max_sweeps</span><span class="p">)</span>
</pre>
 <p>
  This function configures the maximum number of sweeps in
  <span class="pre">
   gesvdj
  </span>
  . The default value is 100.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     The pointer to the structure of
     <span class="pre">
      gesvdj
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      max_sweeps
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Maximum number of sweeps.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.24.
  </span>
  cusolverDnXgesvdjSetSortEig()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxgesvdjsetsorteig" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnXgesvdjSetSortEig</span><span class="p">(</span>
<span class="n">gesvdjInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="n">sort_svd</span><span class="p">)</span>
</pre>
 <p>
  If
  <span class="pre">
   sort_svd
  </span>
  is zero, the singular values are not sorted. This function only works for
  <span class="pre">
   gesvdjBatched
  </span>
  .
  <span class="pre">
   gesvdj
  </span>
  always sorts singular values in descending order. By default, singular values are always sorted in descending order.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     The pointer to the structure of
     <span class="pre">
      gesvdj
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      sort_svd
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      sort_svd
     </span>
     is zero, the singular values are not sorted.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.25.
  </span>
  cusolverDnXgesvdjGetResidual()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxgesvdjgetresidual" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnXgesvdjGetResidual</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">gesvdjInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">residual</span><span class="p">)</span>
</pre>
 <p>
  This function reports residual of
  <span class="pre">
   gesvdj
  </span>
  . It does not support
  <span class="pre">
   gesvdjBatched
  </span>
  . If the user calls this function after
  <span class="pre">
   gesvdjBatched
  </span>
  , the error
  <span class="pre">
   CUSOLVER_STATUS_NOT_SUPPORTED
  </span>
  is returned.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The pointer to the structure of
     <span class="pre">
      gesvdj
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      residual
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Residual of
     <span class="pre">
      gesvdj
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_SUPPORTED
     </span>
    </p>
   </td>
   <td>
    <p>
     Does not support batched version
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.26.
  </span>
  cusolverDnXgesvdjGetSweeps()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxgesvdjgetsweeps" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnXgesvdjGetSweeps</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">gesvdjInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">executed_sweeps</span><span class="p">)</span>
</pre>
 <p>
  This function reports number of executed sweeps of
  <span class="pre">
   gesvdj
  </span>
  . It does not support
  <span class="pre">
   gesvdjBatched
  </span>
  . If the user calls this function after
  <span class="pre">
   gesvdjBatched
  </span>
  , the error
  <span class="pre">
   CUSOLVER_STATUS_NOT_SUPPORTED
  </span>
  is returned.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The pointer to the structure of
     <span class="pre">
      gesvdj
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      executed_sweeps
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of executed sweeps.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_SUPPORTED
     </span>
    </p>
   </td>
   <td>
    <p>
     Does not support batched version
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.27.
  </span>
  cusolverDnIRSParamsCreate()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsparamscreate" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnIRSParamsCreate</span><span class="p">(</span><span class="n">cusolverDnIRSParams_t</span><span class="o">*</span><span class="n">params</span><span class="p">);</span>
</pre>
 <p>
  This function creates and initializes the structure of parameters for an IRS solver such as the
  <span class="pre">
   cusolverDnIRSXgesv()
  </span>
  or the
  <span class="pre">
   cusolverDnIRSXgels()
  </span>
  functions to default values. The params structure created by this function can be used by one or more call to the same or to a different IRS solver. Note that in CUDA 10.2, the behavior was different and a new
  <span class="pre">
   params
  </span>
  structure was needed to be created per each call to an IRS solver. Also note that the user can also change configurations of the params and then call a new IRS instance, but be careful that the previous call was done because any change to the configuration before the previous call was done could affect it.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Pointer to the
     <span class="pre">
      cusolverDnIRSParams_t
     </span>
     <span class="pre">
      Params
     </span>
     structure
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The structure was created and initialized successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     The resources could not be allocated.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.28.
  </span>
  cusolverDnIRSParamsDestroy()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsparamsdestroy" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnIRSParamsDestroy</span><span class="p">(</span><span class="n">cusolverDnIRSParams_t</span><span class="n">params</span><span class="p">);</span>
</pre>
 <p>
  This function destroys and releases any memory required by the Params structure.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      cusolverDnIRSParams_t
     </span>
     <span class="pre">
      Params
     </span>
     structure.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The resources were released successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      Params
     </span>
     structure was not created.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_INFOS_NOT_DESTROYED
     </span>
    </p>
   </td>
   <td>
    <p>
     Not all the
     <span class="pre">
      Infos
     </span>
     structure associated with this
     <span class="pre">
      Params
     </span>
     structure have been destroyed yet.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.29.
  </span>
  cusolverDnIRSParamsSetSolverPrecisions()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsparamssetsolverprecisions" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnIRSParamsSetSolverPrecisions</span><span class="p">(</span>
<span class="n">cusolverDnIRSParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="n">cusolverPrecType_t</span><span class="n">solver_main_precision</span><span class="p">,</span>
<span class="n">cusolverPrecType_t</span><span class="n">solver_lowest_precision</span><span class="p">);</span>
</pre>
 <p>
  This function sets both the main and the lowest precision for the Iterative Refinement Solver (IRS). By main precision, we mean the precision of the Input and Output datatype. By lowest precision, we mean the solver is allowed to use as lowest computational precision during the LU factorization process. Note that the user has to set both the main and lowest precision before the first call to the IRS solver because they are NOT set by default with the
  <span class="pre">
   params
  </span>
  structure creation, as it depends on the Input Output data type and user request. It is a wrapper to both
  <span class="pre">
   cusolverDnIRSParamsSetSolverMainPrecision()
  </span>
  and
  <span class="pre">
   cusolverDnIRSParamsSetSolverLowestPrecision()
  </span>
  . All possible combinations of main/lowest precision are described in the table below. Usually the lowest precision defines the speedup that can be achieved. The ratio of the performance of the lowest precision over the main precision (e.g., Inputs/Outputs datatype) define the upper bound of the speedup that could be obtained. More precisely, it depends on many factors, but for large matrices sizes, it is the ratio of the matrix-matrix rank-k product (e.g., GEMM where K is 256 and M=N=size of the matrix) that define the possible speedup. For instance, if the inout precision is real double precision CUSOLVER_R_64F and the lowest precision is CUSOLVER_R_32F, then we can expect a speedup of at most 2X for large problem sizes. If the lowest precision was CUSOLVER_R_16F, then we can expect 3X-4X. A reasonable strategy should take the number of right-hand sides, the size of the matrix as well as the convergence rate into account.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      cusolverDnIRSParams_t
     </span>
     <span class="pre">
      Params
     </span>
     structure.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      solver_main_precision
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Allowed Inputs/Outputs datatype (for example CUSOLVER_R_FP64 for a real double precision data). See the table below for the supported precisions.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      solver_lowest_precision
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Allowed lowest compute type (for example CUSOLVER_R_16F for half precision computation). See the table below for the supported precisions.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      Params
     </span>
     structure was not created.
    </p>
   </td>
  </tr>
 </table>
 <table class="table-no-stripes docutils align-default" id="id22">
  <span class="caption-text">
   Table 2.
   Supported Inputs/Outputs data type and lower precision for the IRS solver
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#id22" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Inputs/Outputs Data Type (e.g., main precision)
    </p>
   </th>
   <th class="head">
    <p>
     Supported values for the lowest precision
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUSOLVER_C_64F,
     </span>
     <span class="pre">
      CUSOLVER_C_32F,
     </span>
     <span class="pre">
      CUSOLVER_C_16F,
     </span>
     <span class="pre">
      CUSOLVER_C_16BF,
     </span>
     <span class="pre">
      CUSOLVER_C_TF32
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUSOLVER_C_32F,
     </span>
     <span class="pre">
      CUSOLVER_C_16F,
     </span>
     <span class="pre">
      CUSOLVER_C_16BF,
     </span>
     <span class="pre">
      CUSOLVER_C_TF32
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUSOLVER_R_64F,
     </span>
     <span class="pre">
      CUSOLVER_R_32F,
     </span>
     <span class="pre">
      CUSOLVER_R_16F,
     </span>
     <span class="pre">
      CUSOLVER_R_16BF,
     </span>
     <span class="pre">
      CUSOLVER_R_TF32
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUSOLVER_R_32F,
     </span>
     <span class="pre">
      CUSOLVER_R_16F,
     </span>
     <span class="pre">
      CUSOLVER_R_16BF,
     </span>
     <span class="pre">
      CUSOLVER_R_TF32
     </span>
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.30.
  </span>
  cusolverDnIRSParamsSetSolverMainPrecision()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsparamssetsolvermainprecision" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnIRSParamsSetSolverMainPrecision</span><span class="p">(</span>
<span class="n">cusolverDnIRSParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="n">cusolverPrecType_t</span><span class="n">solver_main_precision</span><span class="p">);</span>
</pre>
 <p>
  This function sets the main precision for the Iterative Refinement Solver (IRS). By main precision, we mean, the type of the Input and Output data. Note that the user has to set both the main and lowest precision before a first call to the IRS solver because they are NOT set by default with the
  <span class="pre">
   params
  </span>
  structure creation, as it depends on the Input Output data type and user request. user can set it by either calling this function or by calling
  <span class="pre">
   cusolverDnIRSParamsSetSolverPrecisions()
  </span>
  which set both the main and the lowest precision together. All possible combinations of main/lowest precision are described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverDnIRSParamsSetSolverPrecisions__table-supported-inout">
   table
  </a>
  in the
  <span class="pre">
   cusolverDnIRSParamsSetSolverPrecisions()
  </span>
  section above.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      cusolverDnIRSParams_t
     </span>
     <span class="pre">
      Params
     </span>
     structure.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      solver_main_precision
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Allowed Inputs/Outputs datatype (for example CUSOLVER_R_FP64 for a real double precision data). See the table in the
     <span class="pre">
      cusolverDnIRSParamsSetSolverPrecisions()
     </span>
     section above for the supported precisions.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      Params
     </span>
     structure was not created.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.31.
  </span>
  cusolverDnIRSParamsSetSolverLowestPrecision()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsparamssetsolverlowestprecision" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnIRSParamsSetSolverLowestPrecision</span><span class="p">(</span>
<span class="n">cusolverDnIRSParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="n">cusolverPrecType_t</span><span class="n">lowest_precision_type</span><span class="p">);</span>
</pre>
 <p>
  This function sets the lowest precision that will be used by Iterative Refinement Solver. By lowest precision, we mean the solver is allowed to use as lowest computational precision during the LU factorization process. Note that the user has to set both the main and lowest precision before a first call to the IRS solver because they are NOT set by default with the
  <span class="pre">
   params
  </span>
  structure creation, as it depends on the Input Output data type and user request. Usually the lowest precision defines the speedup that can be achieved. The ratio of the performance of the lowest precision over the main precision (e.g., Inputs/Outputs datatype) define somehow the upper bound of the speedup that could be obtained. More precisely, it depends on many factors, but for large matrices sizes, it is the ratio of the matrix-matrix rank-k product (e.g., GEMM where K is 256 and M=N=size of the matrix) that define the possible speedup. For instance, if the inout precision is real double precision CUSOLVER_R_64F and the lowest precision is CUSOLVER_R_32F, then we can expect a speedup of at most 2X for large problem sizes. If the lowest precision was CUSOLVER_R_16F, then we can expect 3X-4X. A reasonable strategy should take the number of right-hand sides, the size of the matrix as well as the convergence rate into account.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      cusolverDnIRSParams_t
     </span>
     <span class="pre">
      Params
     </span>
     structure.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lowest_precision_type
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Allowed lowest compute type (for example CUSOLVER_R_16F for half precision computation). See the table in the
     <span class="pre">
      cusolverDnIRSParamsSetSolverPrecisions()
     </span>
     section above for the supported precisions.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The Params structure was not created.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.32.
  </span>
  cusolverDnIRSParamsSetRefinementSolver()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsparamssetrefinementsolver" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnIRSParamsSetRefinementSolver</span><span class="p">(</span>
<span class="n">cusolverDnIRSParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="n">cusolverIRSRefinement_t</span><span class="n">solver</span><span class="p">);</span>
</pre>
 <p>
  This function sets the refinement solver to be used in the Iterative Refinement Solver functions such as the
  <span class="pre">
   cusolverDnIRSXgesv()
  </span>
  or the
  <span class="pre">
   cusolverDnIRSXgels()
  </span>
  functions. Note that the user has to set the refinement algorithm before a first call to the IRS solver because it is NOT set by default with the creating of params. Details about values that can be set to and theirs meaning are described in the table below.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      cusolverDnIRSParams_t
     </span>
     <span class="pre">
      Params
     </span>
     structure
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      solver
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Type of the refinement solver to be used by the IRS solver such as
     <span class="pre">
      cusolverDnIRSXgesv()
     </span>
     or
     <span class="pre">
      cusolverDnIRSXgels()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      Params
     </span>
     structure was not created.
    </p>
   </td>
  </tr>
 </table>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_IRS_REFINE_NOT_SET
     </span>
    </p>
   </td>
   <td>
    <p>
     Solver is not set, this value is what is set when creating the params structure. IRS solver will return an error.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_IRS_REFINE_NONE
     </span>
    </p>
   </td>
   <td>
    <p>
     No refinement solver; the IRS solver performs a factorization followed by a solve without any refinement. For example, if the IRS solver was
     <span class="pre">
      cusolverDnIRSXgesv()
     </span>
     , this is equivalent to a Xgesv routine without refinement and where the factorization is carried out in the lowest precision. If for example the main precision was CUSOLVER_R_64F and the lowest was CUSOLVER_R_64F as well, then this is equivalent to a call to
     <span class="pre">
      cusolverDnDgesv()
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_IRS_REFINE_CLASSICAL
     </span>
    </p>
   </td>
   <td>
    <p>
     Classical iterative refinement solver. Similar to the one used in LAPACK routines.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_IRS_REFINE_GMRES
     </span>
    </p>
   </td>
   <td>
    <p>
     GMRES (Generalized Minimal Residual) based iterative refinement solver. In recent study, the GMRES method has drawn the scientific community attention for its ability to be used as refinement solver that outperforms the classical iterative refinement method. Based on our experimentation, we recommend this setting.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_IRS_REFINE_CLASSICAL_GMRES
     </span>
    </p>
   </td>
   <td>
    <p>
     Classical iterative refinement solver that uses the GMRES (Generalized Minimal Residual) internally to solve the correction equation at each iteration. We call the
     classical refinement iteration
     the outer iteration while the
     GMRES
     is called inner iteration. Note that if the tolerance of the inner GMRES is set very low, let say to machine precision, then the outer
     classical refinement iteration
     will performs only one iteration and thus this option will behaves like CUSOLVER_IRS_REFINE_GMRES.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_IRS_REFINE_GMRES_GMRES
     </span>
    </p>
   </td>
   <td>
    <p>
     Similar to
     <span class="pre">
      CUSOLVER_IRS_REFINE_CLASSICAL_GMRES
     </span>
     which consists of classical refinement process that uses GMRES to solve the inner correction system, here it is a GMRES (Generalized Minimal Residual) based iterative refinement solver that uses another GMRES internally to solve the preconditioned system.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.33.
  </span>
  cusolverDnIRSParamsSetTol()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsparamssettol" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnIRSParamsSetTol</span><span class="p">(</span>
<span class="n">cusolverDnIRSParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">double</span><span class="n">val</span><span class="p">);</span>
</pre>
 <p>
  This function sets the tolerance for the refinement solver. By default it is such that all the RHS satisfy:
 </p>
 <p>
  Â Â Â
  <span class="pre">
   RNRM
  </span>
  <span class="pre">
   &lt;
  </span>
  <span class="pre">
   SQRT(N)*XNRM*ANRM*EPS*BWDMAX
  </span>
  where
 </p>
 <ul class="simple">
  <li>
   <p>
    RNRM is the infinity-norm of the residual
   </p>
  </li>
  <li>
   <p>
    XNRM is the infinity-norm of the solution
   </p>
  </li>
  <li>
   <p>
    ANRM is the infinity-operator-norm of the matrix A
   </p>
  </li>
  <li>
   <p>
    EPS is the machine epsilon for the Inputs/Outputs datatype that matches LAPACK &lt;X&gt;LAMCH(âEpsilonâ)
   </p>
  </li>
  <li>
   <p>
    BWDMAX, the value BWDMAX is fixed to 1.0
   </p>
  </li>
 </ul>
 <p>
  The user can use this function to change the tolerance to a lower or higher value. Our goal is to give the user more control such a way he can investigate and control every detail of the IRS solver. Note that the tolerance value is always in
  real double precision
  whatever the Inputs/Outputs datatype is.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      cusolverDnIRSParams_t
     </span>
     <span class="pre">
      Params
     </span>
     structure.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      val
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Double precision real value to which the refinement tolerance will be set.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      Params
     </span>
     structure was not created.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.34.
  </span>
  cusolverDnIRSParamsSetTolInner()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsparamssettolinner" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnIRSParamsSetTolInner</span><span class="p">(</span>
<span class="n">cusolverDnIRSParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">double</span><span class="n">val</span><span class="p">);</span>
</pre>
 <p>
  This function sets the tolerance for the inner refinement solver when the refinement solver consists of two-levels solver (e.g., CUSOLVER_IRS_REFINE_CLASSICAL_GMRES or CUSOLVER_IRS_REFINE_GMRES_GMRES cases). It is not referenced in case of one level refinement solver such as CUSOLVER_IRS_REFINE_CLASSICAL or CUSOLVER_IRS_REFINE_GMRES. It is set to 1e-4 by default. This function set the tolerance for the inner solver (e.g. the inner GMRES). For example, if the Refinement Solver was set to CUSOLVER_IRS_REFINE_CLASSICAL_GMRES, setting this tolerance mean that the inner GMRES solver will converge to that tolerance at each outer iteration of the classical refinement solver. Our goal is to give the user more control such a way he can investigate and control every detail of the IRS solver. Note the, the tolerance value is always in
  real double precision
  whatever the Inputs/Outputs datatype is.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      cusolverDnIRSParams_t
     </span>
     <span class="pre">
      Params
     </span>
     structure.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      val
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Double precision real value to which the tolerance of the inner refinement solver will be set.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      Params
     </span>
     structure was not created.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.35.
  </span>
  cusolverDnIRSParamsSetMaxIters()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsparamssetmaxiters" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnIRSParamsSetMaxIters</span><span class="p">(</span>
<span class="n">cusolverDnIRSParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">int</span><span class="n">max_iters</span><span class="p">);</span>
</pre>
 <p>
  This function sets the total number of allowed refinement iterations after which the solver will stop. Total means any iteration which means the sum of the outer and the inner iterations (inner is meaningful when two-levels refinement solver is set). Default value is set to 50. Our goal is to give the user more control such a way he can investigate and control every detail of the IRS solver.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      cusolverDnIRSParams_t
     </span>
     <span class="pre">
      Params
     </span>
     structure.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      max_iters
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Maximum total number of iterations allowed for the refinement solver.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      Params
     </span>
     structure was not created.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.36.
  </span>
  cusolverDnIRSParamsSetMaxItersInner()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsparamssetmaxitersinner" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnIRSParamsSetMaxItersInner</span><span class="p">(</span>
<span class="n">cusolverDnIRSParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="n">cusolver_int_t</span><span class="n">maxiters_inner</span><span class="p">);</span>
</pre>
 <p>
  This function sets the maximal number of iterations allowed for the inner refinement solver. It is not referenced in case of one level refinement solver such as CUSOLVER_IRS_REFINE_CLASSICAL or CUSOLVER_IRS_REFINE_GMRES. The inner refinement solver will stop after reaching either the inner tolerance or the MaxItersInner value. By default, it is set to 50. Note that this value could not be larger than the MaxIters since MaxIters is the total number of allowed iterations. Note that if the user calls
  <span class="pre">
   cusolverDnIRSParamsSetMaxIters
  </span>
  after calling this function,
  <span class="pre">
   SetMaxIters
  </span>
  has priority and will overwrite
  <span class="pre">
   MaxItersInner
  </span>
  to the minimum value of
  <span class="pre">
   (MaxIters,
  </span>
  <span class="pre">
   MaxItersInner)
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      cusolverDnIRSParams_t
     </span>
     <span class="pre">
      Params
     </span>
     structure
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      maxiters_inner
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Maximum number of allowed inner iterations for the inner refinement solver. Meaningful when the refinement solver is a two-levels solver such as CUSOLVER_IRS_REFINE_CLASSICAL_GMRES or CUSOLVER_IRS_REFINE_GMRES_GMRES. Value should be less or equal to
     <span class="pre">
      MaxIters
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      Params
     </span>
     structure was not created.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_PARAMS_INVALID
     </span>
    </p>
   </td>
   <td>
    <p>
     If the value was larger than
     <span class="pre">
      MaxIters
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.37.
  </span>
  cusolverDnIRSParamsEnableFallback()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsparamsenablefallback" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnIRSParamsEnableFallback</span><span class="p">(</span>
<span class="n">cusolverDnIRSParams_t</span><span class="n">params</span><span class="p">);</span>
</pre>
 <p>
  This function enable the fallback to the main precision in case the Iterative Refinement Solver (IRS) failed to converge. In other term, if the IRS solver failed to converge, the solver will return a no convergence code (e.g.,
  <span class="pre">
   niter
  </span>
  &lt; 0), but can either return the non-convergent solution as it is (e.g., disable fallback) or can fallback (e.g., enable fallback) to the main precision (which is the precision of the Inputs/Outputs data) and solve the problem from scratch returning the good solution. This is the behavior by default, and it will guarantee that the IRS solver always provide the good solution. This function is provided because we provided
  <span class="pre">
   cusolverDnIRSParamsDisableFallback
  </span>
  which allows the user to disable the fallback and thus this function allow the user to re-enable it.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      cusolverDnIRSParams_t
     </span>
     <span class="pre">
      Params
     </span>
     structure
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      Params
     </span>
     structure was not created.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.38.
  </span>
  cusolverDnIRSParamsDisableFallback()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsparamsdisablefallback" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnIRSParamsDisableFallback</span><span class="p">(</span>
<span class="n">cusolverDnIRSParams_t</span><span class="n">params</span><span class="p">);</span>
</pre>
 <p>
  This function disables the fallback to the main precision in case the Iterative Refinement Solver (IRS) failed to converge. In other term, if the IRS solver failed to converge, the solver will return a no convergence code (e.g.,
  <span class="pre">
   niter
  </span>
  &lt; 0), but can either return the non-convergent solution as it is (e.g., disable fallback) or can fallback (e.g., enable fallback) to the main precision (which is the precision of the Inputs/Outputs data) and solve the problem from scratch returning the good solution. This function disables the fallback and the returned solution is whatever the refinement solver was able to reach before it returns. Disabling fallback does not guarantee that the solution is the good one. However, if users want to keep getting the solution of the lower precision in case the IRS did not converge after certain number of iterations, they need to disable the fallback. The user can re-enable it by calling
  <span class="pre">
   cusolverDnIRSParamsEnableFallback
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      cusolverDnIRSParams_t
     </span>
     <span class="pre">
      Params
     </span>
     structure
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      Params
     </span>
     structure was not created.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.39.
  </span>
  cusolverDnIRSParamsGetMaxIters()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsparamsgetmaxiters" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnIRSParamsGetMaxIters</span><span class="p">(</span>
<span class="n">cusolverDnIRSParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="n">cusolver_int_t</span><span class="o">*</span><span class="n">maxiters</span><span class="p">);</span>
</pre>
 <p>
  This function returns the current setting in the
  <span class="pre">
   params
  </span>
  structure for the maximal allowed number of iterations (e.g., either the default
  <span class="pre">
   MaxIters
  </span>
  , or the one set by the user in case he set it using
  <span class="pre">
   cusolverDnIRSParamsSetMaxIters
  </span>
  ). Note that this function returns the current setting in the
  <span class="pre">
   params
  </span>
  configuration and not to be confused with the
  <span class="pre">
   cusolverDnIRSInfosGetMaxIters
  </span>
  which return the maximal allowed number of iterations for a particular call to an IRS solver. To be clearer, the
  <span class="pre">
   params
  </span>
  structure can be used for many calls to an IRS solver. A user can change the allowed
  <span class="pre">
   MaxIters
  </span>
  between calls while the
  <span class="pre">
   Infos
  </span>
  structure in
  <span class="pre">
   cusolverDnIRSInfosGetMaxIters
  </span>
  contains information about a particular call and cannot be reused for different calls, and thus,
  <span class="pre">
   cusolverDnIRSInfosGetMaxIters
  </span>
  returns the allowed
  <span class="pre">
   MaxIters
  </span>
  for that call.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      cusolverDnIRSParams_t
     </span>
     <span class="pre">
      Params
     </span>
     structure.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      maxiters
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The maximal number of iterations that is currently set.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      Params
     </span>
     structure was not created.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.40.
  </span>
  cusolverDnIRSInfosCreate()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsinfoscreate" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnIRSInfosCreate</span><span class="p">(</span>
<span class="n">cusolverDnIRSInfos_t</span><span class="o">*</span><span class="n">infos</span><span class="p">)</span>
</pre>
 <p>
  This function creates and initializes the
  <span class="pre">
   Infos
  </span>
  structure that will hold the refinement information of an Iterative Refinement Solver (IRS) call. Such information includes the total number of iterations that was needed to converge (
  <span class="pre">
   Niters
  </span>
  ), the outer number of iterations (meaningful when two-levels preconditioner such as CUSOLVER_IRS_REFINE_CLASSICAL_GMRES is used ), the maximal number of iterations that was allowed for that call, and a pointer to the matrix of the convergence history residual norms. The
  <span class="pre">
   Infos
  </span>
  structure needs to be created before a call to an IRS solver. The
  <span class="pre">
   Infos
  </span>
  structure is valid for only one call to an IRS solver, since it holds info about that solve and thus each solve will requires its own
  <span class="pre">
   Infos
  </span>
  structure.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Pointer to the
     <span class="pre">
      cusolverDnIRSInfos_t
     </span>
     <span class="pre">
      Infos
     </span>
     structure.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The structure was initialized successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     The resources could not be allocated.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.41.
  </span>
  cusolverDnIRSInfosDestroy()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsinfosdestroy" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnIRSInfosDestroy</span><span class="p">(</span>
<span class="n">cusolverDnIRSInfos_t</span><span class="n">infos</span><span class="p">);</span>
</pre>
 <p>
  This function destroys and releases any memory required by the
  <span class="pre">
   Infos
  </span>
  structure. This function destroys all the information (e.g., Niters performed, OuterNiters performed, residual history etc.) about a solver call; thus, this function should only be called after the user is finished with the information.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      cusolverDnIRSInfos_t
     </span>
     <span class="pre">
      Infos
     </span>
     structure.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The resources were released successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_INFOS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      Infos
     </span>
     structure was not created.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.42.
  </span>
  cusolverDnIRSInfosGetMaxIters()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsinfosgetmaxiters" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnIRSInfosGetMaxIters</span><span class="p">(</span>
<span class="n">cusolverDnIRSInfos_t</span><span class="n">infos</span><span class="p">,</span>
<span class="n">cusolver_int_t</span><span class="o">*</span><span class="n">maxiters</span><span class="p">);</span>
</pre>
 <p>
  This function returns the maximal allowed number of iterations that was set for the corresponding call to the IRS solver. Note that this function returns the setting that was set when that call happened and is not to be confused with the
  <span class="pre">
   cusolverDnIRSParamsGetMaxIters
  </span>
  which returns the current setting in the
  <span class="pre">
   params
  </span>
  configuration structure. To be clearer, the
  <span class="pre">
   params
  </span>
  structure can be used for many calls to an IRS solver. A user can change the allowed
  <span class="pre">
   MaxIters
  </span>
  between calls while the
  <span class="pre">
   Infos
  </span>
  structure in
  <span class="pre">
   cusolverDnIRSInfosGetMaxIters
  </span>
  contains information about a particular call and cannot be reused for different calls, thus
  <span class="pre">
   cusolverDnIRSInfosGetMaxIters
  </span>
  returns the allowed
  <span class="pre">
   MaxIters
  </span>
  for that call.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      infos
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      cusolverDnIRSInfos_t
     </span>
     <span class="pre">
      Infos
     </span>
     structure.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      maxiters
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The maximal number of iterations that is currently set.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_INFOS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      Infos
     </span>
     structure was not created.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.43.
  </span>
  cusolverDnIRSInfosGetNiters()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsinfosgetniters" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span><span class="nf">cusolverDnIRSInfosGetNiters</span><span class="p">(</span>
<span class="n">cusolverDnIRSInfos_t</span><span class="n">infos</span><span class="p">,</span>
<span class="n">cusolver_int_t</span><span class="o">*</span><span class="n">niters</span><span class="p">);</span>
</pre>
 <p>
  This function returns the total number of iterations performed by the IRS solver. If it was negative, it means that the IRS solver did not converge and if the user did not disable the fallback to full precision, then the fallback to a full precision solution happened and solution is good. Please refer to the description of negative
  <span class="pre">
   niters
  </span>
  values in the corresponding IRS linear solver functions such as
  <span class="pre">
   cusolverDnXgesv()
  </span>
  or
  <span class="pre">
   cusolverDnXgels()
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      infos
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      cusolverDnIRSInfos_t
     </span>
     <span class="pre">
      Infos
     </span>
     structure.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      niters
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The total number of iterations performed by the IRS solver.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_INFOS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      Infos
     </span>
     structure was not created.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.44.
  </span>
  cusolverDnIRSInfosGetOuterNiters()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsinfosgetouterniters" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnIRSInfosGetOuterNiters</span><span class="p">(</span>
<span class="n">cusolverDnIRSInfos_t</span><span class="n">infos</span><span class="p">,</span>
<span class="n">cusolver_int_t</span><span class="o">*</span><span class="n">outer_niters</span><span class="p">);</span>
</pre>
 <p>
  This function returns the number of iterations performed by the outer refinement loop of the IRS solver. When the refinement solver consists of a one-level solver such as CUSOLVER_IRS_REFINE_CLASSICAL or CUSOLVER_IRS_REFINE_GMRES, it is the same as
  <span class="pre">
   Niters
  </span>
  . When the refinement solver consists of a two-levels solver such as CUSOLVER_IRS_REFINE_CLASSICAL_GMRES or CUSOLVER_IRS_REFINE_GMRES_GMRES, it is the number of iterations of the outer loop. Refer to the description of the
  <span class="pre">
   cusolverIRSRefinement_t
  </span>
  for more details.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      infos
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      cusolverDnIRSInfos_t
     </span>
     <span class="pre">
      Infos
     </span>
     structure.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      outer_niters
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of iterations of the outer refinement loop of the IRS solver.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_INFOS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      Infos
     </span>
     structure was not created.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.45.
  </span>
  cusolverDnIRSInfosRequestResidual()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsinfosrequestresidual" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span><span class="nf">cusolverDnIRSInfosRequestResidual</span><span class="p">(</span>
<span class="n">cusolverDnIRSInfos_t</span><span class="n">infos</span><span class="p">);</span>
</pre>
 <p>
  This function tells the IRS solver to store the convergence history (residual norms) of the refinement phase in a matrix that can be accessed via a pointer returned by the
  <span class="pre">
   cusolverDnIRSInfosGetResidualHistory()
  </span>
  function.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      infos
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      cusolverDnIRSInfos_t
     </span>
     <span class="pre">
      Infos
     </span>
     structure
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_INFOS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      Infos
     </span>
     structure was not created.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.46.
  </span>
  cusolverDnIRSInfosGetResidualHistory()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsinfosgetresidualhistory" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnIRSInfosGetResidualHistory</span><span class="p">(</span>
<span class="n">cusolverDnIRSInfos_t</span><span class="n">infos</span><span class="p">,</span>
<span class="kt">void</span><span class="o">**</span><span class="n">residual_history</span><span class="p">);</span>
</pre>
 <p>
  If the user called
  <span class="pre">
   cusolverDnIRSInfosRequestResidual()
  </span>
  before the call to the IRS function, then the IRS solver will store the convergence history (residual norms) of the refinement phase in a matrix that can be accessed via a pointer returned by this function. The datatype of the residual norms depends on the input and output data type. If the Inputs/Outputs datatype is double precision real or complex (CUSOLVER_R_FP64 or CUSOLVER_C_FP64), this residual will be of type real double precision (FP64)
  double
  , otherwise if the Inputs/Outputs datatype is single precision real or complex (CUSOLVER_R_FP32 or CUSOLVER_C_FP32), this residual will be real single precision FP32
  float
  .
 </p>
 <p>
  The residual history matrix consists of two columns (even for the multiple right-hand side case NRHS) of
  <span class="pre">
   MaxIters+1
  </span>
  row, thus a matrix of size (
  <span class="pre">
   MaxIters+1,2
  </span>
  ). Only the first
  <span class="pre">
   OuterNiters+1
  </span>
  rows contains the residual norms the other (e.g., OuterNiters+2:Maxiters+1) are garbage. On the first column, each row
  âiâ
  specify the total number of iterations happened till this outer iteration
  âiâ
  and on the second columns the residual norm corresponding to this outer iteration
  âiâ
  . Thus, the first row (e.g., outer iteration
  â0â
  ) consists of the initial residual (e.g., the residual before the refinement loop start) then the consecutive rows are the residual obtained at each outer iteration of the refinement loop. Note, it only consists of the history of the outer loop.
 </p>
 <p>
  If the refinement solver was CUSOLVER_IRS_REFINE_CLASSICAL or CUSOLVER_IRS_REFINE_GMRES, then OuterNiters=Niters (Niters is the total number of iterations performed) and there is Niters+1 rows of norms that correspond to the Niters outer iterations.
 </p>
 <p>
  If the refinement solver was CUSOLVER_IRS_REFINE_CLASSICAL_GMRES or CUSOLVER_IRS_REFINE_GMRES_GMRES, then OuterNiters &lt;= Niters corresponds to the outer iterations performed by the outer refinement loop. Thus, there is OuterNiters+1 residual norms where row
  âiâ
  correspond to the outer iteration
  âiâ
  and the first column specify the total number of iterations (outer and inner) that were performed till this step the second columns correspond to the residual norm at this step.
 </p>
 <p>
  For example, letâs say the user specifies CUSOLVER_IRS_REFINE_CLASSICAL_GMRES as a refinement solver and say it needed 3 outer iterations to converge and 4,3,3 inner iterations at each outer, respectively. This consists of 10 total iterations. Row 0 corresponds to the first residual before the refinement start, so it has 0 in its first column. On row 1 which corresponds to the outer iteration 1, it will be 4 (4 is the total number of iterations that were performed till now), on row 2 it will be 7, and on row 3 it will be 10.
 </p>
 <p>
  In summary, letâs define
  <span class="pre">
   ldh=Maxiters+1
  </span>
  , the leading dimension of the residual matrix. then
  <span class="pre">
   residual_history[i]
  </span>
  shows the total number of iterations performed at the outer iteration
  âiâ
  and
  <span class="pre">
   residual_history[i+ldh]
  </span>
  corresponds to the norm of the residual at this outer iteration.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      infos
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      cusolverDnIRSInfos_t
     </span>
     <span class="pre">
      Infos
     </span>
     structure.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      residual_history
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Returns a void pointer to the matrix of the convergence history residual norms. See the description above for the relation between the residual norm datatype and the inout datatype.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_INFOS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The
     <span class="pre">
      Infos
     </span>
     structure was not created.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     This function was called without calling
     <span class="pre">
      cusolverDnIRSInfosRequestResidual()
     </span>
     in advance.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.47.
  </span>
  cusolverDnCreateParams()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdncreateparams" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCreateParams</span><span class="p">(</span>
<span class="n">cusolverDnParams_t</span><span class="o">*</span><span class="n">params</span><span class="p">);</span>
</pre>
 <p>
  This function creates and initializes the structure of
  <span class="pre">
   64-bit
  </span>
  <span class="pre">
   API
  </span>
  to default values.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The pointer to the structure of
     <span class="pre">
      64-bit
     </span>
     <span class="pre">
      API
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The structure was initialized successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     The resources could not be allocated.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.48.
  </span>
  cusolverDnDestroyParams()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdndestroyparams" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDestroyParams</span><span class="p">(</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">);</span>
</pre>
 <p>
  This function destroys and releases any memory required by the structure.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The structure of
     <span class="pre">
      64-bit
     </span>
     <span class="pre">
      API
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The resources were released successfully.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.1.49.
  </span>
  cusolverDnSetAdvOptions()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnsetadvoptions" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSetAdvOptions</span><span class="p">(</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="n">cusolverDnFunction_t</span><span class="n">function</span><span class="p">,</span>
<span class="n">cusolverAlgMode_t</span><span class="n">algo</span><span class="p">);</span>
</pre>
 <p>
  This function configures algorithm
  <span class="pre">
   algo
  </span>
  of
  <span class="pre">
   function
  </span>
  , a
  <span class="pre">
   64-bit
  </span>
  <span class="pre">
   API
  </span>
  routine.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     The pointer to the structure of
     <span class="pre">
      64-bit
     </span>
     <span class="pre">
      API
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      function
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The routine to be configured.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      algo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The algorithm to be configured.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Wrong combination of
     <span class="pre">
      function
     </span>
     and
     <span class="pre">
      algo
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.4.2.
  </span>
  Dense Linear Solver Reference (legacy)
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#dense-linear-solver-reference-legacy" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  This section describes linear solver API of cuSolverDN, including Cholesky factorization, LU with partial pivoting, QR factorization and Bunch-Kaufman (LDLT) factorization.
 </p>
 <h4>
  <span class="section-number">
   2.4.2.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDN-lt-t-gt-potrf">
   cusolverDn&lt;t&gt;potrf()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-potrf" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  These helper functions calculate the necessary size of work buffers.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSpotrf_bufferSize</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">Lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDpotrf_bufferSize</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">Lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCpotrf_bufferSize</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">Lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZpotrf_bufferSize</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">Lwork</span><span class="p">);</span>
</pre>
 <p>
  The S and D data types are real valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSpotrf</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">Workspace</span><span class="p">,</span>
<span class="kt">int</span><span class="n">Lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDpotrf</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">Workspace</span><span class="p">,</span>
<span class="kt">int</span><span class="n">Lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  The C and Z data types are complex valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCpotrf</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">Workspace</span><span class="p">,</span>
<span class="kt">int</span><span class="n">Lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZpotrf</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">Workspace</span><span class="p">,</span>
<span class="kt">int</span><span class="n">Lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  This function computes the Cholesky factorization of a Hermitian positive-definite matrix.
 </p>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   nÃn
  </span>
  Hermitian matrix, only the lower or upper part is meaningful. The input parameter
  <span class="pre">
   uplo
  </span>
  indicates which part of the matrix is used. The function would leave other parts untouched.
 </p>
 <p>
  If input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_LOWER
  </span>
  , only the lower triangular part of
  <span class="pre">
   A
  </span>
  is processed, and replaced by the lower triangular Cholesky factor
  <span class="pre">
   L
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = L*L^{H}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  If input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_UPPER
  </span>
  , only upper triangular part of
  <span class="pre">
   A
  </span>
  is processed, and replaced by upper triangular Cholesky factor
  <span class="pre">
   U
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = U^{H}*U\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The user has to provide working space which is pointed by input parameter
  <span class="pre">
   Workspace
  </span>
  . The input parameter
  <span class="pre">
   Lwork
  </span>
  is size of the working space, and it is returned by
  <span class="pre">
   potrf_bufferSize()
  </span>
  .
 </p>
 <p>
  If Cholesky factorization failed, i.e. some leading minor of
  <span class="pre">
   A
  </span>
  is not positive definite, or equivalently some diagonal elements of
  <span class="pre">
   L
  </span>
  or
  <span class="pre">
   U
  </span>
  is not a real number. The output parameter
  <span class="pre">
   devInfo
  </span>
  would indicate smallest leading minor of
  <span class="pre">
   A
  </span>
  which is not positive definite.
 </p>
 <p>
  If output parameter
  <span class="pre">
   devInfo
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  API of potrf
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Indicates if matrix
     <span class="pre">
      A
     </span>
     lower or upper part is stored; the other part is not referenced.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      Workspace
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Working space, &lt;type&gt; array of size
     <span class="pre">
      Lwork
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      Lwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of
     <span class="pre">
      Workspace
     </span>
     , returned by
     <span class="pre">
      potrf_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      devInfo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the Cholesky factorization is successful. if
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle). if
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      i
     </span>
     , the leading minor of order i is not positive definite.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n&lt;0
     </span>
     or
     <span class="pre">
      lda&lt;max(1,n)
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.2.2.
  </span>
  cusolverDnPotrf()[DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnpotrf-deprecated" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  [[DEPRECATED]] use
  <span class="pre">
   cusolverDnXpotrf()
  </span>
  instead. The routine will be removed in the next major release.
 </p>
 <p>
  The helper functions below can calculate the sizes needed for pre-allocated buffer.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnPotrf_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytes</span><span class="p">)</span>
</pre>
 <p>
  The routine below
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnPotrf</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">workspaceInBytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">)</span>
</pre>
 <p>
  Computes the Cholesky factorization of a Hermitian positive-definite matrix using the generic API interface.
 </p>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   nÃn
  </span>
  Hermitian matrix, only lower or upper part is meaningful. The input parameter
  <span class="pre">
   uplo
  </span>
  indicates which part of the matrix is used. The function would leave other part untouched.
 </p>
 <p>
  If input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_LOWER
  </span>
  , only lower triangular part of
  <span class="pre">
   A
  </span>
  is processed, and replaced by lower triangular Cholesky factor
  <span class="pre">
   L
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = L*L^{H}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  If input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_UPPER
  </span>
  , only upper triangular part of
  <span class="pre">
   A
  </span>
  is processed, and replaced by upper triangular Cholesky factor
  <span class="pre">
   U
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = U^{H}*U\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The user has to provide working space which is pointed by input parameter
  <span class="pre">
   pBuffer
  </span>
  . The input parameter
  <span class="pre">
   workspaceInBytes
  </span>
  is size in bytes of the working space, and it is returned by
  <span class="pre">
   cusolverDnPotrf_bufferSize()
  </span>
  .
 </p>
 <p>
  If Cholesky factorization failed, i.e. some leading minor of
  <span class="pre">
   A
  </span>
  is not positive definite, or equivalently some diagonal elements of
  <span class="pre">
   L
  </span>
  or
  <span class="pre">
   U
  </span>
  is not a real number. The output parameter
  <span class="pre">
   info
  </span>
  would indicate smallest leading minor of
  <span class="pre">
   A
  </span>
  which is not positive definite.
 </p>
 <p>
  If output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  Currently,
  <span class="pre">
   cusolverDnPotrf
  </span>
  supports only the default algorithm.
 </p>
 <p>
  Table of algorithms supported by cusolverDnPotrf
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_ALG_0
     </span>
     or
     <span class="pre">
      NULL
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm.
    </p>
   </td>
  </tr>
 </table>
 <p>
  List of input arguments for
  <span class="pre">
   cusolverDnPotrf_bufferSize
  </span>
  and
  <span class="pre">
   cusolverDnPotrf
  </span>
  :
 </p>
 <p>
  API of potrf
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Structure with information collected by
     <span class="pre">
      cusolverDnSetAdvOptions
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Indicates if matrix
     <span class="pre">
      A
     </span>
     lower or upper part is stored, the other part is not referenced.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dataTypeA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of computation.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Working space. Array of type
     <span class="pre">
      void
     </span>
     of size
     <span class="pre">
      workspaceInBytes
     </span>
     bytes.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      workspaceInBytes
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      pBuffer
     </span>
     , returned by
     <span class="pre">
      cusolverDnPotrf_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the Cholesky factorization is successful. if
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle). if
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     Â
     <span class="pre">
      i
     </span>
     , the leading minor of order i is not positive definite.
    </p>
   </td>
  </tr>
 </table>
 <p>
  The generic API has two different types,
  <span class="pre">
   dataTypeA
  </span>
  is data type of the matrix
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   computeType
  </span>
  is compute type of the operation.
  <span class="pre">
   cusolverDnPotrf
  </span>
  only supports the following four combinations.
 </p>
 <p>
  Valid combination of data type and compute type
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      DataTypeA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ComputeType
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      Meaning
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      SPOTRF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      DPOTRF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CPOTRF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ZPOTRF
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n&lt;0
     </span>
     or
     <span class="pre">
      lda&lt;max(1,n)
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.2.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDN-lt-t-gt-potrs">
   cusolverDn&lt;t&gt;potrs()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-potrs" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSpotrs</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDpotrs</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCpotrs</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZpotrs</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  This function solves a system of linear equations
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A*X = B\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   nÃn
  </span>
  Hermitian matrix, only lower or upper part is meaningful. The input parameter
  <span class="pre">
   uplo
  </span>
  indicates which part of the matrix is used. The function would leave other part untouched.
 </p>
 <p>
  The user has to call
  <span class="pre">
   potrf
  </span>
  first to factorize matrix
  <span class="pre">
   A
  </span>
  . If input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_LOWER
  </span>
  ,
  <span class="pre">
   A
  </span>
  is lower triangular Cholesky factor
  <span class="pre">
   L
  </span>
  corresponding to
  <span class="math notranslate nohighlight">
   \(A = L*L^{H}\)
  </span>
  . If input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_UPPER
  </span>
  ,
  <span class="pre">
   A
  </span>
  is upper triangular Cholesky factor
  <span class="pre">
   U
  </span>
  corresponding to
  <span class="math notranslate nohighlight">
   \(A = U^{H}*U\)
  </span>
  .
 </p>
 <p>
  The operation is in-place, i.e. matrix
  <span class="pre">
   X
  </span>
  overwrites matrix
  <span class="pre">
   B
  </span>
  with the same leading dimension
  <span class="pre">
   ldb
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   devInfo
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  API of potrs
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Indicates if matrix
     <span class="pre">
      A
     </span>
     lower or upper part is stored, the other part is not referenced.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nrhs
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of matrix
     <span class="pre">
      X
     </span>
     and
     <span class="pre">
      B
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
     <span class="pre">
      A
     </span>
     is either lower Cholesky factor
     <span class="pre">
      L
     </span>
     or upper Cholesky factor
     <span class="pre">
      U
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      B
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      ldb
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      nrhs
     </span>
     .
     <span class="pre">
      ldb
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     . As an input,
     <span class="pre">
      B
     </span>
     is right hand side matrix. As an output,
     <span class="pre">
      B
     </span>
     is the solution matrix.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      devInfo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the Cholesky factorization is successful. if
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle).
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n&lt;0
     </span>
     ,
     <span class="pre">
      nrhs&lt;0
     </span>
     ,
     <span class="pre">
      lda&lt;max(1,n)
     </span>
     or
     <span class="pre">
      ldb&lt;max(1,n)
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.2.4.
  </span>
  cusolverDnPotrs()[DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnpotrs-deprecated" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  [[DEPRECATED]] use
  <span class="pre">
   cusolverDnXpotrs()
  </span>
  instead. The routine will be removed in the next major release.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnPotrs</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeB</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">)</span>
</pre>
 <p>
  This function solves a system of linear equations
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A*X = B\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   A
  </span>
  is a
  <span class="pre">
   nÃn
  </span>
  Hermitian matrix, only lower or upper part is meaningful using the generic API interface. The input parameter
  <span class="pre">
   uplo
  </span>
  indicates which part of the matrix is used. The function would leave other part untouched.
 </p>
 <p>
  The user has to call
  <span class="pre">
   cusolverDnPotrf
  </span>
  first to factorize matrix
  <span class="pre">
   A
  </span>
  . If input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_LOWER
  </span>
  ,
  <span class="pre">
   A
  </span>
  is lower triangular Cholesky factor
  <span class="pre">
   L
  </span>
  corresponding to
  <span class="math notranslate nohighlight">
   \(A = L*L^{H}\)
  </span>
  . If input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_UPPER
  </span>
  ,
  <span class="pre">
   A
  </span>
  is upper triangular Cholesky factor
  <span class="pre">
   U
  </span>
  corresponding to
  <span class="math notranslate nohighlight">
   \(A = U^{H}*U\)
  </span>
  .
 </p>
 <p>
  The operation is in-place, i.e. matrix
  <span class="pre">
   X
  </span>
  overwrites matrix
  <span class="pre">
   B
  </span>
  with the same leading dimension
  <span class="pre">
   ldb
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  Currently,
  <span class="pre">
   cusolverDnPotrs
  </span>
  supports only the default algorithm.
 </p>
 <p>
  Table of algorithms supported by cusolverDnPotrs
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_ALG_0
     </span>
     or
     <span class="pre">
      NULL
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm.
    </p>
   </td>
  </tr>
 </table>
 <p>
  List of input arguments for
  <span class="pre">
   cusolverDnPotrs
  </span>
  :
 </p>
 <p>
  API of potrs
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Structure with information collected by
     <span class="pre">
      cusolverDnSetAdvOptions
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Indicates if matrix
     <span class="pre">
      A
     </span>
     lower or upper part is stored, the other part is not referenced.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nrhs
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of matrix
     <span class="pre">
      X
     </span>
     and
     <span class="pre">
      B
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dataTypeA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
     <span class="pre">
      A
     </span>
     is either lower Cholesky factor
     <span class="pre">
      L
     </span>
     or upper Cholesky factor
     <span class="pre">
      U
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dataTypeB
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      B
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      B
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension
     <span class="pre">
      ldb
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      nrhs
     </span>
     .
     <span class="pre">
      ldb
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     . As an input,
     <span class="pre">
      B
     </span>
     is right hand side matrix. As an output,
     <span class="pre">
      B
     </span>
     is the solution matrix.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the Cholesky factorization is successful. if
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle).
    </p>
   </td>
  </tr>
 </table>
 <p>
  The generic API has two different types,
  <span class="pre">
   dataTypeA
  </span>
  is data type of the matrix
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   dataTypeB
  </span>
  is data type of the matrix
  <span class="pre">
   B
  </span>
  .
  <span class="pre">
   cusolverDnPotrs
  </span>
  only supports the following four combinations.
 </p>
 <p>
  Valid combination of data type and compute type
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dataTypeA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      dataTypeB
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      Meaning
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      SPOTRS
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      DPOTRS
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CPOTRS
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ZPOTRS
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n&lt;0
     </span>
     ,
     <span class="pre">
      nrhs&lt;0
     </span>
     ,
     <span class="pre">
      lda&lt;max(1,n)
     </span>
     or
     <span class="pre">
      ldb&lt;max(1,n)
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.2.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDN-lt-t-gt-potri">
   cusolverDn&lt;t&gt;potri()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-potri" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  These helper functions calculate the necessary size of work buffers.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSpotri_bufferSize</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">Lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDpotri_bufferSize</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">Lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCpotri_bufferSize</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">Lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZpotri_bufferSize</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">Lwork</span><span class="p">);</span>
</pre>
 <p>
  The S and D data types are real valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSpotri</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">Workspace</span><span class="p">,</span>
<span class="kt">int</span><span class="n">Lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDpotri</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">Workspace</span><span class="p">,</span>
<span class="kt">int</span><span class="n">Lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  The C and Z data types are complex valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCpotri</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">Workspace</span><span class="p">,</span>
<span class="kt">int</span><span class="n">Lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZpotri</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">Workspace</span><span class="p">,</span>
<span class="kt">int</span><span class="n">Lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  This function computes the inverse of a positive-definite matrix
  <span class="pre">
   A
  </span>
  using the Cholesky factorization
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = L*L^{H} = U^{H}*U\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  computed by
  <span class="pre">
   potrf()
  </span>
  .
 </p>
 <p>
  <span class="pre">
   A
  </span>
  is a
  <span class="pre">
   nÃn
  </span>
  matrix containing the triangular factor
  <span class="pre">
   L
  </span>
  or
  <span class="pre">
   U
  </span>
  computed by the Cholesky factorization. Only lower or upper part is meaningful and the input parameter
  <span class="pre">
   uplo
  </span>
  indicates which part of the matrix is used. The function would leave the other part untouched.
 </p>
 <p>
  If the input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_LOWER
  </span>
  , only lower triangular part of
  <span class="pre">
   A
  </span>
  is processed, and replaced the by lower triangular part of the inverse of
  <span class="pre">
   A
  </span>
  .
 </p>
 <p>
  If the input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_UPPER
  </span>
  , only upper triangular part of
  <span class="pre">
   A
  </span>
  is processed, and replaced by the upper triangular part of the inverse of
  <span class="pre">
   A
  </span>
  .
 </p>
 <p>
  The user has to provide the working space which is pointed to by input parameter
  <span class="pre">
   Workspace
  </span>
  . The input parameter
  <span class="pre">
   Lwork
  </span>
  is the size of the working space, returned by
  <span class="pre">
   potri_bufferSize()
  </span>
  .
 </p>
 <p>
  If the computation of the inverse fails, i.e. some leading minor of
  <span class="pre">
   L
  </span>
  or
  <span class="pre">
   U
  </span>
  , is null, the output parameter
  <span class="pre">
   devInfo
  </span>
  would indicate the smallest leading minor of
  <span class="pre">
   L
  </span>
  or
  <span class="pre">
   U
  </span>
  which is not positive definite.
 </p>
 <p>
  If the output parameter
  <span class="pre">
   devInfo
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting the handle).
 </p>
 <p>
  API of potri
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Indicates if matrix
     <span class="pre">
      A
     </span>
     lower or upper part is stored, the other part is not referenced.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     where
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      Workspace
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Working space, &lt;type&gt; array of size
     <span class="pre">
      Lwork
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      Lwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of
     <span class="pre">
      Workspace
     </span>
     , returned by
     <span class="pre">
      potri_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      devInfo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the computation of the inverse is successful. if
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle). if
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      i
     </span>
     , the leading minor of order
     <span class="pre">
      i
     </span>
     is zero.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n&lt;0
     </span>
     or
     <span class="pre">
      lda&lt;max(1,n)
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.2.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDN-lt-t-gt-getrf">
   cusolverDn&lt;t&gt;getrf()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-getrf" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  These helper functions calculate the size of work buffers needed.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/getrf">
   cuSOLVER Library Samples - getrf
  </a>
  for a code example.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSgetrf_bufferSize</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">Lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDgetrf_bufferSize</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">Lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCgetrf_bufferSize</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">Lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZgetrf_bufferSize</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">Lwork</span><span class="p">);</span>
</pre>
 <p>
  The S and D data types are real single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSgetrf</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">Workspace</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devIpiv</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDgetrf</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">Workspace</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devIpiv</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  The C and Z data types are complex valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCgetrf</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">Workspace</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devIpiv</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZgetrf</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">Workspace</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devIpiv</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  This function computes the LU factorization of a
  <span class="pre">
   mÃn
  </span>
  matrix
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(P*A = L*U\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   A
  </span>
  is a
  <span class="pre">
   mÃn
  </span>
  matrix,
  <span class="pre">
   P
  </span>
  is a permutation matrix,
  <span class="pre">
   L
  </span>
  is a lower triangular matrix with unit diagonal, and
  <span class="pre">
   U
  </span>
  is an upper triangular matrix.
 </p>
 <p>
  The user has to provide working space which is pointed by input parameter
  <span class="pre">
   Workspace
  </span>
  . The input parameter
  <span class="pre">
   Lwork
  </span>
  is size of the working space, and it is returned by
  <span class="pre">
   getrf_bufferSize()
  </span>
  .
 </p>
 <p>
  If LU factorization failed, i.e. matrix
  <span class="pre">
   A
  </span>
  (
  <span class="pre">
   U
  </span>
  ) is singular, The output parameter
  <span class="pre">
   devInfo=i
  </span>
  indicates
  <span class="pre">
   U(i,i)
  </span>
  <span class="pre">
   =
  </span>
  Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â
  <span class="pre">
   0
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   devInfo
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  If
  <span class="pre">
   devIpiv
  </span>
  is null, no pivoting is performed. The factorization is
  <span class="pre">
   A=L*U
  </span>
  , which is not numerically stable.
 </p>
 <p>
  No matter LU factorization failed or not, the output parameter
  <span class="pre">
   devIpiv
  </span>
  contains pivoting sequence, row
  <span class="pre">
   i
  </span>
  is interchanged with row
  <span class="pre">
   devIpiv(i)
  </span>
  .
 </p>
 <p>
  The user can combine
  <span class="pre">
   getrf
  </span>
  and
  <span class="pre">
   getrs
  </span>
  to complete a linear solver.
 </p>
 <p>
  Remark:
  <span class="pre">
   getrf
  </span>
  uses fastest implementation with large workspace of size
  <span class="pre">
   m*n
  </span>
  . The user can choose the legacy implementation with minimal workspace by
  <span class="pre">
   Getrf
  </span>
  and
  <span class="pre">
   cusolverDnSetAdvOptions(params,
  </span>
  <span class="pre">
   CUSOLVERDN_GETRF,
  </span>
  Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â
  <span class="pre">
   CUSOLVER_ALG_1)
  </span>
  .
 </p>
 <p>
  API of getrf
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,m)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      Workspace
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Working space, &lt;type&gt; array of size
     <span class="pre">
      Lwork
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      devIpiv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of size at least
     <span class="pre">
      min(m,n)
     </span>
     , containing pivot indices.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      devInfo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the LU factorization is successful. if
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle). if
     <span class="pre">
      devInfo
     </span>
     Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â
     <span class="pre">
      =
     </span>
     <span class="pre">
      i
     </span>
     , the
     <span class="pre">
      U(i,i)
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      m,n&lt;0
     </span>
     or
     <span class="pre">
      lda&lt;max(1,m)
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.2.7.
  </span>
  cusolverDnGetrf()[DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdngetrf-deprecated" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  [[DEPRECATED]] use
  <span class="pre">
   cusolverDnXgetrf()
  </span>
  instead. The routine will be removed in the next major release.
 </p>
 <p>
  The helper function below can calculate the sizes needed for pre-allocated buffer.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnGetrf_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytes</span><span class="p">)</span>
</pre>
 <p>
  The following function:
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnGetrf</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">ipiv</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">workspaceInBytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">)</span>
</pre>
 <p>
  computes the LU factorization of a
  <span class="pre">
   mÃn
  </span>
  matrix
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(P*A = L*U\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   mÃn
  </span>
  matrix,
  <span class="pre">
   P
  </span>
  is a permutation matrix,
  <span class="pre">
   L
  </span>
  is a lower triangular matrix with unit diagonal, and
  <span class="pre">
   U
  </span>
  is an upper triangular matrix using the generic API interface.
 </p>
 <p>
  If LU factorization failed, i.e. matrix
  <span class="pre">
   A
  </span>
  (
  <span class="pre">
   U
  </span>
  ) is singular, The output parameter
  <span class="pre">
   info=i
  </span>
  indicates
  <span class="pre">
   U(i,i)
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   0
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  If
  <span class="pre">
   ipiv
  </span>
  is null, no pivoting is performed. The factorization is
  <span class="pre">
   A=L*U
  </span>
  , which is not numerically stable.
 </p>
 <p>
  No matter LU factorization failed or not, the output parameter
  <span class="pre">
   ipiv
  </span>
  contains pivoting sequence, row
  <span class="pre">
   i
  </span>
  is interchanged with row
  <span class="pre">
   ipiv(i)
  </span>
  .
 </p>
 <p>
  The user has to provide working space which is pointed by input parameter
  <span class="pre">
   pBuffer
  </span>
  . The input parameter
  <span class="pre">
   workspaceInBytes
  </span>
  is size in bytes of the working space, and it is returned by
  <span class="pre">
   cusolverDnGetrf_bufferSize()
  </span>
  .
 </p>
 <p>
  The user can combine
  <span class="pre">
   cusolverDnGetrf
  </span>
  and
  <span class="pre">
   cusolverDnGetrs
  </span>
  to complete a linear solver.
 </p>
 <p>
  Currently,
  <span class="pre">
   cusolverDnGetrf
  </span>
  supports two algorithms. To select legacy implementation, the user has to call
  <span class="pre">
   cusolverDnSetAdvOptions
  </span>
  .
 </p>
 <p>
  Table of algorithms supported by cusolverDnGetrf
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_ALG_0
     </span>
     or
     <span class="pre">
      NULL
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm. The fastest, requires a large workspace of
     <span class="pre">
      m*n
     </span>
     elements.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_ALG_1
     </span>
    </p>
   </td>
   <td>
    <p>
     Legacy implementation
    </p>
   </td>
  </tr>
 </table>
 <p>
  List of input arguments for
  <span class="pre">
   cusolverDnGetrf_bufferSize
  </span>
  and
  <span class="pre">
   cusolverDnGetrf
  </span>
  :
 </p>
 <p>
  API of cusolverDnGetrf
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Structure with information collected by
     <span class="pre">
      cusolverDnSetAdvOptions
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dataTypeA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,m)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ipiv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of size at least
     <span class="pre">
      min(m,n)
     </span>
     , containing pivot indices.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of computation.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Working space. Array of type
     <span class="pre">
      void
     </span>
     of size
     <span class="pre">
      workspaceInBytes
     </span>
     bytes.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      workspaceInBytes
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      pBuffer
     </span>
     , returned by
     <span class="pre">
      cusolverDnGetrf_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the LU factorization is successful. if
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle). if
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     Â
     <span class="pre">
      i
     </span>
     , the
     <span class="pre">
      U(i,i)
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  The generic API has two different types,
  <span class="pre">
   dataTypeA
  </span>
  is data type of the matrix
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   computeType
  </span>
  is compute type of the operation.
  <span class="pre">
   cusolverDnGetrf
  </span>
  only supports the following four combinations.
 </p>
 <p>
  valid combination of data type and compute type
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      DataTypeA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ComputeType
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      Meaning
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      SGETRF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      DGETRF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CGETRF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ZGETRF
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      m,n&lt;0
     </span>
     or
     <span class="pre">
      lda&lt;max(1,m)
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.2.8.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDN-lt-t-gt-getrs">
   cusolverDn&lt;t&gt;getrs()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-getrs" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/getrf">
   cuSOLVER Library Samples - getrf
  </a>
  for a code example.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSgetrs</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">devIpiv</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDgetrs</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">devIpiv</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCgetrs</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">devIpiv</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZgetrs</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">devIpiv</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  This function solves a linear system of multiple right-hand sides
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \({op(A)}*X = B\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   nÃn
  </span>
  matrix, and was LU-factored by
  <span class="pre">
   getrf
  </span>
  , that is, lower triangular part of A is
  <span class="pre">
   L
  </span>
  , and upper triangular part (including diagonal elements) of
  <span class="pre">
   A
  </span>
  is
  <span class="pre">
   U
  </span>
  .
  <span class="pre">
   B
  </span>
  is a
  <span class="pre">
   nÃnrhs
  </span>
  right-hand side matrix.
 </p>
 <p>
  The input parameter
  <span class="pre">
   trans
  </span>
  is defined by
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(\text{op}(A) = \left\{ \begin{matrix}
A &amp; {\text{if~}\textsf{trans\ ==\ CUBLAS\_OP\_N}} \\
A^{T} &amp; {\text{if~}\textsf{trans\ ==\ CUBLAS\_OP\_T}} \\
A^{H} &amp; {\text{if~}\textsf{trans\ ==\ CUBLAS\_OP\_C}} \\
\end{matrix} \right.\)
  </span>
 </p>
 <p>
  The input parameter
  <span class="pre">
   devIpiv
  </span>
  is an output of
  <span class="pre">
   getrf
  </span>
  . It contains pivot indices, which are used to permutate right-hand sides.
 </p>
 <p>
  If output parameter
  <span class="pre">
   devInfo
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  The user can combine
  <span class="pre">
   getrf
  </span>
  and
  <span class="pre">
   getrs
  </span>
  to complete a linear solver.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      trans
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Operation
     <span class="pre">
      op(A)
     </span>
     that is non- or (conj.) transpose.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nrhs
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of right-hand sides.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      devIpiv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of size at least
     <span class="pre">
      n
     </span>
     , containing pivot indices.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      B
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      ldb
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      nrhs
     </span>
     with
     <span class="pre">
      ldb
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ldb
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      B
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      devInfo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the operation is successful. if
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle).
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n&lt;0
     </span>
     or
     <span class="pre">
      lda&lt;max(1,n)
     </span>
     or
     <span class="pre">
      ldb&lt;max(1,n)
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.2.9.
  </span>
  cusolverDnGetrs()[DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdngetrs-deprecated" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  [[DEPRECATED]] use
  <span class="pre">
   cusolverDnXgetrs()
  </span>
  instead. The routine will be removed in the next major release.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnGetrs</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="n">cublasOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int64_t</span><span class="o">*</span><span class="n">ipiv</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeB</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">)</span>
</pre>
 <p>
  This function solves a linear system of multiple right-hand sides
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \({op(A)}*X = B\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   A
  </span>
  is a
  <span class="pre">
   nÃn
  </span>
  matrix, and was LU-factored by
  <span class="pre">
   cusolverDnGetrf
  </span>
  , that is, lower triangular part of A is
  <span class="pre">
   L
  </span>
  , and upper triangular part (including diagonal elements) of
  <span class="pre">
   A
  </span>
  is
  <span class="pre">
   U
  </span>
  .
  <span class="pre">
   B
  </span>
  is a
  <span class="pre">
   nÃnrhs
  </span>
  right-hand side matrix using the generic API interface.
 </p>
 <p>
  The input parameter
  <span class="pre">
   trans
  </span>
  is defined by
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(\text{op}(A) = \left\{ \begin{matrix}
A &amp; {\text{if~}\textsf{trans\ ==\ CUBLAS\_OP\_N}} \\
A^{T} &amp; {\text{if~}\textsf{trans\ ==\ CUBLAS\_OP\_T}} \\
A^{H} &amp; {\text{if~}\textsf{trans\ ==\ CUBLAS\_OP\_C}} \\
\end{matrix} \right.\)
  </span>
 </p>
 <p>
  The input parameter
  <span class="pre">
   ipiv
  </span>
  is an output of
  <span class="pre">
   cusolverDnGetrf
  </span>
  . It contains pivot indices, which are used to permutate right-hand sides.
 </p>
 <p>
  If output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  The user can combine
  <span class="pre">
   cusolverDnGetrf
  </span>
  and
  <span class="pre">
   cusolverDnGetrs
  </span>
  to complete a linear solver.
 </p>
 <p>
  Currently,
  <span class="pre">
   cusolverDnGetrs
  </span>
  supports only the default algorithm.
 </p>
 <p>
  Table of algorithms supported by cusolverDnGetrs
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_ALG_0
     </span>
     or
     <span class="pre">
      NULL
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm.
    </p>
   </td>
  </tr>
 </table>
 <p>
  List of input arguments for
  <span class="pre">
   cusolverDnGetrs
  </span>
  :
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Structure with information collected by
     <span class="pre">
      cusolverDnSetAdvOptions
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      trans
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Operation
     <span class="pre">
      op(A)
     </span>
     that is non- or (conj.) transpose.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nrhs
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of right-hand sides.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dataTypeA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ipiv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of size at least
     <span class="pre">
      n
     </span>
     , containing pivot indices.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dataTypeB
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      B
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      B
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      ldb
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      nrhs
     </span>
     with
     <span class="pre">
      ldb
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ldb
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      B
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the operation is successful. if
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle).
    </p>
   </td>
  </tr>
 </table>
 <p>
  The generic API has two different types,
  <span class="pre">
   dataTypeA
  </span>
  is data type of the matrix
  <span class="pre">
   A
  </span>
  and
  <span class="pre">
   dataTypeB
  </span>
  is data type of the matrix
  <span class="pre">
   B
  </span>
  .
  <span class="pre">
   cusolverDnGetrs
  </span>
  only supports the following four combinations.
 </p>
 <p>
  Valid combination of data type and compute type
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      DataTypeA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      dataTypeB
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      Meaning
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      SGETRS
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      DGETRS
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CGETRS
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ZGETRS
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n&lt;0
     </span>
     or
     <span class="pre">
      lda&lt;max(1,n)
     </span>
     or
     <span class="pre">
      ldb&lt;max(1,n)
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.2.10.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverDN-lt-t-gt-gesv">
   cusolverDn&lt;t1&gt;&lt;t2&gt;gesv()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t1-t2-gesv" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  These functions are modelled after functions DSGESV and ZCGESV from LAPACK. They compute the solution of a system of linear equations with one or multiple right hand sides using mixed precision iterative refinement techniques based on the LU factorization
  <span class="pre">
   Xgesv
  </span>
  . These functions are similar in term of functionalities to the full precision LU solver (
  <span class="pre">
   Xgesv
  </span>
  , where X denotes Z,C,D,S) but it uses lower precision internally in order to provide faster time to solution, from here comes the name mixed precision. Mixed precision iterative refinement techniques means that the solver compute an LU factorization in lower precision and then iteratively refine the solution to achieve the accuracy of the Inputs/Outputs datatype precision. The &lt;t1&gt; corresponds to the Inputs/Outputs datatype precision while &lt;t2&gt; represent the internal lower precision at which the factorization will be carried on.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A \times X = B\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Where
  <span class="pre">
   A
  </span>
  is
  <span class="pre">
   n-by-n
  </span>
  matrix and
  <span class="pre">
   X
  </span>
  and
  <span class="pre">
   B
  </span>
  are
  <span class="pre">
   n-by-nrhs
  </span>
  matrices.
 </p>
 <p>
  Functions API are designed to be as close as possible to LAPACK API to be considered as a quick and easy drop-in replacement. Parameters and behavior are mostly the same as LAPACK counterparts. Description of these functions and differences from LAPACK is given below.
  <span class="pre">
   &lt;t1&gt;&lt;t2&gt;gesv()
  </span>
  functions are designated by two floating point precisions The &lt;t1&gt; corresponds to the main precision (e.g., Inputs/Outputs datatype precision) and the &lt;t2&gt; represent the internal lower precision at which the factorization will be carried on.
  <span class="pre">
   cusolver&lt;t1&gt;&lt;t2&gt;gesv()
  </span>
  first attempts to factorize the matrix in lower precision and use this factorization within an iterative refinement procedure to obtain a solution with same normwise backward error as the main precision &lt;t1&gt;. If the approach fails to converge, then the method fallback to the main precision factorization and solve (Xgesv) such a way that there is always a good solution at the output of these functions. If &lt;t2&gt; is equal to &lt;t1&gt;, then it is not a mixed precision process but rather a full one precision factorization, solve and refinement within the same main precision.
 </p>
 <p>
  The iterative refinement process is stopped if
Â Â Â
  <span class="pre">
   ITER
  </span>
  <span class="pre">
   &gt;
  </span>
  <span class="pre">
   ITERMAX
  </span>
  or for all the RHS we have:
Â Â Â
  <span class="pre">
   RNRM
  </span>
  <span class="pre">
   &lt;
  </span>
  Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â
  <span class="pre">
   SQRT(N)*XNRM*ANRM*EPS*BWDMAX
  </span>
  where
 </p>
 <ul class="simple">
  <li>
   <p>
    ITER is the number of the current iteration in the iterative refinement process
   </p>
  </li>
  <li>
   <p>
    RNRM is the infinity-norm of the residual
   </p>
  </li>
  <li>
   <p>
    XNRM is the infinity-norm of the solution
   </p>
  </li>
  <li>
   <p>
    ANRM is the infinity-operator-norm of the matrix A
   </p>
  </li>
  <li>
   <p>
    EPS is the machine epsilon that matches LAPACK &lt;t1&gt;LAMCH(âEpsilonâ)
   </p>
  </li>
 </ul>
 <p>
  The value ITERMAX and BWDMAX are fixed to 50 and 1.0 respectively.
 </p>
 <p>
  The function returns value describes the results of the solving process. A CUSOLVER_STATUS_SUCCESS indicates that the function finished with success otherwise, it indicates if one of the API arguments is incorrect, or if the function did not finish with success. More details about the error will be in the
  <span class="pre">
   niters
  </span>
  and the
  <span class="pre">
   dinfo
  </span>
  API parameters. See their description below for more details. User should provide the required workspace allocated on device memory. The amount of bytes required can be queried by calling the respective function
  <span class="pre">
   &lt;t1&gt;&lt;t2&gt;gesv_bufferSize()
  </span>
  .
 </p>
 <p>
  Note that in addition to the two mixed precision functions available in LAPACK (e.g.,
  <span class="pre">
   dsgesv
  </span>
  and
  <span class="pre">
   zcgesv
  </span>
  ), we provide a large set of mixed precision functions that include half, bfloat and tensorfloat as a lower precision as well as same precision functions (e.g., main and lowest precision are equal &lt;t2&gt; is equal to &lt;t1&gt;). The following table specifies which precisions will be used for which interface function.
 </p>
 <p>
  Tensor Float (TF32), introduced with NVIDIA Ampere Architecture GPUs, is the most robust tensor core accelerated compute mode for the iterative refinement solver. It is able to solve the widest range of problems in HPC arising from different applications and provides up to 4X and 5X speedup for real and complex systems, respectively. On Volta and Turing architecture GPUs, half precision tensor core acceleration is recommended. In cases where the iterative refinement solver fails to converge to the desired accuracy (main precision, INOUT data precision), it is recommended to use main precision as internal lowest precision (i.e.,
  <span class="pre">
   cusolverDn[DD,ZZ]gesv
  </span>
  for the FP64 case).
 </p>
 <table class="table-no-stripes docutils align-default" id="id23">
  <span class="caption-text">
   Table 3.
   Supported combinations of floating point precisions for cusolver &lt;t1&gt;&lt;t2&gt;gesv() functions
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#id23" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Interface function
    </p>
   </th>
   <th class="head">
    <p>
     Main precision (matrix, rhs and solution datatype)
    </p>
   </th>
   <th class="head">
    <p>
     Lowest precision allowed to be used internally
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cusolverDnZZgesv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      cuDoubleComplex
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      double
     </span>
     <span class="pre">
      complex
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cusolverDnZCgesv
     </span>
     <span class="pre">
      *has
     </span>
     <span class="pre">
      LAPACK
     </span>
     <span class="pre">
      counterparts
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      cuDoubleComplex
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      single
     </span>
     <span class="pre">
      complex
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cusolverDnZKgesv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      cuDoubleComplex
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      half
     </span>
     <span class="pre">
      complex
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cusolverDnZEgesv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      cuDoubleComplex
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      bfloat
     </span>
     <span class="pre">
      complex
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cusolverDnZYgesv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      cuDoubleComplex
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      tensorfloat
     </span>
     <span class="pre">
      complex
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cusolverDnCCgesv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      cuComplex
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      single
     </span>
     <span class="pre">
      complex
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cusolverDnCKgesv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      cuComplex
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      half
     </span>
     <span class="pre">
      complex
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cusolverDnCEgesv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      cuComplex
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      bfloat
     </span>
     <span class="pre">
      complex
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cusolverDnCYgesv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      cuComplex
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      tensorfloat
     </span>
     <span class="pre">
      complex
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cusolverDnDDgesv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      double
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      double
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cusolverDnDSgesv
     </span>
     <span class="pre">
      *has
     </span>
     <span class="pre">
      LAPACK
     </span>
     <span class="pre">
      counterparts
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      double
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      single
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cusolverDnDHgesv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      double
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      half
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cusolverDnDBgesv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      double
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      bfloat
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cusolverDnDXgesv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      double
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      tensorfloat
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cusolverDnSSgesv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      float
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      single
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cusolverDnSHgesv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      float
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      half
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cusolverDnSBgesv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      float
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      bfloat
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cusolverDnSXgesv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      float
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      tensorfloat
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusolverDn&lt;t1&gt;&lt;t2&gt;gesv_bufferSize()
  </span>
  functions will return workspace buffer size in bytes required for the corresponding
  <span class="pre">
   cusolverDn&lt;t1&gt;&lt;t2&gt;gesv()
  </span>
  function.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZZgesv_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZCgesv_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZKgesv_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZEgesv_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZYgesv_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCCgesv_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCKgesv_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCEgesv_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCYgesv_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDDgesv_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDSgesv_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDHgesv_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDBgesv_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDXgesv_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSSgesv_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSHgesv_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSBgesv_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSXgesv_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>
</pre>
 <p>
  Parameters of cusolverDn&lt;T1&gt;&lt;T2&gt;gesv_bufferSize() functions
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cusolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of square matrix
     <span class="pre">
      A
     </span>
     . Should be non-negative.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nrhs
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of right hand sides to solve. Should be non-negative.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      None
     </span>
    </p>
   </td>
   <td>
    <p>
     Matrix
     <span class="pre">
      A
     </span>
     with size
     <span class="pre">
      n-by-n
     </span>
     . Can be
     <span class="pre">
      NULL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ldda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
     <span class="pre">
      lda
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dipiv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      None
     </span>
    </p>
   </td>
   <td>
    <p>
     Pivoting sequence. Not used and can be
     <span class="pre">
      NULL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dB
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      None
     </span>
    </p>
   </td>
   <td>
    <p>
     Set of right hand sides
     <span class="pre">
      B
     </span>
     of size
     <span class="pre">
      n-by-nrhs
     </span>
     . Can be
     <span class="pre">
      NULL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lddb
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix of right hand sides
     <span class="pre">
      B
     </span>
     .
     <span class="pre">
      ldb
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dX
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      None
     </span>
    </p>
   </td>
   <td>
    <p>
     Set of solution vectors
     <span class="pre">
      X
     </span>
     of size
     <span class="pre">
      n-by-nrhs
     </span>
     . Can be
     <span class="pre">
      NULL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lddx
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix of solution vectors
     <span class="pre">
      X
     </span>
     .
     <span class="pre">
      ldx
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      none
     </span>
    </p>
   </td>
   <td>
    <p>
     Pointer to device workspace. Not used and can be
     <span class="pre">
      NULL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lwork_bytes
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Pointer to a variable where required size of temporary workspace in bytes will be stored. Canât be NULL.
    </p>
   </td>
  </tr>
 </table>
 <pre><span class="n">cusolverStatus_t</span><span class="nf">cusolverDnZZgesv</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnZCgesv</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnZKgesv</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnZEgesv</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnZYgesv</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnCCgesv</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnCKgesv</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnCEgesv</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnCYgesv</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnDDgesv</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnDSgesv</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnDHgesv</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnDBgesv</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnDXgesv</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnSSgesv</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnSHgesv</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnSBgesv</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnSXgesv</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dipiv</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>
</pre>
 <p>
  Parameters of cusolverDn&lt;T1&gt;&lt;T2&gt;gesv() functions
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cusolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of square matrix
     <span class="pre">
      A
     </span>
     . Should be non-negative.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nrhs
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of right hand sides to solve. Should be non-negative.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Matrix
     <span class="pre">
      A
     </span>
     with size
     <span class="pre">
      n-by-n
     </span>
     . Canât be
     <span class="pre">
      NULL
     </span>
     . On return - unchanged if the iterative refinement process converged. If not - will contains the factorization of the matrix A in the main precision &lt;T1&gt; (
     <span class="pre">
      A
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      P
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      L
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      U
     </span>
     , where P - permutation matrix defined by vector ipiv, L and U - lower and upper triangular matrices).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ldda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
     <span class="pre">
      lda
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dipiv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Vector that defines permutation for the factorization - row
     <span class="pre">
      i
     </span>
     was interchanged with row
     <span class="pre">
      ipiv[i]
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dB
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Set of right hand sides
     <span class="pre">
      B
     </span>
     of size
     <span class="pre">
      n-by-nrhs
     </span>
     . Canât be
     <span class="pre">
      NULL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lddb
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix of right hand sides
     <span class="pre">
      B
     </span>
     .
     <span class="pre">
      ldb
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dX
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Set of solution vectors
     <span class="pre">
      X
     </span>
     of size
     <span class="pre">
      n-by-nrhs
     </span>
     . Canât be
     <span class="pre">
      NULL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lddx
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix of solution vectors
     <span class="pre">
      X
     </span>
     .
     <span class="pre">
      ldx
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dWorkspace
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Pointer to an allocated workspace in device memory of size
     <span class="pre">
      lwork_bytes
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lwork_bytes
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of the allocated device workspace. Should be at least what was returned by
     <span class="pre">
      cusolverDn&lt;T1&gt;&lt;T2&gt;gesv_bufferSize()
     </span>
     function.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      niters
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      iter
     </span>
     is
    </p>
    <ul class="simple">
     <li>
      <p>
       &lt;0 : iterative refinement has failed, main precision (Inputs/Outputs precision) factorization has been performed
      </p>
     </li>
     <li>
      <p>
       -1 : taking into account machine parameters, n, nrhs, it is a priori not worth working in lower precision
      </p>
     </li>
     <li>
      <p>
       -2 : overflow of an entry when moving from main to lower precision
      </p>
     </li>
     <li>
      <p>
       -3 : failure during the factorization
      </p>
     </li>
     <li>
      <p>
       -5 : overflow occurred during computation
      </p>
     </li>
     <li>
      <p>
       -50: solver stopped the iterative refinement after reaching maximum allowed iterations
      </p>
     </li>
     <li>
      <p>
       &gt;0 : iter is a number of iterations solver performed to reach convergence criteria
      </p>
     </li>
    </ul>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dinfo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Status of the IRS solver on the return. If 0 - solve was successful. If
     <span class="pre">
      dinfo
     </span>
     = -
     <span class="pre">
      i
     </span>
     then
     <span class="pre">
      i
     </span>
     -th argument is not valid. If
     <span class="pre">
      dinfo
     </span>
     =
     <span class="pre">
      i
     </span>
     , then
     <span class="pre">
      U(i,i)
     </span>
     computed in main precision is exactly zero. The factorization has been completed, but the factor U is exactly singular, so the solution could not be computed.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed, for example:
    </p>
    <ul class="simple">
     <li>
      <p>
       <span class="pre">
        n&lt;0
       </span>
      </p>
     </li>
     <li>
      <p>
       <span class="pre">
        lda&lt;max(1,n)
       </span>
      </p>
     </li>
     <li>
      <p>
       <span class="pre">
        ldb&lt;max(1,n)
       </span>
      </p>
     </li>
     <li>
      <p>
       <span class="pre">
        ldx&lt;max(1,n)
       </span>
      </p>
     </li>
    </ul>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The IRS solver supports compute capability 7.0 and above. The lowest precision options CUSOLVER_[CR]_16BF and CUSOLVER_[CR]_TF32 are only available on compute capability 8.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_WORKSPACE
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      lwork_bytes
     </span>
     is smaller than the required workspace.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_OUT_OF_RANGE
     </span>
    </p>
   </td>
   <td>
    <p>
     Numerical error related to niters &lt;0, see
     <span class="pre">
      niters
     </span>
     description for more details.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal error occurred, check the
     <span class="pre">
      dinfo
     </span>
     and the
     <span class="pre">
      niters
     </span>
     arguments for more details.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.2.11.
  </span>
  cusolverDnIRSXgesv()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsxgesv" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  This function is designed to perform same functionality as
  <span class="pre">
   cusolverDn&lt;T1&gt;&lt;T2&gt;gesv()
  </span>
  functions, but wrapped in a more generic and expert interface that gives user more control to parametrize the function as well as it provides more information on output.
  <span class="pre">
   cusolverDnIRSXgesv()
  </span>
  allows additional control of the solver parameters such as setting:
 </p>
 <ul class="simple">
  <li>
   <p>
    the main precision (Inputs/Outputs precision) of the solver
   </p>
  </li>
  <li>
   <p>
    the lowest precision to be used internally by the solver
   </p>
  </li>
  <li>
   <p>
    the refinement solver type
   </p>
  </li>
  <li>
   <p>
    the maximum allowed number of iterations in the refinement phase
   </p>
  </li>
  <li>
   <p>
    the tolerance of the refinement solver
   </p>
  </li>
  <li>
   <p>
    the fallback to main precision
   </p>
  </li>
  <li>
   <p>
    and more
   </p>
  </li>
 </ul>
 <p>
  through the configuration parameters structure
  <span class="pre">
   gesv_irs_params
  </span>
  and its helper functions. For more details about what configuration can be set and its meaning please refer to all the functions in the cuSolverDN Helper Function Section that start with
  <span class="pre">
   cusolverDnIRSParamsxxxx()
  </span>
  . Moreover,
  <span class="pre">
   cusolverDnIRSXgesv()
  </span>
  provides additional information on the output such as the convergence history (e.g., the residual norms) at each iteration and the number of iterations needed to converge. For more details about what information can be retrieved and its meaning please refer to all the functions in the cuSolverDN Helper Function Section that start with
  <span class="pre">
   cusolverDnIRSInfosxxxx()
  </span>
 </p>
 <p>
  The function returns value describes the results of the solving process. A CUSOLVER_STATUS_SUCCESS indicates that the function finished with success otherwise, it indicates if one of the API arguments is incorrect, or if the configurations of params/infos structure is incorrect or if the function did not finish with success. More details about the error can be found by checking the
  <span class="pre">
   niters
  </span>
  and the
  <span class="pre">
   dinfo
  </span>
  API parameters. See their description below for further details. User should provide the required workspace allocated on device for the
  <span class="pre">
   cusolverDnIRSXgesv()
  </span>
  function. The amount of bytes required for the function can be queried by calling the respective function
  <span class="pre">
   cusolverDnIRSXgesv_bufferSize()
  </span>
  . Note that, if the user would like a particular configuration to be set via the params structure, it should be set before the call to
  <span class="pre">
   cusolverDnIRSXgesv_bufferSize()
  </span>
  to get the size of the required workspace.
 </p>
 <p>
  Tensor Float (TF32), introduced with NVIDIA Ampere Architecture GPUs, is the most robust tensor core accelerated compute mode for the iterative refinement solver. It is able to solve the widest range of problems in HPC arising from different applications and provides up to 4X and 5X speedup for real and complex systems, respectively. On Volta and Turing architecture GPUs, half precision tensor core acceleration is recommended. In cases where the iterative refinement solver fails to converge to the desired accuracy (main precision, INOUT data precision), it is recommended to use main precision as internal lowest precision.
 </p>
 <p>
  The following table provides all possible combinations values for the lowest precision corresponding to the Inputs/Outputs data type. Note that if the lowest precision matches the Inputs/Outputs datatype, then the main precision factorization will be used.
 </p>
 <table class="table-no-stripes docutils align-default" id="id24">
  <span class="caption-text">
   Table 4.
   Supported Inputs/Outputs data type and lower precision for the IRS solver
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#id24" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Inputs/Outputs Data Type (e.g., main precision)
    </p>
   </th>
   <th class="head">
    <p>
     Supported values for the lowest precision
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUSOLVER_C_64F,
     </span>
     <span class="pre">
      CUSOLVER_C_32F,
     </span>
     <span class="pre">
      CUSOLVER_C_16F,
     </span>
     <span class="pre">
      CUSOLVER_C_16BF,
     </span>
     <span class="pre">
      CUSOLVER_C_TF32
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUSOLVER_C_32F,
     </span>
     <span class="pre">
      CUSOLVER_C_16F,
     </span>
     <span class="pre">
      CUSOLVER_C_16BF,
     </span>
     <span class="pre">
      CUSOLVER_C_TF32
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUSOLVER_R_64F,
     </span>
     <span class="pre">
      CUSOLVER_R_32F,
     </span>
     <span class="pre">
      CUSOLVER_R_16F,
     </span>
     <span class="pre">
      CUSOLVER_R_16BF,
     </span>
     <span class="pre">
      CUSOLVER_R_TF32
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUSOLVER_R_32F,
     </span>
     <span class="pre">
      CUSOLVER_R_16F,
     </span>
     <span class="pre">
      CUSOLVER_R_16BF,
     </span>
     <span class="pre">
      CUSOLVER_R_TF32
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The
  <span class="pre">
   cusolverDnIRSXgesv_bufferSize()
  </span>
  function returns the required workspace buffer size in bytes for the corresponding
  <span class="pre">
   cusolverDnXgesv()
  </span>
  call with the given
  <span class="pre">
   gesv_irs_params
  </span>
  configuration.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnIRSXgesv_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnIRSParams_t</span><span class="n">gesv_irs_params</span><span class="p">,</span>
<span class="n">cusolver_int_t</span><span class="n">n</span><span class="p">,</span>
<span class="n">cusolver_int_t</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>
</pre>
 <table class="table-no-stripes docutils align-default" id="id25">
  <span class="caption-text">
   Table 5.
   Parameters of cusolverDnIRSXgesv_bufferSize() functions
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#id25" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cusolverDn library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      Xgesv
     </span>
     configuration parameters
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of the square matrix
     <span class="pre">
      A
     </span>
     . Should be non-negative.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nrhs
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of right hand sides to solve. Should be non-negative. Note that
     <span class="pre">
      nrhs
     </span>
     is limited to 1 if the selected IRS refinement solver is CUSOLVER_IRS_REFINE_GMRES, CUSOLVER_IRS_REFINE_GMRES_GMRES, CUSOLVER_IRS_REFINE_CLASSICAL_GMRES.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lwork_bytes
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      out
     </span>
    </p>
   </td>
   <td>
    <p>
     Pointer to a variable, where the required size in bytes, of the workspace will be stored after a call to
     <span class="pre">
      cusolverDnIRSXgesv_bufferSize
     </span>
     . Canât be NULL.
    </p>
   </td>
  </tr>
 </table>
 <pre><span class="n">cusolverStatus_t</span><span class="nf">cusolverDnIRSXgesv</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnIRSParams_t</span><span class="n">gesv_irs_params</span><span class="p">,</span>
<span class="n">cusolverDnIRSInfos_t</span><span class="n">gesv_irs_infos</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>
</pre>
 <table class="table-no-stripes docutils align-default" id="id26">
  <span class="caption-text">
   Table 6.
   Parameters of cusolverDnIRSXgesv() functions
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#id26" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cusolverDn library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      gesv_irs_params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Configuration parameters structure, can serve one or more calls to any IRS solver
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      gesv_irs_infos
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Info structure, where information about a particular solve will be stored. The
     <span class="pre">
      gesv_irs_infos
     </span>
     structure correspond to a particular call. Thus different calls requires different
     <span class="pre">
      gesv_irs_infos
     </span>
     structure otherwise, it will be overwritten.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of square matrix
     <span class="pre">
      A
     </span>
     . Should be non-negative.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nrhs
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of right hand sides to solve. Should be non-negative. Note that,
     <span class="pre">
      nrhs
     </span>
     is limited to 1 if the selected IRS refinement solver is CUSOLVER_IRS_REFINE_GMRES, CUSOLVER_IRS_REFINE_GMRES_GMRES, CUSOLVER_IRS_REFINE_CLASSICAL_GMRES.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Matrix
     <span class="pre">
      A
     </span>
     with size
     <span class="pre">
      n-by-n
     </span>
     . Canât be
     <span class="pre">
      NULL
     </span>
     . On return - will contain the factorization of the matrix A in the main precision (
     <span class="pre">
      A
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      P
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      L
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      U
     </span>
     , where P - permutation matrix defined by vector ipiv, L and U - lower and upper triangular matrices) if the iterative refinement solver was set to CUSOLVER_IRS_REFINE_NONE and the lowest precision is equal to the main precision (Inputs/Outputs datatype), or if the iterative refinement solver did not converge and the fallback to main precision was enabled (fallback enabled is the default setting); unchanged otherwise.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ldda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
     <span class="pre">
      lda
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dB
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Set of right hand sides
     <span class="pre">
      B
     </span>
     of size
     <span class="pre">
      n-by-nrhs
     </span>
     . Canât be
     <span class="pre">
      NULL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lddb
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix of right hand sides
     <span class="pre">
      B
     </span>
     .
     <span class="pre">
      ldb
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dX
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Set of solution vectors
     <span class="pre">
      X
     </span>
     of size
     <span class="pre">
      n-by-nrhs
     </span>
     . Canât be
     <span class="pre">
      NULL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lddx
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix of solution vectors
     <span class="pre">
      X
     </span>
     .
     <span class="pre">
      ldx
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dWorkspace
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Pointer to an allocated workspace in device memory of size lwork_bytes.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lwork_bytes
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of the allocated device workspace. Should be at least what was returned by
     <span class="pre">
      cusolverDnIRSXgesv_bufferSize()
     </span>
     function
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      niters
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If iter is
    </p>
    <ul class="simple">
     <li>
      <p>
       &lt;0 : iterative refinement has failed, main precision (Inputs/Outputs precision) factorization has been performed if fallback is enabled.
      </p>
     </li>
     <li>
      <p>
       -1 : taking into account machine parameters, n, nrhs, it is a priori not worth working in lower precision
      </p>
     </li>
     <li>
      <p>
       -2 : overflow of an entry when moving from main to lower precision
      </p>
     </li>
     <li>
      <p>
       -3 : failure during the factorization
      </p>
     </li>
     <li>
      <p>
       -5 : overflow occurred during computation
      </p>
     </li>
     <li>
      <p>
       -maxiter: solver stopped the iterative refinement after reaching maximum allowed iterations.
      </p>
     </li>
     <li>
      <p>
       &gt;0 : iter is a number of iterations solver performed to reach convergence criteria
      </p>
     </li>
    </ul>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dinfo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Status of the IRS solver on the return. If 0 - solve was successful. If dinfo = -
     <span class="pre">
      i
     </span>
     then
     <span class="pre">
      i
     </span>
     -th argument is not valid. If dinfo =
     <span class="pre">
      i
     </span>
     , then
     <span class="pre">
      U(i,i)
     </span>
     computed in main precision is exactly zero. The factorization has been completed, but the factor U is exactly singular, so the solution could not be computed.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed, for example:
    </p>
    <ul class="simple">
     <li>
      <p>
       <span class="pre">
        n&lt;0
       </span>
      </p>
     </li>
     <li>
      <p>
       <span class="pre">
        lda&lt;max(1,n)
       </span>
      </p>
     </li>
     <li>
      <p>
       <span class="pre">
        ldb&lt;max(1,n)
       </span>
      </p>
     </li>
     <li>
      <p>
       <span class="pre">
        ldx&lt;max(1,n)
       </span>
      </p>
     </li>
    </ul>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The IRS solver supports compute capability 7.0 and above. The lowest precision options CUSOLVER_[CR]_16BF and CUSOLVER_[CR]_TF32 are only available on compute capability 8.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_WORKSPACE
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      lwork_bytes
     </span>
     is smaller than the required workspace. Could happen if the users called
     <span class="pre">
      cusolverDnIRSXgesv_bufferSize()
     </span>
     function, then changed some of the configurations setting such as the lowest precision.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_OUT_OF_RANGE
     </span>
    </p>
   </td>
   <td>
    <p>
     Numerical error related to niters &lt;0, see niters description for more details.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal error occurred, check the
     <span class="pre">
      dinfo
     </span>
     and the
     <span class="pre">
      niters
     </span>
     arguments for more details.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The configuration parameter
     <span class="pre">
      gesv_irs_params
     </span>
     structure was not created.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_PARAMS_INVALID
     </span>
    </p>
   </td>
   <td>
    <p>
     One of the configuration parameter in the
     <span class="pre">
      gesv_irs_params
     </span>
     structure is not valid.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_PARAMS_INVALID_PREC
     </span>
    </p>
   </td>
   <td>
    <p>
     The main and/or the lowest precision configuration parameter in the
     <span class="pre">
      gesv_irs_params
     </span>
     structure is not valid, check the table above for the supported combinations.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_PARAMS_INVALID_MAXITER
     </span>
    </p>
   </td>
   <td>
    <p>
     The maxiter configuration parameter in the
     <span class="pre">
      gesv_irs_params
     </span>
     structure is not valid.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_PARAMS_INVALID_REFINE
     </span>
    </p>
   </td>
   <td>
    <p>
     The refinement solver configuration parameter in the
     <span class="pre">
      gesv_irs_params
     </span>
     structure is not valid.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_NOT_SUPPORTED
     </span>
    </p>
   </td>
   <td>
    <p>
     One of the configuration parameter in the
     <span class="pre">
      gesv_irs_params
     </span>
     structure is not supported. For example if nrhs &gt;1, and refinement solver was set to CUSOLVER_IRS_REFINE_GMRES.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_INFOS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The information structure
     <span class="pre">
      gesv_irs_infos
     </span>
     was not created.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     CPU memory allocation failed, most likely during the allocation of the residual array that store the residual norms.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.2.12.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDN-lt-t-gt-geqrf">
   cusolverDn&lt;t&gt;geqrf()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-geqrf" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  These helper functions calculate the size of work buffers needed.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSgeqrf_bufferSize</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">Lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDgeqrf_bufferSize</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">Lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCgeqrf_bufferSize</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">Lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZgeqrf_bufferSize</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">Lwork</span><span class="p">);</span>
</pre>
 <p>
  The S and D data types are real valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSgeqrf</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">TAU</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">Workspace</span><span class="p">,</span>
<span class="kt">int</span><span class="n">Lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDgeqrf</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">TAU</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">Workspace</span><span class="p">,</span>
<span class="kt">int</span><span class="n">Lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  The C and Z data types are complex valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCgeqrf</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">TAU</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">Workspace</span><span class="p">,</span>
<span class="kt">int</span><span class="n">Lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZgeqrf</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">TAU</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">Workspace</span><span class="p">,</span>
<span class="kt">int</span><span class="n">Lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  This function computes the QR factorization of a
  <span class="pre">
   mÃn
  </span>
  matrix
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = Q*R\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   mÃn
  </span>
  matrix,
  <span class="pre">
   Q
  </span>
  is an
  <span class="pre">
   mÃn
  </span>
  matrix, and
  <span class="pre">
   R
  </span>
  is a
  <span class="pre">
   nÃn
  </span>
  upper triangular matrix.
 </p>
 <p>
  The user has to provide working space which is pointed by input parameter
  <span class="pre">
   Workspace
  </span>
  . The input parameter
  <span class="pre">
   Lwork
  </span>
  is size of the working space, and it is returned by
  <span class="pre">
   geqrf_bufferSize()
  </span>
  .
 </p>
 <p>
  The matrix
  <span class="pre">
   R
  </span>
  is overwritten in upper triangular part of
  <span class="pre">
   A
  </span>
  , including diagonal elements.
 </p>
 <p>
  The matrix
  <span class="pre">
   Q
  </span>
  is not formed explicitly, instead, a sequence of householder vectors are stored in lower triangular part of
  <span class="pre">
   A
  </span>
  . The leading nonzero element of householder vector is assumed to be 1 such that output parameter
  <span class="pre">
   TAU
  </span>
  contains the scaling factor
  <span class="pre">
   Ï
  </span>
  . If
  <span class="pre">
   v
  </span>
  is original householder vector,
  <span class="pre">
   q
  </span>
  is the new householder vector corresponding to
  <span class="pre">
   Ï
  </span>
  , satisfying the following relation
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(I - 2*v*v^{H} = I - \tau*q*q^{H}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  If output parameter
  <span class="pre">
   devInfo
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  API of geqrf
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,m)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      TAU
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension at least
     <span class="pre">
      min(m,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      Workspace
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Working space, &lt;type&gt; array of size
     <span class="pre">
      Lwork
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      Lwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of working array
     <span class="pre">
      Workspace
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      devInfo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the LU factorization is successful. if
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle).
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      m,n&lt;0
     </span>
     or
     <span class="pre">
      lda&lt;max(1,m)
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.2.13.
  </span>
  cusolverDnGeqrf()[DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdngeqrf-deprecated" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  [[DEPRECATED]] use
  <span class="pre">
   cusolverDnXgeqrf()
  </span>
  instead. The routine will be removed in the next major release.
 </p>
 <p>
  The helper functions below can calculate the sizes needed for pre-allocated buffer.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnGeqrf_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeTau</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytes</span><span class="p">)</span>
</pre>
 <p>
  The following routine:
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnGeqrf</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeTau</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">workspaceInBytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">)</span>
</pre>
 <p>
  computes the QR factorization of an
  <span class="pre">
   mÃn
  </span>
  matrix
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = Q*R\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   A
  </span>
  is a
  <span class="pre">
   mÃn
  </span>
  matrix,
  <span class="pre">
   Q
  </span>
  is an
  <span class="pre">
   mÃn
  </span>
  matrix, and
  <span class="pre">
   R
  </span>
  is an
  <span class="pre">
   nÃn
  </span>
  upper triangular matrix using the generic API interface.
 </p>
 <p>
  The user has to provide working space which is pointed by input parameter
  <span class="pre">
   pBuffer
  </span>
  . The input parameter
  <span class="pre">
   workspaceInBytes
  </span>
  is size in bytes of the working space, and it is returned by
  <span class="pre">
   cusolverDnGeqrf_bufferSize()
  </span>
  .
 </p>
 <p>
  The matrix
  <span class="pre">
   R
  </span>
  is overwritten in upper triangular part of
  <span class="pre">
   A
  </span>
  , including diagonal elements.
 </p>
 <p>
  The matrix
  <span class="pre">
   Q
  </span>
  is not formed explicitly, instead, a sequence of householder vectors are stored in lower triangular part of
  <span class="pre">
   A
  </span>
  . The leading nonzero element of householder vector is assumed to be 1 such that output parameter
  <span class="pre">
   TAU
  </span>
  contains the scaling factor
  <span class="pre">
   Ï
  </span>
  . If
  <span class="pre">
   v
  </span>
  is original householder vector,
  <span class="pre">
   q
  </span>
  is the new householder vector corresponding to
  <span class="pre">
   Ï
  </span>
  , satisfying the following relation
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(I - 2*v*v^{H} = I - \tau*q*q^{H}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  If output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  Currently,
  <span class="pre">
   cusolverDnGeqrf
  </span>
  supports only the default algorithm.
 </p>
 <p>
  Table of algorithms supported by cusolverDnGeqrf
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_ALG_0
     </span>
     or
     <span class="pre">
      NULL
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm.
    </p>
   </td>
  </tr>
 </table>
 <p>
  List of input arguments for
  <span class="pre">
   cusolverDnGeqrf_bufferSize
  </span>
  and
  <span class="pre">
   cusolverDnGeqrf
  </span>
  :
 </p>
 <p>
  API of geqrf
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Structure with information collected by
     <span class="pre">
      cusolverDnSetAdvOptions
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dataTypeA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,m)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      TAU
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension at least
     <span class="pre">
      min(m,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of computation.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Working space. Array of type
     <span class="pre">
      void
     </span>
     of size
     <span class="pre">
      workspaceInBytes
     </span>
     bytes.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      workspaceInBytes
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size in bytes of working array
     <span class="pre">
      pBuffer
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the LU factorization is successful. if
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle).
    </p>
   </td>
  </tr>
 </table>
 <p>
  The generic API has two different types,
  <span class="pre">
   dataTypeA
  </span>
  is data type of the matrix
  <span class="pre">
   A
  </span>
  and array
  <span class="pre">
   tau
  </span>
  and
  <span class="pre">
   computeType
  </span>
  is compute type of the operation.
  <span class="pre">
   cusolverDnGeqrf
  </span>
  only supports the following four combinations.
 </p>
 <p>
  Valid combination of data type and compute type
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     DataTypeA
    </p>
   </td>
   <td>
    <p>
     ComputeType
    </p>
   </td>
   <td>
    <p>
     Meaning
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      SGEQRF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      DGEQRF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CGEQRF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ZGEQRF
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      m,n&lt;0
     </span>
     or
     <span class="pre">
      lda&lt;max(1,m)
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.2.14.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverDN-lt-t-gt-gels">
   cusolverDn&lt;t1&gt;&lt;t2&gt;gels()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t1-t2-gels" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  These functions compute the solution of a system of linear equations with one or multiple right hand sides using mixed precision iterative refinement techniques based on the QR factorization Xgels. These functions are similar in term of functionalities to the full precision LAPACK QR (least squares) solver (Xgels, where X denotes Z,C,D,S) but it uses lower precision internally in order to provide faster time to solution, from here comes the name mixed precision. Mixed precision iterative refinement techniques means that the solver compute an QR factorization in lower precision and then iteratively refine the solution to achieve the accuracy of the Inputs/Outputs datatype precision. The &lt;t1&gt; corresponds to the Inputs/Outputs datatype precision while &lt;t2&gt; represent the internal lower precision at which the factorization will be carried on.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A \times X = B\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Where
  <span class="pre">
   A
  </span>
  is
  <span class="pre">
   m-by-n
  </span>
  matrix and
  <span class="pre">
   X
  </span>
  is
  <span class="pre">
   n-by-nrhs
  </span>
  and
  <span class="pre">
   B
  </span>
  is
  <span class="pre">
   m-by-nrhs
  </span>
  matrices.
 </p>
 <p>
  Functions API are designed to be as close as possible to LAPACK API to be considered as a quick and easy drop-in replacement. Description of these functions is given below.
  <span class="pre">
   &lt;t1&gt;&lt;t2&gt;gels()
  </span>
  functions are designated by two floating point precisions The
  <span class="pre">
   &lt;t1&gt;
  </span>
  corresponds to the main precision (e.g., Inputs/Outputs datatype precision) and the
  <span class="pre">
   &lt;t2&gt;
  </span>
  represent the internal lower precision at which the factorization will be carried on.
  <span class="pre">
   cusolver&lt;t1&gt;&lt;t2&gt;gels()
  </span>
  first attempts to factorize the matrix in lower precision and use this factorization within an iterative refinement procedure to obtain a solution with same normwise backward error as the main precision
  <span class="pre">
   &lt;t1&gt;
  </span>
  . If the approach fails to converge, then the method fallback to the main precision factorization and solve (Xgels) such a way that there is always a good solution at the output of these functions. If
  <span class="pre">
   &lt;t2&gt;
  </span>
  is equal to
  <span class="pre">
   &lt;t1&gt;
  </span>
  , then it is not a mixed precision process but rather a full one precision factorization, solve and refinement within the same main precision.
 </p>
 <p>
  The iterative refinement process is stopped if:
Â Â Â
  <span class="pre">
   ITER
  </span>
  <span class="pre">
   &gt;
  </span>
  <span class="pre">
   ITERMAX
  </span>
  or for all the RHS we have:
Â Â Â
  <span class="pre">
   RNRM
  </span>
  <span class="pre">
   &lt;
  </span>
  Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â
  <span class="pre">
   SQRT(N)*XNRM*ANRM*EPS*BWDMAX
  </span>
  where
 </p>
 <ul class="simple">
  <li>
   <p>
    ITER is the number of the current iteration in the iterative refinement process
   </p>
  </li>
  <li>
   <p>
    RNRM is the infinity-norm of the residual
   </p>
  </li>
  <li>
   <p>
    XNRM is the infinity-norm of the solution
   </p>
  </li>
  <li>
   <p>
    ANRM is the infinity-operator-norm of the matrix A
   </p>
  </li>
  <li>
   <p>
    EPS is the machine epsilon that matches
    <span class="pre">
     LAPACK
    </span>
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â
    <span class="pre">
     &lt;t1&gt;LAMCH('Epsilon')
    </span>
   </p>
  </li>
 </ul>
 <p>
  The values ITERMAX and BWDMAX are fixed to 50 and 1.0 respectively.
 </p>
 <p>
  The function returns value describes the results of the solving process. A CUSOLVER_STATUS_SUCCESS indicates that the function finished with success otherwise, it indicates if one of the API arguments is incorrect, or if the function did not finish with success. More details about the error will be in the
  <span class="pre">
   niters
  </span>
  and the
  <span class="pre">
   dinfo
  </span>
  API parameters. See their description below for more details. User should provide the required workspace allocated on device memory. The amount of bytes required can be queried by calling the respective function
  <span class="pre">
   &lt;t1&gt;&lt;t2&gt;gels_bufferSize()
  </span>
  .
 </p>
 <p>
  We provide a large set of mixed precision functions that include half, bfloat and tensorfloat as a lower precision as well as same precision functions (e.g., main and lowest precision are equal
  <span class="pre">
   &lt;t2&gt;
  </span>
  is equal to
  <span class="pre">
   &lt;t1&gt;
  </span>
  ). The following table specifies which precisions will be used for which interface function:
 </p>
 <p>
  Tensor Float (TF32), introduced with NVIDIA Ampere Architecture GPUs, is the most robust tensor core accelerated compute mode for the iterative refinement solver. It is able to solve the widest range of problems in HPC arising from different applications and provides up to 4X and 5X speedup for real and complex systems, respectively. On Volta and Turing architecture GPUs, half precision tensor core acceleration is recommended. In cases where the iterative refinement solver fails to converge to the desired accuracy (main precision, INOUT data precision), it is recommended to use main precision as internal lowest precision (i.e.,
  <span class="pre">
   cusolverDn[DD,ZZ]gels
  </span>
  for the FP64 case).
 </p>
 <table class="table-no-stripes docutils align-default" id="id27">
  <span class="caption-text">
   Table 7.
   Supported combinations of floating point precisions for cusolver &lt;t1&gt;&lt;t2&gt;gels() functions
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#id27" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Interface function
    </p>
   </th>
   <th class="head">
    <p>
     Main precision (matrix, rhs and solution datatype)
    </p>
   </th>
   <th class="head">
    <p>
     Lowest precision allowed to be used internally
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cusolverDnZZgels
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      cuDoubleComplex
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      double
     </span>
     <span class="pre">
      complex
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cusolverDnZCgels
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      cuDoubleComplex
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      single
     </span>
     <span class="pre">
      complex
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cusolverDnZKgels
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      cuDoubleComplex
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      half
     </span>
     <span class="pre">
      complex
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cusolverDnZEgels
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      cuDoubleComplex
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      bfloat
     </span>
     <span class="pre">
      complex
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cusolverDnZYgels
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      cuDoubleComplex
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      tensorfloat
     </span>
     <span class="pre">
      complex
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cusolverDnCCgels
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      cuComplex
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      single
     </span>
     <span class="pre">
      complex
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cusolverDnCKgels
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      cuComplex
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      half
     </span>
     <span class="pre">
      complex
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cusolverDnCEgels
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      cuComplex
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      bfloat
     </span>
     <span class="pre">
      complex
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cusolverDnCYgels
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      cuComplex
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      tensorfloat
     </span>
     <span class="pre">
      complex
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cusolverDnDDgels
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      double
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      double
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cusolverDnDSgels
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      double
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      single
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cusolverDnDHgels
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      double
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      half
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cusolverDnDBgels
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      double
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      bfloat
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cusolverDnDXgels
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      double
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      tensorfloat
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cusolverDnSSgels
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      float
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      single
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cusolverDnSHgels
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      float
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      half
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cusolverDnSBgels
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      float
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      bfloat
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cusolverDnSXgels
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      float
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      tensorfloat
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusolverDn&lt;t1&gt;&lt;t2&gt;gels_bufferSize()
  </span>
  functions will return workspace buffer size in bytes required for the corresponding
  <span class="pre">
   cusolverDn&lt;t1&gt;&lt;t2&gt;gels()
  </span>
  function.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZZgels_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZCgels_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZKgels_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZEgels_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZYgels_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCCgels_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCKgels_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCEgels_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCYgels_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDDgels_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDSgels_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDHgels_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDBgels_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDXgels_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSSgels_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSHgels_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSBgels_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSXgels_bufferSize</span><span class="p">(</span>
<span class="n">cusolverHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>
</pre>
 <table class="table-no-stripes docutils align-default" id="id28">
  <span class="caption-text">
   Table 8.
   Parameters of cusolverDn&lt;T1&gt;&lt;T2&gt;gels_bufferSize() functions
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#id28" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cusolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows of the matrix
     <span class="pre">
      A
     </span>
     . Should be non-negative and n&lt;=m
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of the matrix
     <span class="pre">
      A
     </span>
     . Should be non-negative and n&lt;=m.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nrhs
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of right hand sides to solve. Should be non-negative.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      None
     </span>
    </p>
   </td>
   <td>
    <p>
     Matrix
     <span class="pre">
      A
     </span>
     with size
     <span class="pre">
      m-by-n
     </span>
     . Can be
     <span class="pre">
      NULL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ldda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
     <span class="pre">
      ldda
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      m
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dB
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      None
     </span>
    </p>
   </td>
   <td>
    <p>
     Set of right hand sides
     <span class="pre">
      B
     </span>
     of size
     <span class="pre">
      m-by-nrhs
     </span>
     . Can be
     <span class="pre">
      NULL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lddb
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix of right hand sides
     <span class="pre">
      B
     </span>
     .
     <span class="pre">
      lddb
     </span>
     <span class="pre">
      &gt;=
     </span>
     Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â
     <span class="pre">
      max(1,m)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dX
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      None
     </span>
    </p>
   </td>
   <td>
    <p>
     Set of solution vectors
     <span class="pre">
      X
     </span>
     of size
     <span class="pre">
      n-by-nrhs
     </span>
     . Can be
     <span class="pre">
      NULL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lddx
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix of solution vectors
     <span class="pre">
      X
     </span>
     .
     <span class="pre">
      lddx
     </span>
     <span class="pre">
      &gt;=
     </span>
     Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      none
     </span>
    </p>
   </td>
   <td>
    <p>
     Pointer to device workspace. Not used and can be
     <span class="pre">
      NULL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lwork_bytes
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Pointer to a variable where required size of temporary workspace in bytes will be stored. Canât be NULL.
    </p>
   </td>
  </tr>
 </table>
 <pre><span class="n">cusolverStatus_t</span><span class="nf">cusolverDnZZgels</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnZCgels</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnZKgels</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnZEgels</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnZYgels</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnCCgels</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnCKgels</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnCEgels</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnCYgels</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnDDgels</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnDSgels</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnDHgels</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnDBgels</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnDXgels</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnSSgels</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnSHgels</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnSBgels</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="nf">cusolverDnSXgels</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">niter</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>
</pre>
 <table class="table-no-stripes docutils align-default" id="id29">
  <span class="caption-text">
   Table 9.
   Parameters of cusolverDn&lt;T1&gt;&lt;T2&gt;gels() functions
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#id29" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cusolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows of the matrix
     <span class="pre">
      A
     </span>
     . Should be non-negative and n&lt;=m
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of the matrix
     <span class="pre">
      A
     </span>
     . Should be non-negative and n&lt;=m.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nrhs
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of right hand sides to solve. Should be non-negative.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Matrix
     <span class="pre">
      A
     </span>
     with size
     <span class="pre">
      m-by-n
     </span>
     . Canât be
     <span class="pre">
      NULL
     </span>
     . On return - unchanged if the lowest precision is not equal to the main precision and the iterative refinement solver converged, - garbage otherwise.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ldda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
     <span class="pre">
      ldda
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      m
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dB
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Set of right hand sides
     <span class="pre">
      B
     </span>
     of size
     <span class="pre">
      m-by-nrhs
     </span>
     . Canât be
     <span class="pre">
      NULL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lddb
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix of right hand sides
     <span class="pre">
      B
     </span>
     .
     <span class="pre">
      lddb
     </span>
     <span class="pre">
      &gt;=
     </span>
     Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â
     <span class="pre">
      max(1,m)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dX
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Set of solution vectors
     <span class="pre">
      X
     </span>
     of size
     <span class="pre">
      n-by-nrhs
     </span>
     . Canât be
     <span class="pre">
      NULL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lddx
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix of solution vectors
     <span class="pre">
      X
     </span>
     .
     <span class="pre">
      lddx
     </span>
     <span class="pre">
      &gt;=
     </span>
     Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dWorkspace
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Pointer to an allocated workspace in device memory of size lwork_bytes.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lwork_bytes
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of the allocated device workspace. Should be at least what was returned by
     <span class="pre">
      cusolverDn&lt;T1&gt;&lt;T2&gt;gels_bufferSize()
     </span>
     function
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      niters
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If iter is
    </p>
    <ul class="simple">
     <li>
      <p>
       &lt;0 : iterative refinement has failed, main precision (Inputs/Outputs precision) factorization has been performed.
      </p>
     </li>
     <li>
      <p>
       -1 : taking into account machine parameters, n, nrhs, it is a priori not worth working in lower precision
      </p>
     </li>
     <li>
      <p>
       -2 : overflow of an entry when moving from main to lower precision
      </p>
     </li>
     <li>
      <p>
       -3 : failure during the factorization
      </p>
     </li>
     <li>
      <p>
       -5 : overflow occurred during computation
      </p>
     </li>
     <li>
      <p>
       -50: solver stopped the iterative refinement after reaching maximum allowed iterations.
      </p>
     </li>
     <li>
      <p>
       &gt;0 : iter is a number of iterations solver performed to reach convergence criteria
      </p>
     </li>
    </ul>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dinfo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Status of the IRS solver on the return. If 0 - solve was successful. If dinfo = -
     <span class="pre">
      i
     </span>
     then
     <span class="pre">
      i
     </span>
     -th argument is not valid.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed, for example:
    </p>
    <ul class="simple">
     <li>
      <p>
       <span class="pre">
        n&lt;0
       </span>
      </p>
     </li>
     <li>
      <p>
       <span class="pre">
        ldda&lt;max(1,m)
       </span>
      </p>
     </li>
     <li>
      <p>
       <span class="pre">
        lddb&lt;max(1,m)
       </span>
      </p>
     </li>
     <li>
      <p>
       <span class="pre">
        lddx&lt;max(1,n)
       </span>
      </p>
     </li>
    </ul>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The IRS solver supports compute capability 7.0 and above. The lowest precision options CUSOLVER_[CR]_16BF and CUSOLVER_[CR]_TF32 are only available on compute capability 8.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_WORKSPACE
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      lwork_bytes
     </span>
     is smaller than the required workspace.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_OUT_OF_RANGE
     </span>
    </p>
   </td>
   <td>
    <p>
     Numerical error related to niters &lt;0, see niters description for more details.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal error occurred; check the
     <span class="pre">
      dinfo
     </span>
     and the
     <span class="pre">
      niters
     </span>
     arguments for more details.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.2.15.
  </span>
  cusolverDnIRSXgels()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnirsxgels" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  This function is designed to perform same functionality as
  <span class="pre">
   cusolverDn&lt;T1&gt;&lt;T2&gt;gels()
  </span>
  functions, but wrapped in a more generic and expert interface that gives user more control to parametrize the function as well as it provides more information on output.
  <span class="pre">
   cusolverDnIRSXgels()
  </span>
  allows additional control of the solver parameters such as setting:
 </p>
 <ul class="simple">
  <li>
   <p>
    the main precision (Inputs/Outputs precision) of the solver,
   </p>
  </li>
  <li>
   <p>
    the lowest precision to be used internally by the solver,
   </p>
  </li>
  <li>
   <p>
    the refinement solver type
   </p>
  </li>
  <li>
   <p>
    the maximum allowed number of iterations in the refinement phase
   </p>
  </li>
  <li>
   <p>
    the tolerance of the refinement solver
   </p>
  </li>
  <li>
   <p>
    the fallback to main precision
   </p>
  </li>
  <li>
   <p>
    and others
   </p>
  </li>
 </ul>
 <p>
  through the configuration parameters structure
  <span class="pre">
   gels_irs_params
  </span>
  and its helper functions. For more details about what configuration can be set and its meaning please refer to all the functions in the cuSolverDN Helper Function Section that start with
  <span class="pre">
   cusolverDnIRSParamsxxxx()
  </span>
  . Moreover,
  <span class="pre">
   cusolverDnIRSXgels()
  </span>
  provides additional information on the output such as the convergence history (e.g., the residual norms) at each iteration and the number of iterations needed to converge. For more details about what information can be retrieved and its meaning please refer to all the functions in the cuSolverDN Helper Function Section that start with
  <span class="pre">
   cusolverDnIRSInfosxxxx()
  </span>
  .
 </p>
 <p>
  The function returns value describes the results of the solving process. A CUSOLVER_STATUS_SUCCESS indicates that the function finished with success otherwise, it indicates if one of the API arguments is incorrect, or if the configurations of params/infos structure is incorrect or if the function did not finish with success. More details about the error can be found by checking the
  <span class="pre">
   niters
  </span>
  and the
  <span class="pre">
   dinfo
  </span>
  API parameters. See their description below for further details. Users should provide the required workspace allocated on device for the
  <span class="pre">
   cusolverDnIRSXgels()
  </span>
  function. The amount of bytes required for the function can be queried by calling the respective function
  <span class="pre">
   cusolverDnIRSXgels_bufferSize()
  </span>
  . Note that, if the user would like a particular configuration to be set via the params structure, it should be set before the call to
  <span class="pre">
   cusolverDnIRSXgels_bufferSize()
  </span>
  to get the size of the required workspace.
 </p>
 <p>
  The following table provides all possible combinations values for the lowest precision corresponding to the Inputs/Outputs data type. Note that if the lowest precision matches the Inputs/Outputs datatype, then main precision factorization will be used
 </p>
 <p>
  Tensor Float (TF32), introduced with NVIDIA Ampere Architecture GPUs, is the most robust tensor core accelerated compute mode for the iterative refinement solver. It is able to solve the widest range of problems in HPC arising from different applications and provides up to 4X and 5X speedup for real and complex systems, respectively. On Volta and Turing architecture GPUs, half precision tensor core acceleration is recommended. In cases where the iterative refinement solver fails to converge to the desired accuracy (main precision, INOUT data precision), it is recommended to use main precision as internal lowest precision.
 </p>
 <table class="docutils align-default" id="id30">
  <span class="caption-text">
   Table 10.
   Supported Inputs/Outputs data type and lower precision for the IRS solver
   :class: table-no-stripes
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#id30" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Inputs/Outputs Data Type (e.g., main precision)
    </p>
   </th>
   <th class="head">
    <p>
     Supported values for the lowest precision
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUSOLVER_C_64F,
     </span>
     <span class="pre">
      CUSOLVER_C_32F,
     </span>
     <span class="pre">
      CUSOLVER_C_16F,
     </span>
     <span class="pre">
      CUSOLVER_C_16BF,
     </span>
     <span class="pre">
      CUSOLVER_C_TF32
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUSOLVER_C_32F,
     </span>
     <span class="pre">
      CUSOLVER_C_16F,
     </span>
     <span class="pre">
      CUSOLVER_C_16BF,
     </span>
     <span class="pre">
      CUSOLVER_C_TF32
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUSOLVER_R_64F,
     </span>
     <span class="pre">
      CUSOLVER_R_32F,
     </span>
     <span class="pre">
      CUSOLVER_R_16F,
     </span>
     <span class="pre">
      CUSOLVER_R_16BF,
     </span>
     <span class="pre">
      CUSOLVER_R_TF32
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUSOLVER_R_32F,
     </span>
     <span class="pre">
      CUSOLVER_R_16F,
     </span>
     <span class="pre">
      CUSOLVER_R_16BF,
     </span>
     <span class="pre">
      CUSOLVER_R_TF32
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The
  <span class="pre">
   cusolverDnIRSXgels_bufferSize()
  </span>
  function return the required workspace buffer size in bytes for the corresponding
  <span class="pre">
   cusolverDnXgels()
  </span>
  call with given
  <span class="pre">
   gels_irs_params
  </span>
  configuration.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnIRSXgels_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnIRSParams_t</span><span class="n">gels_irs_params</span><span class="p">,</span>
<span class="n">cusolver_int_t</span><span class="n">m</span><span class="p">,</span>
<span class="n">cusolver_int_t</span><span class="n">n</span><span class="p">,</span>
<span class="n">cusolver_int_t</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">lwork_bytes</span><span class="p">);</span>
</pre>
 <p>
  Parameters of cusolverDnIRSXgels_bufferSize() functions
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cusolverDn library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Xgels configuration parameters
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows of the matrix
     <span class="pre">
      A
     </span>
     . Should be non-negative and n&lt;=m
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of the matrix
     <span class="pre">
      A
     </span>
     . Should be non-negative and n&lt;=m.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nrhs
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of right hand sides to solve. Should be non-negative. Note that,
     <span class="pre">
      nrhs
     </span>
     is limited to 1 if the selected IRS refinement solver is CUSOLVER_IRS_REFINE_GMRES, CUSOLVER_IRS_REFINE_GMRES_GMRES, CUSOLVER_IRS_REFINE_CLASSICAL_GMRES.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lwork_bytes
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      out
     </span>
    </p>
   </td>
   <td>
    <p>
     Pointer to a variable, where the required size in bytes, of the workspace will be stored after a call to cusolverDnIRSXgels_bufferSize. Canât be NULL.
    </p>
   </td>
  </tr>
 </table>
 <pre><span class="n">cusolverStatus_t</span><span class="nf">cusolverDnIRSXgels</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnIRSParams_t</span><span class="n">gels_irs_params</span><span class="p">,</span>
<span class="n">cusolverDnIRSInfos_t</span><span class="n">gels_irs_infos</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldda</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddb</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lddx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">dWorkspace</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">lwork_bytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">dinfo</span><span class="p">);</span>
</pre>
 <table class="table-no-stripes docutils align-default" id="id31">
  <span class="caption-text">
   Table 11.
   Parameters of cusolverDnIRSXgels() functions
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#id31" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cusolverDn library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      gels_irs_params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Configuration parameters structure, can serve one or more calls to any IRS solver
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      gels_irs_infos
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Info structure, where information about a particular solve will be stored. The
     <span class="pre">
      gels_irs_infos
     </span>
     structure correspond to a particular call. Thus different calls requires different
     <span class="pre">
      gels_irs_infos
     </span>
     structure otherwise, it will be overwritten.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows of the matrix
     <span class="pre">
      A
     </span>
     . Should be non-negative and n&lt;=m
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of the matrix
     <span class="pre">
      A
     </span>
     . Should be non-negative and n&lt;=m.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nrhs
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of right hand sides to solve. Should be non-negative. Note that,
     <span class="pre">
      nrhs
     </span>
     is limited to 1 if the selected IRS refinement solver is CUSOLVER_IRS_REFINE_GMRES, CUSOLVER_IRS_REFINE_GMRES_GMRES, CUSOLVER_IRS_REFINE_CLASSICAL_GMRES.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Matrix
     <span class="pre">
      A
     </span>
     with size
     <span class="pre">
      m-by-n
     </span>
     . Canât be
     <span class="pre">
      NULL
     </span>
     . On return - unchanged if the lowest precision is not equal to the main precision and the iterative refinement solver converged, - garbage otherwise.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ldda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
     <span class="pre">
      ldda
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      m
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dB
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Set of right hand sides
     <span class="pre">
      B
     </span>
     of size
     <span class="pre">
      m-by-nrhs
     </span>
     . Canât be
     <span class="pre">
      NULL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lddb
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix of right hand sides
     <span class="pre">
      B
     </span>
     .
     <span class="pre">
      lddb
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      max(1,m)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dX
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Set of solution vectors
     <span class="pre">
      X
     </span>
     of size
     <span class="pre">
      n-by-nrhs
     </span>
     . Canât be
     <span class="pre">
      NULL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lddx
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix of solution vectors
     <span class="pre">
      X
     </span>
     .
     <span class="pre">
      lddx
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dWorkspace
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Pointer to an allocated workspace in device memory of size lwork_bytes.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lwork_bytes
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of the allocated device workspace. Should be at least what was returned by
     <span class="pre">
      cusolverDnIRSXgels_bufferSize()
     </span>
     function.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      niters
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      iter
     </span>
     is
    </p>
    <ul class="simple">
     <li>
      <p>
       &lt;0 : iterative refinement has failed, main precision (Inputs/Outputs precision) factorization has been performed if fallback is enabled
      </p>
     </li>
     <li>
      <p>
       -1 : taking into account machine parameters, n, nrhs, it is a priori not worth working in lower precision
      </p>
     </li>
     <li>
      <p>
       -2 : overflow of an entry when moving from main to lower precision
      </p>
     </li>
     <li>
      <p>
       -3 : failure during the factorization
      </p>
     </li>
     <li>
      <p>
       -5 : overflow occurred during computation
      </p>
     </li>
     <li>
      <p>
       <span class="pre">
        -maxiter
       </span>
       : solver stopped the iterative refinement after reaching maximum allowed iterations
      </p>
     </li>
     <li>
      <p>
       &gt;0 : iter is a number of iterations solver performed to reach convergence criteria
      </p>
     </li>
    </ul>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dinfo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Status of the IRS solver on the return. If 0 - solve was successful. If dinfo = -
     <span class="pre">
      i
     </span>
     then
     <span class="pre">
      i
     </span>
     -th argument is not valid.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed, for example:
    </p>
    <ul class="simple">
     <li>
      <p>
       <span class="pre">
        n&lt;0
       </span>
      </p>
     </li>
     <li>
      <p>
       <span class="pre">
        ldda&lt;max(1,m)
       </span>
      </p>
     </li>
     <li>
      <p>
       <span class="pre">
        lddb&lt;max(1,m)
       </span>
      </p>
     </li>
     <li>
      <p>
       <span class="pre">
        lddx&lt;max(1,n)
       </span>
      </p>
     </li>
    </ul>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The IRS solver supports compute capability 7.0 and above. The lowest precision options CUSOLVER_[CR]_16BF and CUSOLVER_[CR]_TF32 are only available on compute capability 8.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_WORKSPACE
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      lwork_bytes
     </span>
     is smaller than the required workspace. Could happen if the users called
     <span class="pre">
      cusolverDnIRSXgels_bufferSize()
     </span>
     function, then changed some of the configurations setting such as the lowest precision.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_OUT_OF_RANGE
     </span>
    </p>
   </td>
   <td>
    <p>
     Numerical error related to
     <span class="pre">
      niters
     </span>
     &lt;0; see
     <span class="pre">
      niters
     </span>
     description for more details.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal error occurred, check the
     <span class="pre">
      dinfo
     </span>
     and the
     <span class="pre">
      niters
     </span>
     arguments for more details.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_PARAMS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The configuration parameter
     <span class="pre">
      gels_irs_params
     </span>
     structure was not created.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_PARAMS_INVALID
     </span>
    </p>
   </td>
   <td>
    <p>
     One of the configuration parameter in the
     <span class="pre">
      gels_irs_params
     </span>
     structure is not valid.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_PARAMS_INVALID_PREC
     </span>
    </p>
   </td>
   <td>
    <p>
     The main and/or the lowest precision configuration parameter in the
     <span class="pre">
      gels_irs_params
     </span>
     structure is not valid, check the table above for the supported combinations.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_PARAMS_INVALID_MAXITER
     </span>
    </p>
   </td>
   <td>
    <p>
     The maxiter configuration parameter in the
     <span class="pre">
      gels_irs_params
     </span>
     structure is not valid.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_PARAMS_INVALID_REFINE
     </span>
    </p>
   </td>
   <td>
    <p>
     The refinement solver configuration parameter in the gels_irs_params structure is not valid.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_NOT_SUPPORTED
     </span>
    </p>
   </td>
   <td>
    <p>
     One of the configuration parameter in the
     <span class="pre">
      gels_irs_params
     </span>
     structure is not supported. For example if nrhs &gt;1, and refinement solver was set to CUSOLVER_IRS_REFINE_GMRES.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_IRS_INFOS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The information structure
     <span class="pre">
      gels_irs_infos
     </span>
     was not created.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     CPU memory allocation failed, most likely during the allocation of the residual array that store the residual norms.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.2.16.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDN-lt-t-gt-ormqr">
   cusolverDn&lt;t&gt;ormqr()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-ormqr" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  These helper functions calculate the size of work buffers needed. Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/ormqr">
   cuSOLVER Library Samples - ormqr
  </a>
  for a code example.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSormqr_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasSideMode_t</span><span class="n">side</span><span class="p">,</span>
<span class="n">cublasOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">k</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">C</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldc</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDormqr_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasSideMode_t</span><span class="n">side</span><span class="p">,</span>
<span class="n">cublasOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">k</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">C</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldc</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCunmqr_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasSideMode_t</span><span class="n">side</span><span class="p">,</span>
<span class="n">cublasOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">k</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">C</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldc</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZunmqr_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasSideMode_t</span><span class="n">side</span><span class="p">,</span>
<span class="n">cublasOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">k</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">C</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldc</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>
</pre>
 <p>
  The S and D data types are real valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSormqr</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasSideMode_t</span><span class="n">side</span><span class="p">,</span>
<span class="n">cublasOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">k</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">C</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldc</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDormqr</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasSideMode_t</span><span class="n">side</span><span class="p">,</span>
<span class="n">cublasOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">k</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">C</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldc</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  The C and Z data types are complex valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCunmqr</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasSideMode_t</span><span class="n">side</span><span class="p">,</span>
<span class="n">cublasOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">k</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">C</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldc</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZunmqr</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasSideMode_t</span><span class="n">side</span><span class="p">,</span>
<span class="n">cublasOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">k</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">C</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldc</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  This function overwrites
  <span class="pre">
   mÃn
  </span>
  matrix
  <span class="pre">
   C
  </span>
  by
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(C = \left\{ \begin{matrix}
{\text{op}(Q)*C} &amp; {\text{if~}\textsf{side\ ==\ CUBLAS\_SIDE\_LEFT}} \\
{C*\text{op}(Q)} &amp; {\text{if~}\textsf{side\ ==\ CUBLAS\_SIDE\_RIGHT}} \\
\end{matrix} \right.\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The operation of
  <span class="pre">
   Q
  </span>
  is defined by
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\text{op}(Q) = \left\{ \begin{matrix}
Q &amp; {\text{if~}\textsf{transa\ ==\ CUBLAS\_OP\_N}} \\
Q^{T} &amp; {\text{if~}\textsf{transa\ ==\ CUBLAS\_OP\_T}} \\
Q^{H} &amp; {\text{if~}\textsf{transa\ ==\ CUBLAS\_OP\_C}} \\
\end{matrix} \right.\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   Q
  </span>
  is a unitary matrix formed by a sequence of elementary reflection vectors from QR factorization (
  <span class="pre">
   geqrf
  </span>
  ) of
  <span class="pre">
   A
  </span>
  .
 </p>
 <p>
  <span class="pre">
   Q
  </span>
  =
  <span class="pre">
   H(1)
  </span>
  <span class="pre">
   H(2)
  </span>
  â¦
  <span class="pre">
   H(k)
  </span>
 </p>
 <p>
  <span class="pre">
   Q
  </span>
  is of order
  <span class="pre">
   m
  </span>
  if
  <span class="pre">
   side
  </span>
  =
  <span class="pre">
   CUBLAS_SIDE_LEFT
  </span>
  and of order
  <span class="pre">
   n
  </span>
  if
  <span class="pre">
   side
  </span>
  =
  <span class="pre">
   CUBLAS_SIDE_RIGHT
  </span>
  .
 </p>
 <p>
  The user has to provide working space which is pointed by input parameter
  <span class="pre">
   work
  </span>
  . The input parameter
  <span class="pre">
   lwork
  </span>
  is size of the working space, and it is returned by
  <span class="pre">
   geqrf_bufferSize()
  </span>
  or
  <span class="pre">
   ormqr_bufferSize()
  </span>
  . Please note that the size in bytes of the working space is equal to
  <span class="pre">
   sizeof(&lt;type&gt;)
  </span>
  <span class="pre">
   *
  </span>
  <span class="pre">
   lwork
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   devInfo
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  The user can combine
  <span class="pre">
   geqrf
  </span>
  ,
  <span class="pre">
   ormqr
  </span>
  and
  <span class="pre">
   trsm
  </span>
  to complete a linear solver or a least-square solver.
 </p>
 <p>
  API of ormqr
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDn library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      side
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Indicates if matrix
     <span class="pre">
      Q
     </span>
     is on the left or right of
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      trans
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Operation
     <span class="pre">
      op(Q)
     </span>
     that is non- or (conj.) transpose.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows of matrix
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of matrix
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      k
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of elementary reflections whose product defines the matrix Q.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      k
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,m)
     </span>
     . The matrix
     <span class="pre">
      A
     </span>
     is from
     <span class="pre">
      geqrf
     </span>
     , so i-th column contains elementary reflection vector.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     . if
     <span class="pre">
      side
     </span>
     is
     <span class="pre">
      CUBLAS_SIDE_LEFT
     </span>
     , lda &gt;= max(1,m); if
     <span class="pre">
      side
     </span>
     is
     <span class="pre">
      CUBLAS_SIDE_RIGHT
     </span>
     , lda &gt;= max(1,n).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      tau
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension at least
     <span class="pre">
      min(m,n)
     </span>
     . The vector
     <span class="pre">
      tau
     </span>
     is from
     <span class="pre">
      geqrf
     </span>
     , so
     <span class="pre">
      tau(i)
     </span>
     is the scalar of i-th elementary reflection vector.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      C
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of size
     <span class="pre">
      ldc
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     . On exit,
     <span class="pre">
      C
     </span>
     is overwritten by
     <span class="pre">
      op(Q)*C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ldc
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array of matrix
     <span class="pre">
      C
     </span>
     . ldc &gt;= max(1,m).
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      work
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Working space, &lt;type&gt; array of size
     <span class="pre">
      lwork
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of working array
     <span class="pre">
      work
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      devInfo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the ormqr is successful. If
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle).
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      m,n&lt;0
     </span>
     or wrong
     <span class="pre">
      lda
     </span>
     or
     <span class="pre">
      ldc
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.2.17.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDN-lt-t-gt-orgqr">
   cusolverDn&lt;t&gt;orgqr()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-orgqr" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  These helper functions calculate the size of work buffers needed. Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/orgqr">
   cuSOLVER Library Samples - orgqr
  </a>
  for a code example.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSorgqr_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">k</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDorgqr_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">k</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCungqr_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">k</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZungqr_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">k</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>
</pre>
 <p>
  The S and D data types are real valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSorgqr</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">k</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDorgqr</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">k</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  The C and Z data types are complex valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCungqr</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">k</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZungqr</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">k</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  This function overwrites
  <span class="pre">
   mÃn
  </span>
  matrix
  <span class="pre">
   A
  </span>
  by
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(Q = {H(1)}*{H(2)}*{...}*{H(k)}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   Q
  </span>
  is a unitary matrix formed by a sequence of elementary reflection vectors stored in
  <span class="pre">
   A
  </span>
  .
 </p>
 <p>
  The user has to provide working space which is pointed by input parameter
  <span class="pre">
   work
  </span>
  . The input parameter
  <span class="pre">
   lwork
  </span>
  is size of the working space, and it is returned by
  <span class="pre">
   orgqr_bufferSize()
  </span>
  . Please note that the size in bytes of the working space is equal to
  <span class="pre">
   sizeof(&lt;type&gt;)
  </span>
  <span class="pre">
   *
  </span>
  <span class="pre">
   lwork
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   devInfo
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  The user can combine
  <span class="pre">
   geqrf
  </span>
  ,
  <span class="pre">
   orgqr
  </span>
  to complete orthogonalization.
 </p>
 <p>
  API of orgqr
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows of matrix
     <span class="pre">
      Q
     </span>
     . m &gt;= 0;
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of matrix
     <span class="pre">
      Q
     </span>
     . m &gt;= n &gt;= 0;
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      k
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of elementary reflections whose product defines the matrix
     <span class="pre">
      Q
     </span>
     . n &gt;= k &gt;= 0;
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,m)
     </span>
     . i-th column of
     <span class="pre">
      A
     </span>
     contains elementary reflection vector.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     . lda &gt;= max(1,m).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      tau
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      k
     </span>
     .
     <span class="pre">
      tau(i)
     </span>
     is the scalar of i-th elementary reflection vector.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      work
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Working space, &lt;type&gt; array of size
     <span class="pre">
      lwork
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of working array
     <span class="pre">
      work
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      devInfo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the orgqr is successful. if
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle).
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      m,n,k&lt;0
     </span>
     ,
     <span class="pre">
      n&gt;m
     </span>
     ,
     <span class="pre">
      k&gt;n
     </span>
     or
     <span class="pre">
      lda&lt;m
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.2.18.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDN-lt-t-gt-sytrf">
   cusolverDn&lt;t&gt;sytrf()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-sytrf" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  These helper functions calculate the size of the needed buffers.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSsytrf_bufferSize</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">Lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDsytrf_bufferSize</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">Lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCsytrf_bufferSize</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">Lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZsytrf_bufferSize</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">Lwork</span><span class="p">);</span>
</pre>
 <p>
  The S and D data types are real valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSsytrf</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">ipiv</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDsytrf</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">ipiv</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  The C and Z data types are complex valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCsytrf</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">ipiv</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZsytrf</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">ipiv</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  This function computes the Bunch-Kaufman factorization of a
  <span class="pre">
   nÃn
  </span>
  symmetric indefinite matrix
 </p>
 <p>
  <span class="pre">
   A
  </span>
  is a
  <span class="pre">
   nÃn
  </span>
  symmetric matrix, only lower or upper part is meaningful. The input parameter
  <span class="pre">
   uplo
  </span>
  which part of the matrix is used. The function would leave other part untouched.
 </p>
 <p>
  If input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_LOWER
  </span>
  , only lower triangular part of
  <span class="pre">
   A
  </span>
  is processed, and replaced by lower triangular factor
  <span class="pre">
   L
  </span>
  and block diagonal matrix
  <span class="pre">
   D
  </span>
  . Each block of
  <span class="pre">
   D
  </span>
  is either 1x1 or 2x2 block, depending on pivoting.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(P*A*P^{T} = L*D*L^{T}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  If input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_UPPER
  </span>
  , only upper triangular part of
  <span class="pre">
   A
  </span>
  is processed, and replaced by upper triangular factor
  <span class="pre">
   U
  </span>
  and block diagonal matrix
  <span class="pre">
   D
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(P*A*P^{T} = U*D*U^{T}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The user has to provide working space which is pointed by input parameter
  <span class="pre">
   work
  </span>
  . The input parameter
  <span class="pre">
   lwork
  </span>
  is size of the working space, and it is returned by
  <span class="pre">
   sytrf_bufferSize()
  </span>
  . Please note that the size in bytes of the working space is equal to
  <span class="pre">
   sizeof(&lt;type&gt;)
  </span>
  <span class="pre">
   *
  </span>
  <span class="pre">
   lwork
  </span>
  .
 </p>
 <p>
  If Bunch-Kaufman factorization failed, i.e.
  <span class="pre">
   A
  </span>
  is singular. The output parameter
  <span class="pre">
   devInfo
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   i
  </span>
  would indicate
  <span class="pre">
   D(i,i)=0
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   devInfo
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  The output parameter
  <span class="pre">
   devIpiv
  </span>
  contains pivoting sequence. If
  <span class="pre">
   devIpiv(i)
  </span>
  <span class="pre">
   =
  </span>
  Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â
  <span class="pre">
   k
  </span>
  <span class="pre">
   &gt;
  </span>
  <span class="pre">
   0
  </span>
  ,
  <span class="pre">
   D(i,i)
  </span>
  is 1x1 block, and
  <span class="pre">
   i-th
  </span>
  row/column of
  <span class="pre">
   A
  </span>
  is interchanged with
  <span class="pre">
   k-th
  </span>
  row/column of
  <span class="pre">
   A
  </span>
  . If
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_UPPER
  </span>
  and
  <span class="pre">
   devIpiv(i-1)
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   devIpiv(i)
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -m
  </span>
  <span class="pre">
   &lt;
  </span>
  <span class="pre">
   0
  </span>
  ,
  <span class="pre">
   D(i-1:i,i-1:i)
  </span>
  is a 2x2 block, and
  <span class="pre">
   (i-1)-th
  </span>
  row/column is interchanged with
  <span class="pre">
   m-th
  </span>
  row/column. If
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_LOWER
  </span>
  and
  <span class="pre">
   devIpiv(i+1)
  </span>
  <span class="pre">
   =
  </span>
  Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â
  <span class="pre">
   devIpiv(i)
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -m
  </span>
  <span class="pre">
   &lt;
  </span>
  <span class="pre">
   0
  </span>
  ,
  <span class="pre">
   D(i:i+1,i:i+1)
  </span>
  is a 2x2 block, and
  <span class="pre">
   (i+1)-th
  </span>
  row/column is interchanged with
  <span class="pre">
   m-th
  </span>
  row/column.
 </p>
 <p>
  API of sytrf
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Indicates if matrix
     <span class="pre">
      A
     </span>
     lower or upper part is stored, the other part is not referenced.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ipiv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of size at least
     <span class="pre">
      n
     </span>
     , containing pivot indices.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      work
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Working space, &lt;type&gt; array of size
     <span class="pre">
      lwork
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of working space
     <span class="pre">
      work
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      devInfo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the LU factorization is successful. if
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle). if
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     Â
     <span class="pre">
      i
     </span>
     , the
     <span class="pre">
      D(i,i)
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n&lt;0
     </span>
     or
     <span class="pre">
      lda&lt;max(1,n)
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.2.19.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDN-lt-t-gt-batchpotrf">
   cusolverDn&lt;t&gt;potrfBatched()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-potrfbatched" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The S and D data types are real valued single and double precision, respectively. Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/potrfBatched">
   cuSOLVER Library Samples - potrfBatched
  </a>
  for a code example.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSpotrfBatched</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">Aarray</span><span class="p">[],</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">infoArray</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDpotrfBatched</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">Aarray</span><span class="p">[],</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">infoArray</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">);</span>
</pre>
 <p>
  The C and Z data types are complex valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCpotrfBatched</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">Aarray</span><span class="p">[],</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">infoArray</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZpotrfBatched</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">Aarray</span><span class="p">[],</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">infoArray</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">);</span>
</pre>
 <p>
  This function computes the Cholesky factorization of a sequence of Hermitian positive-definite matrices.
 </p>
 <p>
  Each
  <span class="pre">
   Aarray[i]
  </span>
  <span class="pre">
   for
  </span>
  <span class="pre">
   i=0,1,...,
  </span>
  <span class="pre">
   batchSize-1
  </span>
  is a
  <span class="pre">
   nÃn
  </span>
  Hermitian matrix, only lower or upper part is meaningful. The input parameter
  <span class="pre">
   uplo
  </span>
  indicates which part of the matrix is used.
 </p>
 <p>
  If input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_LOWER
  </span>
  , only lower triangular part of
  <span class="pre">
   A
  </span>
  is processed, and replaced by lower triangular Cholesky factor
  <span class="pre">
   L
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = L*L^{H}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  If input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_UPPER
  </span>
  , only upper triangular part of
  <span class="pre">
   A
  </span>
  is processed, and replaced by upper triangular Cholesky factor
  <span class="pre">
   U
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = U^{H}*U\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  If Cholesky factorization failed, i.e. some leading minor of
  <span class="pre">
   A
  </span>
  is not positive definite, or equivalently some diagonal elements of
  <span class="pre">
   L
  </span>
  or
  <span class="pre">
   U
  </span>
  is not a real number. The output parameter
  <span class="pre">
   infoArray
  </span>
  would indicate smallest leading minor of
  <span class="pre">
   A
  </span>
  which is not positive definite.
 </p>
 <p>
  <span class="pre">
   infoArray
  </span>
  is an integer array of size
  <span class="pre">
   batchsize
  </span>
  . If
  <span class="pre">
   potrfBatched
  </span>
  returns
  <span class="pre">
   CUSOLVER_STATUS_INVALID_VALUE
  </span>
  ,
  <span class="pre">
   infoArray[0]
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), meaning that the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle). If
  <span class="pre">
   potrfBatched
  </span>
  returns
  <span class="pre">
   CUSOLVER_STATUS_SUCCESS
  </span>
  but
  <span class="pre">
   infoArray[i]
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   k
  </span>
  is positive, then
  <span class="pre">
   i-th
  </span>
  matrix is not positive definite and the Cholesky factorization failed at row
  <span class="pre">
   k
  </span>
  .
 </p>
 <p>
  Remark: the other part of
  <span class="pre">
   A
  </span>
  is used as a workspace. For example, if
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_UPPER
  </span>
  , upper triangle of
  <span class="pre">
   A
  </span>
  contains Cholesky factor
  <span class="pre">
   U
  </span>
  and lower triangle of
  <span class="pre">
   A
  </span>
  is destroyed after
  <span class="pre">
   potrfBatched
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default" id="id32">
  <span class="caption-text">
   Table 12. API of potrfBatched
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#id32" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Indicates if lower or upper part is stored; the other part is used as a workspace.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      Aarray
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of pointers to &lt;type&gt; array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store each matrix
     <span class="pre">
      Aarray[i]
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      infoArray
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of size
     <span class="pre">
      batchSize
     </span>
     .
     <span class="pre">
      infoArray[i]
     </span>
     contains information of factorization of
     <span class="pre">
      Aarray[i]
     </span>
     . if
     <span class="pre">
      potrfBatched
     </span>
     returns
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
     ,
     <span class="pre">
      infoArray[0]
     </span>
     Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     (less than zero) means the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle). if
     <span class="pre">
      potrfBatched
     </span>
     returns
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
     ,
     <span class="pre">
      infoArray[i]
     </span>
     <span class="pre">
      =
     </span>
     Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â
     <span class="pre">
      0
     </span>
     means the Cholesky factorization of
     <span class="pre">
      i-th
     </span>
     matrix is successful, and
     <span class="pre">
      infoArray[i]
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      k
     </span>
     means the leading submatrix of order k of
     <span class="pre">
      i-th
     </span>
     matrix is not positive definite.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      batchSize
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of pointers in
     <span class="pre">
      Aarray
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n&lt;0
     </span>
     or
     <span class="pre">
      lda&lt;max(1,n)
     </span>
     or
     <span class="pre">
      batchSize&lt;1
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.2.20.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDN-lt-t-gt-batchpotrs">
   cusolverDn&lt;t&gt;potrsBatched()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-potrsbatched" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSpotrsBatched</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">Aarray</span><span class="p">[],</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">Barray</span><span class="p">[],</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDpotrsBatched</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">Aarray</span><span class="p">[],</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">Barray</span><span class="p">[],</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCpotrsBatched</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">Aarray</span><span class="p">[],</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">Barray</span><span class="p">[],</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZpotrsBatched</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">Aarray</span><span class="p">[],</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">Barray</span><span class="p">[],</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">);</span>
</pre>
 <p>
  This function solves a sequence of linear systems
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \({A\lbrack i\rbrack}*{X\lbrack i\rbrack} = {B\lbrack i\rbrack}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where each
  <span class="pre">
   Aarray[i]
  </span>
  <span class="pre">
   for
  </span>
  <span class="pre">
   i=0,1,...,
  </span>
  <span class="pre">
   batchSize-1
  </span>
  is a
  <span class="pre">
   nÃn
  </span>
  Hermitian matrix, only lower or upper part is meaningful. The input parameter
  <span class="pre">
   uplo
  </span>
  indicates which part of the matrix is used.
 </p>
 <p>
  The user has to call
  <span class="pre">
   potrfBatched
  </span>
  first to factorize matrix
  <span class="pre">
   Aarray[i]
  </span>
  . If input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_LOWER
  </span>
  ,
  <span class="pre">
   A
  </span>
  is lower triangular Cholesky factor
  <span class="pre">
   L
  </span>
  corresponding to
  <span class="math notranslate nohighlight">
   \(A = L*L^{H}\)
  </span>
  . If input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_UPPER
  </span>
  ,
  <span class="pre">
   A
  </span>
  is upper triangular Cholesky factor
  <span class="pre">
   U
  </span>
  corresponding to
  <span class="math notranslate nohighlight">
   \(A = U^{H}*U\)
  </span>
  .
 </p>
 <p>
  The operation is in-place, i.e. matrix
  <span class="pre">
   X
  </span>
  overwrites matrix
  <span class="pre">
   B
  </span>
  with the same leading dimension
  <span class="pre">
   ldb
  </span>
  .
 </p>
 <p>
  The output parameter
  <span class="pre">
   info
  </span>
  is a scalar. If
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  Remark 1: only
  <span class="pre">
   nrhs=1
  </span>
  is supported.
 </p>
 <p>
  Remark 2:
  <span class="pre">
   infoArray
  </span>
  from
  <span class="pre">
   potrfBatched
  </span>
  indicates if the matrix is positive definite.
  <span class="pre">
   info
  </span>
  from
  <span class="pre">
   potrsBatched
  </span>
  only shows which input parameter is wrong (not counting handle).
 </p>
 <p>
  Remark 3: the other part of
  <span class="pre">
   A
  </span>
  is used as a workspace. For example, if
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_UPPER
  </span>
  , upper triangle of
  <span class="pre">
   A
  </span>
  contains Cholesky factor
  <span class="pre">
   U
  </span>
  and lower triangle of
  <span class="pre">
   A
  </span>
  is destroyed after
  <span class="pre">
   potrsBatched
  </span>
  .
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/potrfBatched">
   cuSOLVER Library Samples - potrfBatched
  </a>
  for a code example.
 </p>
 <p>
  API of potrsBatched
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Indicates if matrix
     <span class="pre">
      A
     </span>
     lower or upper part is stored.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nrhs
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of matrix
     <span class="pre">
      X
     </span>
     and
     <span class="pre">
      B
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      Aarray
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of pointers to &lt;type&gt; array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
     <span class="pre">
      Aarray[i]
     </span>
     is either lower Cholesky factor
     <span class="pre">
      L
     </span>
     or upper Cholesky factor
     <span class="pre">
      U
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store each matrix
     <span class="pre">
      Aarray[i]
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      Barray
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of pointers to &lt;type&gt; array of dimension
     <span class="pre">
      ldb
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      nrhs
     </span>
     .
     <span class="pre">
      ldb
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     . As an input,
     <span class="pre">
      Barray[i]
     </span>
     is right hand side matrix. As an output,
     <span class="pre">
      Barray[i]
     </span>
     is the solution matrix.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ldb
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store each matrix
     <span class="pre">
      Barray[i]
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , all parameters are correct. if
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle).
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      batchSize
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of pointers in
     <span class="pre">
      Aarray
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n&lt;0
     </span>
     ,
     <span class="pre">
      nrhs&lt;0
     </span>
     ,
     <span class="pre">
      lda&lt;max(1,n)
     </span>
     ,
     <span class="pre">
      ldb&lt;max(1,n)
     </span>
     or
     <span class="pre">
      batchSize&lt;0
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.4.3.
  </span>
  Dense Eigenvalue Solver Reference (legacy)
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#dense-eigenvalue-solver-reference-legacy" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  This chapter describes eigenvalue solver API of cuSolverDN, including bidiagonalization and SVD.
 </p>
 <h4>
  <span class="section-number">
   2.4.3.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDN-lt-t-gt-gebrd">
   cusolverDn&lt;t&gt;gebrd()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-gebrd" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  These helper functions calculate the size of work buffers needed.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSgebrd_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">Lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDgebrd_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">Lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCgebrd_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">Lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZgebrd_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">Lwork</span><span class="p">);</span>
</pre>
 <p>
  The S and D data types are real valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSgebrd</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">D</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">E</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">TAUQ</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">TAUP</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">Work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">Lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDgebrd</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">D</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">E</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">TAUQ</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">TAUP</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">Work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">Lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  The C and Z data types are complex valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCgebrd</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">D</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">E</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">TAUQ</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">TAUP</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">Work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">Lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZgebrd</span><span class="p">(</span><span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">D</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">E</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">TAUQ</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">TAUP</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">Work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">Lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  This function reduces a general
  <span class="pre">
   mÃn
  </span>
  matrix
  <span class="pre">
   A
  </span>
  to a real upper or lower bidiagonal form
  <span class="pre">
   B
  </span>
  by an orthogonal transformation:
  <span class="math notranslate nohighlight">
   \(Q^{H}*A*P = B\)
  </span>
 </p>
 <p>
  If
  <span class="pre">
   m&gt;=n
  </span>
  ,
  <span class="pre">
   B
  </span>
  is upper bidiagonal; if
  <span class="pre">
   m&lt;n
  </span>
  ,
  <span class="pre">
   B
  </span>
  is lower bidiagonal.
 </p>
 <p>
  The matrix
  <span class="pre">
   Q
  </span>
  and
  <span class="pre">
   P
  </span>
  are overwritten into matrix
  <span class="pre">
   A
  </span>
  in the following sense:
 </p>
 <ul class="simple">
  <li>
   <p>
    if
    <span class="pre">
     m&gt;=n
    </span>
    , the diagonal and the first superdiagonal are overwritten with the upper bidiagonal matrix
    <span class="pre">
     B
    </span>
    ; the elements below the diagonal, with the array
    <span class="pre">
     TAUQ
    </span>
    , represent the orthogonal matrix
    <span class="pre">
     Q
    </span>
    as a product of elementary reflectors, and the elements above the first superdiagonal, with the array
    <span class="pre">
     TAUP
    </span>
    , represent the orthogonal matrix
    <span class="pre">
     P
    </span>
    as a product of elementary reflectors.
   </p>
  </li>
  <li>
   <p>
    if
    <span class="pre">
     m&lt;n
    </span>
    , the diagonal and the first subdiagonal are overwritten with the lower bidiagonal matrix
    <span class="pre">
     B
    </span>
    ; the elements below the first subdiagonal, with the array
    <span class="pre">
     TAUQ
    </span>
    , represent the orthogonal matrix
    <span class="pre">
     Q
    </span>
    as a product of elementary reflectors, and the elements above the diagonal, with the array
    <span class="pre">
     TAUP
    </span>
    , represent the orthogonal matrix
    <span class="pre">
     P
    </span>
    as a product of elementary reflectors.
   </p>
  </li>
 </ul>
 <p>
  The user has to provide working space which is pointed by input parameter
  <span class="pre">
   Work
  </span>
  . The input parameter
  <span class="pre">
   Lwork
  </span>
  is size of the working space, and it is returned by
  <span class="pre">
   gebrd_bufferSize()
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   devInfo
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  Remark:
  <span class="pre">
   gebrd
  </span>
  only supports
  <span class="pre">
   m&gt;=n
  </span>
  .
 </p>
 <p>
  API of gebrd
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      D
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Real array of dimension
     <span class="pre">
      min(m,n)
     </span>
     . The diagonal elements of the bidiagonal matrix
     <span class="pre">
      B
     </span>
     :
     <span class="pre">
      D(i)
     </span>
     Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â
     <span class="pre">
      =
     </span>
     <span class="pre">
      A(i,i)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      E
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Real array of dimension
     <span class="pre">
      min(m,n)
     </span>
     . The off-diagonal elements of the bidiagonal matrix
     <span class="pre">
      B
     </span>
     : if
     <span class="pre">
      m&gt;=n
     </span>
     ,
     <span class="pre">
      E(i)
     </span>
     <span class="pre">
      =
     </span>
     Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â
     <span class="pre">
      A(i,i+1)
     </span>
     for
     <span class="pre">
      i
     </span>
     <span class="pre">
      =
     </span>
     Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â
     <span class="pre">
      1,2,...,n-1
     </span>
     ; if
     <span class="pre">
      m&lt;n
     </span>
     ,
     <span class="pre">
      E(i)
     </span>
     <span class="pre">
      =
     </span>
     Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â
     <span class="pre">
      A(i+1,i)
     </span>
     for
     <span class="pre">
      i
     </span>
     <span class="pre">
      =
     </span>
     Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â
     <span class="pre">
      1,2,...,m-1
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      TAUQ
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      min(m,n)
     </span>
     . The scalar factors of the elementary reflectors which represent the orthogonal matrix
     <span class="pre">
      Q
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      TAUP
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      min(m,n)
     </span>
     . The scalar factors of the elementary reflectors which represent the orthogonal matrix
     <span class="pre">
      P
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      Work
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Working space, &lt;type&gt; array of size
     <span class="pre">
      Lwork
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      Lwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of
     <span class="pre">
      Work
     </span>
     , returned by
     <span class="pre">
      gebrd_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      devInfo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the operation is successful. if
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle).
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      m,n&lt;0
     </span>
     , or
     <span class="pre">
      lda&lt;max(1,m)
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.3.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDN-lt-t-gt-orgbr">
   cusolverDn&lt;t&gt;orgbr()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-orgbr" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  These helper functions calculate the size of work buffers needed.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSorgbr_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasSideMode_t</span><span class="n">side</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">k</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDorgbr_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasSideMode_t</span><span class="n">side</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">k</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCungbr_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasSideMode_t</span><span class="n">side</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">k</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZungbr_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasSideMode_t</span><span class="n">side</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">k</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>
</pre>
 <p>
  The S and D data types are real valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSorgbr</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasSideMode_t</span><span class="n">side</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">k</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDorgbr</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasSideMode_t</span><span class="n">side</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">k</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  The C and Z data types are complex valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCungbr</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasSideMode_t</span><span class="n">side</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">k</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZungbr</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasSideMode_t</span><span class="n">side</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">k</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  This function generates one of the unitary matrices
  <span class="pre">
   Q
  </span>
  or
  <span class="pre">
   P**H
  </span>
  determined by
  <span class="pre">
   gebrd
  </span>
  when reducing a matrix A to bidiagonal form:
  <span class="math notranslate nohighlight">
   \(Q^{H}*A*P = B\)
  </span>
 </p>
 <p>
  <span class="pre">
   Q
  </span>
  and
  <span class="pre">
   P**H
  </span>
  are defined as products of elementary reflectors H(i) or G(i) respectively.
 </p>
 <p>
  The user has to provide working space which is pointed by input parameter
  <span class="pre">
   work
  </span>
  . The input parameter
  <span class="pre">
   lwork
  </span>
  is size of the working space, and it is returned by
  <span class="pre">
   orgbr_bufferSize()
  </span>
  . Please note that the size in bytes of the working space is equal to
  <span class="pre">
   sizeof(&lt;type&gt;)
  </span>
  <span class="pre">
   *
  </span>
  <span class="pre">
   lwork
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   devInfo
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  API of orgbr
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      side
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      side
     </span>
     =
     <span class="pre">
      CUBLAS_SIDE_LEFT
     </span>
     , generate Q. if
     <span class="pre">
      side
     </span>
     =
     <span class="pre">
      CUBLAS_SIDE_RIGHT
     </span>
     , generate P**T.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows of matrix
     <span class="pre">
      Q
     </span>
     or
     <span class="pre">
      P**T
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      side
     </span>
     =
     <span class="pre">
      CUBLAS_SIDE_LEFT
     </span>
     , m&gt;= n&gt;= min(m,k). if
     <span class="pre">
      side
     </span>
     =
     <span class="pre">
      CUBLAS_SIDE_RIGHT
     </span>
     , n&gt;= m&gt;= min(n,k).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      k
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      side
     </span>
     =
     <span class="pre">
      CUBLAS_SIDE_LEFT
     </span>
     , the number of columns in the original m-by-k matrix reduced by
     <span class="pre">
      gebrd
     </span>
     . if
     <span class="pre">
      side
     </span>
     =
     <span class="pre">
      CUBLAS_SIDE_RIGHT
     </span>
     , the number of rows in the original k-by-n matrix reduced by
     <span class="pre">
      gebrd
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     On entry, the vectors which define the elementary reflectors, as returned by
     <span class="pre">
      gebrd
     </span>
     . On exit, the m-by-n matrix
     <span class="pre">
      Q
     </span>
     or
     <span class="pre">
      P**T
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     . lda &gt;= max(1,m);
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      tau
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      min(m,k)
     </span>
     if
     <span class="pre">
      side
     </span>
     is
     <span class="pre">
      CUBLAS_SIDE_LEFT
     </span>
     ; of dimension
     <span class="pre">
      min(n,k)
     </span>
     if
     <span class="pre">
      side
     </span>
     is
     <span class="pre">
      CUBLAS_SIDE_RIGHT
     </span>
     ; tau(i) must contain the scalar factor of the elementary reflector H(i) or G(i), which determines Q or P**T, as returned by
     <span class="pre">
      gebrd
     </span>
     in its array argument
     <span class="pre">
      TAUQ
     </span>
     or
     <span class="pre">
      TAUP
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      work
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Working space, &lt;type&gt; array of size
     <span class="pre">
      lwork
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of working array
     <span class="pre">
      work
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      devInfo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the ormqr is successful. if
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle).
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      m,n&lt;0
     </span>
     or wrong
     <span class="pre">
      lda
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.3.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDN-lt-t-gt-sytrd">
   cusolverDn&lt;t&gt;sytrd()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-sytrd" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  These helper functions calculate the size of work buffers needed.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSsytrd_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">e</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDsytrd_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">e</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnChetrd_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">e</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZhetrd_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">e</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>
</pre>
 <p>
  The S and D data types are real valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSsytrd</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">e</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDsytrd</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">e</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  The C and Z data types are complex valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnChetrd</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">e</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span><span class="n">CUDENSEAPI</span><span class="n">cusolverDnZhetrd</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">e</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  This function reduces a general symmetric (Hermitian)
  <span class="pre">
   nÃn
  </span>
  matrix
  <span class="pre">
   A
  </span>
  to real symmetric tridiagonal form
  <span class="pre">
   T
  </span>
  by an orthogonal transformation:
  <span class="math notranslate nohighlight">
   \(Q^{H}*A*Q = T\)
  </span>
 </p>
 <p>
  As an output,
  <span class="pre">
   A
  </span>
  contains
  <span class="pre">
   T
  </span>
  and householder reflection vectors. If
  <span class="pre">
   uplo
  </span>
  =
  <span class="pre">
   CUBLAS_FILL_MODE_UPPER
  </span>
  , the diagonal and first superdiagonal of
  <span class="pre">
   A
  </span>
  are overwritten by the corresponding elements of the tridiagonal matrix
  <span class="pre">
   T
  </span>
  , and the elements above the first superdiagonal, with the array
  <span class="pre">
   tau
  </span>
  , represent the orthogonal matrix
  <span class="pre">
   Q
  </span>
  as a product of elementary reflectors; If
  <span class="pre">
   uplo
  </span>
  =
  <span class="pre">
   CUBLAS_FILL_MODE_LOWER
  </span>
  , the diagonal and first subdiagonal of
  <span class="pre">
   A
  </span>
  are overwritten by the corresponding elements of the tridiagonal matrix
  <span class="pre">
   T
  </span>
  , and the elements below the first subdiagonal, with the array
  <span class="pre">
   tau
  </span>
  , represent the orthogonal matrix
  <span class="pre">
   Q
  </span>
  as a product of elementary reflectors.
 </p>
 <p>
  The user has to provide working space which is pointed by input parameter
  <span class="pre">
   work
  </span>
  . The input parameter
  <span class="pre">
   lwork
  </span>
  is size of the working space, and it is returned by
  <span class="pre">
   sytrd_bufferSize()
  </span>
  . Please note that the size in bytes of the working space is equal to
  <span class="pre">
   sizeof(&lt;type&gt;)
  </span>
  <span class="pre">
   *
  </span>
  <span class="pre">
   lwork
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   devInfo
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  API of sytrd
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies which part of
     <span class="pre">
      A
     </span>
     is stored.
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     : Lower triangle of
     <span class="pre">
      A
     </span>
     is stored.
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     : Upper triangle of
     <span class="pre">
      A
     </span>
     is stored.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows (columns) of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     . If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     , the leading n-by-n upper triangular part of
     <span class="pre">
      A
     </span>
     contains the upper triangular part of the matrix
     <span class="pre">
      A
     </span>
     , and the strictly lower triangular part of
     <span class="pre">
      A
     </span>
     is not referenced. If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     , the leading n-by-n lower triangular part of
     <span class="pre">
      A
     </span>
     contains the lower triangular part of the matrix
     <span class="pre">
      A
     </span>
     , and the strictly upper triangular part of
     <span class="pre">
      A
     </span>
     is not referenced. On exit,
     <span class="pre">
      A
     </span>
     is overwritten by
     <span class="pre">
      T
     </span>
     and householder reflection vectors.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
     <span class="pre">
      lda
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      D
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Real array of dimension
     <span class="pre">
      n
     </span>
     . The diagonal elements of the tridiagonal matrix
     <span class="pre">
      T
     </span>
     :
     <span class="pre">
      D(i)
     </span>
     <span class="pre">
      =
     </span>
     Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â
     <span class="pre">
      A(i,i)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      E
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Real array of dimension
     <span class="pre">
      (n-1)
     </span>
     . The off-diagonal elements of the tridiagonal matrix
     <span class="pre">
      T
     </span>
     : if
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     ,
     <span class="pre">
      E(i)
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      A(i,i+1)
     </span>
     . if
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     <span class="pre">
      E(i)
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      A(i+1,i)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      tau
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      (n-1)
     </span>
     . The scalar factors of the elementary reflectors which represent the orthogonal matrix
     <span class="pre">
      Q
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      work
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Working space, &lt;type&gt; array of size
     <span class="pre">
      lwork
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of
     <span class="pre">
      work
     </span>
     , returned by
     <span class="pre">
      sytrd_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      devInfo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the operation is successful. if
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle).
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n&lt;0
     </span>
     , or
     <span class="pre">
      lda&lt;max(1,n)
     </span>
     , or
     <span class="pre">
      uplo
     </span>
     is not
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     or
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.3.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDN-lt-t-gt-ormtr">
   cusolverDn&lt;t&gt;ormtr()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-ormtr" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  These helper functions calculate the size of work buffers needed.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSormtr_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasSideMode_t</span><span class="n">side</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="n">cublasOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">C</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldc</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDormtr_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasSideMode_t</span><span class="n">side</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="n">cublasOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">C</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldc</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCunmtr_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasSideMode_t</span><span class="n">side</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="n">cublasOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">C</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldc</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZunmtr_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasSideMode_t</span><span class="n">side</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="n">cublasOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">C</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldc</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>
</pre>
 <p>
  The S and D data types are real valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSormtr</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasSideMode_t</span><span class="n">side</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="n">cublasOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">C</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldc</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDormtr</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasSideMode_t</span><span class="n">side</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="n">cublasOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">C</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldc</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  The C and Z data types are complex valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCunmtr</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasSideMode_t</span><span class="n">side</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="n">cublasOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">C</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldc</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZunmtr</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasSideMode_t</span><span class="n">side</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="n">cublasOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">C</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldc</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  This function overwrites
  <span class="pre">
   mÃn
  </span>
  matrix
  <span class="pre">
   C
  </span>
  by
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(C = \left\{ \begin{matrix}
{\text{op}(Q)*C} &amp; {\text{if~}\textsf{side\ ==\ CUBLAS\_SIDE\_LEFT}} \\
{C*\text{op}(Q)} &amp; {\text{if~}\textsf{side\ ==\ CUBLAS\_SIDE\_RIGHT}} \\
\end{matrix} \right.\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   Q
  </span>
  is a unitary matrix formed by a sequence of elementary reflection vectors from
  <span class="pre">
   sytrd
  </span>
  .
 </p>
 <p>
  The operation on
  <span class="pre">
   Q
  </span>
  is defined by
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\text{op}(Q) = \left\{ \begin{matrix}
Q &amp; {\text{if~}\textsf{transa\ ==\ CUBLAS\_OP\_N}} \\
Q^{T} &amp; {\text{if~}\textsf{transa\ ==\ CUBLAS\_OP\_T}} \\
Q^{H} &amp; {\text{if~}\textsf{transa\ ==\ CUBLAS\_OP\_C}} \\
\end{matrix} \right.\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The user has to provide working space which is pointed by input parameter
  <span class="pre">
   work
  </span>
  . The input parameter
  <span class="pre">
   lwork
  </span>
  is size of the working space, and it is returned by
  <span class="pre">
   ormtr_bufferSize()
  </span>
  . Please note that the size in bytes of the working space is equal to
  <span class="pre">
   sizeof(&lt;type&gt;)
  </span>
  <span class="pre">
   *
  </span>
  <span class="pre">
   lwork
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   devInfo
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  API of ormtr
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      side
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      side
     </span>
     =
     <span class="pre">
      CUBLAS_SIDE_LEFT
     </span>
     , apply Q or Q**T from the Left;
     <span class="pre">
      side
     </span>
     =
     <span class="pre">
      CUBLAS_SIDE_RIGHT
     </span>
     , apply Q or Q**T from the Right.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     : Lower triangle of
     <span class="pre">
      A
     </span>
     contains elementary reflectors from
     <span class="pre">
      sytrd
     </span>
     .
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     : Upper triangle of
     <span class="pre">
      A
     </span>
     contains elementary reflectors from
     <span class="pre">
      sytrd
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      trans
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Operation
     <span class="pre">
      op(Q)
     </span>
     that is non- or (conj.) transpose.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows of matrix
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of matrix
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      m
     </span>
     if
     <span class="pre">
      side
     </span>
     =
     <span class="pre">
      CUBLAS_SIDE_LEFT
     </span>
     ;
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     if
     <span class="pre">
      side
     </span>
     =
     <span class="pre">
      CUBLAS_SIDE_RIGHT
     </span>
     . The matrix
     <span class="pre">
      A
     </span>
     from
     <span class="pre">
      sytrd
     </span>
     contains the elementary reflectors.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     . if
     <span class="pre">
      side
     </span>
     is
     <span class="pre">
      CUBLAS_SIDE_LEFT
     </span>
     , lda &gt;= max(1,m); if
     <span class="pre">
      side
     </span>
     is
     <span class="pre">
      CUBLAS_SIDE_RIGHT
     </span>
     , lda &gt;= max(1,n).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      tau
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      (m-1)
     </span>
     if
     <span class="pre">
      side
     </span>
     is
     <span class="pre">
      CUBLAS_SIDE_LEFT
     </span>
     ; of dimension
     <span class="pre">
      (n-1)
     </span>
     if
     <span class="pre">
      side
     </span>
     is
     <span class="pre">
      CUBLAS_SIDE_RIGHT
     </span>
     ; The vector
     <span class="pre">
      tau
     </span>
     is from
     <span class="pre">
      sytrd
     </span>
     , so
     <span class="pre">
      tau(i)
     </span>
     is the scalar of i-th elementary reflection vector.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      C
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of size
     <span class="pre">
      ldc
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     . On exit,
     <span class="pre">
      C
     </span>
     is overwritten by
     <span class="pre">
      op(Q)*C
     </span>
     or
     <span class="pre">
      C*op(Q)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ldc
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array of matrix
     <span class="pre">
      C
     </span>
     . ldc &gt;= max(1,m).
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      work
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Working space, &lt;type&gt; array of size
     <span class="pre">
      lwork
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of working array
     <span class="pre">
      work
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      devInfo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the ormqr is successful. if
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle).
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      m,n&lt;0
     </span>
     or wrong
     <span class="pre">
      lda
     </span>
     or
     <span class="pre">
      ldc
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.3.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDN-lt-t-gt-orgtr">
   cusolverDn&lt;t&gt;orgtr()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-orgtr" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  These helper functions calculate the size of work buffers needed.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSorgtr_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDorgtr_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCungtr_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZungtr_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>
</pre>
 <p>
  The S and D data types are real valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSorgtr</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDorgtr</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  The C and Z data types are complex valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCungtr</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZungtr</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  This function generates a unitary matrix
  <span class="pre">
   Q
  </span>
  which is defined as the product of n-1 elementary reflectors of order n, as returned by
  <span class="pre">
   sytrd
  </span>
  :
 </p>
 <p>
  The user has to provide working space which is pointed by input parameter
  <span class="pre">
   work
  </span>
  . The input parameter
  <span class="pre">
   lwork
  </span>
  is size of the working space, and it is returned by
  <span class="pre">
   orgtr_bufferSize()
  </span>
  . Please note that the size in bytes of the working space is equal to
  <span class="pre">
   sizeof(&lt;type&gt;)
  </span>
  <span class="pre">
   *
  </span>
  <span class="pre">
   lwork
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   devInfo
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  API of orgtr
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     : Lower triangle of
     <span class="pre">
      A
     </span>
     contains elementary reflectors from
     <span class="pre">
      sytrd
     </span>
     .
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     : Upper triangle of
     <span class="pre">
      A
     </span>
     contains elementary reflectors from
     <span class="pre">
      sytrd
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows (columns) of matrix
     <span class="pre">
      Q
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     On entry, matrix
     <span class="pre">
      A
     </span>
     from
     <span class="pre">
      sytrd
     </span>
     contains the elementary reflectors. On exit, matrix
     <span class="pre">
      A
     </span>
     contains the n-by-n orthogonal matrix
     <span class="pre">
      Q
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     . lda &gt;= max(1,n).
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      tau
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      (n-1)
     </span>
     <span class="pre">
      tau(i)
     </span>
     is the scalar of i-th elementary reflection vector.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      work
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Working space, &lt;type&gt; array of size
     <span class="pre">
      lwork
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of working array
     <span class="pre">
      work
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      devInfo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the orgtr is successful. if
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle).
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n&lt;0
     </span>
     or wrong
     <span class="pre">
      lda
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.3.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDN-lt-t-gt-gesvd">
   cusolverDn&lt;t&gt;gesvd()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-gesvd" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The helper functions below can calculate the sizes needed for pre-allocated buffer.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSgesvd_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDgesvd_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCgesvd_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZgesvd_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>
</pre>
 <p>
  The S and D data types are real valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSgesvd</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">signed</span><span class="kt">char</span><span class="n">jobu</span><span class="p">,</span>
<span class="kt">signed</span><span class="kt">char</span><span class="n">jobvt</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldu</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">VT</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldvt</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">rwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDgesvd</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">signed</span><span class="kt">char</span><span class="n">jobu</span><span class="p">,</span>
<span class="kt">signed</span><span class="kt">char</span><span class="n">jobvt</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldu</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">VT</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldvt</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">rwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  The C and Z data types are complex valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCgesvd</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">signed</span><span class="kt">char</span><span class="n">jobu</span><span class="p">,</span>
<span class="kt">signed</span><span class="kt">char</span><span class="n">jobvt</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldu</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">VT</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldvt</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">rwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZgesvd</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">signed</span><span class="kt">char</span><span class="n">jobu</span><span class="p">,</span>
<span class="kt">signed</span><span class="kt">char</span><span class="n">jobvt</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldu</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">VT</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldvt</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">rwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  This function computes the singular value decomposition (SVD) of a
  <span class="pre">
   mÃn
  </span>
  matrix
  <span class="pre">
   A
  </span>
  and corresponding the left and/or right singular vectors. The SVD is written
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = U*\Sigma*V^{H}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   Î£
  </span>
  is an
  <span class="pre">
   mÃn
  </span>
  matrix which is zero except for its
  <span class="pre">
   min(m,n)
  </span>
  diagonal elements,
  <span class="pre">
   U
  </span>
  is an
  <span class="pre">
   mÃm
  </span>
  unitary matrix, and
  <span class="pre">
   V
  </span>
  is an
  <span class="pre">
   nÃn
  </span>
  unitary matrix. The diagonal elements of
  <span class="pre">
   Î£
  </span>
  are the singular values of
  <span class="pre">
   A
  </span>
  ; they are real and non-negative, and are returned in descending order. The first
  <span class="pre">
   min(m,n)
  </span>
  columns of
  <span class="pre">
   U
  </span>
  and
  <span class="pre">
   V
  </span>
  are the left and right singular vectors of
  <span class="pre">
   A
  </span>
  .
 </p>
 <p>
  The user has to provide working space which is pointed by input parameter
  <span class="pre">
   work
  </span>
  . The input parameter
  <span class="pre">
   lwork
  </span>
  is size of the working space, and it is returned by
  <span class="pre">
   gesvd_bufferSize()
  </span>
  . Please note that the size in bytes of the working space is equal to
  <span class="pre">
   sizeof(&lt;type&gt;)
  </span>
  <span class="pre">
   *
  </span>
  <span class="pre">
   lwork
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   devInfo
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle). if
  <span class="pre">
   bdsqr
  </span>
  did not converge,
  <span class="pre">
   devInfo
  </span>
  specifies how many superdiagonals of an intermediate bidiagonal form did not converge to zero.
 </p>
 <p>
  The
  <span class="pre">
   rwork
  </span>
  is real array of dimension (min(m,n)-1). If
  <span class="pre">
   devInfo
  </span>
  &gt;0 and
  <span class="pre">
   rwork
  </span>
  is not NULL,
  <span class="pre">
   rwork
  </span>
  contains the unconverged superdiagonal elements of an upper bidiagonal matrix. This is slightly different from LAPACK which puts unconverged superdiagonal elements in
  <span class="pre">
   work
  </span>
  if type is
  <span class="pre">
   real
  </span>
  ; in
  <span class="pre">
   rwork
  </span>
  if type is
  <span class="pre">
   complex
  </span>
  .
  <span class="pre">
   rwork
  </span>
  can be a NULL pointer if the user does not want the information from superdiagonal.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/gesvd">
   cuSOLVER Library Samples - gesvd
  </a>
  for a code example.
 </p>
 <p>
  Remark 1:
  <span class="pre">
   gesvd
  </span>
  only supports
  <span class="pre">
   m&gt;=n
  </span>
  .
 </p>
 <p>
  Remark 2: the routine returns
  <span class="math notranslate nohighlight">
   \(V^{H}\)
  </span>
  , not
  <span class="pre">
   V
  </span>
  .
 </p>
 <p>
  API of gesvd
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      jobu
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies options for computing all or part of the matrix
     <span class="pre">
      U
     </span>
     : = âAâ: all m columns of U are returned in array U: = âSâ: the first min(m,n) columns of U (the left singular vectors) are returned in the array U; = âOâ: the first min(m,n) columns of U (the left singular vectors) are overwritten on the array A; = âNâ: no columns of U (no left singular vectors) are computed.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      jobvt
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies options for computing all or part of the matrix V**T: = âAâ: all N rows of V**T are returned in the array VT; = âSâ: the first min(m,n) rows of V**T (the right singular vectors) are returned in the array VT; = âOâ: the first min(m,n) rows of V**T (the right singular vectors) are overwritten on the array A; = âNâ: no rows of V**T (no right singular vectors) are computed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,m)
     </span>
     . On exit, the contents of
     <span class="pre">
      A
     </span>
     are destroyed.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      S
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Real array of dimension
     <span class="pre">
      min(m,n)
     </span>
     . The singular values of A, sorted so that
     <span class="pre">
      S(i)
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      S(i+1)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      U
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      ldu
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      m
     </span>
     with
     <span class="pre">
      ldu
     </span>
     is not less than
     <span class="pre">
      max(1,m)
     </span>
     .
     <span class="pre">
      U
     </span>
     contains the
     <span class="pre">
      mÃm
     </span>
     unitary matrix
     <span class="pre">
      U
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ldu
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      U
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      VT
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      ldvt
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      ldvt
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
     <span class="pre">
      VT
     </span>
     contains the
     <span class="pre">
      nÃn
     </span>
     unitary matrix V**T.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ldvt
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      Vt
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      work
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Working space, &lt;type&gt; array of size
     <span class="pre">
      lwork
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of
     <span class="pre">
      work
     </span>
     , returned by
     <span class="pre">
      gesvd_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      rwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Real array of dimension min(m,n)-1. It contains the unconverged superdiagonal elements of an upper bidiagonal matrix if
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      &gt;
     </span>
     <span class="pre">
      0
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      devInfo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the operation is successful. if
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle). If
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      &gt;
     </span>
     <span class="pre">
      0
     </span>
     ,
     <span class="pre">
      devInfo
     </span>
     indicates how many superdiagonals of an intermediate bidiagonal form did not converge to zero.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      m,n&lt;0
     </span>
     or
     <span class="pre">
      lda&lt;max(1,m)
     </span>
     or
     <span class="pre">
      ldu&lt;max(1,m)
     </span>
     or
     <span class="pre">
      ldvt&lt;max(1,n)
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.3.7.
  </span>
  cusolverDnGesvd()[DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdngesvd-deprecated" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  [[DEPRECATED]] use
  <span class="pre">
   cusolverDnXgesvd()
  </span>
  instead. The routine will be removed in the next major release.
 </p>
 <p>
  The helper functions below can calculate the sizes needed for pre-allocated buffer.
 </p>
 <pre><span class="n">cusolverStatus_t</span><span class="nf">cusolverDnGesvd_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">signed</span><span class="kt">char</span><span class="n">jobu</span><span class="p">,</span>
<span class="kt">signed</span><span class="kt">char</span><span class="n">jobvt</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeS</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeU</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ldu</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeVT</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">VT</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ldvt</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytes</span><span class="p">);</span>
</pre>
 <p>
  The routine below:
 </p>
 <pre><span class="n">cusolverStatus_t</span><span class="nf">cusolverDnGesvd</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">signed</span><span class="kt">char</span><span class="n">jobu</span><span class="p">,</span>
<span class="kt">signed</span><span class="kt">char</span><span class="n">jobvt</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeS</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeU</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ldu</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeVT</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">VT</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ldvt</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">workspaceInBytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">);</span>
</pre>
 <p>
  This function computes the singular value decomposition (SVD) of a
  <span class="pre">
   mÃn
  </span>
  matrix
  <span class="pre">
   A
  </span>
  and corresponding the left and/or right singular vectors. The SVD is written
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = U*\Sigma*V^{H}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   Î£
  </span>
  is an
  <span class="pre">
   mÃn
  </span>
  matrix which is zero except for its
  <span class="pre">
   min(m,n)
  </span>
  diagonal elements,
  <span class="pre">
   U
  </span>
  is an
  <span class="pre">
   mÃm
  </span>
  unitary matrix, and
  <span class="pre">
   V
  </span>
  is an
  <span class="pre">
   nÃn
  </span>
  unitary matrix. The diagonal elements of
  <span class="pre">
   Î£
  </span>
  are the singular values of
  <span class="pre">
   A
  </span>
  ; they are real and non-negative, and are returned in descending order. The first
  <span class="pre">
   min(m,n)
  </span>
  columns of
  <span class="pre">
   U
  </span>
  and
  <span class="pre">
   V
  </span>
  are the left and right singular vectors of
  <span class="pre">
   A
  </span>
  .
 </p>
 <p>
  The user has to provide working space which is pointed by input parameter
  <span class="pre">
   pBuffer
  </span>
  . The input parameter
  <span class="pre">
   workspaceInBytes
  </span>
  is size in bytes of the working space, and it is returned by
  <span class="pre">
   cusolverDnGesvd_bufferSize()
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle). if
  <span class="pre">
   bdsqr
  </span>
  did not converge,
  <span class="pre">
   info
  </span>
  specifies how many superdiagonals of an intermediate bidiagonal form did not converge to zero.
 </p>
 <p>
  Currently,
  <span class="pre">
   cusolverDnGesvd
  </span>
  supports only the default algorithm.
 </p>
 <p>
  Table of algorithms supported by cusolverDnGesvd
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_ALG_0
     </span>
     or
     <span class="pre">
      NULL
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Appendix G.5 provides a simple example of
  <span class="pre">
   cusolverDnGesvd
  </span>
  .
 </p>
 <p>
  Remark 1:
  <span class="pre">
   gesvd
  </span>
  only supports
  <span class="pre">
   m&gt;=n
  </span>
  .
 </p>
 <p>
  Remark 2: the routine returns
  <span class="math notranslate nohighlight">
   \(V^{H}\)
  </span>
  , not
  <span class="pre">
   V
  </span>
  .
 </p>
 <p>
  List of input arguments for
  <span class="pre">
   cusolverDnGesvd_bufferSize
  </span>
  and
  <span class="pre">
   cusolverDnGesvd
  </span>
  :
 </p>
 <p>
  API of cusolverDnGesvd
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Structure with information collected by
     <span class="pre">
      cusolverDnSetAdvOptions
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      jobu
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies options for computing all or part of the matrix
     <span class="pre">
      U
     </span>
     : = âAâ: all m columns of U are returned in array U: = âSâ: the first min(m,n) columns of U (the left singular vectors) are returned in the array U; = âOâ: the first min(m,n) columns of U (the left singular vectors) are overwritten on the array A; = âNâ: no columns of U (no left singular vectors) are computed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      jobvt
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies options for computing all or part of the matrix V**T: = âAâ: all N rows of V**T are returned in the array VT; = âSâ: the first min(m,n) rows of V**T (the right singular vectors) are returned in the array VT; = âOâ: the first min(m,n) rows of V**T (the right singular vectors) are overwritten on the array A; = âNâ: no rows of V**T (no right singular vectors) are computed.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dataTypeA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,m)
     </span>
     . On exit, the contents of
     <span class="pre">
      A
     </span>
     are destroyed.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dataTypeS
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      S
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      S
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Real array of dimension
     <span class="pre">
      min(m,n)
     </span>
     . The singular values of A, sorted so that
     <span class="pre">
      S(i)
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      S(i+1)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dataTypeU
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      U
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      U
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension
     <span class="pre">
      ldu
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      m
     </span>
     with
     <span class="pre">
      ldu
     </span>
     is not less than
     <span class="pre">
      max(1,m)
     </span>
     .
     <span class="pre">
      U
     </span>
     contains the
     <span class="pre">
      mÃm
     </span>
     unitary matrix
     <span class="pre">
      U
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ldu
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      U
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dataTypeVT
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      VT
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      VT
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension
     <span class="pre">
      ldvt
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      ldvt
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
     <span class="pre">
      VT
     </span>
     contains the
     <span class="pre">
      nÃn
     </span>
     unitary matrix V**T.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ldvt
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      Vt
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of computation.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Working space. Array of type
     <span class="pre">
      void
     </span>
     of size
     <span class="pre">
      workspaceInBytes
     </span>
     bytes.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      workspaceInBytes
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      pBuffer
     </span>
     , returned by
     <span class="pre">
      cusolverDnGesvd_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the operation is successful. if
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle). if
     <span class="pre">
      info
     </span>
     <span class="pre">
      &gt;
     </span>
     <span class="pre">
      0
     </span>
     ,
     <span class="pre">
      info
     </span>
     indicates how many superdiagonals of an intermediate bidiagonal form did not converge to zero.
    </p>
   </td>
  </tr>
 </table>
 <p>
  The generic API has three different types,
  <span class="pre">
   dataTypeA
  </span>
  is data type of the matrix
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   dataTypeS
  </span>
  is data type of the vector
  <span class="pre">
   S
  </span>
  and
  <span class="pre">
   dataTypeU
  </span>
  is data type of the matrix
  <span class="pre">
   U
  </span>
  ,
  <span class="pre">
   dataTypeVT
  </span>
  is data type of the matrix
  <span class="pre">
   VT
  </span>
  ,
  <span class="pre">
   computeType
  </span>
  is compute type of the operation.
  <span class="pre">
   cusolverDnGesvd
  </span>
  only supports the following four combinations.
 </p>
 <p>
  Valid combination of data type and compute type
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     DataTypeA
    </p>
   </th>
   <th class="head">
    <p>
     DataTypeS
    </p>
   </th>
   <th class="head">
    <p>
     DataTypeU
    </p>
   </th>
   <th class="head">
    <p>
     DataTypeVT
    </p>
   </th>
   <th class="head">
    <p>
     ComputeType
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      SGESVD
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      DGESVD
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CGESVD
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ZGESVD
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      m,n&lt;0
     </span>
     or
     <span class="pre">
      lda&lt;max(1,m)
     </span>
     or
     <span class="pre">
      ldu&lt;max(1,m)
     </span>
     or
     <span class="pre">
      ldvt&lt;max(1,n)
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.3.8.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDN-lt-t-gt-gesvdj">
   cusolverDn&lt;t&gt;gesvdj()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-gesvdj" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The helper functions below can calculate the sizes needed for pre-allocated buffer.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSgesvdj_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="kt">int</span><span class="n">econ</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldu</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">V</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldv</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">,</span>
<span class="n">gesvdjInfo_t</span><span class="n">params</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDgesvdj_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="kt">int</span><span class="n">econ</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldu</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">V</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldv</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">,</span>
<span class="n">gesvdjInfo_t</span><span class="n">params</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCgesvdj_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="kt">int</span><span class="n">econ</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldu</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">V</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldv</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">,</span>
<span class="n">gesvdjInfo_t</span><span class="n">params</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZgesvdj_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="kt">int</span><span class="n">econ</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldu</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">V</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldv</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">,</span>
<span class="n">gesvdjInfo_t</span><span class="n">params</span><span class="p">);</span>
</pre>
 <p>
  The S and D data types are real valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSgesvdj</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="kt">int</span><span class="n">econ</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldu</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">V</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldv</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="n">gesvdjInfo_t</span><span class="n">params</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDgesvdj</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="kt">int</span><span class="n">econ</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldu</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">V</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldv</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="n">gesvdjInfo_t</span><span class="n">params</span><span class="p">);</span>
</pre>
 <p>
  The C and Z data types are complex valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCgesvdj</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="kt">int</span><span class="n">econ</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldu</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">V</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldv</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="n">gesvdjInfo_t</span><span class="n">params</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZgesvdj</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="kt">int</span><span class="n">econ</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldu</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">V</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldv</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="n">gesvdjInfo_t</span><span class="n">params</span><span class="p">);</span>
</pre>
 <p>
  This function computes the singular value decomposition (SVD) of a
  <span class="pre">
   mÃn
  </span>
  matrix
  <span class="pre">
   A
  </span>
  and corresponding the left and/or right singular vectors. The SVD is written:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = U*\Sigma*V^{H}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   Î£
  </span>
  is an
  <span class="pre">
   mÃn
  </span>
  matrix which is zero except for its
  <span class="pre">
   min(m,n)
  </span>
  diagonal elements,
  <span class="pre">
   U
  </span>
  is an
  <span class="pre">
   mÃm
  </span>
  unitary matrix, and
  <span class="pre">
   V
  </span>
  is an
  <span class="pre">
   nÃn
  </span>
  unitary matrix. The diagonal elements of
  <span class="pre">
   Î£
  </span>
  are the singular values of
  <span class="pre">
   A
  </span>
  ; they are real and non-negative, and are returned in descending order. The first
  <span class="pre">
   min(m,n)
  </span>
  columns of
  <span class="pre">
   U
  </span>
  and
  <span class="pre">
   V
  </span>
  are the left and right singular vectors of
  <span class="pre">
   A
  </span>
  .
 </p>
 <p>
  <span class="pre">
   gesvdj
  </span>
  has the same functionality as
  <span class="pre">
   gesvd
  </span>
  . The difference is that
  <span class="pre">
   gesvd
  </span>
  uses QR algorithm and
  <span class="pre">
   gesvdj
  </span>
  uses Jacobi method. The parallelism of Jacobi method gives GPU better performance on small and medium size matrices. Moreover the user can configure
  <span class="pre">
   gesvdj
  </span>
  to perform approximation up to certain accuracy.
 </p>
 <p>
  <span class="pre">
   gesvdj
  </span>
  iteratively generates a sequence of unitary matrices to transform matrix
  <span class="pre">
   A
  </span>
  to the following form
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(U^{H}*A*V = S + E\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   S
  </span>
  is diagonal and diagonal of
  <span class="pre">
   E
  </span>
  is zero.
 </p>
 <p>
  During the iterations, the Frobenius norm of
  <span class="pre">
   E
  </span>
  decreases monotonically. As
  <span class="pre">
   E
  </span>
  goes down to zero,
  <span class="pre">
   S
  </span>
  is the set of singular values. In practice, Jacobi method stops if
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \({||E||}_{F}\leq\operatorname{eps}*{||A||}_{F}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   eps
  </span>
  is given tolerance.
 </p>
 <p>
  <span class="pre">
   gesvdj
  </span>
  has two parameters to control the accuracy. First parameter is tolerance (
  <span class="pre">
   eps
  </span>
  ). The default value is machine accuracy but The user can use function
  <span class="pre">
   cusolverDnXgesvdjSetTolerance
  </span>
  to set a priori tolerance. The second parameter is maximum number of sweeps which controls number of iterations of Jacobi method. The default value is 100 but the user can use function
  <span class="pre">
   cusolverDnXgesvdjSetMaxSweeps
  </span>
  to set a proper bound. The experiments show 15 sweeps are good enough to converge to machine accuracy.
  <span class="pre">
   gesvdj
  </span>
  stops either tolerance is met or maximum number of sweeps is met.
 </p>
 <p>
  Jacobi method has quadratic convergence, so the accuracy is not proportional to number of sweeps. To guarantee certain accuracy, the user should configure tolerance only.
 </p>
 <p>
  The user has to provide working space which is pointed by input parameter
  <span class="pre">
   work
  </span>
  . The input parameter
  <span class="pre">
   lwork
  </span>
  is the size of the working space, and it is returned by
  <span class="pre">
   gesvdj_bufferSize()
  </span>
  . Please note that the size in bytes of the working space is equal to
  <span class="pre">
   sizeof(&lt;type&gt;)
  </span>
  <span class="pre">
   *
  </span>
  <span class="pre">
   lwork
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle). If
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   min(m,n)+1
  </span>
  ,
  <span class="pre">
   gesvdj
  </span>
  does not converge under given tolerance and maximum sweeps.
 </p>
 <p>
  If the user sets an improper tolerance,
  <span class="pre">
   gesvdj
  </span>
  may not converge. For example, tolerance should not be smaller than machine accuracy.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/gesvdj">
   cuSOLVER Library Samples - gesvdj
  </a>
  for a code example.
 </p>
 <p>
  Remark 1:
  <span class="pre">
   gesvdj
  </span>
  supports any combination of
  <span class="pre">
   m
  </span>
  and
  <span class="pre">
   n
  </span>
  .
 </p>
 <p>
  Remark 2: the routine returns
  <span class="pre">
   V
  </span>
  , not
  <span class="math notranslate nohighlight">
   \(V^{H}\)
  </span>
  . This is different from
  <span class="pre">
   gesvd
  </span>
  .
 </p>
 <p>
  API of gesvdj
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      jobz
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies options to either compute singular value only or singular vectors as well:
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     : Compute singular values only;
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     : Compute singular values and singular vectors.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      econ
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      econ
     </span>
     = 1 for economy size for
     <span class="pre">
      U
     </span>
     and
     <span class="pre">
      V
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,m)
     </span>
     . On exit, the contents of
     <span class="pre">
      A
     </span>
     are destroyed.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      S
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Real array of dimension
     <span class="pre">
      min(m,n)
     </span>
     . The singular values of A, sorted so that
     <span class="pre">
      S(i)
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      S(i+1)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      U
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      ldu
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      m
     </span>
     if
     <span class="pre">
      econ
     </span>
     is zero. If
     <span class="pre">
      econ
     </span>
     is nonzero, the dimension is
     <span class="pre">
      ldu
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      min(m,n)
     </span>
     .
     <span class="pre">
      U
     </span>
     contains the left singular vectors.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ldu
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      U
     </span>
     .
     <span class="pre">
      ldu
     </span>
     is not less than
     <span class="pre">
      max(1,m)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      V
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      ldv
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     if
     <span class="pre">
      econ
     </span>
     is zero. If
     <span class="pre">
      econ
     </span>
     is nonzero, the dimension is
     <span class="pre">
      ldv
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      min(m,n)
     </span>
     .
     <span class="pre">
      V
     </span>
     contains the right singular vectors.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ldv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      V
     </span>
     .
     <span class="pre">
      ldv
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      work
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of size
     <span class="pre">
      lwork
     </span>
     , working space.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of
     <span class="pre">
      work
     </span>
     , returned by
     <span class="pre">
      gesvdj_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the operation is successful. if
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle). if
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     Â
     <span class="pre">
      min(m,n)+1
     </span>
     ,
     <span class="pre">
      gesvdj
     </span>
     dose not converge under given tolerance and maximum sweeps.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Structure filled with parameters of Jacobi algorithm and results of
     <span class="pre">
      gesvdj
     </span>
     .
     <span class="pre">
      params
     </span>
     can be destroyed after the host thread exits the routine.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      m,n&lt;0
     </span>
     or
     <span class="pre">
      lda&lt;max(1,m)
     </span>
     or
     <span class="pre">
      ldu&lt;max(1,m)
     </span>
     or
     <span class="pre">
      ldv&lt;max(1,n)
     </span>
     or
     <span class="pre">
      jobz
     </span>
     is not
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     or
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.3.9.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDN-lt-t-gt-gesvdjbatch">
   cusolverDn&lt;t&gt;gesvdjBatched()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-gesvdjbatched" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The helper functions below can calculate the sizes needed for pre-allocated buffer.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSgesvdjBatched_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldu</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">V</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldv</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">,</span>
<span class="n">gesvdjInfo_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDgesvdjBatched_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldu</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">V</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldv</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">,</span>
<span class="n">gesvdjInfo_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCgesvdjBatched_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldu</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">V</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldv</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">,</span>
<span class="n">gesvdjInfo_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZgesvdjBatched_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldu</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">V</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldv</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">,</span>
<span class="n">gesvdjInfo_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">);</span>
</pre>
 <p>
  The S and D data types are real valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSgesvdjBatched</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldu</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">V</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldv</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="n">gesvdjInfo_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDgesvdjBatched</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldu</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">V</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldv</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="n">gesvdjInfo_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">);</span>
</pre>
 <p>
  The C and Z data types are complex valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCgesvdjBatched</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldu</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">V</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldv</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="n">gesvdjInfo_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZgesvdjBatched</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldu</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">V</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldv</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="n">gesvdjInfo_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">);</span>
</pre>
 <p>
  This function computes singular values and singular vectors of a sequence of general
  <span class="pre">
   mÃn
  </span>
  matrices
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A_{j} = U_{j}*\Sigma_{j}*V_{j}^{H}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="math notranslate nohighlight">
   \(\Sigma_{j}\)
  </span>
  is a real
  <span class="pre">
   mÃn
  </span>
  diagonal matrix which is zero except for its
  <span class="pre">
   min(m,n)
  </span>
  diagonal elements.
  <span class="math notranslate nohighlight">
   \(U_{j}\)
  </span>
  (left singular vectors) is a
  <span class="pre">
   mÃm
  </span>
  unitary matrix and
  <span class="math notranslate nohighlight">
   \(V_{j}\)
  </span>
  (right singular vectors) is a
  <span class="pre">
   nÃn
  </span>
  unitary matrix. The diagonal elements of
  <span class="math notranslate nohighlight">
   \(\Sigma_{j}\)
  </span>
  are the singular values of
  <span class="math notranslate nohighlight">
   \(A_{j}\)
  </span>
  in either descending order or non-sorting order.
 </p>
 <p>
  <span class="pre">
   gesvdjBatched
  </span>
  performs
  <span class="pre">
   gesvdj
  </span>
  on each matrix. It requires that all matrices are of the same size
  <span class="pre">
   m,n
  </span>
  no greater than 32 and are packed in contiguous way,
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = \begin{pmatrix}
{A0} &amp; {A1} &amp; \cdots \\
\end{pmatrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Each matrix is column-major with leading dimension
  <span class="pre">
   lda
  </span>
  , so the formula for random access is
  <span class="math notranslate nohighlight">
   \(A_{k}\operatorname{(i,j)} = {A\lbrack\ i\ +\ lda*j\ +\ lda*n*k\rbrack}\)
  </span>
  .
 </p>
 <p>
  The parameter
  <span class="pre">
   S
  </span>
  also contains singular values of each matrix in contiguous way,
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(S = \begin{pmatrix}
{S0} &amp; {S1} &amp; \cdots \\
\end{pmatrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The formula for random access of
  <span class="pre">
   S
  </span>
  is
  <span class="math notranslate nohighlight">
   \(S_{k}\operatorname{(j)} = {S\lbrack\ j\ +\ min(m,n)*k\rbrack}\)
  </span>
  .
 </p>
 <p>
  Except for tolerance and maximum sweeps,
  <span class="pre">
   gesvdjBatched
  </span>
  can either sort the singular values in descending order (default) or chose as-is (without sorting) by the function
  <span class="pre">
   cusolverDnXgesvdjSetSortEig
  </span>
  . If the user packs several tiny matrices into diagonal blocks of one matrix, non-sorting option can separate singular values of those tiny matrices.
 </p>
 <p>
  <span class="pre">
   gesvdjBatched
  </span>
  cannot report residual and executed sweeps by function
  <span class="pre">
   cusolverDnXgesvdjGetResidual
  </span>
  and
  <span class="pre">
   cusolverDnXgesvdjGetSweeps
  </span>
  . Any call of the above two returns
  <span class="pre">
   CUSOLVER_STATUS_NOT_SUPPORTED
  </span>
  . The user needs to compute residual explicitly.
 </p>
 <p>
  The user has to provide working space pointed by input parameter
  <span class="pre">
   work
  </span>
  . The input parameter
  <span class="pre">
   lwork
  </span>
  is the size of the working space, and it is returned by
  <span class="pre">
   gesvdjBatched_bufferSize()
  </span>
  . Please note that the size in bytes of the working space is equal to
  <span class="pre">
   sizeof(&lt;type&gt;)
  </span>
  <span class="pre">
   *
  </span>
  <span class="pre">
   lwork
  </span>
  .
 </p>
 <p>
  The output parameter
  <span class="pre">
   info
  </span>
  is an integer array of size
  <span class="pre">
   batchSize
  </span>
  . If the function returns
  <span class="pre">
   CUSOLVER_STATUS_INVALID_VALUE
  </span>
  , the first element
  <span class="pre">
   info[0]
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero) indicates
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle). Otherwise, if
  <span class="pre">
   info[i]
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   min(m,n)+1
  </span>
  ,
  <span class="pre">
   gesvdjBatched
  </span>
  does not converge on
  <span class="pre">
   i-th
  </span>
  matrix under given tolerance and maximum sweeps.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/gesvdjBatched">
   cuSOLVER Library Samples - gesvdjBatched
  </a>
  for a code example.
 </p>
 <p>
  API of gesvdjBatched
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      jobz
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies options to either compute singular value only or singular vectors as well:
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     : Compute singular values only;
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     : Compute singular values and singular vectors.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows of matrix
     <span class="pre">
      Aj
     </span>
     .
     <span class="pre">
      m
     </span>
     is no greater than 32.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of matrix
     <span class="pre">
      Aj
     </span>
     .
     <span class="pre">
      n
     </span>
     is no greater than 32.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      batchSize
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     . on Exit: the contents of
     <span class="pre">
      Aj
     </span>
     are destroyed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Lading dimension of two-dimensional array used to store matrix
     <span class="pre">
      Aj
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      S
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Areal array of dimension
     <span class="pre">
      min(m,n)*batchSize
     </span>
     . It stores the singular values of
     <span class="pre">
      Aj
     </span>
     in descending order or non-sorting order.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      U
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      ldu
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      m
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      batchSize
     </span>
     .
     <span class="pre">
      Uj
     </span>
     contains the left singular vectors of
     <span class="pre">
      Aj
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ldu
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      Uj
     </span>
     .
     <span class="pre">
      ldu
     </span>
     is not less than
     <span class="pre">
      max(1,m)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      V
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      ldv
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      batchSize
     </span>
     .
     <span class="pre">
      Vj
     </span>
     contains the right singular vectors of
     <span class="pre">
      Aj
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ldv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      Vj
     </span>
     .
     <span class="pre">
      ldv
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      work
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of size
     <span class="pre">
      lwork
     </span>
     , working space.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of
     <span class="pre">
      work
     </span>
     , returned by
     <span class="pre">
      gesvdjBatched_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     An integer array of dimension
     <span class="pre">
      batchSize
     </span>
     . If
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
     is returned,
     <span class="pre">
      info[0]
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     (less than zero) indicates
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle). Otherwise, if
     <span class="pre">
      info[i]
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the operation is successful. if
     <span class="pre">
      info[i]
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      min(m,n)+1
     </span>
     ,
     <span class="pre">
      gesvdjBatched
     </span>
     dose not converge on
     <span class="pre">
      i-th
     </span>
     matrix under given tolerance and maximum sweeps.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Structure filled with parameters of Jacobi algorithm.
     <span class="pre">
      params
     </span>
     can be destroyed after the host thread exits the routine.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      batchSize
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of matrices.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      m,n&lt;0
     </span>
     or
     <span class="pre">
      lda&lt;max(1,m)
     </span>
     or
     <span class="pre">
      ldu&lt;max(1,m)
     </span>
     or
     <span class="pre">
      ldv&lt;max(1,n)
     </span>
     or
     <span class="pre">
      jobz
     </span>
     is not
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     or
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     , or
     <span class="pre">
      batchSize&lt;0
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.3.10.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDN-lt-t-gt-gesvda">
   cusolverDn&lt;t&gt;gesvdaStridedBatched()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-gesvdastridedbatched" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The helper functions below can calculate the sizes needed for pre-allocated buffer.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSgesvdaStridedBatched_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rank</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideS</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldu</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideU</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">V</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldv</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideV</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDgesvdaStridedBatched_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rank</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideS</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldu</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideU</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">V</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldv</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideV</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCgesvdaStridedBatched_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rank</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideS</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldu</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideU</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">V</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldv</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideV</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZgesvdaStridedBatched_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rank</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideS</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldu</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideU</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">V</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldv</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideV</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">);</span>
</pre>
 <p>
  The S and D data types are real valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSgesvdaStridedBatched</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rank</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideA</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideS</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldu</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideU</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">V</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldv</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideV</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">h_R_nrmF</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDgesvdaStridedBatched</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rank</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideA</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideS</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldu</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideU</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">V</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldv</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideV</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">h_R_nrmF</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">);</span>
</pre>
 <p>
  The C and Z data types are complex valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCgesvdaStridedBatched</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rank</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideA</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideS</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldu</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideU</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">V</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldv</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideV</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">h_R_nrmF</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZgesvdaStridedBatched</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rank</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideA</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideS</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldu</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideU</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">V</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldv</span><span class="p">,</span>
<span class="kt">long</span><span class="kt">long</span><span class="kt">int</span><span class="n">strideV</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">h_R_nrmF</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">);</span>
</pre>
 <p>
  This function
  <span class="pre">
   gesvda
  </span>
  (
  <span class="pre">
   a
  </span>
  stands for approximate) approximates the singular value decomposition of a tall skinny
  <span class="pre">
   mÃn
  </span>
  matrix
  <span class="pre">
   A
  </span>
  and corresponding the left and right singular vectors. The economy form of SVD is written by
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = U*\Sigma*V^{H}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   Î£
  </span>
  is an
  <span class="pre">
   nÃn
  </span>
  matrix.
  <span class="pre">
   U
  </span>
  is an
  <span class="pre">
   mÃn
  </span>
  unitary matrix, and
  <span class="pre">
   V
  </span>
  is an
  <span class="pre">
   nÃn
  </span>
  unitary matrix. The diagonal elements of
  <span class="pre">
   Î£
  </span>
  are the singular values of
  <span class="pre">
   A
  </span>
  ; they are real and non-negative, and are returned in descending order.
  <span class="pre">
   U
  </span>
  and
  <span class="pre">
   V
  </span>
  are the left and right singular vectors of
  <span class="pre">
   A
  </span>
  .
 </p>
 <p>
  <span class="pre">
   gesvda
  </span>
  computes eigenvalues of
  <span class="pre">
   A**T*A
  </span>
  , or
  <span class="pre">
   A**H*A
  </span>
  (if
  <span class="pre">
   A
  </span>
  is complex), to approximate singular values and singular vectors. It generates matrices
  <span class="pre">
   U
  </span>
  and
  <span class="pre">
   V
  </span>
  and transforms the matrix
  <span class="pre">
   A
  </span>
  to the following form
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(U^{H}*A*V = S + E\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   S
  </span>
  is diagonal and
  <span class="pre">
   E
  </span>
  depends on rounding errors. To certain conditions,
  <span class="pre">
   U
  </span>
  ,
  <span class="pre">
   V
  </span>
  and
  <span class="pre">
   S
  </span>
  approximate singular values and singular vectors up to machine zero of single precision. In general,
  <span class="pre">
   V
  </span>
  is unitary,
  <span class="pre">
   S
  </span>
  is more accurate than
  <span class="pre">
   U
  </span>
  . If singular value is far from zero, then left singular vector
  <span class="pre">
   U
  </span>
  is accurate. In other words, the accuracy of singular values and left singular vectors depend on the distance between singular value and zero.
 </p>
 <p>
  The input parameter
  <span class="pre">
   rank
  </span>
  decides the number of singular values and singular vectors are computed in parameter
  <span class="pre">
   S
  </span>
  ,
  <span class="pre">
   U
  </span>
  and
  <span class="pre">
   V
  </span>
  .
 </p>
 <p>
  The output parameter
  <span class="pre">
   h_RnrmF
  </span>
  computes Frobenius norm of residual.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A - U*S*V^{H}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  if the parameter
  <span class="pre">
   rank
  </span>
  is equal
  <span class="pre">
   n
  </span>
  . Otherwise,
  <span class="pre">
   h_RnrmF
  </span>
  reports
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \({||}U*S*V^{H}{||} - {||S||}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  in Frobenius norm sense, that is, how far
  <span class="pre">
   U
  </span>
  is from unitary.
 </p>
 <p>
  <span class="pre">
   gesvdaStridedBatched
  </span>
  performs
  <span class="pre">
   gesvda
  </span>
  on each matrix. It requires that all matrices are of the same size
  <span class="pre">
   m,n
  </span>
  and are packed in a contiguous way,
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = \begin{pmatrix}
{A0} &amp; {A1} &amp; \cdots \\
\end{pmatrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Each matrix is column-major with leading dimension
  <span class="pre">
   lda
  </span>
  , so the formula for random access is
  <span class="math notranslate nohighlight">
   \(A_{k}\operatorname{(i,j)} = {A\lbrack\ i\ +\ lda*j\ +\ strideA*k\rbrack}\)
  </span>
  . Similarly, the formula for random access of
  <span class="pre">
   S
  </span>
  is
  <span class="math notranslate nohighlight">
   \(S_{k}\operatorname{(j)} = {S\lbrack\ j\ +\ StrideS*k\rbrack}\)
  </span>
  , the formula for random access of
  <span class="pre">
   U
  </span>
  is
  <span class="math notranslate nohighlight">
   \(U_{k}\operatorname{(i,j)} = {U\lbrack\ i\ +\ ldu*j\ +\ strideU*k\rbrack}\)
  </span>
  and the formula for random access of
  <span class="pre">
   V
  </span>
  is
  <span class="math notranslate nohighlight">
   \(V_{k}\operatorname{(i,j)} = {V\lbrack\ i\ +\ ldv*j\ +\ strideV*k\rbrack}\)
  </span>
  .
 </p>
 <p>
  The user has to provide working space which is pointed by input parameter
  <span class="pre">
   work
  </span>
  . The input parameter
  <span class="pre">
   lwork
  </span>
  is the size of the working space, and it is returned by
  <span class="pre">
   gesvdaStridedBatched_bufferSize()
  </span>
  . Please note that the size in bytes of the working space is equal to
  <span class="pre">
   sizeof(&lt;type&gt;)
  </span>
  <span class="pre">
   *
  </span>
  <span class="pre">
   lwork
  </span>
  .
 </p>
 <p>
  The output parameter
  <span class="pre">
   info
  </span>
  is an integer array of size
  <span class="pre">
   batchSize
  </span>
  . If the function returns
  <span class="pre">
   CUSOLVER_STATUS_INVALID_VALUE
  </span>
  , the first element
  <span class="pre">
   info[0]
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero) indicates
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle). Otherwise, if
  <span class="pre">
   info[i]
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   min(m,n)+1
  </span>
  ,
  <span class="pre">
   gesvdaStridedBatched
  </span>
  does not converge on
  <span class="pre">
   i-th
  </span>
  matrix under given tolerance.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/gesvdaStridedBatched">
   cuSOLVER Library Samples - gesvdaStridedBatched
  </a>
  for a code example.
 </p>
 <p>
  Remark 1: the routine returns
  <span class="pre">
   V
  </span>
  , not
  <span class="math notranslate nohighlight">
   \(V^{H}\)
  </span>
  . This is different from
  <span class="pre">
   gesvd
  </span>
  .
 </p>
 <p>
  Remark 2: if the user is confident on the accuracy of singular values and singular vectors, for example, certain conditions hold (required singular value is far from zero), then the performance can be improved by passing a null pointer to
  <span class="pre">
   h_RnrmF
  </span>
  , i.e. no computation of residual norm.
 </p>
 <p>
  API of gesvda
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      jobz
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies options to either compute singular value only or singular vectors as well:
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     : Compute singular values only;
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     : Compute singular values and singular vectors.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      rank
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of singular values (from largest to smallest).
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows of matrix
     <span class="pre">
      Aj
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of matrix
     <span class="pre">
      Aj
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      strideA
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      batchSize
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,m)
     </span>
     .
     <span class="pre">
      Aj
     </span>
     is of dimension
     <span class="pre">
      m
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      Aj
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      strideA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Value of type long long int that gives the address offset between
     <span class="pre">
      A[i]
     </span>
     and
     <span class="pre">
      A[i+1]
     </span>
     .
     <span class="pre">
      strideA
     </span>
     is not less than
     <span class="pre">
      lda*n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      S
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     A real array of dimension
     <span class="pre">
      strideS*batchSize
     </span>
     . It stores the singular values of
     <span class="pre">
      Aj
     </span>
     in descending order.
     <span class="pre">
      Sj
     </span>
     is of dimension
     <span class="pre">
      rank
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      1
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      strideS
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Value of type long long int that gives the address offset between
     <span class="pre">
      S[i]
     </span>
     and
     <span class="pre">
      S[i+1]
     </span>
     .
     <span class="pre">
      strideS
     </span>
     is not less than
     <span class="pre">
      rank
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      U
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      strideU
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      batchSize
     </span>
     .
     <span class="pre">
      Uj
     </span>
     contains the left singular vectors of
     <span class="pre">
      Aj
     </span>
     .
     <span class="pre">
      Uj
     </span>
     is of dimension
     <span class="pre">
      m
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      rank
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ldu
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      Uj
     </span>
     .
     <span class="pre">
      ldu
     </span>
     is not less than
     <span class="pre">
      max(1,m)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      strideU
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Value of type long long int that gives the address offset between
     <span class="pre">
      U[i]
     </span>
     and
     <span class="pre">
      U[i+1]
     </span>
     .
     <span class="pre">
      strideU
     </span>
     is not less than
     <span class="pre">
      ldu*rank
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      V
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      strideV
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      batchSize
     </span>
     .
     <span class="pre">
      Vj
     </span>
     contains the right singular vectors of
     <span class="pre">
      Aj
     </span>
     .
     <span class="pre">
      Vj
     </span>
     is of dimension
     <span class="pre">
      n
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      rank
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ldv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      Vj
     </span>
     .
     <span class="pre">
      ldv
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      strideV
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Value of type long long int that gives the address offset between
     <span class="pre">
      V[i]
     </span>
     and
     <span class="pre">
      V[i+1]
     </span>
     .
     <span class="pre">
      strideV
     </span>
     is not less than
     <span class="pre">
      ldv*rank
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      work
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of size
     <span class="pre">
      lwork
     </span>
     , working space.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of
     <span class="pre">
      work
     </span>
     , returned by
     <span class="pre">
      gesvdaStridedBatched_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     An integer array of dimension
     <span class="pre">
      batchSize
     </span>
     . If
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
     is returned,
     <span class="pre">
      info[0]
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     (less than zero) indicates
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle). Otherwise, if
     <span class="pre">
      info[i]
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the operation is successful. if
     <span class="pre">
      info[i]
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      min(m,n)+1
     </span>
     ,
     <span class="pre">
      gesvdaStridedBatched
     </span>
     dose not converge on
     <span class="pre">
      i-th
     </span>
     matrix.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      h_RnrmF
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;double&gt; array of size
     <span class="pre">
      batchSize
     </span>
     .
     <span class="pre">
      h_RnrmF[i]
     </span>
     is norm of residual of
     <span class="pre">
      i-th
     </span>
     matrix.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      batchSize
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of matrices.
     <span class="pre">
      batchSize
     </span>
     is not less than 1.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      m,n&lt;0
     </span>
     or
     <span class="pre">
      lda&lt;max(1,m)
     </span>
     or
     <span class="pre">
      ldu&lt;max(1,m)
     </span>
     or
     <span class="pre">
      ldv&lt;max(1,n)
     </span>
     or
     <span class="pre">
      strideA&lt;lda*n
     </span>
     or
     <span class="pre">
      strideS&lt;rank
     </span>
     or
     <span class="pre">
      strideU&lt;ldu*rank
     </span>
     or
     <span class="pre">
      strideV&lt;ldv*rank
     </span>
     or
     <span class="pre">
      batchSize&lt;1
     </span>
     or
     <span class="pre">
      jobz
     </span>
     is not
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     or
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.3.11.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDN-lt-t-gt-syevd">
   cusolverDn&lt;t&gt;syevd()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-syevd" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The helper functions below can calculate the sizes needed for pre-allocated buffer.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSsyevd_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDsyevd_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCheevd_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZheevd_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>
</pre>
 <p>
  The S and D data types are real valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSsyevd</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDsyevd</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  The C and Z data types are complex valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCheevd</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZheevd</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  This function computes eigenvalues and eigenvectors of a symmetric (Hermitian)
  <span class="pre">
   nÃn
  </span>
  matrix
  <span class="pre">
   A
  </span>
  . The standard symmetric eigenvalue problem is
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A*V = V*\Lambda\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   Î
  </span>
  is a real
  <span class="pre">
   nÃn
  </span>
  diagonal matrix.
  <span class="pre">
   V
  </span>
  is an
  <span class="pre">
   nÃn
  </span>
  unitary matrix. The diagonal elements of
  <span class="pre">
   Î
  </span>
  are the eigenvalues of
  <span class="pre">
   A
  </span>
  in ascending order.
 </p>
 <p>
  The user has to provide working space which is pointed by input parameter
  <span class="pre">
   work
  </span>
  . The input parameter
  <span class="pre">
   lwork
  </span>
  is size of the working space, and it is returned by
  <span class="pre">
   syevd_bufferSize()
  </span>
  . Please note that the size in bytes of the working space is equal to
  <span class="pre">
   sizeof(&lt;type&gt;)
  </span>
  <span class="pre">
   *
  </span>
  <span class="pre">
   lwork
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   devInfo
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle). If
  <span class="pre">
   devInfo
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   i
  </span>
  (greater than zero),
  <span class="pre">
   i
  </span>
  off-diagonal elements of an intermediate tridiagonal form did not converge to zero.
 </p>
 <p>
  If
  <span class="pre">
   jobz
  </span>
  = CUSOLVER_EIG_MODE_VECTOR,
  <span class="pre">
   A
  </span>
  contains the orthonormal eigenvectors of the matrix
  <span class="pre">
   A
  </span>
  . The eigenvectors are computed by a divide and conquer algorithm.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/syevd">
   cuSOLVER Library Samples - syevd
  </a>
  for a code example.
 </p>
 <p>
  API of syevd
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      jobz
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies options to either compute eigenvalue only or compute eigen-pair:
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     : Compute eigenvalues only;
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     : Compute eigenvalues and eigenvectors.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies which part of
     <span class="pre">
      A
     </span>
     is stored.
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     : Lower triangle of
     <span class="pre">
      A
     </span>
     is stored.
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     : Upper triangle of
     <span class="pre">
      A
     </span>
     is stored.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows (or columns) of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     . If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     , the leading n-by-n upper triangular part of
     <span class="pre">
      A
     </span>
     contains the upper triangular part of the matrix
     <span class="pre">
      A
     </span>
     . If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     , the leading n-by-n lower triangular part of
     <span class="pre">
      A
     </span>
     contains the lower triangular part of the matrix
     <span class="pre">
      A
     </span>
     . On exit, if
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     , and
     <span class="pre">
      devInfo
     </span>
     = 0,
     <span class="pre">
      A
     </span>
     contains the orthonormal eigenvectors of the matrix
     <span class="pre">
      A
     </span>
     . If
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     , the contents of
     <span class="pre">
      A
     </span>
     are destroyed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      W
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     A real array of dimension
     <span class="pre">
      n
     </span>
     . The eigenvalue values of
     <span class="pre">
      A
     </span>
     , in ascending order ie, sorted so that
     <span class="pre">
      W(i)
     </span>
     <span class="pre">
      &lt;=
     </span>
     <span class="pre">
      W(i+1)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      work
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Working space, &lt;type&gt; array of size
     <span class="pre">
      lwork
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      Lwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of
     <span class="pre">
      work
     </span>
     , returned by
     <span class="pre">
      syevd_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      devInfo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the operation is successful. If
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle). If
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      i
     </span>
     <span class="pre">
      (&gt;
     </span>
     <span class="pre">
      0)
     </span>
     ,
     <span class="pre">
      devInfo
     </span>
     indicates
     <span class="pre">
      i
     </span>
     off-diagonal elements of an intermediate tridiagonal form did not converge to zero;
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n&lt;0
     </span>
     , or
     <span class="pre">
      lda&lt;max(1,n)
     </span>
     , or
     <span class="pre">
      jobz
     </span>
     is not
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     or
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     , or
     <span class="pre">
      uplo
     </span>
     is not
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     or
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.3.12.
  </span>
  cusolverDnSyevd()[DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnsyevd-deprecated" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  [[DEPRECATED]] use
  <span class="pre">
   cusolverDnXsyevd()
  </span>
  instead. The routine will be removed in the next major release.
 </p>
 <p>
  The helper functions below can calculate the sizes needed for pre-allocated buffer.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSyevd_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeW</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytes</span><span class="p">);</span>
</pre>
 <p>
  The routine below
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSyevd</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeW</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">workspaceInBytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">);</span>
</pre>
 <p>
  computes eigenvalues and eigenvectors of a symmetric (Hermitian)
  <span class="pre">
   nÃn
  </span>
  matrix
  <span class="pre">
   A
  </span>
  using the generic API interface. The standard symmetric eigenvalue problem is
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A*V = V*\Lambda\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   Î
  </span>
  is a real
  <span class="pre">
   nÃn
  </span>
  diagonal matrix.
  <span class="pre">
   V
  </span>
  is an
  <span class="pre">
   nÃn
  </span>
  unitary matrix. The diagonal elements of
  <span class="pre">
   Î
  </span>
  are the eigenvalues of
  <span class="pre">
   A
  </span>
  in ascending order.
 </p>
 <p>
  The user has to provide working space which is pointed by input parameter
  <span class="pre">
   pBuffer
  </span>
  . The input parameter
  <span class="pre">
   workspaceInBytes
  </span>
  is size in bytes of the working space, and it is returned by
  <span class="pre">
   cusolverDnSyevd_bufferSize()
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle). If
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   i
  </span>
  (greater than zero),
  <span class="pre">
   i
  </span>
  off-diagonal elements of an intermediate tridiagonal form did not converge to zero.
 </p>
 <p>
  if
  <span class="pre">
   jobz
  </span>
  = CUSOLVER_EIG_MODE_VECTOR,
  <span class="pre">
   A
  </span>
  contains the orthonormal eigenvectors of the matrix
  <span class="pre">
   A
  </span>
  . The eigenvectors are computed by a divide and conquer algorithm.
 </p>
 <p>
  Currently,
  <span class="pre">
   cusolverDnSyevd
  </span>
  supports only the default algorithm.
 </p>
 <p>
  Table of algorithms supported by cusolverDnSyevd
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_ALG_0
     </span>
     or
     <span class="pre">
      NULL
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm.
    </p>
   </td>
  </tr>
 </table>
 <p>
  List of input arguments for
  <span class="pre">
   cusolverDnSyevd_bufferSize
  </span>
  and
  <span class="pre">
   cusolverDnSyevd
  </span>
  :
 </p>
 <p>
  API of cusolverDnSyevd
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      parameter
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      Memory
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      In/out
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      Meaning
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Structure with information collected by
     <span class="pre">
      cusolverDnSetAdvOptions
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      jobz
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies options to either compute eigenvalue only or compute eigen-pair:
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     : Compute eigenvalues only;
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     : Compute eigenvalues and eigenvectors.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies which part of
     <span class="pre">
      A
     </span>
     is stored.
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     : Lower triangle of
     <span class="pre">
      A
     </span>
     is stored.
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     : Upper triangle of
     <span class="pre">
      A
     </span>
     is stored.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows (or columns) of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dataTypeA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     . If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     , the leading n-by-n upper triangular part of
     <span class="pre">
      A
     </span>
     contains the upper triangular part of the matrix
     <span class="pre">
      A
     </span>
     . If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     , the leading n-by-n lower triangular part of
     <span class="pre">
      A
     </span>
     contains the lower triangular part of the matrix
     <span class="pre">
      A
     </span>
     . On exit, if
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     , and
     <span class="pre">
      info
     </span>
     = 0,
     <span class="pre">
      A
     </span>
     contains the orthonormal eigenvectors of the matrix
     <span class="pre">
      A
     </span>
     . If
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     , the contents of
     <span class="pre">
      A
     </span>
     are destroyed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dataTypeW
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      W
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      W
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     A real array of dimension
     <span class="pre">
      n
     </span>
     . The eigenvalue values of
     <span class="pre">
      A
     </span>
     , in ascending order ie, sorted so that
     <span class="pre">
      W(i)
     </span>
     <span class="pre">
      &lt;=
     </span>
     Â
     <span class="pre">
      W(i+1)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of computation.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Working space. Array of type
     <span class="pre">
      void
     </span>
     of size
     <span class="pre">
      workspaceInBytes
     </span>
     bytes.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      workspaceInBytes
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      pBuffer
     </span>
     , returned by
     <span class="pre">
      cusolverDnSyevd_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the operation is successful. if
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle). if
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     Â
     <span class="pre">
      i
     </span>
     <span class="pre">
      (&gt;
     </span>
     <span class="pre">
      0)
     </span>
     ,
     <span class="pre">
      info
     </span>
     indicates
     <span class="pre">
      i
     </span>
     off-diagonal elements of an intermediate tridiagonal form did not converge to zero;
    </p>
   </td>
  </tr>
 </table>
 <p>
  The generic API has three different types,
  <span class="pre">
   dataTypeA
  </span>
  is data type of the matrix
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   dataTypeW
  </span>
  is data type of the matrix
  <span class="pre">
   W
  </span>
  and
  <span class="pre">
   computeType
  </span>
  is compute type of the operation.
  <span class="pre">
   cusolverDnSyevd
  </span>
  only supports the following four combinations.
 </p>
 <p>
  Valid combination of data type and compute type
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      DataTypeA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      DataTypeW
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ComputeType
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      Meaning
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      SSYEVD
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      DSYEVD
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CHEEVD
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ZHEEVD
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n&lt;0
     </span>
     , or
     <span class="pre">
      lda&lt;max(1,n)
     </span>
     , or
     <span class="pre">
      jobz
     </span>
     is not
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     or
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     , or
     <span class="pre">
      uplo
     </span>
     is not
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     or
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.3.13.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDN-lt-t-gt-syevdx">
   cusolverDn&lt;t&gt;syevdx()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-syevdx" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The helper functions below can calculate the sizes needed for pre-allocated buffer.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSsyevdx_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cusolverEigRange_t</span><span class="n">range</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="n">vl</span><span class="p">,</span>
<span class="kt">float</span><span class="n">vu</span><span class="p">,</span>
<span class="kt">int</span><span class="n">il</span><span class="p">,</span>
<span class="kt">int</span><span class="n">iu</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_meig</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDsyevdx_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cusolverEigRange_t</span><span class="n">range</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="n">vl</span><span class="p">,</span>
<span class="kt">double</span><span class="n">vu</span><span class="p">,</span>
<span class="kt">int</span><span class="n">il</span><span class="p">,</span>
<span class="kt">int</span><span class="n">iu</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_meig</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCheevdx_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cusolverEigRange_t</span><span class="n">range</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="n">vl</span><span class="p">,</span>
<span class="kt">float</span><span class="n">vu</span><span class="p">,</span>
<span class="kt">int</span><span class="n">il</span><span class="p">,</span>
<span class="kt">int</span><span class="n">iu</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_meig</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZheevdx_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cusolverEigRange_t</span><span class="n">range</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="n">vl</span><span class="p">,</span>
<span class="kt">double</span><span class="n">vu</span><span class="p">,</span>
<span class="kt">int</span><span class="n">il</span><span class="p">,</span>
<span class="kt">int</span><span class="n">iu</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_meig</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>
</pre>
 <p>
  The S and D data types are real valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSsyevdx</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cusolverEigRange_t</span><span class="n">range</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="n">vl</span><span class="p">,</span>
<span class="kt">float</span><span class="n">vu</span><span class="p">,</span>
<span class="kt">int</span><span class="n">il</span><span class="p">,</span>
<span class="kt">int</span><span class="n">iu</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_meig</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDsyevdx</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cusolverEigRange_t</span><span class="n">range</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="n">vl</span><span class="p">,</span>
<span class="kt">double</span><span class="n">vu</span><span class="p">,</span>
<span class="kt">int</span><span class="n">il</span><span class="p">,</span>
<span class="kt">int</span><span class="n">iu</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_meig</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  The C and Z data types are complex valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCheevdx</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cusolverEigRange_t</span><span class="n">range</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="n">vl</span><span class="p">,</span>
<span class="kt">float</span><span class="n">vu</span><span class="p">,</span>
<span class="kt">int</span><span class="n">il</span><span class="p">,</span>
<span class="kt">int</span><span class="n">iu</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_meig</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZheevdx</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cusolverEigRange_t</span><span class="n">range</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="n">vl</span><span class="p">,</span>
<span class="kt">double</span><span class="n">vu</span><span class="p">,</span>
<span class="kt">int</span><span class="n">il</span><span class="p">,</span>
<span class="kt">int</span><span class="n">iu</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_meig</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  This function computes all or selection of the eigenvalues and optionally eigenvectors of a symmetric (Hermitian)
  <span class="pre">
   nÃn
  </span>
  matrix
  <span class="pre">
   A
  </span>
  . The standard symmetric eigenvalue problem is:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A*V = V*\Lambda\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   Î
  </span>
  is a real
  <span class="pre">
   nÃh_meig
  </span>
  diagonal matrix.
  <span class="pre">
   V
  </span>
  is an
  <span class="pre">
   nÃh_meig
  </span>
  unitary matrix.
  <span class="pre">
   h_meig
  </span>
  is the number of eigenvalues/eigenvectors computed by the routine,
  <span class="pre">
   h_meig
  </span>
  is equal to
  <span class="pre">
   n
  </span>
  when the whole spectrum (e.g.,
  <span class="pre">
   range
  </span>
  =
  <span class="pre">
   CUSOLVER_EIG_RANGE_ALL
  </span>
  ) is requested. The diagonal elements of
  <span class="pre">
   Î
  </span>
  are the eigenvalues of
  <span class="pre">
   A
  </span>
  in ascending order.
 </p>
 <p>
  The user has to provide working space which is pointed by input parameter
  <span class="pre">
   work
  </span>
  . The input parameter
  <span class="pre">
   lwork
  </span>
  is size of the working space, and it is returned by
  <span class="pre">
   syevdx_bufferSize()
  </span>
  . Please note that the size in bytes of the working space is equal to
  <span class="pre">
   sizeof(&lt;type&gt;)
  </span>
  <span class="pre">
   *
  </span>
  <span class="pre">
   lwork
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   devInfo
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle). If
  <span class="pre">
   devInfo
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   i
  </span>
  (greater than zero),
  <span class="pre">
   i
  </span>
  off-diagonal elements of an intermediate tridiagonal form did not converge to zero.
 </p>
 <p>
  If
  <span class="pre">
   jobz
  </span>
  = CUSOLVER_EIG_MODE_VECTOR,
  <span class="pre">
   A
  </span>
  contains the orthonormal eigenvectors of the matrix
  <span class="pre">
   A
  </span>
  . The eigenvectors are computed by a divide and conquer algorithm.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/syevdx">
   cuSOLVER Library Samples - syevdx
  </a>
  for a code example.
 </p>
 <p>
  API of syevdx
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      jobz
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies options to either compute eigenvalue only or compute eigen-pair:
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     : Compute eigenvalues only;
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     : Compute eigenvalues and eigenvectors.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      range
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies options to which selection of eigenvalues and optionally eigenvectors that need to be computed:
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_ALL
     </span>
     : all eigenvalues/eigenvectors will be found, will becomes the classical syevd/heevd routine;
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_V
     </span>
     : all eigenvalues/eigenvectors in the half-open interval (vl,vu] will be found;
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_I
     </span>
     : the il-th through iu-th eigenvalues/eigenvectors will be found;
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies which part of
     <span class="pre">
      A
     </span>
     is stored.
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     : Lower triangle of
     <span class="pre">
      A
     </span>
     is stored.
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     : Upper triangle of
     <span class="pre">
      A
     </span>
     is stored.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows (or columns) of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     . If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     , the leading n-by-n upper triangular part of
     <span class="pre">
      A
     </span>
     contains the upper triangular part of the matrix
     <span class="pre">
      A
     </span>
     . If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     , the leading n-by-n lower triangular part of
     <span class="pre">
      A
     </span>
     contains the lower triangular part of the matrix
     <span class="pre">
      A
     </span>
     . On exit, if
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     , and
     <span class="pre">
      devInfo
     </span>
     = 0,
     <span class="pre">
      A
     </span>
     contains the orthonormal eigenvectors of the matrix
     <span class="pre">
      A
     </span>
     . If
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     , the contents of
     <span class="pre">
      A
     </span>
     are destroyed.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      vl,vu
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Real values float or double for (C, S) or (Z, D) precision respectively. If
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_V
     </span>
     , the lower and upper bounds of the interval to be searched for eigenvalues. vl &gt; vu. Not referenced if
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_ALL
     </span>
     or
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_I
     </span>
     . Note that, if eigenvalues are very close to each other, it is well known that two different eigenvalues routines might find slightly different number of eigenvalues inside the same interval. This is due to the fact that different eigenvalue algorithms, or even same algorithm but different run might find eigenvalues within some rounding error close to the machine precision. Thus, if the user wants to be sure not to miss any eigenvalue within the interval bound, we suggest that the user subtract/add epsilon (machine precision) to the interval bound such as
     <span class="pre">
      (vl=vl-eps,
     </span>
     <span class="pre">
      vu=vu+eps]
     </span>
     . This suggestion is valid for any selective routine from cuSolver or LAPACK.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      il,iu
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer. If
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_I
     </span>
     , the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= il &lt;=
     <span class="pre">
      iu
     </span>
     &lt;= n, if
     <span class="pre">
      n
     </span>
     &gt; 0;
     <span class="pre">
      il
     </span>
     = 1 and
     <span class="pre">
      iu
     </span>
     = 0 if
     <span class="pre">
      n
     </span>
     = 0. Not referenced if
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_ALL
     </span>
     or
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_V
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      h_meig
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer. The total number of eigenvalues found. 0 &lt;=
     <span class="pre">
      h_meig
     </span>
     &lt;= n. If
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_ALL
     </span>
     ,
     <span class="pre">
      h_meig
     </span>
     = n, and if
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_I
     </span>
     ,
     <span class="pre">
      h_meig
     </span>
     =
     <span class="pre">
      iu-il
     </span>
     +1.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      W
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     A real array of dimension
     <span class="pre">
      n
     </span>
     . The eigenvalue values of
     <span class="pre">
      A
     </span>
     , in ascending order ie, sorted so that
     <span class="pre">
      W(i)
     </span>
     <span class="pre">
      &lt;=
     </span>
     <span class="pre">
      W(i+1)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      work
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Working space, &lt;type&gt; array of size
     <span class="pre">
      lwork
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of
     <span class="pre">
      work
     </span>
     , returned by
     <span class="pre">
      syevdx_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      devInfo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the operation is successful. If
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle). If
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      i
     </span>
     <span class="pre">
      (&gt;
     </span>
     <span class="pre">
      0)
     </span>
     ,
     <span class="pre">
      devInfo
     </span>
     indicates
     <span class="pre">
      i
     </span>
     off-diagonal elements of an intermediate tridiagonal form did not converge to zero.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n&lt;0
     </span>
     , or
     <span class="pre">
      lda&lt;max(1,n)
     </span>
     , or
     <span class="pre">
      jobz
     </span>
     is not
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     or
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     , or
     <span class="pre">
      range
     </span>
     is not
     <span class="pre">
      CUSOLVER_EIG_RANGE_ALL
     </span>
     or
     <span class="pre">
      CUSOLVER_EIG_RANGE_V
     </span>
     or
     <span class="pre">
      CUSOLVER_EIG_RANGE_I
     </span>
     , or
     <span class="pre">
      uplo
     </span>
     is not
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     or
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.3.14.
  </span>
  cusolverDnSyevdx()[DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnsyevdx-deprecated" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  [[DEPRECATED]] use
  <span class="pre">
   cusolverDnXsyevdx()
  </span>
  instead. The routine will be removed in the next major release.
 </p>
 <p>
  The helper functions below can calculate the sizes needed for pre-allocated buffer.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSyevdx_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cusolverEigRange_t</span><span class="n">range</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">vl</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">vu</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">il</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">iu</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">h_meig</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeW</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytes</span><span class="p">);</span>
</pre>
 <p>
  The routine below
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSyevdx</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cusolverEigRange_t</span><span class="n">range</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">vl</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">vu</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">il</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">iu</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">h_meig</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeW</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">workspaceInBytes</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">);</span>
</pre>
 <p>
  computes all or selection of the eigenvalues and optionally eigenvectors of a symmetric (Hermitian)
  <span class="pre">
   nÃn
  </span>
  matrix
  <span class="pre">
   A
  </span>
  using the generic API interface. The standard symmetric eigenvalue problem is
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A*V = V*\Lambda\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   Î
  </span>
  is a real
  <span class="pre">
   nÃh_meig
  </span>
  diagonal matrix.
  <span class="pre">
   V
  </span>
  is an
  <span class="pre">
   nÃh_meig
  </span>
  unitary matrix.
  <span class="pre">
   h_meig
  </span>
  is the number of eigenvalues/eigenvectors computed by the routine,
  <span class="pre">
   h_meig
  </span>
  is equal to
  <span class="pre">
   n
  </span>
  when the whole spectrum (e.g.,
  <span class="pre">
   range
  </span>
  =
  <span class="pre">
   CUSOLVER_EIG_RANGE_ALL
  </span>
  ) is requested. The diagonal elements of
  <span class="pre">
   Î
  </span>
  are the eigenvalues of
  <span class="pre">
   A
  </span>
  in ascending order.
 </p>
 <p>
  The user has to provide working space which is pointed by input parameter
  <span class="pre">
   pBuffer
  </span>
  . The input parameter
  <span class="pre">
   workspaceInBytes
  </span>
  is size in bytes of the working space, and it is returned by
  <span class="pre">
   cusolverDnSyevdx_bufferSize()
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle). If
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   i
  </span>
  (greater than zero),
  <span class="pre">
   i
  </span>
  off-diagonal elements of an intermediate tridiagonal form did not converge to zero.
 </p>
 <p>
  if
  <span class="pre">
   jobz
  </span>
  = CUSOLVER_EIG_MODE_VECTOR,
  <span class="pre">
   A
  </span>
  contains the orthonormal eigenvectors of the matrix
  <span class="pre">
   A
  </span>
  . The eigenvectors are computed by a divide and conquer algorithm.
 </p>
 <p>
  Currently,
  <span class="pre">
   cusolverDnSyevdx
  </span>
  supports only the default algorithm.
 </p>
 <p>
  Table of algorithms supported by cusolverDnSyevdx
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_ALG_0
     </span>
     or
     <span class="pre">
      NULL
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm.
    </p>
   </td>
  </tr>
 </table>
 <p>
  List of input arguments for
  <span class="pre">
   cusolverDnSyevdx_bufferSize
  </span>
  and
  <span class="pre">
   cusolverDnSyevdx
  </span>
  :
 </p>
 <p>
  API of cusolverDnSyevdx
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      parameter
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      Memory
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      In/out
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      Meaning
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Structure with information collected by
     <span class="pre">
      cusolverDnSetAdvOptions
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      jobz
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies options to either compute eigenvalue only or compute eigen-pair:
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     : Compute eigenvalues only;
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     : Compute eigenvalues and eigenvectors.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      range
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies options to which selection of eigenvalues and optionally eigenvectors that need to be computed:
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_ALL
     </span>
     : all eigenvalues/eigenvectors will be found, will becomes the classical syevd/heevd routine;
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_V
     </span>
     : all eigenvalues/eigenvectors in the half-open interval (vl,vu] will be found;
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_I
     </span>
     : the il-th through iu-th eigenvalues/eigenvectors will be found;
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies which part of
     <span class="pre">
      A
     </span>
     is stored.
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     : Lower triangle of
     <span class="pre">
      A
     </span>
     is stored.
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     : Upper triangle of
     <span class="pre">
      A
     </span>
     is stored.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows (or columns) of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dataTypeA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     . If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     , the leading n-by-n upper triangular part of
     <span class="pre">
      A
     </span>
     contains the upper triangular part of the matrix
     <span class="pre">
      A
     </span>
     . If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     , the leading n-by-n lower triangular part of
     <span class="pre">
      A
     </span>
     contains the lower triangular part of the matrix
     <span class="pre">
      A
     </span>
     . On exit, if
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     , and
     <span class="pre">
      info
     </span>
     = 0,
     <span class="pre">
      A
     </span>
     contains the orthonormal eigenvectors of the matrix
     <span class="pre">
      A
     </span>
     . If
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     , the contents of
     <span class="pre">
      A
     </span>
     are destroyed.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      vl,vu
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_V
     </span>
     , the lower and upper bounds of the interval to be searched for eigenvalues. vl &gt; vu. Not referenced if
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_ALL
     </span>
     or
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_I
     </span>
     . Note that, if eigenvalues are very close to each other, it is well known that two different eigenvalues routines might find slightly different number of eigenvalues inside the same interval. This is due to the fact that different eigenvalue algorithms, or even same algorithm but different run might find eigenvalues within some rounding error close to the machine precision. Thus, if the user want to be sure not to miss any eigenvalue within the interval bound, we suggest that, the user subtract/add epsilon (machine precision) to the interval bound such as (vl=vl-eps, vu=vu+eps]. this suggestion is valid for any selective routine from cuSolver or LAPACK.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      il,iu
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer. If
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_I
     </span>
     , the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= il &lt;= iu &lt;= n, if n &gt; 0; il = 1 and iu = 0 if n = 0. Not referenced if
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_ALL
     </span>
     or
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_V
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      h_meig
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer. The total number of eigenvalues found. 0 &lt;= h_meig &lt;= n. If
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_ALL
     </span>
     , h_meig = n, and if
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_I
     </span>
     , h_meig = iu-il+1.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dataTypeW
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      W
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      W
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     A real array of dimension
     <span class="pre">
      n
     </span>
     . The eigenvalue values of
     <span class="pre">
      A
     </span>
     , in ascending order ie, sorted so that
     <span class="pre">
      W(i)
     </span>
     <span class="pre">
      &lt;=
     </span>
     Â
     <span class="pre">
      W(i+1)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of computation.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Working space. Array of type
     <span class="pre">
      void
     </span>
     of size
     <span class="pre">
      workspaceInBytes
     </span>
     bytes.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      workspaceInBytes
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      pBuffer
     </span>
     , returned by
     <span class="pre">
      cusolverDnSyevdx_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the operation is successful. if
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle). if
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     Â
     <span class="pre">
      i
     </span>
     <span class="pre">
      (&gt;
     </span>
     <span class="pre">
      0)
     </span>
     ,
     <span class="pre">
      info
     </span>
     indicates
     <span class="pre">
      i
     </span>
     off-diagonal elements of an intermediate tridiagonal form did not converge to zero;
    </p>
   </td>
  </tr>
 </table>
 <p>
  The generic API has three different types,
  <span class="pre">
   dataTypeA
  </span>
  is data type of the matrix
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   dataTypeW
  </span>
  is data type of the matrix
  <span class="pre">
   W
  </span>
  and
  <span class="pre">
   computeType
  </span>
  is compute type of the operation.
  <span class="pre">
   cusolverDnSyevdx
  </span>
  only supports the following four combinations.
 </p>
 <p>
  Valid combination of data type and compute type
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      DataTypeA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      DataTypeW
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ComputeType
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      Meaning
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      SSYEVDX
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      DSYEVDX
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CHEEVDX
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ZHEEVDX
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n&lt;0
     </span>
     , or
     <span class="pre">
      lda&lt;max(1,n)
     </span>
     , or
     <span class="pre">
      jobz
     </span>
     is not
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     or
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     , or
     <span class="pre">
      range
     </span>
     is not
     <span class="pre">
      CUSOLVER_EIG_RANGE_ALL
     </span>
     or
     <span class="pre">
      CUSOLVER_EIG_RANGE_V
     </span>
     or
     <span class="pre">
      CUSOLVER_EIG_RANGE_I
     </span>
     , or
     <span class="pre">
      uplo
     </span>
     is not
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     or
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.3.15.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDN-lt-t-gt-sygvd">
   cusolverDn&lt;t&gt;sygvd()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-sygvd" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The helper functions below can calculate the sizes needed for pre-allocated buffer.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSsygvd_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigType_t</span><span class="n">itype</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDsygvd_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigType_t</span><span class="n">itype</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnChegvd_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigType_t</span><span class="n">itype</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZhegvd_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigType_t</span><span class="n">itype</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>
</pre>
 <p>
  The S and D data types are real valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSsygvd</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigType_t</span><span class="n">itype</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDsygvd</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigType_t</span><span class="n">itype</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  The C and Z data types are complex valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnChegvd</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigType_t</span><span class="n">itype</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZhegvd</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigType_t</span><span class="n">itype</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  This function computes eigenvalues and eigenvectors of a symmetric (Hermitian)
  <span class="pre">
   nÃn
  </span>
  matrix-pair (
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   B
  </span>
  ). The generalized symmetric-definite eigenvalue problem is
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \({eig(A,B)} = \left\{ \begin{matrix}
{A*V = B*V*\Lambda} &amp; {\text{if~}\textsf{itype\ =\ CUSOLVER\_EIG\_TYPE\_1}} \\
{A*B*V = V*\Lambda} &amp; {\text{if~}\textsf{itype\ =\ CUSOLVER\_EIG\_TYPE\_2}} \\
{B*A*V = V*\Lambda} &amp; {\text{if~}\textsf{itype\ =\ CUSOLVER\_EIG\_TYPE\_3}} \\
\end{matrix} \right.\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where the matrix
  <span class="pre">
   B
  </span>
  is positive definite.
  <span class="pre">
   Î
  </span>
  is a real
  <span class="pre">
   nÃn
  </span>
  diagonal matrix. The diagonal elements of
  <span class="pre">
   Î
  </span>
  are the eigenvalues of (
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   B
  </span>
  ) in ascending order.
  <span class="pre">
   V
  </span>
  is an
  <span class="pre">
   nÃn
  </span>
  orthogonal matrix. The eigenvectors are normalized as follows:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\left\{ \begin{matrix}
{V^{H}*B*V = I} &amp; {\text{if~}\textsf{itype\ =\ CUSOLVER\_EIG\_TYPE\_1,\ CUSOLVER\_EIG\_TYPE\_2}} \\
{V^{H}*{inv(B)}*V = I} &amp; {\text{if~}\textsf{itype\ =\ CUSOLVER\_EIG\_TYPE\_3}} \\
\end{matrix} \right.\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The user has to provide working space which is pointed by input parameter
  <span class="pre">
   work
  </span>
  . The input parameter
  <span class="pre">
   lwork
  </span>
  is size of the working space, and it is returned by
  <span class="pre">
   sygvd_bufferSize()
  </span>
  . Please note that the size in bytes of the working space is equal to
  <span class="pre">
   sizeof(&lt;type&gt;)
  </span>
  <span class="pre">
   *
  </span>
  <span class="pre">
   lwork
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   devInfo
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle). If
  <span class="pre">
   devInfo
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   i
  </span>
  (i &gt; 0 and i&lt;=n) and
  <span class="pre">
   jobz
  </span>
  = CUSOLVER_EIG_MODE_NOVECTOR,
  <span class="pre">
   i
  </span>
  off-diagonal elements of an intermediate tridiagonal form did not converge to zero. If
  <span class="pre">
   devInfo
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   N
  </span>
  <span class="pre">
   +
  </span>
  <span class="pre">
   i
  </span>
  (i &gt; 0), then the leading minor of order
  <span class="pre">
   i
  </span>
  of
  <span class="pre">
   B
  </span>
  is not positive definite. The factorization of
  <span class="pre">
   B
  </span>
  could not be completed and no eigenvalues or eigenvectors were computed.
 </p>
 <p>
  if
  <span class="pre">
   jobz
  </span>
  = CUSOLVER_EIG_MODE_VECTOR,
  <span class="pre">
   A
  </span>
  contains the orthogonal eigenvectors of the matrix
  <span class="pre">
   A
  </span>
  . The eigenvectors are computed by divide and conquer algorithm.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/sygvd">
   cuSOLVER Library Samples - sygvd
  </a>
  for a code example.
 </p>
 <p>
  API of sygvd
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      itype
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies the problem type to be solved:
    </p>
    <ul class="simple">
     <li>
      <p>
       <span class="pre">
        itype
       </span>
       =CUSOLVER_EIG_TYPE_1: A*x = (lambda)*B*x.
      </p>
     </li>
     <li>
      <p>
       <span class="pre">
        itype
       </span>
       =CUSOLVER_EIG_TYPE_2: A*B*x = (lambda)*x.
      </p>
     </li>
     <li>
      <p>
       <span class="pre">
        itype
       </span>
       =CUSOLVER_EIG_TYPE_3: B*A*x = (lambda)*x.
      </p>
     </li>
    </ul>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      jobz
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies options to either compute eigenvalue only or compute eigen-pair:
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     : Compute eigenvalues only;
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     : Compute eigenvalues and eigenvectors.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies which part of
     <span class="pre">
      A
     </span>
     and
     <span class="pre">
      B
     </span>
     are stored.
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     : Lower triangle of
     <span class="pre">
      A
     </span>
     and
     <span class="pre">
      B
     </span>
     are stored.
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     : Upper triangle of
     <span class="pre">
      A
     </span>
     and
     <span class="pre">
      B
     </span>
     are stored.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows (or columns) of matrix
     <span class="pre">
      A
     </span>
     and
     <span class="pre">
      B
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     . If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     , the leading n-by-n upper triangular part of
     <span class="pre">
      A
     </span>
     contains the upper triangular part of the matrix
     <span class="pre">
      A
     </span>
     . If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     , the leading n-by-n lower triangular part of
     <span class="pre">
      A
     </span>
     contains the lower triangular part of the matrix
     <span class="pre">
      A
     </span>
     . On exit, if
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     , and
     <span class="pre">
      devInfo
     </span>
     = 0,
     <span class="pre">
      A
     </span>
     contains the orthonormal eigenvectors of the matrix
     <span class="pre">
      A
     </span>
     . If
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     , the contents of
     <span class="pre">
      A
     </span>
     are destroyed.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      B
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      ldb
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     . If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     , the leading n-by-n upper triangular part of
     <span class="pre">
      B
     </span>
     contains the upper triangular part of the matrix
     <span class="pre">
      B
     </span>
     . If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     , the leading n-by-n lower triangular part of
     <span class="pre">
      B
     </span>
     contains the lower triangular part of the matrix
     <span class="pre">
      B
     </span>
     . On exit, if
     <span class="pre">
      devInfo
     </span>
     is less than
     <span class="pre">
      n
     </span>
     ,
     <span class="pre">
      B
     </span>
     is overwritten by triangular factor
     <span class="pre">
      U
     </span>
     or
     <span class="pre">
      L
     </span>
     from the Cholesky factorization of
     <span class="pre">
      B
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ldb
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      B
     </span>
     .
     <span class="pre">
      ldb
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      W
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     A real array of dimension
     <span class="pre">
      n
     </span>
     . The eigenvalue values of
     <span class="pre">
      A
     </span>
     , sorted so that
     <span class="pre">
      W(i)
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      W(i+1)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      work
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Working space, &lt;type&gt; array of size
     <span class="pre">
      lwork
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      Lwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of
     <span class="pre">
      work
     </span>
     , returned by
     <span class="pre">
      sygvd_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      devInfo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the operation is successful. If
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle). If
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      i
     </span>
     <span class="pre">
      (&gt;
     </span>
     <span class="pre">
      0)
     </span>
     ,
     <span class="pre">
      devInfo
     </span>
     indicates either
     <span class="pre">
      potrf
     </span>
     or
     <span class="pre">
      syevd
     </span>
     is wrong.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n&lt;0
     </span>
     , or
     <span class="pre">
      lda&lt;max(1,n)
     </span>
     , or
     <span class="pre">
      ldb&lt;max(1,n)
     </span>
     , or
     <span class="pre">
      itype
     </span>
     is not 1, 2 or 3, or
     <span class="pre">
      jobz
     </span>
     is not âNâ or âVâ, or
     <span class="pre">
      uplo
     </span>
     is not
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     or
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.3.16.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDN-lt-t-gt-sygvdx">
   cusolverDn&lt;t&gt;sygvdx()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-sygvdx" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The helper functions below can calculate the sizes needed for pre-allocated buffer.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSsygvdx_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigType_t</span><span class="n">itype</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cusolverEigRange_t</span><span class="n">range</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">float</span><span class="n">vl</span><span class="p">,</span>
<span class="kt">float</span><span class="n">vu</span><span class="p">,</span>
<span class="kt">int</span><span class="n">il</span><span class="p">,</span>
<span class="kt">int</span><span class="n">iu</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_meig</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDsygvdx_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigType_t</span><span class="n">itype</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cusolverEigRange_t</span><span class="n">range</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">double</span><span class="n">vl</span><span class="p">,</span>
<span class="kt">double</span><span class="n">vu</span><span class="p">,</span>
<span class="kt">int</span><span class="n">il</span><span class="p">,</span>
<span class="kt">int</span><span class="n">iu</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_meig</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnChegvdx_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigType_t</span><span class="n">itype</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cusolverEigRange_t</span><span class="n">range</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">float</span><span class="n">vl</span><span class="p">,</span>
<span class="kt">float</span><span class="n">vu</span><span class="p">,</span>
<span class="kt">int</span><span class="n">il</span><span class="p">,</span>
<span class="kt">int</span><span class="n">iu</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_meig</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZhegvdx_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigType_t</span><span class="n">itype</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cusolverEigRange_t</span><span class="n">range</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">double</span><span class="n">vl</span><span class="p">,</span>
<span class="kt">double</span><span class="n">vu</span><span class="p">,</span>
<span class="kt">int</span><span class="n">il</span><span class="p">,</span>
<span class="kt">int</span><span class="n">iu</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_meig</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>
</pre>
 <p>
  The S and D data types are real valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSsygvdx</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigType_t</span><span class="n">itype</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cusolverEigRange_t</span><span class="n">range</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">float</span><span class="n">vl</span><span class="p">,</span>
<span class="kt">float</span><span class="n">vu</span><span class="p">,</span>
<span class="kt">int</span><span class="n">il</span><span class="p">,</span>
<span class="kt">int</span><span class="n">iu</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_meig</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDsygvdx</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigType_t</span><span class="n">itype</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cusolverEigRange_t</span><span class="n">range</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">double</span><span class="n">vl</span><span class="p">,</span>
<span class="kt">double</span><span class="n">vu</span><span class="p">,</span>
<span class="kt">int</span><span class="n">il</span><span class="p">,</span>
<span class="kt">int</span><span class="n">iu</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_meig</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  The C and Z data types are complex valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnChegvdx</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigType_t</span><span class="n">itype</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cusolverEigRange_t</span><span class="n">range</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">float</span><span class="n">vl</span><span class="p">,</span>
<span class="kt">float</span><span class="n">vu</span><span class="p">,</span>
<span class="kt">int</span><span class="n">il</span><span class="p">,</span>
<span class="kt">int</span><span class="n">iu</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_meig</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZhegvdx</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigType_t</span><span class="n">itype</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cusolverEigRange_t</span><span class="n">range</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">double</span><span class="n">vl</span><span class="p">,</span>
<span class="kt">double</span><span class="n">vu</span><span class="p">,</span>
<span class="kt">int</span><span class="n">il</span><span class="p">,</span>
<span class="kt">int</span><span class="n">iu</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_meig</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">devInfo</span><span class="p">);</span>
</pre>
 <p>
  This function computes all or selection of the eigenvalues and optionally eigenvectors of a symmetric (Hermitian)
  <span class="pre">
   nÃn
  </span>
  matrix-pair (
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   B
  </span>
  ). The generalized symmetric-definite eigenvalue problem is
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \({eig(A,B)} = \left\{ \begin{matrix}
{A*V = B*V*\Lambda} &amp; {\text{if~}\textsf{itype\ =\ CUSOLVER\_EIG\_TYPE\_1}} \\
{A*B*V = V*\Lambda} &amp; {\text{if~}\textsf{itype\ =\ CUSOLVER\_EIG\_TYPE\_2}} \\
{B*A*V = V*\Lambda} &amp; {\text{if~}\textsf{itype\ =\ CUSOLVER\_EIG\_TYPE\_3}} \\
\end{matrix} \right.\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where the matrix
  <span class="pre">
   B
  </span>
  is positive definite.
  <span class="pre">
   Î
  </span>
  is a real
  <span class="pre">
   nÃh_meig
  </span>
  diagonal matrix. The diagonal elements of
  <span class="pre">
   Î
  </span>
  are the eigenvalues of (
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   B
  </span>
  ) in ascending order.
  <span class="pre">
   V
  </span>
  is an
  <span class="pre">
   nÃh_meig
  </span>
  orthogonal matrix.
  <span class="pre">
   h_meig
  </span>
  is the number of eigenvalues/eigenvectors computed by the routine,
  <span class="pre">
   h_meig
  </span>
  is equal to
  <span class="pre">
   n
  </span>
  when the whole spectrum (e.g.,
  <span class="pre">
   range
  </span>
  =
  <span class="pre">
   CUSOLVER_EIG_RANGE_ALL
  </span>
  ) is requested. The eigenvectors are normalized as follows:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\left\{ \begin{matrix}
{V^{H}*B*V = I} &amp; {\text{if~}\textsf{itype\ =\ CUSOLVER\_EIG\_TYPE\_1,\ CUSOLVER\_EIG\_TYPE\_2}} \\
{V^{H}*{inv(B)}*V = I} &amp; {\text{if~}\textsf{itype\ =\ CUSOLVER\_EIG\_TYPE\_3}} \\
\end{matrix} \right.\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The user has to provide working space which is pointed by input parameter
  <span class="pre">
   work
  </span>
  . The input parameter
  <span class="pre">
   lwork
  </span>
  is size of the working space, and it is returned by
  <span class="pre">
   sygvdx_bufferSize()
  </span>
  . Please note that the size in bytes of the working space is equal to
  <span class="pre">
   sizeof(&lt;type&gt;)
  </span>
  <span class="pre">
   *
  </span>
  <span class="pre">
   lwork
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   devInfo
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle). If
  <span class="pre">
   devInfo
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   i
  </span>
  (i &gt; 0 and i&lt;=n) and
  <span class="pre">
   jobz
  </span>
  = CUSOLVER_EIG_MODE_NOVECTOR,
  <span class="pre">
   i
  </span>
  off-diagonal elements of an intermediate tridiagonal form did not converge to zero. If
  <span class="pre">
   devInfo
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   n
  </span>
  Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â
  <span class="pre">
   +
  </span>
  <span class="pre">
   i
  </span>
  (i &gt; 0), then the leading minor of order
  <span class="pre">
   i
  </span>
  of
  <span class="pre">
   B
  </span>
  is not positive definite. The factorization of
  <span class="pre">
   B
  </span>
  could not be completed and no eigenvalues or eigenvectors were computed.
 </p>
 <p>
  If
  <span class="pre">
   jobz
  </span>
  = CUSOLVER_EIG_MODE_VECTOR,
  <span class="pre">
   A
  </span>
  contains the orthogonal eigenvectors of the matrix
  <span class="pre">
   A
  </span>
  . The eigenvectors are computed by divide and conquer algorithm.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/sygvdx">
   cuSOLVER Library Samples - sygvdx
  </a>
  for a code example.
 </p>
 <p>
  API of sygvdx
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      itype
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies the problem type to be solved:
    </p>
    <ul class="simple">
     <li>
      <p>
       <span class="pre">
        itype
       </span>
       =CUSOLVER_EIG_TYPE_1: A*x = (lambda)*B*x
      </p>
     </li>
     <li>
      <p>
       <span class="pre">
        itype
       </span>
       =CUSOLVER_EIG_TYPE_2: A*B*x = (lambda)*x
      </p>
     </li>
     <li>
      <p>
       <span class="pre">
        itype
       </span>
       =CUSOLVER_EIG_TYPE_3: B*A*x = (lambda)*x
      </p>
     </li>
    </ul>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      jobz
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies options to either compute eigenvalue only or compute eigen-pair:
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     : Compute eigenvalues only;
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     : Compute eigenvalues and eigenvectors.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      range
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies options to which selection of eigenvalues and optionally eigenvectors that need to be computed:
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_ALL
     </span>
     : all eigenvalues/eigenvectors will be found, will becomes the classical syevd/heevd routine;
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_V
     </span>
     : all eigenvalues/eigenvectors in the half-open interval
     <span class="pre">
      (vl,vu]
     </span>
     will be found;
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_I
     </span>
     : the il-th through iu-th eigenvalues/eigenvectors will be found;
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies which part of
     <span class="pre">
      A
     </span>
     and
     <span class="pre">
      B
     </span>
     are stored.
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     : Lower triangle of
     <span class="pre">
      A
     </span>
     and
     <span class="pre">
      B
     </span>
     are stored.
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     : Upper triangle of
     <span class="pre">
      A
     </span>
     and
     <span class="pre">
      B
     </span>
     are stored.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows (or columns) of matrix
     <span class="pre">
      A
     </span>
     and
     <span class="pre">
      B
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     . If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     , the leading n-by-n upper triangular part of
     <span class="pre">
      A
     </span>
     contains the upper triangular part of the matrix
     <span class="pre">
      A
     </span>
     . If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     , the leading n-by-n lower triangular part of
     <span class="pre">
      A
     </span>
     contains the lower triangular part of the matrix
     <span class="pre">
      A
     </span>
     . On exit, if
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     , and
     <span class="pre">
      devInfo
     </span>
     = 0,
     <span class="pre">
      A
     </span>
     contains the orthonormal eigenvectors of the matrix
     <span class="pre">
      A
     </span>
     . If
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     , the contents of
     <span class="pre">
      A
     </span>
     are destroyed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      B
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      ldb
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     . If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     , the leading n-by-n upper triangular part of
     <span class="pre">
      B
     </span>
     contains the upper triangular part of the matrix
     <span class="pre">
      B
     </span>
     . If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     , the leading n-by-n lower triangular part of
     <span class="pre">
      B
     </span>
     contains the lower triangular part of the matrix
     <span class="pre">
      B
     </span>
     . On exit, if
     <span class="pre">
      devInfo
     </span>
     is less than
     <span class="pre">
      n
     </span>
     ,
     <span class="pre">
      B
     </span>
     is overwritten by triangular factor
     <span class="pre">
      U
     </span>
     or
     <span class="pre">
      L
     </span>
     from the Cholesky factorization of
     <span class="pre">
      B
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ldb
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      B
     </span>
     .
     <span class="pre">
      ldb
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      vl,vu
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Real values float or double for (C, S) or (Z, D) precision respectively. If
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_V
     </span>
     , the lower and upper bounds of the interval to be searched for eigenvalues. vl &gt; vu. Not referenced if
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_ALL
     </span>
     or
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_I
     </span>
     . Note that, if eigenvalues are very close to each other, it is well known that two different eigenvalues routines might find slightly different number of eigenvalues inside the same interval. This is due to the fact that different eigenvalue algorithms, or even same algorithm but different run might find eigenvalues within some rounding error close to the machine precision. Thus, if the user want to be sure not to miss any eigenvalue within the interval bound, we suggest that, the user subtract/add epsilon (machine precision) to the interval bound such as (
     <span class="pre">
      vl
     </span>
     =
     <span class="pre">
      vl
     </span>
     -
     <span class="pre">
      eps
     </span>
     ,
     <span class="pre">
      vu
     </span>
     =
     <span class="pre">
      vu
     </span>
     +
     <span class="pre">
      eps
     </span>
     ]. this suggestion is valid for any selective routine from cuSolver or LAPACK.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      il,iu
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer. If
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_I
     </span>
     , the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;=
     <span class="pre">
      il
     </span>
     &lt;=
     <span class="pre">
      iu
     </span>
     &lt;=
     <span class="pre">
      n
     </span>
     , if
     <span class="pre">
      n
     </span>
     &gt; 0;
     <span class="pre">
      il
     </span>
     = 1 and
     <span class="pre">
      iu
     </span>
     = 0 if
     <span class="pre">
      n
     </span>
     = 0. Not referenced if
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_ALL
     </span>
     or
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_V
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      h_meig
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer. The total number of eigenvalues found. 0 &lt;= h_meig &lt;= n. If
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_ALL
     </span>
     , h_meig = n, and if
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_I
     </span>
     , h_meig = iu-il+1.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      W
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     A real array of dimension
     <span class="pre">
      n
     </span>
     . The eigenvalue values of
     <span class="pre">
      A
     </span>
     , sorted so that
     <span class="pre">
      W(i)
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      W(i+1)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      work
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Working space, &lt;type&gt; array of size
     <span class="pre">
      lwork
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of
     <span class="pre">
      work
     </span>
     , returned by
     <span class="pre">
      sygvdx_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      devInfo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the operation is successful. If
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle). If
     <span class="pre">
      devInfo
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      i
     </span>
     <span class="pre">
      (&gt;
     </span>
     <span class="pre">
      0)
     </span>
     ,
     <span class="pre">
      devInfo
     </span>
     indicates either
     <span class="pre">
      potrf
     </span>
     or
     <span class="pre">
      syevd
     </span>
     is wrong.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n&lt;0
     </span>
     , or
     <span class="pre">
      lda&lt;max(1,n)
     </span>
     , or
     <span class="pre">
      ldb&lt;max(1,n)
     </span>
     , or
     <span class="pre">
      itype
     </span>
     is not
     <span class="pre">
      CUSOLVER_EIG_TYPE_1
     </span>
     or
     <span class="pre">
      CUSOLVER_EIG_TYPE_2
     </span>
     or
     <span class="pre">
      CUSOLVER_EIG_TYPE_3
     </span>
     or
     <span class="pre">
      jobz
     </span>
     is not
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     or
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTORL
     </span>
     , or
     <span class="pre">
      range
     </span>
     is not
     <span class="pre">
      CUSOLVER_EIG_RANGE_ALL
     </span>
     or
     <span class="pre">
      CUSOLVER_EIG_RANGE_V
     </span>
     or
     <span class="pre">
      CUSOLVER_EIG_RANGE_I
     </span>
     , or
     <span class="pre">
      uplo
     </span>
     is not
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     or
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.3.17.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDN-lt-t-gt-syevj">
   cusolverDn&lt;t&gt;syevj()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-syevj" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The helper functions below can calculate the sizes needed for pre-allocated buffer.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSsyevj_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">,</span>
<span class="n">syevjInfo_t</span><span class="n">params</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDsyevj_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">,</span>
<span class="n">syevjInfo_t</span><span class="n">params</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCheevj_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">,</span>
<span class="n">syevjInfo_t</span><span class="n">params</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZheevj_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">,</span>
<span class="n">syevjInfo_t</span><span class="n">params</span><span class="p">);</span>
</pre>
 <p>
  The S and D data types are real valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSsyevj</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="n">syevjInfo_t</span><span class="n">params</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDsyevj</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="n">syevjInfo_t</span><span class="n">params</span><span class="p">);</span>
</pre>
 <p>
  The C and Z data types are complex valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCheevj</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="n">syevjInfo_t</span><span class="n">params</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZheevj</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="n">syevjInfo_t</span><span class="n">params</span><span class="p">);</span>
</pre>
 <p>
  This function computes eigenvalues and eigenvectors of a symmetric (Hermitian)
  <span class="pre">
   nÃn
  </span>
  matrix
  <span class="pre">
   A
  </span>
  . The standard symmetric eigenvalue problem is
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A*Q = Q*\Lambda\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   Î
  </span>
  is a real
  <span class="pre">
   nÃn
  </span>
  diagonal matrix.
  <span class="pre">
   Q
  </span>
  is an
  <span class="pre">
   nÃn
  </span>
  unitary matrix. The diagonal elements of
  <span class="pre">
   Î
  </span>
  are the eigenvalues of
  <span class="pre">
   A
  </span>
  in ascending order.
 </p>
 <p>
  <span class="pre">
   syevj
  </span>
  has the same functionality as
  <span class="pre">
   syevd
  </span>
  . The difference is that
  <span class="pre">
   syevd
  </span>
  uses QR algorithm and
  <span class="pre">
   syevj
  </span>
  uses Jacobi method. The parallelism of Jacobi method gives GPU better performance on small and medium size matrices. Moreover the user can configure
  <span class="pre">
   syevj
  </span>
  to perform approximation up to certain accuracy.
 </p>
 <p>
  How does it work?
 </p>
 <p>
  <span class="pre">
   syevj
  </span>
  iteratively generates a sequence of unitary matrices to transform matrix
  <span class="pre">
   A
  </span>
  to the following form
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(V^{H}*A*V = W + E\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   W
  </span>
  is diagonal and
  <span class="pre">
   E
  </span>
  is symmetric without diagonal.
 </p>
 <p>
  During the iterations, the Frobenius norm of
  <span class="pre">
   E
  </span>
  decreases monotonically. As
  <span class="pre">
   E
  </span>
  goes down to zero,
  <span class="pre">
   W
  </span>
  is the set of eigenvalues. In practice, Jacobi method stops if
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \({||E||}_{F}\leq\operatorname{eps}*{||A||}_{F}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   eps
  </span>
  is the given tolerance.
 </p>
 <p>
  <span class="pre">
   syevj
  </span>
  has two parameters to control the accuracy. First parameter is tolerance (
  <span class="pre">
   eps
  </span>
  ). The default value is machine accuracy but The user can use function
  <span class="pre">
   cusolverDnXsyevjSetTolerance
  </span>
  to set a priori tolerance. The second parameter is maximum number of sweeps which controls number of iterations of Jacobi method. The default value is 100 but the user can use function
  <span class="pre">
   cusolverDnXsyevjSetMaxSweeps
  </span>
  to set a proper bound. The experiments show 15 sweeps are good enough to converge to machine accuracy.
  <span class="pre">
   syevj
  </span>
  stops either tolerance is met or maximum number of sweeps is met.
 </p>
 <p>
  The Jacobi method has quadratic convergence, so the accuracy is not proportional to number of sweeps. To guarantee certain accuracy, the user should configure tolerance only.
 </p>
 <p>
  After
  <span class="pre">
   syevj
  </span>
  , the user can query residual by function
  <span class="pre">
   cusolverDnXsyevjGetResidual
  </span>
  and number of executed sweeps by function
  <span class="pre">
   cusolverDnXsyevjGetSweeps
  </span>
  . However the user needs to be aware that residual is the Frobenius norm of
  <span class="pre">
   E
  </span>
  , not accuracy of individual eigenvalue, i.e.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \({residual}={||E||}_{F} = {{||}\Lambda - W{||}}_{F}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The same as
  <span class="pre">
   syevd
  </span>
  , the user has to provide working space pointed by input parameter
  <span class="pre">
   work
  </span>
  . The input parameter
  <span class="pre">
   lwork
  </span>
  is the size of the working space, and it is returned by
  <span class="pre">
   syevj_bufferSize()
  </span>
  . Please note that the size in bytes of the working space is equal to
  <span class="pre">
   sizeof(&lt;type&gt;)
  </span>
  <span class="pre">
   *
  </span>
  <span class="pre">
   lwork
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle). If
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   n+1
  </span>
  ,
  <span class="pre">
   syevj
  </span>
  does not converge under given tolerance and maximum sweeps.
 </p>
 <p>
  If the user sets an improper tolerance,
  <span class="pre">
   syevj
  </span>
  may not converge. For example, tolerance should not be smaller than machine accuracy.
 </p>
 <p>
  If
  <span class="pre">
   jobz
  </span>
  = CUSOLVER_EIG_MODE_VECTOR,
  <span class="pre">
   A
  </span>
  contains the orthonormal eigenvectors
  <span class="pre">
   V
  </span>
  .
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/syevj">
   cuSOLVER Library Samples - syevj
  </a>
  for a code example.
 </p>
 <p>
  API of syevj
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      jobz
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies options to either compute eigenvalue only or compute eigen-pair:
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     : Compute eigenvalues only;
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     : Compute eigenvalues and eigenvectors.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies which part of
     <span class="pre">
      A
     </span>
     is stored.
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     : Lower triangle of
     <span class="pre">
      A
     </span>
     is stored.
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     : Upper triangle of
     <span class="pre">
      A
     </span>
     is stored.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows (or columns) of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     . If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     , the leading n-by-n upper triangular part of
     <span class="pre">
      A
     </span>
     contains the upper triangular part of the matrix
     <span class="pre">
      A
     </span>
     . If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     , the leading n-by-n lower triangular part of
     <span class="pre">
      A
     </span>
     contains the lower triangular part of the matrix
     <span class="pre">
      A
     </span>
     . On exit, if
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     , and
     <span class="pre">
      info
     </span>
     = 0,
     <span class="pre">
      A
     </span>
     contains the orthonormal eigenvectors of the matrix
     <span class="pre">
      A
     </span>
     . If
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     , the contents of
     <span class="pre">
      A
     </span>
     are destroyed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      W
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     A real array of dimension
     <span class="pre">
      n
     </span>
     . The eigenvalue values of
     <span class="pre">
      A
     </span>
     , in ascending order ie, sorted so that
     <span class="pre">
      W(i)
     </span>
     <span class="pre">
      &lt;=
     </span>
     <span class="pre">
      W(i+1)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      work
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Working space, &lt;type&gt; array of size
     <span class="pre">
      lwork
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of
     <span class="pre">
      work
     </span>
     , returned by
     <span class="pre">
      syevj_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the operation is successful. If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle). If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      n+1
     </span>
     ,
     <span class="pre">
      syevj
     </span>
     does not converge under given tolerance and maximum sweeps.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Structure filled with parameters of Jacobi algorithm and results of
     <span class="pre">
      syevj
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n&lt;0
     </span>
     , or
     <span class="pre">
      lda&lt;max(1,n)
     </span>
     , or
     <span class="pre">
      jobz
     </span>
     is not
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     or
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     , or
     <span class="pre">
      uplo
     </span>
     is not
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     or
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.3.18.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDN-lt-t-gt-sygvj">
   cusolverDn&lt;t&gt;sygvj()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-sygvj" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The helper functions below can calculate the sizes needed for pre-allocated buffer.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSsygvj_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigType_t</span><span class="n">itype</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">,</span>
<span class="n">syevjInfo_t</span><span class="n">params</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDsygvj_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigType_t</span><span class="n">itype</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">,</span>
<span class="n">syevjInfo_t</span><span class="n">params</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnChegvj_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigType_t</span><span class="n">itype</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">,</span>
<span class="n">syevjInfo_t</span><span class="n">params</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZhegvj_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigType_t</span><span class="n">itype</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">,</span>
<span class="n">syevjInfo_t</span><span class="n">params</span><span class="p">);</span>
</pre>
 <p>
  The S and D data types are real valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSsygvj</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigType_t</span><span class="n">itype</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="n">syevjInfo_t</span><span class="n">params</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDsygvj</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigType_t</span><span class="n">itype</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="n">syevjInfo_t</span><span class="n">params</span><span class="p">);</span>
</pre>
 <p>
  The C and Z data types are complex valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnChegvj</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigType_t</span><span class="n">itype</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="n">syevjInfo_t</span><span class="n">params</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZhegvj</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigType_t</span><span class="n">itype</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="n">syevjInfo_t</span><span class="n">params</span><span class="p">);</span>
</pre>
 <p>
  This function computes eigenvalues and eigenvectors of a symmetric (Hermitian)
  <span class="pre">
   nÃn
  </span>
  matrix-pair (
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   B
  </span>
  ). The generalized symmetric-definite eigenvalue problem is
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \({eig(A,B)} = \left\{ \begin{matrix}
{A*V = B*V*\Lambda} &amp; {\text{if }\textsf{itype = CUSOLVER_EIG_TYPE_1}} \\
{A*B*V = V*\Lambda} &amp; {\text{if }\textsf{itype = CUSOLVER_EIG_TYPE_2}} \\
{B*A*V = V*\Lambda} &amp; {\text{if }\textsf{itype = CUSOLVER_EIG_TYPE_3}} \\
\end{matrix} \right.\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where the matrix
  <span class="pre">
   B
  </span>
  is positive definite.
  <span class="pre">
   Î
  </span>
  is a real
  <span class="pre">
   nÃn
  </span>
  diagonal matrix. The diagonal elements of
  <span class="pre">
   Î
  </span>
  are the eigenvalues of (
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   B
  </span>
  ) in ascending order.
  <span class="pre">
   V
  </span>
  is an
  <span class="pre">
   nÃn
  </span>
  orthogonal matrix. The eigenvectors are normalized as follows:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\left\{ \begin{matrix}
{V^{H}*B*V = I} &amp; {\text{if }\textsf{itype = CUSOLVER_EIG_TYPE_1, CUSOLVER_EIG_TYPE_2}} \\
{V^{H}*{inv(B)}*V = I} &amp; {\text{if }\textsf{itype = CUSOLVER_EIG_TYPE_3}}      \\
\end{matrix} \right.\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  This function has the same functionality as
  <span class="pre">
   sygvd
  </span>
  except that
  <span class="pre">
   syevd
  </span>
  in
  <span class="pre">
   sygvd
  </span>
  is replaced by
  <span class="pre">
   syevj
  </span>
  in
  <span class="pre">
   sygvj
  </span>
  . Therefore,
  <span class="pre">
   sygvj
  </span>
  inherits properties of
  <span class="pre">
   syevj
  </span>
  , the user can use
  <span class="pre">
   cusolverDnXsyevjSetTolerance
  </span>
  and
  <span class="pre">
   cusolverDnXsyevjSetMaxSweeps
  </span>
  to configure tolerance and maximum sweeps.
 </p>
 <p>
  However the meaning of residual is different from
  <span class="pre">
   syevj
  </span>
  .
  <span class="pre">
   sygvj
  </span>
  first computes Cholesky factorization of matrix
  <span class="pre">
   B
  </span>
  ,
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(B = L*L^{H}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  transform the problem to standard eigenvalue problem, then calls
  <span class="pre">
   syevj
  </span>
  .
 </p>
 <p>
  For example, the standard eigenvalue problem of type I is
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(M*Q = Q*\Lambda\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where matrix
  <span class="pre">
   M
  </span>
  is symmetric
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(M = L^{-1}*A*L^{-H}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The residual is the result of
  <span class="pre">
   syevj
  </span>
  on matrix
  <span class="pre">
   M
  </span>
  , not
  <span class="pre">
   A
  </span>
  .
 </p>
 <p>
  The user has to provide working space which is pointed by input parameter
  <span class="pre">
   work
  </span>
  . The input parameter
  <span class="pre">
   lwork
  </span>
  is the size of the working space, and it is returned by
  <span class="pre">
   sygvj_bufferSize()
  </span>
  . Please note that the size in bytes of the working space is equal to
  <span class="pre">
   sizeof(&lt;type&gt;)
  </span>
  <span class="pre">
   *
  </span>
  <span class="pre">
   lwork
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle). If
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   i
  </span>
  (i &gt; 0 and i&lt;=n),
  <span class="pre">
   B
  </span>
  is not positive definite, the factorization of
  <span class="pre">
   B
  </span>
  could not be completed and no eigenvalues or eigenvectors were computed. If
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   n+1
  </span>
  ,
  <span class="pre">
   syevj
  </span>
  does not converge under given tolerance and maximum sweeps. In this case, the eigenvalues and eigenvectors are still computed because non-convergence comes from improper tolerance of maximum sweeps.
 </p>
 <p>
  if
  <span class="pre">
   jobz
  </span>
  = CUSOLVER_EIG_MODE_VECTOR,
  <span class="pre">
   A
  </span>
  contains the orthogonal eigenvectors
  <span class="pre">
   V
  </span>
  .
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/sygvj">
   cuSOLVER Library Samples - sygvj
  </a>
  for a code example.
 </p>
 <p>
  API of sygvj
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      itype
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies the problem type to be solved:
     <span class="pre">
      itype
     </span>
     =CUSOLVER_EIG_TYPE_1: A*x = (lambda)*B*x.
     <span class="pre">
      itype
     </span>
     =CUSOLVER_EIG_TYPE_2: A*B*x = (lambda)*x.
     <span class="pre">
      itype
     </span>
     =CUSOLVER_EIG_TYPE_3: B*A*x = (lambda)*x.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      jobz
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies options to either compute eigenvalue only or compute eigen-pair:
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     : Compute eigenvalues only;
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     : Compute eigenvalues and eigenvectors.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies which part of
     <span class="pre">
      A
     </span>
     and
     <span class="pre">
      B
     </span>
     are stored.
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     : Lower triangle of
     <span class="pre">
      A
     </span>
     and
     <span class="pre">
      B
     </span>
     are stored.
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     : Upper triangle of
     <span class="pre">
      A
     </span>
     and
     <span class="pre">
      B
     </span>
     are stored.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows (or columns) of matrix
     <span class="pre">
      A
     </span>
     and
     <span class="pre">
      B
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     . If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     , the leading n-by-n upper triangular part of
     <span class="pre">
      A
     </span>
     contains the upper triangular part of the matrix
     <span class="pre">
      A
     </span>
     . If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     , the leading n-by-n lower triangular part of
     <span class="pre">
      A
     </span>
     contains the lower triangular part of the matrix
     <span class="pre">
      A
     </span>
     . On exit, if
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     , and
     <span class="pre">
      info
     </span>
     = 0,
     <span class="pre">
      A
     </span>
     contains the orthonormal eigenvectors of the matrix
     <span class="pre">
      A
     </span>
     . If
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     , the contents of
     <span class="pre">
      A
     </span>
     are destroyed.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      B
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      ldb
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     . If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     , the leading n-by-n upper triangular part of
     <span class="pre">
      B
     </span>
     contains the upper triangular part of the matrix
     <span class="pre">
      B
     </span>
     . If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     , the leading n-by-n lower triangular part of
     <span class="pre">
      B
     </span>
     contains the lower triangular part of the matrix
     <span class="pre">
      B
     </span>
     . On exit, if
     <span class="pre">
      info
     </span>
     is less than
     <span class="pre">
      n
     </span>
     ,
     <span class="pre">
      B
     </span>
     is overwritten by triangular factor
     <span class="pre">
      U
     </span>
     or
     <span class="pre">
      L
     </span>
     from the Cholesky factorization of
     <span class="pre">
      B
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ldb
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      B
     </span>
     .
     <span class="pre">
      ldb
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      W
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     A real array of dimension
     <span class="pre">
      n
     </span>
     . The eigenvalue values of
     <span class="pre">
      A
     </span>
     , sorted so that
     <span class="pre">
      W(i)
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      W(i+1)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      work
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Working space, &lt;type&gt; array of size
     <span class="pre">
      lwork
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of
     <span class="pre">
      work
     </span>
     , returned by
     <span class="pre">
      sygvj_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the operation is successful. if
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle). If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      i
     </span>
     <span class="pre">
      (&gt;
     </span>
     <span class="pre">
      0)
     </span>
     ,
     <span class="pre">
      info
     </span>
     indicates either
     <span class="pre">
      B
     </span>
     is not positive definite or
     <span class="pre">
      syevj
     </span>
     (called by
     <span class="pre">
      sygvj
     </span>
     ) does not converge.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n&lt;0
     </span>
     , or
     <span class="pre">
      lda&lt;max(1,n)
     </span>
     , or
     <span class="pre">
      ldb&lt;max(1,n)
     </span>
     , or
     <span class="pre">
      itype
     </span>
     is not 1, 2 or 3, or
     <span class="pre">
      jobz
     </span>
     is not
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     or
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     , or
     <span class="pre">
      uplo
     </span>
     is not
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     or
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.3.19.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cuSolverDN-lt-t-gt-syevjbatch">
   cusolverDn&lt;t&gt;syevjBatched()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdn-t-syevjbatched" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The helper functions below can calculate the sizes needed for pre-allocated buffer.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSsyevjBatched_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">,</span>
<span class="n">syevjInfo_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span>
<span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDsyevjBatched_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">,</span>
<span class="n">syevjInfo_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span>
<span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCheevjBatched_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">,</span>
<span class="n">syevjInfo_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span>
<span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZheevjBatched_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">lwork</span><span class="p">,</span>
<span class="n">syevjInfo_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span>
<span class="p">);</span>
</pre>
 <p>
  The S and D data types are real valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnSsyevjBatched</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="n">syevjInfo_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span>
<span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnDsyevjBatched</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="n">syevjInfo_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span>
<span class="p">);</span>
</pre>
 <p>
  The C and Z data types are complex valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnCheevjBatched</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="n">syevjInfo_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span>
<span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnZheevjBatched</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="n">syevjInfo_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span>
<span class="p">);</span>
</pre>
 <p>
  This function computes eigenvalues and eigenvectors of a sequence of symmetric (Hermitian)
  <span class="pre">
   nÃn
  </span>
  matrices
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A_{j}*Q_{j} = Q_{j}*\Lambda_{j}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="math notranslate nohighlight">
   \(\Lambda_{j}\)
  </span>
  is a real
  <span class="pre">
   nÃn
  </span>
  diagonal matrix.
  <span class="math notranslate nohighlight">
   \(Q_{j}\)
  </span>
  is an
  <span class="pre">
   nÃn
  </span>
  unitary matrix. The diagonal elements of
  <span class="math notranslate nohighlight">
   \(\Lambda_{j}\)
  </span>
  are the eigenvalues of
  <span class="math notranslate nohighlight">
   \(A_{j}\)
  </span>
  in either ascending order or non-sorting order.
 </p>
 <p>
  <span class="pre">
   syevjBatched
  </span>
  performs
  <span class="pre">
   syevj
  </span>
  on each matrix. It requires that all matrices are of the same size
  <span class="pre">
   n
  </span>
  and are packed in contiguous way,
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = \begin{pmatrix}
{A0} &amp; {A1} &amp; \cdots \\
\end{pmatrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Each matrix is column-major with leading dimension
  <span class="pre">
   lda
  </span>
  , so the formula for random access is
  <span class="math notranslate nohighlight">
   \(A_{k}\operatorname{(i,j)} = {A\lbrack\ i\ +\ lda*j\ +\ lda*n*k\rbrack}\)
  </span>
  .
 </p>
 <p>
  The parameter
  <span class="pre">
   W
  </span>
  also contains eigenvalues of each matrix in contiguous way,
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(W = \begin{pmatrix}
{W0} &amp; {W1} &amp; \cdots \\
\end{pmatrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The formula for random access of
  <span class="pre">
   W
  </span>
  is
  <span class="math notranslate nohighlight">
   \(W_{k}\operatorname{(j)} = {W\lbrack\ j\ +\ n*k\rbrack}\)
  </span>
  .
 </p>
 <p>
  Except for tolerance and maximum sweeps,
  <span class="pre">
   syevjBatched
  </span>
  can either sort the eigenvalues in ascending order (default) or chose as-is (without sorting) by the function
  <span class="pre">
   cusolverDnXsyevjSetSortEig
  </span>
  . If the user packs several tiny matrices into diagonal blocks of one matrix, non-sorting option can separate spectrum of those tiny matrices.
 </p>
 <p>
  <span class="pre">
   syevjBatched
  </span>
  cannot report residual and executed sweeps by function
  <span class="pre">
   cusolverDnXsyevjGetResidual
  </span>
  and
  <span class="pre">
   cusolverDnXsyevjGetSweeps
  </span>
  . Any call of the above two returns
  <span class="pre">
   CUSOLVER_STATUS_NOT_SUPPORTED
  </span>
  . The user needs to compute residual explicitly.
 </p>
 <p>
  The user has to provide working space pointed by input parameter
  <span class="pre">
   work
  </span>
  . The input parameter
  <span class="pre">
   lwork
  </span>
  is the size of the working space, and it is returned by
  <span class="pre">
   syevjBatched_bufferSize()
  </span>
  . Please note that the size in bytes of the working space is equal to
  <span class="pre">
   sizeof(&lt;type&gt;)
  </span>
  <span class="pre">
   *
  </span>
  <span class="pre">
   lwork
  </span>
  .
 </p>
 <p>
  The output parameter
  <span class="pre">
   info
  </span>
  is an integer array of size
  <span class="pre">
   batchSize
  </span>
  . If the function returns
  <span class="pre">
   CUSOLVER_STATUS_INVALID_VALUE
  </span>
  , the first element
  <span class="pre">
   info[0]
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero) indicates
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle). Otherwise, if
  <span class="pre">
   info[i]
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   n+1
  </span>
  ,
  <span class="pre">
   syevjBatched
  </span>
  does not converge on
  <span class="pre">
   i-th
  </span>
  matrix under given tolerance and maximum sweeps.
 </p>
 <p>
  If
  <span class="pre">
   jobz
  </span>
  = CUSOLVER_EIG_MODE_VECTOR,
  <span class="math notranslate nohighlight">
   \(A_{j}\)
  </span>
  contains the orthonormal eigenvectors
  <span class="math notranslate nohighlight">
   \(V_{j}\)
  </span>
  .
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/syevjBatched">
   cuSOLVER Library Samples - syevjBatched
  </a>
  for a code example.
 </p>
 <p>
  API of syevjBatched
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      jobz
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies options to either compute eigenvalue only or compute eigen-pair:
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     : Compute eigenvalues only;
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     : Compute eigenvalues and eigenvectors.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies which part of
     <span class="pre">
      Aj
     </span>
     is stored.
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     : Lower triangle of
     <span class="pre">
      Aj
     </span>
     is stored.
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     : Upper triangle of
     <span class="pre">
      Aj
     </span>
     is stored.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows (or columns) of matrix each
     <span class="pre">
      Aj
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      batchSize
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     . If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     , the leading n-by-n upper triangular part of
     <span class="pre">
      Aj
     </span>
     contains the upper triangular part of the matrix
     <span class="pre">
      Aj
     </span>
     . If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     , the leading n-by-n lower triangular part of
     <span class="pre">
      Aj
     </span>
     contains the lower triangular part of the matrix
     <span class="pre">
      Aj
     </span>
     . On exit, if
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     , and
     <span class="pre">
      info[j]
     </span>
     = 0,
     <span class="pre">
      Aj
     </span>
     contains the orthonormal eigenvectors of the matrix
     <span class="pre">
      Aj
     </span>
     . If
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     , the contents of
     <span class="pre">
      Aj
     </span>
     are destroyed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      Aj
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      W
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     A real array of dimension
     <span class="pre">
      n*batchSize
     </span>
     . It stores the eigenvalues of
     <span class="pre">
      Aj
     </span>
     in ascending order or non-sorting order.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      work
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of size
     <span class="pre">
      lwork
     </span>
     , workspace.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of
     <span class="pre">
      work
     </span>
     , returned by
     <span class="pre">
      syevjBatched_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     An integer array of dimension
     <span class="pre">
      batchSize
     </span>
     . If
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
     is returned,
     <span class="pre">
      info[0]
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     (less than zero) indicates
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle). Otherwise, if
     <span class="pre">
      info[i]
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the operation is successful. If
     <span class="pre">
      info[i]
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      n+1
     </span>
     ,
     <span class="pre">
      syevjBatched
     </span>
     does not converge on
     <span class="pre">
      i-th
     </span>
     matrix under given tolerance and maximum sweeps.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Structure filled with parameters of Jacobi algorithm.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      batchSize
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of matrices.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n&lt;0
     </span>
     , or
     <span class="pre">
      lda&lt;max(1,n)
     </span>
     , or
     <span class="pre">
      jobz
     </span>
     is not
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     or
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     , or
     <span class="pre">
      uplo
     </span>
     is not
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     or
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     ), or
     <span class="pre">
      batchSize&lt;0
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.4.4.
  </span>
  Dense Linear Solver Reference (64-bit API)
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#dense-linear-solver-reference-64-bit-api" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  This section describes linear solver 64-bit API of cuSolverDN, including Cholesky factorization, LU with partial pivoting and QR factorization.
 </p>
 <h4>
  <span class="section-number">
   2.4.4.1.
  </span>
  cusolverDnXpotrf()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxpotrf" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The helper functions below can calculate the sizes needed for pre-allocated buffer.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnXpotrf_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytesOnDevice</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytesOnHost</span><span class="p">)</span>
</pre>
 <p>
  The following routine:
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnXpotrf</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">bufferOnDevice</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">workspaceInBytesOnDevice</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">bufferOnHost</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">workspaceInBytesOnHost</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">)</span>
</pre>
 <p>
  computes the Cholesky factorization of a Hermitian positive-definite matrix using the generic API interface.
 </p>
 <p>
  <span class="pre">
   A
  </span>
  is a
  <span class="pre">
   nÃn
  </span>
  Hermitian matrix, only lower or upper part is meaningful. The input parameter
  <span class="pre">
   uplo
  </span>
  indicates which part of the matrix is used. The function would leave other part untouched.
 </p>
 <p>
  If input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_LOWER
  </span>
  , only lower triangular part of
  <span class="pre">
   A
  </span>
  is processed, and replaced by lower triangular Cholesky factor
  <span class="pre">
   L
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = L*L^{H}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  If input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_UPPER
  </span>
  , only upper triangular part of
  <span class="pre">
   A
  </span>
  is processed, and replaced by upper triangular Cholesky factor
  <span class="pre">
   U
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = U^{H}*U\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The user has to provide device and host working spaces which are pointed by input parameters
  <span class="pre">
   bufferOnDevice
  </span>
  and
  <span class="pre">
   bufferOnHost
  </span>
  . The input parameters
  <span class="pre">
   workspaceInBytesOnDevice
  </span>
  (and
  <span class="pre">
   workspaceInBytesOnHost
  </span>
  ) is size in bytes of the device (and host) working space, and it is returned by
  <span class="pre">
   cusolverDnXpotrf_bufferSize()
  </span>
  .
 </p>
 <p>
  If Cholesky factorization failed, i.e. some leading minor of
  <span class="pre">
   A
  </span>
  is not positive definite, or equivalently some diagonal elements of
  <span class="pre">
   L
  </span>
  or
  <span class="pre">
   U
  </span>
  is not a real number. The output parameter
  <span class="pre">
   info
  </span>
  would indicate smallest leading minor of
  <span class="pre">
   A
  </span>
  which is not positive definite.
 </p>
 <p>
  If output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  Currently,
  <span class="pre">
   cusolverDnXpotrf
  </span>
  supports only the default algorithm.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/Xpotrf">
   cuSOLVER Library Samples - Xpotrf
  </a>
  for a code example.
 </p>
 <p>
  Table of algorithms supported by cusolverDnXpotrf
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_ALG_0
     </span>
     or
     <span class="pre">
      NULL
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm.
    </p>
   </td>
  </tr>
 </table>
 <p>
  List of input arguments for
  <span class="pre">
   cusolverDnXpotrf_bufferSize
  </span>
  and
  <span class="pre">
   cusolverDnXpotrf
  </span>
  :
 </p>
 <p>
  API of potrf
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Structure with information collected by
     <span class="pre">
      cusolverDnSetAdvOptions
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Indicates if matrix
     <span class="pre">
      A
     </span>
     lower or upper part is stored, the other part is not referenced.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dataTypeA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of computation.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bufferOnDevice
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Device workspace. Array of type
     <span class="pre">
      void
     </span>
     of size
     <span class="pre">
      workspaceInBytesOnDevice
     </span>
     bytes.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      workspaceInBytesOnDevice
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      bufferOnDevice
     </span>
     , returned by
     <span class="pre">
      cusolverDnXpotrf_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bufferOnHost
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Host workspace. Array of type
     <span class="pre">
      void
     </span>
     of size
     <span class="pre">
      workspaceInBytesOnHost
     </span>
     bytes.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      workspaceInBytesOnHost
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      bufferOnHost
     </span>
     , returned by
     <span class="pre">
      cusolverDnXpotrf_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the Cholesky factorization is successful. If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle). If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      i
     </span>
     , the leading minor of order
     <span class="pre">
      i
     </span>
     is not positive definite.
    </p>
   </td>
  </tr>
 </table>
 <p>
  The generic API has two different types,
  <span class="pre">
   dataTypeA
  </span>
  is data type of the matrix
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   computeType
  </span>
  is compute type of the operation.
  <span class="pre">
   cusolverDnXpotrf
  </span>
  only supports the following four combinations.
 </p>
 <p>
  Valid combination of data type and compute type
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     DataTypeA
    </p>
   </th>
   <th class="head">
    <p>
     ComputeType
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      SPOTRF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      DPOTRF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CPOTRF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ZPOTRF
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n&lt;0
     </span>
     or
     <span class="pre">
      lda&lt;max(1,n)
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.4.2.
  </span>
  cusolverDnXpotrs()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxpotrs" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnXpotrs</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeB</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">)</span>
</pre>
 <p>
  This function solves a system of linear equations
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A*X = B\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   A
  </span>
  is a
  <span class="pre">
   nÃn
  </span>
  Hermitian matrix, only lower or upper part is meaningful using the generic API interface. The input parameter
  <span class="pre">
   uplo
  </span>
  indicates which part of the matrix is used. The function would leave other part untouched.
 </p>
 <p>
  The user has to call
  <span class="pre">
   cusolverDnXpotrf
  </span>
  first to factorize matrix
  <span class="pre">
   A
  </span>
  . If input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_LOWER
  </span>
  ,
  <span class="pre">
   A
  </span>
  is lower triangular Cholesky factor
  <span class="pre">
   L
  </span>
  corresponding to
  <span class="math notranslate nohighlight">
   \(A = L*L^{H}\)
  </span>
  . If input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_UPPER
  </span>
  ,
  <span class="pre">
   A
  </span>
  is upper triangular Cholesky factor
  <span class="pre">
   U
  </span>
  corresponding to
  <span class="math notranslate nohighlight">
   \(A = U^{H}*U\)
  </span>
  .
 </p>
 <p>
  The operation is in-place, i.e. matrix
  <span class="pre">
   X
  </span>
  overwrites matrix
  <span class="pre">
   B
  </span>
  with the same leading dimension
  <span class="pre">
   ldb
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  Currently,
  <span class="pre">
   cusolverDnXpotrs
  </span>
  supports only the default algorithm.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/Xpotrf">
   cuSOLVER Library Samples - Xpotrf
  </a>
  for a code example.
 </p>
 <p>
  Table of algorithms supported by cusolverDnXpotrs
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_ALG_0
     </span>
     or
     <span class="pre">
      NULL
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm.
    </p>
   </td>
  </tr>
 </table>
 <p>
  List of input arguments for
  <span class="pre">
   cusolverDnXpotrs
  </span>
  :
 </p>
 <p>
  API of potrs
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Structure with information collected by
     <span class="pre">
      cusolverDnSetAdvOptions
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Indicates if matrix
     <span class="pre">
      A
     </span>
     lower or upper part is stored, the other part is not referenced.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nrhs
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of matrix
     <span class="pre">
      X
     </span>
     and
     <span class="pre">
      B
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dataTypeA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
     <span class="pre">
      A
     </span>
     is either lower Cholesky factor
     <span class="pre">
      L
     </span>
     or upper Cholesky factor
     <span class="pre">
      U
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dataTypeB
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      B
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      B
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension
     <span class="pre">
      ldb
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      nrhs
     </span>
     .
     <span class="pre">
      ldb
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     . As an input,
     <span class="pre">
      B
     </span>
     is right hand side matrix. As an output,
     <span class="pre">
      B
     </span>
     is the solution matrix.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the Cholesky factorization is successful. if
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle).
    </p>
   </td>
  </tr>
 </table>
 <p>
  The generic API has two different types,
  <span class="pre">
   dataTypeA
  </span>
  is data type of the matrix
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   dataTypeB
  </span>
  is data type of the matrix
  <span class="pre">
   B
  </span>
  .
  <span class="pre">
   cusolverDnXpotrs
  </span>
  only supports the following four combinations.
 </p>
 <p>
  Valid combination of data type and compute type
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     dataTypeA
    </p>
   </th>
   <th class="head">
    <p>
     dataTypeB
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      SPOTRS
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      DPOTRS
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CPOTRS
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ZPOTRS
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n&lt;0
     </span>
     ,
     <span class="pre">
      nrhs&lt;0
     </span>
     ,
     <span class="pre">
      lda&lt;max(1,n)
     </span>
     or
     <span class="pre">
      ldb&lt;max(1,n)
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.4.3.
  </span>
  cusolverDnXgetrf()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxgetrf" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The helper function below can calculate the sizes needed for pre-allocated buffer.
 </p>
 <pre><span class="n">cusolverStatus_t</span><span class="n">cusolverDnXgetrf_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytesOnDevice</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytesOnHost</span><span class="p">)</span>
</pre>
 <p>
  The function below
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnXgetrf</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">ipiv</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">bufferOnDevice</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">workspaceInBytesOnDevice</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">bufferOnHost</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">workspaceInBytesOnHost</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">)</span>
</pre>
 <p>
  computes the LU factorization of a
  <span class="pre">
   mÃn
  </span>
  matrix
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(P*A = L*U\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   A
  </span>
  is a
  <span class="pre">
   mÃn
  </span>
  matrix,
  <span class="pre">
   P
  </span>
  is a permutation matrix,
  <span class="pre">
   L
  </span>
  is a lower triangular matrix with unit diagonal, and
  <span class="pre">
   U
  </span>
  is an upper triangular matrix using the generic API interface.
 </p>
 <p>
  If LU factorization failed, i.e. matrix
  <span class="pre">
   A
  </span>
  (
  <span class="pre">
   U
  </span>
  ) is singular, The output parameter
  <span class="pre">
   info=i
  </span>
  indicates
  <span class="pre">
   U(i,i)
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   0
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  If
  <span class="pre">
   ipiv
  </span>
  is null, no pivoting is performed. The factorization is
  <span class="pre">
   A=L*U
  </span>
  , which is not numerically stable.
 </p>
 <p>
  No matter LU factorization failed or not, the output parameter
  <span class="pre">
   ipiv
  </span>
  contains pivoting sequence, row
  <span class="pre">
   i
  </span>
  is interchanged with row
  <span class="pre">
   ipiv(i)
  </span>
  .
 </p>
 <p>
  The user has to provide device and host working spaces which are pointed by input parameters
  <span class="pre">
   bufferOnDevice
  </span>
  and
  <span class="pre">
   bufferOnHost
  </span>
  . The input parameters
  <span class="pre">
   workspaceInBytesOnDevice
  </span>
  (and
  <span class="pre">
   workspaceInBytesOnHost
  </span>
  ) is size in bytes of the device (and host) working space, and it is returned by
  <span class="pre">
   cusolverDnXgetrf_bufferSize()
  </span>
  .
 </p>
 <p>
  The user can combine
  <span class="pre">
   cusolverDnXgetrf
  </span>
  and
  <span class="pre">
   cusolverDnGetrs
  </span>
  to complete a linear solver.
 </p>
 <p>
  Currently,
  <span class="pre">
   cusolverDnXgetrf
  </span>
  supports two algorithms. To select legacy implementation, the user has to call
  <span class="pre">
   cusolverDnSetAdvOptions
  </span>
  .
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/Xgetrf">
   cuSOLVER Library Samples - Xgetrf
  </a>
  for a code example.
 </p>
 <p>
  Table of algorithms supported by cusolverDnXgetrf
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_ALG_0
     </span>
     or
     <span class="pre">
      NULL
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm. The fastest, requires a large workspace of
     <span class="pre">
      m*n
     </span>
     elements.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_ALG_1
     </span>
    </p>
   </td>
   <td>
    <p>
     Legacy implementation
    </p>
   </td>
  </tr>
 </table>
 <p>
  List of input arguments for
  <span class="pre">
   cusolverDnXgetrf_bufferSize
  </span>
  and
  <span class="pre">
   cusolverDnXgetrf
  </span>
  :
 </p>
 <p>
  API of cusolverDnXgetrf
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Structure with information collected by
     <span class="pre">
      cusolverDnSetAdvOptions
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dataTypeA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,m)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ipiv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of size at least
     <span class="pre">
      min(m,n)
     </span>
     , containing pivot indices.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of computation.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bufferOnDevice
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Device workspace. Array of type
     <span class="pre">
      void
     </span>
     of size
     <span class="pre">
      workspaceInBytesOnDevice
     </span>
     bytes.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      workspaceInBytesOnDevice
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      bufferOnDevice
     </span>
     , returned by
     <span class="pre">
      cusolverDnXgetrf_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bufferOnHost
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Host workspace. Array of type
     <span class="pre">
      void
     </span>
     of size
     <span class="pre">
      workspaceInBytesOnHost
     </span>
     bytes.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      workspaceInBytesOnHost
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      bufferOnHost
     </span>
     , returned by
     <span class="pre">
      cusolverDnXgetrf_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the LU factorization is successful. if
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle). If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      i
     </span>
     , the
     <span class="pre">
      U(i,i)
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  The generic API has two different types,
  <span class="pre">
   dataTypeA
  </span>
  is data type of the matrix
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   computeType
  </span>
  is compute type of the operation.
  <span class="pre">
   cusolverDnXgetrf
  </span>
  only supports the following four combinations.
 </p>
 <p>
  valid combination of data type and compute type
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     DataTypeA
    </p>
   </th>
   <th class="head">
    <p>
     ComputeType
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      SGETRF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      DGETRF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CGETRF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ZGETRF
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      m,n&lt;0
     </span>
     or
     <span class="pre">
      lda&lt;max(1,m)
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.4.4.
  </span>
  cusolverDnXgetrs()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxgetrs" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnXgetrs</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="n">cublasOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int64_t</span><span class="o">*</span><span class="n">ipiv</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeB</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">)</span>
</pre>
 <p>
  This function solves a linear system of multiple right-hand sides
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \({op(A)}*X = B\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   A
  </span>
  is a
  <span class="pre">
   nÃn
  </span>
  matrix, and was LU-factored by
  <span class="pre">
   cusolverDnXgetrf
  </span>
  , that is, lower triangular part of A is
  <span class="pre">
   L
  </span>
  , and upper triangular part (including diagonal elements) of
  <span class="pre">
   A
  </span>
  is
  <span class="pre">
   U
  </span>
  .
  <span class="pre">
   B
  </span>
  is a
  <span class="pre">
   nÃnrhs
  </span>
  right-hand side matrix using the generic API interface.
 </p>
 <p>
  The input parameter
  <span class="pre">
   trans
  </span>
  is defined by
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(\text{op}(A) = \left\{ \begin{matrix}
A &amp; {\text{if~}\textsf{trans\ ==\ CUBLAS\_OP\_N}} \\
A^{T} &amp; {\text{if~}\textsf{trans\ ==\ CUBLAS\_OP\_T}} \\
A^{H} &amp; {\text{if~}\textsf{trans\ ==\ CUBLAS\_OP\_C}} \\
\end{matrix} \right.\)
  </span>
 </p>
 <p>
  The input parameter
  <span class="pre">
   ipiv
  </span>
  is an output of
  <span class="pre">
   cusolverDnXgetrf
  </span>
  . It contains pivot indices, which are used to permutate right-hand sides.
 </p>
 <p>
  If output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  The user can combine
  <span class="pre">
   cusolverDnXgetrf
  </span>
  and
  <span class="pre">
   cusolverDnXgetrs
  </span>
  to complete a linear solver.
 </p>
 <p>
  Currently,
  <span class="pre">
   cusolverDnXgetrs
  </span>
  supports only the default algorithm.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/Xgetrf">
   cuSOLVER Library Samples - Xgetrf
  </a>
  for a code example.
 </p>
 <p>
  Table of algorithms supported by cusolverDnXgetrs
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_ALG_0
     </span>
     or
     <span class="pre">
      NULL
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm.
    </p>
   </td>
  </tr>
 </table>
 <p>
  List of input arguments for
  <span class="pre">
   cusolverDnXgetrs
  </span>
  :
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Structure with information collected by
     <span class="pre">
      cusolverDnSetAdvOptions
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      trans
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Operation
     <span class="pre">
      op(A)
     </span>
     that is non- or (conj.) transpose.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nrhs
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of right-hand sides.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dataTypeA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ipiv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of size at least
     <span class="pre">
      n
     </span>
     , containing pivot indices.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dataTypeB
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      B
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      B
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of dimension
     <span class="pre">
      ldb
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      nrhs
     </span>
     with
     <span class="pre">
      ldb
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ldb
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      B
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the operation is successful. If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle).
    </p>
   </td>
  </tr>
 </table>
 <p>
  The generic API has two different types:
  <span class="pre">
   dataTypeA
  </span>
  is data type of the matrix
  <span class="pre">
   A
  </span>
  and
  <span class="pre">
   dataTypeB
  </span>
  is data type of the matrix
  <span class="pre">
   B
  </span>
  .
  <span class="pre">
   cusolverDnXgetrs
  </span>
  only supports the following four combinations:
 </p>
 <p>
  Valid combination of data type and compute type
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     DataTypeA
    </p>
   </th>
   <th class="head">
    <p>
     dataTypeB
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      SGETRS
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      DGETRS
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CGETRS
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ZGETRS
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n&lt;0
     </span>
     or
     <span class="pre">
      lda&lt;max(1,n)
     </span>
     or
     <span class="pre">
      ldb&lt;max(1,n)
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.4.5.
  </span>
  cusolverDnXgeqrf()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxgeqrf" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The helper functions below can calculate the sizes needed for pre-allocated buffer.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnXgeqrf_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeTau</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytesOnDevice</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytesOnHost</span><span class="p">)</span>
</pre>
 <p>
  The following routine:
 </p>
 <pre><span class="n">cusolverStatus_t</span><span class="n">cusolverDnXgeqrf</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeTau</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">bufferOnDevice</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">workspaceInBytesOnDevice</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">bufferOnHost</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">workspaceInBytesOnHost</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">)</span>
</pre>
 <p>
  computes the QR factorization of a
  <span class="pre">
   mÃn
  </span>
  matrix
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = Q*R\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   mÃn
  </span>
  matrix,
  <span class="pre">
   Q
  </span>
  is a
  <span class="pre">
   mÃn
  </span>
  matrix, and
  <span class="pre">
   R
  </span>
  is an
  <span class="pre">
   nÃn
  </span>
  upper triangular matrix using the generic API interface.
 </p>
 <p>
  The user has to provide device and host working spaces which are pointed by input parameters
  <span class="pre">
   bufferOnDevice
  </span>
  and
  <span class="pre">
   bufferOnHost
  </span>
  . The input parameters
  <span class="pre">
   workspaceInBytesOnDevice
  </span>
  (and
  <span class="pre">
   workspaceInBytesOnHost
  </span>
  ) is size in bytes of the device (and host) working space, and it is returned by
  <span class="pre">
   cusolverDnXgeqrf_bufferSize()
  </span>
  .
 </p>
 <p>
  The matrix
  <span class="pre">
   R
  </span>
  is overwritten in upper triangular part of
  <span class="pre">
   A
  </span>
  , including diagonal elements.
 </p>
 <p>
  The matrix
  <span class="pre">
   Q
  </span>
  is not formed explicitly, instead, a sequence of householder vectors are stored in lower triangular part of
  <span class="pre">
   A
  </span>
  . The leading nonzero element of householder vector is assumed to be 1 such that output parameter
  <span class="pre">
   TAU
  </span>
  contains the scaling factor
  <span class="pre">
   Ï
  </span>
  . If
  <span class="pre">
   v
  </span>
  is original householder vector,
  <span class="pre">
   q
  </span>
  is the new householder vector corresponding to
  <span class="pre">
   Ï
  </span>
  , satisfying the following relation
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(I - 2*v*v^{H} = I - \tau*q*q^{H}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  If output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  Currently,
  <span class="pre">
   cusolverDnXgeqrf
  </span>
  supports only the default algorithm.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/Xgeqrf">
   cuSOLVER Library Samples - Xgeqrf
  </a>
  for a code example.
 </p>
 <p>
  Table of algorithms supported by cusolverDnXgeqrf
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_ALG_0
     </span>
     or
     <span class="pre">
      NULL
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm.
    </p>
   </td>
  </tr>
 </table>
 <p>
  List of input arguments for
  <span class="pre">
   cusolverDnXgeqrf_bufferSize
  </span>
  and
  <span class="pre">
   cusolverDnXgeqrf
  </span>
  :
 </p>
 <p>
  API of geqrf
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Structure with information collected by
     <span class="pre">
      cusolverDnSetAdvOptions
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dataTypeA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,m)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dataTypeTau
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      tau
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      tau
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension at least
     <span class="pre">
      min(m,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of computation.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bufferOnDevice
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Device workspace. Array of type
     <span class="pre">
      void
     </span>
     of size
     <span class="pre">
      workspaceInBytesOnDevice
     </span>
     bytes.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      workspaceInBytesOnDevice
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      bufferOnDevice
     </span>
     , returned by
     <span class="pre">
      cusolverDnXgeqrf_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bufferOnHost
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Host workspace. Array of type
     <span class="pre">
      void
     </span>
     of size
     <span class="pre">
      workspaceInBytesOnHost
     </span>
     bytes.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      workspaceInBytesOnHost
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      bufferOnHost
     </span>
     , returned by
     <span class="pre">
      cusolverDnXgeqrf_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the QR factorization is successful. If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle).
    </p>
   </td>
  </tr>
 </table>
 <p>
  The generic API has two different types,
  <span class="pre">
   dataTypeA
  </span>
  is data type of the matrix
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   dataTypeTau
  </span>
  is data type of the array
  <span class="pre">
   tau
  </span>
  and
  <span class="pre">
   computeType
  </span>
  is compute type of the operation.
  <span class="pre">
   cusolverDnXgeqrf
  </span>
  only supports the following four combinations.
 </p>
 <p>
  Valid combination of data type and compute type
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     DataTypeA
    </p>
   </th>
   <th class="head">
    <p>
     ComputeType
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      SGEQRF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      DGEQRF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CGEQRF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ZGEQRF
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      m,n&lt;0
     </span>
     or
     <span class="pre">
      lda&lt;max(1,m)
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.4.6.
  </span>
  cusolverDnXsytrs()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxsytrs" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The helper functions below can calculate the sizes needed for pre-allocated buffers.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnXsytrs_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int64_t</span><span class="o">*</span><span class="n">ipiv</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeB</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytesOnDevice</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytesOnHost</span><span class="p">);</span>
</pre>
 <p>
  The following routine:
 </p>
 <pre><span class="n">cusolverStatus_t</span><span class="nf">cusolverDnXsytrs</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">nrhs</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int64_t</span><span class="o">*</span><span class="n">ipiv</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeB</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">bufferOnDevice</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">workspaceInBytesOnDevice</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">bufferOnHost</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">workspaceInBytesOnHost</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">);</span>
</pre>
 <p>
  solves a system of linear equations using the generic API interface.
 </p>
 <p>
  <span class="pre">
   A
  </span>
  contains the factorization from
  <span class="pre">
   cusolverDnXsytrf()
  </span>
  , only lower or upper part is meaningful, the other part is not touched.
 </p>
 <p>
  If input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_LOWER
  </span>
  , the details of the factorization are stores as:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = L*D*L^{T}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  If input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_UPPER
  </span>
  , the details of the factorization are stores as:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = U*D*U^{T}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The user has to provide the pivot indices that can be obtained by
  <span class="pre">
   cusolverDnXsytrf()
  </span>
  as well as device and host work spaces which are pointed by input parameters
  <span class="pre">
   bufferOnDevice
  </span>
  and
  <span class="pre">
   bufferOnHost
  </span>
  . The input parameters
  <span class="pre">
   workspaceInBytesOnDevice
  </span>
  and
  <span class="pre">
   workspaceInBytesOnHost
  </span>
  are sizes in bytes of the device and host work spaces, and they are returned by
  <span class="pre">
   cusolverDnXsytrs_bufferSize()
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  List of input arguments for
  <span class="pre">
   cusolverDnXsytrs_bufferSize
  </span>
  and
  <span class="pre">
   cusolverDnXsytrs
  </span>
  :
 </p>
 <p>
  API of sytrs
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Indicates if matrix
     <span class="pre">
      A
     </span>
     lower or upper part is stored, the other part is not referenced.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nrhs
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of right-hand sides.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dataTypeA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ipiv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of size at least
     <span class="pre">
      n
     </span>
     , containing pivot indices.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dataTypeB
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      B
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      B
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension
     <span class="pre">
      ldb
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      nrhs
     </span>
     with
     <span class="pre">
      ldb
     </span>
     is not less than
     <span class="pre">
      max(1,nrhs)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ldb
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      B
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bufferOnDevice
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Device workspace. Array of type
     <span class="pre">
      void
     </span>
     of size
     <span class="pre">
      workspaceInBytesOnDevice
     </span>
     bytes.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      workspaceInBytesOnDevice
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      bufferOnDevice
     </span>
     , returned by
     <span class="pre">
      cusolverDnXsytrs_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bufferOnHost
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Host workspace. Array of type
     <span class="pre">
      void
     </span>
     of size
     <span class="pre">
      workspaceInBytesOnHost
     </span>
     bytes.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      workspaceInBytesOnHost
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      bufferOnHost
     </span>
     , returned by
     <span class="pre">
      cusolverDnXsytrs_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the Cholesky factorization is successful. If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle). If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     Â
     <span class="pre">
      i
     </span>
     , the leading minor of order i is not positive definite.
    </p>
   </td>
  </tr>
 </table>
 <p>
  The generic API has two different types:
  <span class="pre">
   dataTypeA
  </span>
  is data type of the matrix
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   dataTypeB
  </span>
  is data type of the matrix
  <span class="pre">
   A
  </span>
  .
  <span class="pre">
   cusolverDnXsytrs
  </span>
  only supports the following four combinations:
 </p>
 <p>
  Valid combination of data type and compute type
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     DataTypeA
    </p>
   </th>
   <th class="head">
    <p>
     DataTypeB
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      SSYTRS
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      DSYTRS
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CSYTRS
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ZSYTRS
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n&lt;0
     </span>
     or
     <span class="pre">
      lda&lt;max(1,n)
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type is not supported.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.4.7.
  </span>
  cusolverDnXtrtri()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxtrtri" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The helper functions below can calculate the sizes needed for pre-allocated buffers.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnXtrtri_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="n">cublasDiagType_t</span><span class="n">diag</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytesOnDevice</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytesOnHost</span><span class="p">);</span>
</pre>
 <p>
  The following routine:
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverDnXtrtri</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="n">cublasDiagType_t</span><span class="n">diag</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">bufferOnDevice</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">workspaceInBytesOnDevice</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">bufferOnHost</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">workspaceInBytesOnHost</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">);</span>
</pre>
 <p>
  computes the inverse of a triangular matrix using the generic API interface.
 </p>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   nÃn
  </span>
  triangular matrix, only lower or upper part is meaningful. The input parameter
  <span class="pre">
   uplo
  </span>
  indicates which part of the matrix is used. The function would leave other part untouched.
 </p>
 <p>
  If input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_LOWER
  </span>
  , only lower triangular part of
  <span class="pre">
   A
  </span>
  is processed, and replaced by lower triangular inverse.
 </p>
 <p>
  If input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_UPPER
  </span>
  , only upper triangular part of
  <span class="pre">
   A
  </span>
  is processed, and replaced by upper triangular inverse.
 </p>
 <p>
  The user has to provide device and host work spaces which are pointed by input parameters
  <span class="pre">
   bufferOnDevice
  </span>
  and
  <span class="pre">
   bufferOnHost
  </span>
  . The input parameters
  <span class="pre">
   workspaceInBytesOnDevice
  </span>
  and
  <span class="pre">
   workspaceInBytesOnHost
  </span>
  are sizes in bytes of the device and host work spaces, and they are returned by
  <span class="pre">
   cusolverDnXtrtri_bufferSize()
  </span>
  .
 </p>
 <p>
  If matrix inversion fails, the output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   i
  </span>
  shows
  <span class="pre">
   A(i,i)
  </span>
  <span class="pre">
   =
  </span>
  Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â
  <span class="pre">
   0
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/Xtrtri">
   cuSOLVER Library Samples - Xtrtri
  </a>
  for a code example.
 </p>
 <p>
  List of input arguments for
  <span class="pre">
   cusolverDnXtrtri_bufferSize
  </span>
  and
  <span class="pre">
   cusolverDnXtrtri
  </span>
  :
 </p>
 <p>
  API of trtri
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Indicates if matrix
     <span class="pre">
      A
     </span>
     lower or upper part is stored, the other part is not referenced.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      diag
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The enumerated unit diagonal type.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dataTypeA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bufferOnDevice
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Device workspace. Array of type
     <span class="pre">
      void
     </span>
     of size
     <span class="pre">
      workspaceInBytesOnDevice
     </span>
     bytes.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      workspaceInBytesOnDevice
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      bufferOnDevice
     </span>
     , returned by
     <span class="pre">
      cusolverDnXtrtri_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bufferOnHost
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Host workspace. Array of type
     <span class="pre">
      void
     </span>
     of size
     <span class="pre">
      workspaceInBytesOnHost
     </span>
     bytes.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      workspaceInBytesOnHost
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      bufferOnHost
     </span>
     , returned by
     <span class="pre">
      cusolverDnXtrtri_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the matrix inversion succeeded. If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle). If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      i
     </span>
     ,
     <span class="pre">
      A(i,i)
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Valid data types
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      DataTypeA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      Meaning
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      STRTRI
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      DTRTRI
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CTRTRI
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ZTRTRI
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_SUPPORTED
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type is not supported.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n&lt;0
     </span>
     or
     <span class="pre">
      lda&lt;max(1,n)
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.4.8.
  </span>
  cusolverDnXlarft()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxlarft" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The helper functions below can calculate the sizes needed for pre-allocated buffer.
 </p>
 <pre><span class="n">cusolverStatus_t</span><span class="n">cusolverDnXlarft_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="n">cusolverDirectMode_t</span><span class="n">direct</span><span class="p">,</span>
<span class="n">cusolverStorevMode_t</span><span class="n">storev</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">k</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeV</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">V</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ldv</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeTau</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeT</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">T</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ldt</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytesOnDevice</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytesOnHost</span><span class="p">)</span>
</pre>
 <p>
  The following routine:
 </p>
 <pre><span class="n">cusolverStatus_t</span><span class="n">cusolverDnXlarft</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="n">cusolverDirectMode_t</span><span class="n">direct</span><span class="p">,</span>
<span class="n">cusolverStorevMode_t</span><span class="n">storev</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">k</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeV</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">V</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ldv</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeTau</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeT</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">T</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ldt</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">bufferOnDevice</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">workspaceInBytesOnDevice</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">bufferOnHost</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">workspaceInBytesOnHost</span><span class="p">)</span>
</pre>
 <p>
  forms the triangular factor
  <span class="pre">
   T
  </span>
  of a real block reflector
  <span class="pre">
   H
  </span>
  of order
  <span class="pre">
   n
  </span>
  , which is defined as a product of
  <span class="pre">
   k
  </span>
  elementary reflectors.
If:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     direct
    </span>
    <span class="pre">
     ==
    </span>
    <span class="pre">
     CUBLAS_DIRECT_FORWARD
    </span>
    :
    <span class="math notranslate nohighlight">
     \(H = H(1) H(2) ... H(k)\)
    </span>
    and
    <span class="pre">
     T
    </span>
    is upper triangular;
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     direct
    </span>
    <span class="pre">
     ==
    </span>
    <span class="pre">
     CUBLAS_DIRECT_BACKWARD
    </span>
    :
    <span class="math notranslate nohighlight">
     \(H = H(k) ... H(2) H(1)\)
    </span>
    and
    <span class="pre">
     T
    </span>
    is lower triangular.
   </p>
  </li>
 </ul>
 <p>
  Only
  <span class="pre">
   storev
  </span>
  <span class="pre">
   ==
  </span>
  <span class="pre">
   CUBLAS_STOREV_COLUMNWISE
  </span>
  is supported, which indicates that the vector defining the elementary reflector
  <span class="pre">
   H(i)
  </span>
  is stored in the i-th column of the array
  <span class="pre">
   V
  </span>
  , and
  <span class="math notranslate nohighlight">
   \(H = I - V * T * V^{T}\)
  </span>
  (
  <span class="math notranslate nohighlight">
   \(H = I - V * T * V^{H}\)
  </span>
  for complex types).
 </p>
 <p>
  The user has to provide device and host working spaces which are pointed by input parameters
  <span class="pre">
   bufferOnDevice
  </span>
  and
  <span class="pre">
   bufferOnHost
  </span>
  . The input parameters
  <span class="pre">
   workspaceInBytesOnDevice
  </span>
  (and
  <span class="pre">
   workspaceInBytesOnHost
  </span>
  ) is size in bytes of the device (and host) working space, and it is returned by
  <span class="pre">
   cusolverDnXlarft_bufferSize()
  </span>
  .
 </p>
 <p>
  Currently, only
  <span class="pre">
   n
  </span>
  <span class="pre">
   &gt;=
  </span>
  <span class="pre">
   k
  </span>
  scenario is supported.
 </p>
 <p>
  API of larft
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Structure with information collected by
     <span class="pre">
      cusolverDnSetAdvOptions
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      direct
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies the order in which the elementary reflectors are multiplied to form the block reflector.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      storev
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies how the vectors which define the elementary reflectors are stored.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The order of the block reflector
     <span class="pre">
      H
     </span>
     .
     <span class="pre">
      n
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      0
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      k
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The order of the triangular factor
     <span class="pre">
      T
     </span>
     (= the number of elementary reflectors).
     <span class="pre">
      k
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      1
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dataTypeV
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      V
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      V
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix
     <span class="pre">
      V
     </span>
     of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      k
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ldv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of the array
     <span class="pre">
      V
     </span>
     .
     <span class="pre">
      ldv
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dataTypeTau
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      tau
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      tau
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Dimension
     <span class="pre">
      k
     </span>
     .
     <span class="pre">
      tau(i)
     </span>
     must contain the scalar factor of the elementary reflector
     <span class="pre">
      H(i)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dataTypeT
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      T
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      T
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Dimension
     <span class="pre">
      ldt
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      k
     </span>
     . The
     <span class="pre">
      kÃk
     </span>
     triangular factor
     <span class="pre">
      T
     </span>
     of the block reflector. If
     <span class="pre">
      direct
     </span>
     <span class="pre">
      ==
     </span>
     <span class="pre">
      CUBLAS_DIRECT_FORWARD
     </span>
     ,
     <span class="pre">
      T
     </span>
     is upper triangular; if
     <span class="pre">
      direct
     </span>
     <span class="pre">
      ==
     </span>
     <span class="pre">
      CUBLAS_DIRECT_BACKWARD
     </span>
     ,
     <span class="pre">
      T
     </span>
     is lower triangular.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ldt
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The leading dimension of the array
     <span class="pre">
      T
     </span>
     .
     <span class="pre">
      ldt
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      k
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of computation.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bufferOnDevice
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Device workspace. Array of type
     <span class="pre">
      void
     </span>
     of size
     <span class="pre">
      workspaceInBytesOnDevice
     </span>
     bytes.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      workspaceInBytesOnDevice
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      bufferOnDevice
     </span>
     , returned by
     <span class="pre">
      cusolverDnXlarft_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bufferOnHost
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Host workspace. Array of type
     <span class="pre">
      void
     </span>
     of size
     <span class="pre">
      workspaceInBytesOnHost
     </span>
     bytes.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      workspaceInBytesOnHost
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      bufferOnHost
     </span>
     , returned by
     <span class="pre">
      cusolverDnXlarft_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  The generic API has four different types:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     dataTypeV
    </span>
    is data type of the array
    <span class="pre">
     V
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     dataTypeTau
    </span>
    is data type of the array
    <span class="pre">
     tau
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     dataTypeT
    </span>
    is data type of the array
    <span class="pre">
     T
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     computeType
    </span>
    is compute type of the operation
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusolverDnXlarft
  </span>
  only supports the following four combinations.
 </p>
 <p>
  Valid combinations of data types and compute types
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     DataTypeV
    </p>
   </th>
   <th class="head">
    <p>
     DataTypeTau
    </p>
   </th>
   <th class="head">
    <p>
     DataTypeT
    </p>
   </th>
   <th class="head">
    <p>
     ComputeType
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      SLARFT
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      DLARFT
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CLARFT
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ZLARFT
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n
     </span>
     <span class="pre">
      ==
     </span>
     <span class="pre">
      0
     </span>
     ,
     <span class="pre">
      k
     </span>
     <span class="pre">
      &gt;
     </span>
     <span class="pre">
      n
     </span>
     , or
     <span class="pre">
      storev
     </span>
     <span class="pre">
      ==
     </span>
     <span class="pre">
      CUBLAS_STOREV_ROWWISE
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.4.5.
  </span>
  Dense Eigenvalue Solver Reference (64-bit API)
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#dense-eigenvalue-solver-reference-64-bit-api" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  This section describes eigenvalue solver API of cuSolverDN, including bidiagonalization and SVD.
 </p>
 <h4>
  <span class="section-number">
   2.4.5.1.
  </span>
  cusolverDnXgesvd()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxgesvd" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The helper functions below can calculate the sizes needed for pre-allocated buffer.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnXgesvd_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">signed</span><span class="kt">char</span><span class="n">jobu</span><span class="p">,</span>
<span class="kt">signed</span><span class="kt">char</span><span class="n">jobvt</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeS</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeU</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ldu</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeVT</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">VT</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ldvt</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytesOnDevice</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytesOnHost</span><span class="p">)</span>
</pre>
 <p>
  The following routine:
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnXgesvd</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">signed</span><span class="kt">char</span><span class="n">jobu</span><span class="p">,</span>
<span class="kt">signed</span><span class="kt">char</span><span class="n">jobvt</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeS</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeU</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ldu</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeVT</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">VT</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ldvt</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">bufferOnDevice</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">workspaceInBytesOnDevice</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">bufferOnHost</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">workspaceInBytesOnHost</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">)</span>
</pre>
 <p>
  This function computes the singular value decomposition (SVD) of a
  <span class="pre">
   mÃn
  </span>
  matrix
  <span class="pre">
   A
  </span>
  and corresponding the left and/or right singular vectors. The SVD is written
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = U*\Sigma*V^{H}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   Î£
  </span>
  is an
  <span class="pre">
   mÃn
  </span>
  matrix which is zero except for its
  <span class="pre">
   min(m,n)
  </span>
  diagonal elements,
  <span class="pre">
   U
  </span>
  is an
  <span class="pre">
   mÃm
  </span>
  unitary matrix, and
  <span class="pre">
   V
  </span>
  is an
  <span class="pre">
   nÃn
  </span>
  unitary matrix. The diagonal elements of
  <span class="pre">
   Î£
  </span>
  are the singular values of
  <span class="pre">
   A
  </span>
  ; they are real and non-negative, and are returned in descending order. The first
  <span class="pre">
   min(m,n)
  </span>
  columns of
  <span class="pre">
   U
  </span>
  and
  <span class="pre">
   V
  </span>
  are the left and right singular vectors of
  <span class="pre">
   A
  </span>
  .
 </p>
 <p>
  The user has to provide device and host working spaces which are pointed by input parameters
  <span class="pre">
   bufferOnDevice
  </span>
  and
  <span class="pre">
   bufferOnHost
  </span>
  . The input parameters
  <span class="pre">
   workspaceInBytesOnDevice
  </span>
  (and
  <span class="pre">
   workspaceInBytesOnHost
  </span>
  ) is size in bytes of the device (and host) working space, and it is returned by
  <span class="pre">
   cusolverDnXgesvd_bufferSize()
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle). if
  <span class="pre">
   bdsqr
  </span>
  did not converge,
  <span class="pre">
   info
  </span>
  specifies how many superdiagonals of an intermediate bidiagonal form did not converge to zero.
 </p>
 <p>
  Currently,
  <span class="pre">
   cusolverDnXgesvd
  </span>
  supports only the default algorithm.
 </p>
 <p>
  Table of algorithms supported by cusolverDnXgesvd
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_ALG_0
     </span>
     or
     <span class="pre">
      NULL
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/Xgesvd">
   cuSOLVER Library Samples - Xgesvd
  </a>
  for a code example.
 </p>
 <p>
  Remark 1:
  <span class="pre">
   gesvd
  </span>
  only supports
  <span class="pre">
   m&gt;=n
  </span>
  .
 </p>
 <p>
  Remark 2: the routine returns
  <span class="math notranslate nohighlight">
   \(V^{H}\)
  </span>
  , not
  <span class="pre">
   V
  </span>
  .
 </p>
 <p>
  List of input arguments for
  <span class="pre">
   cusolverDnXgesvd_bufferSize
  </span>
  and
  <span class="pre">
   cusolverDnXgesvd
  </span>
  :
 </p>
 <p>
  API of cusolverDnXgesvd
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Structure with information collected by
     <span class="pre">
      cusolverDnSetAdvOptions
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      jobu
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies options for computing all or part of the matrix
     <span class="pre">
      U
     </span>
     : = âAâ: all m columns of U are returned in array U: = âSâ: the first min(m,n) columns of U (the left singular vectors) are returned in the array U; = âOâ: the first min(m,n) columns of U (the left singular vectors) are overwritten on the array A; = âNâ: no columns of U (no left singular vectors) are computed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      jobvt
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies options for computing all or part of the matrix V**T: = âAâ: all N rows of V**T are returned in the array VT; = âSâ: the first min(m,n) rows of V**T (the right singular vectors) are returned in the array VT; = âOâ: the first min(m,n) rows of V**T (the right singular vectors) are overwritten on the array A; = âNâ: no rows of V**T (no right singular vectors) are computed.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dataTypeA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,m)
     </span>
     . On exit, the contents of
     <span class="pre">
      A
     </span>
     are destroyed.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dataTypeS
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      S
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      S
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Real array of dimension
     <span class="pre">
      min(m,n)
     </span>
     . The singular values of A, sorted so that
     <span class="pre">
      S(i)
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      S(i+1)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dataTypeU
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      U
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      U
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension
     <span class="pre">
      ldu
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      m
     </span>
     with
     <span class="pre">
      ldu
     </span>
     is not less than
     <span class="pre">
      max(1,m)
     </span>
     .
     <span class="pre">
      U
     </span>
     contains the
     <span class="pre">
      mÃm
     </span>
     unitary matrix
     <span class="pre">
      U
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ldu
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      U
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dataTypeVT
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      VT
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      VT
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension
     <span class="pre">
      ldvt
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      ldvt
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
     <span class="pre">
      VT
     </span>
     contains the
     <span class="pre">
      nÃn
     </span>
     unitary matrix V**T.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ldvt
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      Vt
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of computation.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bufferOnDevice
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Device workspace. Array of type
     <span class="pre">
      void
     </span>
     of size
     <span class="pre">
      workspaceInBytesOnDevice
     </span>
     bytes.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      workspaceInBytesOnDevice
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      bufferOnDevice
     </span>
     , returned by
     <span class="pre">
      cusolverDnXgesvd_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bufferOnHost
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Host workspace. Array of type
     <span class="pre">
      void
     </span>
     of size
     <span class="pre">
      workspaceInBytesOnHost
     </span>
     bytes.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      workspaceInBytesOnHost
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      bufferOnHost
     </span>
     , returned by
     <span class="pre">
      cusolverDnXgesvd_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the operation is successful. If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle). If
     <span class="pre">
      info
     </span>
     <span class="pre">
      &gt;
     </span>
     <span class="pre">
      0
     </span>
     ,
     <span class="pre">
      info
     </span>
     indicates how many superdiagonals of an intermediate bidiagonal form did not converge to zero.
    </p>
   </td>
  </tr>
 </table>
 <p>
  The generic API has three different types,
  <span class="pre">
   dataTypeA
  </span>
  is data type of the matrix
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   dataTypeS
  </span>
  is data type of the vector
  <span class="pre">
   S
  </span>
  and
  <span class="pre">
   dataTypeU
  </span>
  is data type of the matrix
  <span class="pre">
   U
  </span>
  ,
  <span class="pre">
   dataTypeVT
  </span>
  is data type of the matrix
  <span class="pre">
   VT
  </span>
  ,
  <span class="pre">
   computeType
  </span>
  is compute type of the operation.
  <span class="pre">
   cusolverDnXgesvd
  </span>
  only supports the following four combinations.
 </p>
 <p>
  Valid combination of data type and compute type
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     DataTypeA
    </p>
   </th>
   <th class="head">
    <p>
     DataTypeS
    </p>
   </th>
   <th class="head">
    <p>
     DataTypeU
    </p>
   </th>
   <th class="head">
    <p>
     DataTypeVT
    </p>
   </th>
   <th class="head">
    <p>
     ComputeType
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      SGESVD
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      DGESVD
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CGESVD
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ZGESVD
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      m,n&lt;0
     </span>
     or
     <span class="pre">
      lda&lt;max(1,m)
     </span>
     or
     <span class="pre">
      ldu&lt;max(1,m)
     </span>
     or
     <span class="pre">
      ldvt&lt;max(1,n)
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.5.2.
  </span>
  cusolverDnXgesvdp()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxgesvdp" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The helper functions below can calculate the sizes needed for pre-allocated buffer.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnXgesvdp_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="kt">int</span><span class="n">econ</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeS</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeU</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ldu</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeV</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">V</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ldv</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytesOnDevice</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytesOnHost</span><span class="p">)</span>
</pre>
 <p>
  The routine below:
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnXgesvdp</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="kt">int</span><span class="n">econ</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeS</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">S</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeU</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ldu</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeV</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">V</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ldv</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">bufferOnDevice</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">workspaceInBytesOnDevice</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">bufferOnHost</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">workspaceInBytesOnHost</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">d_info</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">h_err_sigma</span><span class="p">)</span>
</pre>
 <p>
  This function computes the singular value decomposition (SVD) of a
  <span class="pre">
   mÃn
  </span>
  matrix
  <span class="pre">
   A
  </span>
  and corresponding the left and/or right singular vectors. The SVD is written
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = U*\Sigma*V^{H}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   Î£
  </span>
  is an
  <span class="pre">
   mÃn
  </span>
  matrix which is zero except for its
  <span class="pre">
   min(m,n)
  </span>
  diagonal elements,
  <span class="pre">
   U
  </span>
  is an
  <span class="pre">
   mÃm
  </span>
  unitary matrix, and
  <span class="pre">
   V
  </span>
  is an
  <span class="pre">
   nÃn
  </span>
  unitary matrix. The diagonal elements of
  <span class="pre">
   Î£
  </span>
  are the singular values of
  <span class="pre">
   A
  </span>
  ; they are real and non-negative, and are returned in descending order. The first
  <span class="pre">
   min(m,n)
  </span>
  columns of
  <span class="pre">
   U
  </span>
  and
  <span class="pre">
   V
  </span>
  are the left and right singular vectors of
  <span class="pre">
   A
  </span>
  .
 </p>
 <p>
  <span class="pre">
   cusolverDnXgesvdp
  </span>
  combines polar decomposition in [14] and
  <span class="pre">
   cusolverDnXsyevd
  </span>
  to compute SVD. It is much faster than
  <span class="pre">
   cusolverDnXgesvd
  </span>
  which is based on QR algorithm. However polar decomposition in [14] may not deliver a full unitary matrix when the matrix A has a singular value close to zero. To workaround the issue when the singular value is close to zero, we add a small perturbation so polar decomposition can deliver the correct result. The consequence is inaccurate singular values shifted by this perturbation. The output parameter
  <span class="pre">
   h_err_sigma
  </span>
  is the magnitude of this perturbation. In other words,
  <span class="pre">
   h_err_sigma
  </span>
  shows the accuracy of SVD.
 </p>
 <p>
  The user has to provide device and host working spaces which are pointed by input parameters
  <span class="pre">
   bufferOnDevice
  </span>
  and
  <span class="pre">
   bufferOnHost
  </span>
  . The input parameters
  <span class="pre">
   workspaceInBytesOnDevice
  </span>
  (and
  <span class="pre">
   workspaceInBytesOnHost
  </span>
  ) is size in bytes of the device (and host) working space, and it is returned by
  <span class="pre">
   cusolverDnXgesvdp_bufferSize()
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  Currently,
  <span class="pre">
   cusolverDnXgesvdp
  </span>
  supports only the default algorithm.
 </p>
 <p>
  Table of algorithms supported by cusolverDnXgesvdp
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_ALG_0
     </span>
     or
     <span class="pre">
      NULL
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/Xgesvdp">
   cuSOLVER Library Samples - Xgesvdp
  </a>
  for a code example.
 </p>
 <p>
  Remark 1:
  <span class="pre">
   gesvdp
  </span>
  supports
  <span class="pre">
   n&gt;=m
  </span>
  as well.
 </p>
 <p>
  Remark 2: the routine returns
  <span class="pre">
   V
  </span>
  , not
  <span class="math notranslate nohighlight">
   \(V^{H}\)
  </span>
 </p>
 <p>
  List of input arguments for
  <span class="pre">
   cusolverDnXgesvdp_bufferSize
  </span>
  and
  <span class="pre">
   cusolverDnXgesvdp
  </span>
  :
 </p>
 <p>
  API of cusolverDnXgesvdp
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Structure with information collected by
     <span class="pre">
      cusolverDnSetAdvOptions
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      jobz
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies options to either compute singular values only or compute singular vectors as well:
    </p>
    <p>
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     : Compute singular values only.
    </p>
    <p>
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     : Compute singular values and singular vectors.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      econ
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      econ
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      1
     </span>
     for economy size for
     <span class="pre">
      U
     </span>
     and
     <span class="pre">
      V
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dataTypeA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,m)
     </span>
     . On exit, the contents of
     <span class="pre">
      A
     </span>
     are destroyed.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dataTypeS
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      S
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      S
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Real array of dimension
     <span class="pre">
      min(m,n)
     </span>
     . The singular values of A, sorted so that
     <span class="pre">
      S(i)
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      S(i+1)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dataTypeU
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      U
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      U
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension
     <span class="pre">
      ldu
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      m
     </span>
     with
     <span class="pre">
      ldu
     </span>
     is not less than
     <span class="pre">
      max(1,m)
     </span>
     .
     <span class="pre">
      U
     </span>
     contains the
     <span class="pre">
      mÃm
     </span>
     unitary matrix
     <span class="pre">
      U
     </span>
     . If
     <span class="pre">
      econ=1
     </span>
     , only reports first
     <span class="pre">
      min(m,n)
     </span>
     columns of
     <span class="pre">
      U
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ldu
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      U
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dataTypeV
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      V
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      V
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension
     <span class="pre">
      ldv
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      ldv
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
     <span class="pre">
      V
     </span>
     contains the
     <span class="pre">
      nÃn
     </span>
     unitary matrix V. if
     <span class="pre">
      econ=1
     </span>
     , only reports first
     <span class="pre">
      min(m,n)
     </span>
     columns of
     <span class="pre">
      V
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ldv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      V
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of computation.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bufferOnDevice
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Device workspace. Array of type
     <span class="pre">
      void
     </span>
     of size
     <span class="pre">
      workspaceInBytesOnDevice
     </span>
     bytes.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      workspaceInBytesOnDevice
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      bufferOnDevice
     </span>
     , returned by
     <span class="pre">
      cusolverDnXgesvdp_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bufferOnHost
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Host workspace. Array of type
     <span class="pre">
      void
     </span>
     of size
     <span class="pre">
      workspaceInBytesOnHost
     </span>
     bytes.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      workspaceInBytesOnHost
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      bufferOnHost
     </span>
     , returned by
     <span class="pre">
      cusolverDnXgesvdp_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the operation is successful. If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle).
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      h_err_sigma
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Magnitude of the perturbation, showing the accuracy of SVD.
    </p>
   </td>
  </tr>
 </table>
 <p>
  The generic API has three different types,
  <span class="pre">
   dataTypeA
  </span>
  is data type of the matrix
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   dataTypeS
  </span>
  is data type of the vector
  <span class="pre">
   S
  </span>
  and
  <span class="pre">
   dataTypeU
  </span>
  is data type of the matrix
  <span class="pre">
   U
  </span>
  ,
  <span class="pre">
   dataTypeV
  </span>
  is data type of the matrix
  <span class="pre">
   V
  </span>
  ,
  <span class="pre">
   computeType
  </span>
  is compute type of the operation.
  <span class="pre">
   cusolverDnXgesvdp
  </span>
  only supports the following four combinations:
 </p>
 <p>
  Valid combination of data type and compute type
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     DataTypeA
    </p>
   </th>
   <th class="head">
    <p>
     DataTypeS
    </p>
   </th>
   <th class="head">
    <p>
     DataTypeU
    </p>
   </th>
   <th class="head">
    <p>
     DataTypeV
    </p>
   </th>
   <th class="head">
    <p>
     ComputeType
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      SGESVDP
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      DGESVDP
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CGESVDP
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ZGESVDP
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      m,n&lt;0
     </span>
     or
     <span class="pre">
      lda&lt;max(1,m)
     </span>
     or
     <span class="pre">
      ldu&lt;max(1,m)
     </span>
     or
     <span class="pre">
      ldv&lt;max(1,n)
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.5.3.
  </span>
  cusolverDnXgesvdr()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxgesvdr" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The helper functions below can calculate the sizes needed for pre-allocated buffer.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnXgesvdr_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">signed</span><span class="kt">char</span><span class="n">jobu</span><span class="p">,</span>
<span class="kt">signed</span><span class="kt">char</span><span class="n">jobv</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">k</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">p</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">niters</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeSrand</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">Srand</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeUrand</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">Urand</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ldUrand</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeVrand</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">Vrand</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ldVrand</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytesOnDevice</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytesOnHost</span><span class="p">)</span>
</pre>
 <p>
  The routine below
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnXgesvdr</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="kt">signed</span><span class="kt">char</span><span class="n">jobu</span><span class="p">,</span>
<span class="kt">signed</span><span class="kt">char</span><span class="n">jobv</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">k</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">p</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">niters</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeSrand</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">Srand</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeUrand</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">Urand</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ldUrand</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeVrand</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">Vrand</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ldVrand</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">bufferOnDevice</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">workspaceInBytesOnDevice</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">bufferOnHost</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">workspaceInBytesOnHost</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">d_info</span><span class="p">)</span>
</pre>
 <p>
  This function computes the approximated rank-k singular value decomposition (k-SVD) of an
  <span class="pre">
   mÃn
  </span>
  matrix
  <span class="pre">
   A
  </span>
  and the corresponding left and/or right singular vectors. The k-SVD is written as
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A_{k}\approx U*\Sigma*V^{H}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   Î£
  </span>
  is a
  <span class="pre">
   kÃk
  </span>
  matrix which is zero except for its diagonal elements,
  <span class="pre">
   U
  </span>
  is an
  <span class="pre">
   mÃk
  </span>
  orthonormal matrix, and
  <span class="pre">
   V
  </span>
  is an
  <span class="pre">
   kÃn
  </span>
  orthonormal matrix. The diagonal elements of
  <span class="pre">
   Î£
  </span>
  are the approximated singular values of
  <span class="pre">
   A
  </span>
  ; they are real and non-negative, and are returned in descending order. The columns of
  <span class="pre">
   U
  </span>
  and
  <span class="pre">
   V
  </span>
  are the top-
  <span class="pre">
   k
  </span>
  left and right singular vectors of
  <span class="pre">
   A
  </span>
  .
 </p>
 <p>
  <span class="pre">
   cusolverDnXgesvdr
  </span>
  implements randomized methods described in [15] to compute k-SVD that is accurate with high probability if the conditions described in [15] hold.
  <span class="pre">
   cusolverDnXgesvdr
  </span>
  is intended to compute a very small portion of the spectrum (meaning that
  <span class="pre">
   k
  </span>
  is very small compared to
  <span class="pre">
   min(m,n)
  </span>
  ). of
  <span class="pre">
   A
  </span>
  fast and with good quality, specially when the dimensions of the matrix are large.
 </p>
 <p>
  The accuracy of the method depends on the spectrum of
  <span class="pre">
   A
  </span>
  , the number of power iterations
  <span class="pre">
   niters
  </span>
  , the oversampling parameter
  <span class="pre">
   p
  </span>
  and the ratio between
  <span class="pre">
   p
  </span>
  and the dimensions of the matrix
  <span class="pre">
   A
  </span>
  . Larger values of oversampling
  <span class="pre">
   p
  </span>
  or larger number of iterations
  <span class="pre">
   niters
  </span>
  might produce more accurate approximations, but it will also increase the run time of
  <span class="pre">
   cusolverDnXgesvdr
  </span>
  .
 </p>
 <p>
  Our recommendation is to use two iterations and set the oversampling to at least
  <span class="pre">
   2k
  </span>
  . Once the solver provides enough accuracy, adjust the values of
  <span class="pre">
   k
  </span>
  and
  <span class="pre">
   niters
  </span>
  for better performance.
 </p>
 <p>
  The user has to provide device and host working spaces which are pointed by input parameters
  <span class="pre">
   bufferOnDevice
  </span>
  and
  <span class="pre">
   bufferOnHost
  </span>
  . The input parameters
  <span class="pre">
   workspaceInBytesOnDevice
  </span>
  (and
  <span class="pre">
   workspaceInBytesOnHost
  </span>
  ) is size in bytes of the device (and host) working space, and it is returned by
  <span class="pre">
   cusolverDnXgesvdr_bufferSize()
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  Currently,
  <span class="pre">
   cusolverDnXgesvdr
  </span>
  supports only the default algorithm.
 </p>
 <p>
  Table of algorithms supported by cusolverDnXgesvdr
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_ALG_0
     </span>
     or
     <span class="pre">
      NULL
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/Xgesvdr">
   cuSOLVER Library Samples - Xgesvdr
  </a>
  for a code example.
 </p>
 <p>
  Remark 1:
  <span class="pre">
   gesvdr
  </span>
  supports
  <span class="pre">
   n&gt;=m
  </span>
  as well.
 </p>
 <p>
  Remark 2: the routine returns
  <span class="pre">
   V
  </span>
  , not
  <span class="math notranslate nohighlight">
   \(V^{H}\)
  </span>
 </p>
 <p>
  List of input arguments for
  <span class="pre">
   cusolverDnXgesvdr_bufferSize
  </span>
  and
  <span class="pre">
   cusolverDnXgesvdr
  </span>
  :
 </p>
 <p>
  API of cusolverDnXgesvdr
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Structure with information collected by
     <span class="pre">
      cusolverDnSetAdvOptions
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      jobu
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies options for computing all or part of the matrix
     <span class="pre">
      U
     </span>
     : = âSâ: the first k columns of U (the left singular vectors) are returned in the array U; = âNâ: no columns of U (no left singular vectors) are computed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      jobv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies options for computing all or part of the matrix V: = âSâ: the first k rows of V (the right singular vectors) are returned in the array V; = âNâ: no rows of V (no right singular vectors) are computed.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      k
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Rank of the k-SVD decomposition of matrix
     <span class="pre">
      A
     </span>
     .
     <span class="pre">
      rank
     </span>
     is less than
     <span class="pre">
      min(m,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      p
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Oversampling. The size of the subspace will be
     <span class="pre">
      (k
     </span>
     <span class="pre">
      +
     </span>
     <span class="pre">
      p)
     </span>
     .
     <span class="pre">
      (k+p)
     </span>
     is less than
     <span class="pre">
      min(m,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      niters
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of iteration of power method.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dataTypeA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,m)
     </span>
     . On exit, the contents of
     <span class="pre">
      A
     </span>
     are destroyed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dataTypeS
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      S
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      S
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Real array of dimension
     <span class="pre">
      min(m,n)
     </span>
     . The singular values of A, sorted so that
     <span class="pre">
      S(i)
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      S(i+1)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dataTypeU
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      U
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      U
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension
     <span class="pre">
      ldu
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      m
     </span>
     with
     <span class="pre">
      ldu
     </span>
     is not less than
     <span class="pre">
      max(1,m)
     </span>
     .
     <span class="pre">
      U
     </span>
     contains the
     <span class="pre">
      mÃm
     </span>
     unitary matrix
     <span class="pre">
      U
     </span>
     . if
     <span class="pre">
      jobu=S
     </span>
     , only reports first min(m,n) columns of
     <span class="pre">
      U
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ldu
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      U
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dataTypeV
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      V
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      V
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension
     <span class="pre">
      ldv
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      ldv
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
     <span class="pre">
      V
     </span>
     contains the
     <span class="pre">
      nÃn
     </span>
     unitary matrix V. If
     <span class="pre">
      jobv=S
     </span>
     , only reports first min(m,n) columns of
     <span class="pre">
      V
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ldv
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      V
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of computation.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bufferOnDevice
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Device workspace. Array of type
     <span class="pre">
      void
     </span>
     of size
     <span class="pre">
      workspaceInBytesOnDevice
     </span>
     bytes.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      workspaceInBytesOnDevice
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      bufferOnDevice
     </span>
     , returned by
     <span class="pre">
      cusolverDnXgesvdr_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bufferOnHost
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Host workspace. Array of type
     <span class="pre">
      void
     </span>
     of size
     <span class="pre">
      workspaceInBytesOnHost
     </span>
     bytes.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      workspaceInBytesOnHost
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      bufferOnHost
     </span>
     , returned by
     <span class="pre">
      cusolverDnXgesvdr_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      d_info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the operation is successful. If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle).
    </p>
   </td>
  </tr>
 </table>
 <p>
  The generic API has five different types,
  <span class="pre">
   dataTypeA
  </span>
  is data type of the matrix
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   dataTypeS
  </span>
  is data type of the vector
  <span class="pre">
   S
  </span>
  and
  <span class="pre">
   dataTypeU
  </span>
  is data type of the matrix
  <span class="pre">
   U
  </span>
  ,
  <span class="pre">
   dataTypeV
  </span>
  is data type of the matrix
  <span class="pre">
   V
  </span>
  ,
  <span class="pre">
   computeType
  </span>
  is compute type of the operation.
  <span class="pre">
   cusolverDnXgesvdr
  </span>
  only supports the following four combinations.
 </p>
 <p>
  Valid combination of data type and compute type
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     DataTypeA
    </p>
   </th>
   <th class="head">
    <p>
     DataTypeS
    </p>
   </th>
   <th class="head">
    <p>
     DataTypeU
    </p>
   </th>
   <th class="head">
    <p>
     DataTypeV
    </p>
   </th>
   <th class="head">
    <p>
     ComputeType
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      SGESVDR
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      DGESVDR
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CGESVDR
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ZGESVDR
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      m,n&lt;0
     </span>
     or
     <span class="pre">
      lda&lt;max(1,m)
     </span>
     or
     <span class="pre">
      ldu&lt;max(1,m)
     </span>
     or
     <span class="pre">
      ldv&lt;max(1,n)
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.5.4.
  </span>
  cusolverDnXsyevd()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxsyevd" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The helper functions below can calculate the sizes needed for pre-allocated buffer.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnXsyevd_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeW</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytesOnDevice</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytesOnHost</span><span class="p">)</span>
</pre>
 <p>
  The following routine:
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnXsyevd</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeW</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">bufferOnDevice</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">workspaceInBytesOnDevice</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">bufferOnHost</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">workspaceInBytesOnHost</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">)</span>
</pre>
 <p>
  computes eigenvalues and eigenvectors of a symmetric (Hermitian)
  <span class="pre">
   nÃn
  </span>
  matrix
  <span class="pre">
   A
  </span>
  using the generic API interface. The standard symmetric eigenvalue problem is
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A*V = V*\Lambda\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   Î
  </span>
  is a real
  <span class="pre">
   nÃn
  </span>
  diagonal matrix.
  <span class="pre">
   V
  </span>
  is an
  <span class="pre">
   nÃn
  </span>
  unitary matrix. The diagonal elements of
  <span class="pre">
   Î
  </span>
  are the eigenvalues of
  <span class="pre">
   A
  </span>
  in ascending order.
 </p>
 <p>
  The user has to provide device and host working spaces which are pointed by input parameters
  <span class="pre">
   bufferOnDevice
  </span>
  and
  <span class="pre">
   bufferOnHost
  </span>
  . The input parameters
  <span class="pre">
   workspaceInBytesOnDevice
  </span>
  (and
  <span class="pre">
   workspaceInBytesOnHost
  </span>
  ) is size in bytes of the device (and host) working space, and it is returned by
  <span class="pre">
   cusolverDnXsyevd_bufferSize()
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle). If
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   i
  </span>
  (greater than zero),
  <span class="pre">
   i
  </span>
  off-diagonal elements of an intermediate tridiagonal form did not converge to zero.
 </p>
 <p>
  If
  <span class="pre">
   jobz
  </span>
  = CUSOLVER_EIG_MODE_VECTOR,
  <span class="pre">
   A
  </span>
  contains the orthonormal eigenvectors of the matrix
  <span class="pre">
   A
  </span>
  . The eigenvectors are computed by a divide and conquer algorithm.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/Xsyevd">
   cuSOLVER Library Samples - Xsyevd
  </a>
  for a code example.
 </p>
 <p>
  Currently,
  <span class="pre">
   cusolverDnXsyevd
  </span>
  supports only the default algorithm.
 </p>
 <p>
  Table of algorithms supported by cusolverDnXsyevd
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_ALG_0
     </span>
     or
     <span class="pre">
      NULL
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm.
    </p>
   </td>
  </tr>
 </table>
 <p>
  List of input arguments for
  <span class="pre">
   cusolverDnXsyevd_bufferSize
  </span>
  and
  <span class="pre">
   cusolverDnXsyevd
  </span>
  :
 </p>
 <p>
  API of cusolverDnXsyevd
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Structure with information collected by
     <span class="pre">
      cusolverDnSetAdvOptions
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      jobz
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies options to either compute eigenvalue only or compute eigen-pair:
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     : Compute eigenvalues only;
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     : Compute eigenvalues and eigenvectors.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies which part of
     <span class="pre">
      A
     </span>
     is stored.
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     : Lower triangle of
     <span class="pre">
      A
     </span>
     is stored.
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     : Upper triangle of
     <span class="pre">
      A
     </span>
     is stored.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows (or columns) of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dataTypeA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     . If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     , the leading n-by-n upper triangular part of
     <span class="pre">
      A
     </span>
     contains the upper triangular part of the matrix
     <span class="pre">
      A
     </span>
     . If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     , the leading n-by-n lower triangular part of
     <span class="pre">
      A
     </span>
     contains the lower triangular part of the matrix
     <span class="pre">
      A
     </span>
     . On exit, if
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     , and
     <span class="pre">
      info
     </span>
     = 0,
     <span class="pre">
      A
     </span>
     contains the orthonormal eigenvectors of the matrix
     <span class="pre">
      A
     </span>
     . If
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     , the contents of
     <span class="pre">
      A
     </span>
     are destroyed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dataTypeW
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      W
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      W
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     A real array of dimension
     <span class="pre">
      n
     </span>
     . The eigenvalue values of
     <span class="pre">
      A
     </span>
     , in ascending order, i.e., sorted so that
     <span class="pre">
      W(i)
     </span>
     <span class="pre">
      &lt;=
     </span>
     <span class="pre">
      W(i+1)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of computation.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bufferOnDevice
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Device workspace. Array of type
     <span class="pre">
      void
     </span>
     of size
     <span class="pre">
      workspaceInBytesOnDevice
     </span>
     bytes.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      workspaceInBytesOnDevice
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      bufferOnDevice
     </span>
     , returned by
     <span class="pre">
      cusolverDnXsyevd_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bufferOnHost
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Host workspace. Array of type
     <span class="pre">
      void
     </span>
     of size
     <span class="pre">
      workspaceInBytesOnHost
     </span>
     bytes.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      workspaceInBytesOnHost
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      bufferOnHost
     </span>
     , returned by
     <span class="pre">
      cusolverDnXsyevd_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the operation is successful. If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle). If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      i
     </span>
     <span class="pre">
      (&gt;
     </span>
     <span class="pre">
      0)
     </span>
     ,
     <span class="pre">
      info
     </span>
     indicates
     <span class="pre">
      i
     </span>
     off-diagonal elements of an intermediate tridiagonal form did not converge to zero.
    </p>
   </td>
  </tr>
 </table>
 <p>
  The generic API has three different types,
  <span class="pre">
   dataTypeA
  </span>
  is data type of the matrix
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   dataTypeW
  </span>
  is data type of the matrix
  <span class="pre">
   W
  </span>
  and
  <span class="pre">
   computeType
  </span>
  is compute type of the operation.
  <span class="pre">
   cusolverDnXsyevd
  </span>
  only supports the following four combinations.
 </p>
 <p>
  Valid combination of data type and compute type
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     DataTypeA
    </p>
   </th>
   <th class="head">
    <p>
     DataTypeW
    </p>
   </th>
   <th class="head">
    <p>
     ComputeType
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      SSYEVD
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      DSYEVD
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CHEEVD
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ZHEEVD
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n&lt;0
     </span>
     , or
     <span class="pre">
      lda&lt;max(1,n)
     </span>
     , or
     <span class="pre">
      jobz
     </span>
     is not
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     or
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     , or
     <span class="pre">
      uplo
     </span>
     is not
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     or
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.4.5.5.
  </span>
  cusolverDnXsyevdx()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxsyevdx" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The helper functions below can calculate the sizes needed for pre-allocated buffer.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverDnXsyevdx_bufferSize</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cusolverEigRange_t</span><span class="n">range</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">vl</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">vu</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">il</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">iu</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">h_meig</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeW</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytesOnDevice</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytesOnHost</span><span class="p">)</span>
</pre>
 <p>
  The following routine:
 </p>
 <pre><span class="n">cusolverStatus_t</span><span class="n">cusolverDnXsyevdx</span><span class="p">(</span>
<span class="n">cusolverDnHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverDnParams_t</span><span class="n">params</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cusolverEigRange_t</span><span class="n">range</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">n</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeA</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">vl</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">vu</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">il</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">iu</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">meig64</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">dataTypeW</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">bufferOnDevice</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">workspaceInBytesOnDevice</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">bufferOnHost</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">workspaceInBytesOnHost</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">)</span>
</pre>
 <p>
  computes all or selection of the eigenvalues and optionally eigenvectors of a symmetric (Hermitian)
  <span class="pre">
   nÃn
  </span>
  matrix
  <span class="pre">
   A
  </span>
  using the generic API interface. The standard symmetric eigenvalue problem is
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A*V = V*\Lambda\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   Î
  </span>
  is a real
  <span class="pre">
   nÃh_meig
  </span>
  diagonal matrix.
  <span class="pre">
   V
  </span>
  is an
  <span class="pre">
   nÃh_meig
  </span>
  unitary matrix.
  <span class="pre">
   h_meig
  </span>
  is the number of eigenvalues/eigenvectors computed by the routine,
  <span class="pre">
   h_meig
  </span>
  is equal to
  <span class="pre">
   n
  </span>
  when the whole spectrum (e.g.,
  <span class="pre">
   range
  </span>
  =
  <span class="pre">
   CUSOLVER_EIG_RANGE_ALL
  </span>
  ) is requested. The diagonal elements of
  <span class="pre">
   Î
  </span>
  are the eigenvalues of
  <span class="pre">
   A
  </span>
  in ascending order.
 </p>
 <p>
  The user has to provide device and host working spaces which are pointed by input parameters
  <span class="pre">
   bufferOnDevice
  </span>
  and
  <span class="pre">
   bufferOnHost
  </span>
  . The input parameters
  <span class="pre">
   workspaceInBytesOnDevice
  </span>
  (and
  <span class="pre">
   workspaceInBytesOnHost
  </span>
  ) is size in bytes of the device (and host) working space, and it is returned by
  <span class="pre">
   cusolverDnXsyevdx_bufferSize()
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle). If
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   i
  </span>
  (greater than zero),
  <span class="pre">
   i
  </span>
  off-diagonal elements of an intermediate tridiagonal form did not converge to zero.
 </p>
 <p>
  if
  <span class="pre">
   jobz
  </span>
  = CUSOLVER_EIG_MODE_VECTOR,
  <span class="pre">
   A
  </span>
  contains the orthonormal eigenvectors of the matrix
  <span class="pre">
   A
  </span>
  . The eigenvectors are computed by a divide and conquer algorithm.
 </p>
 <p>
  Currently,
  <span class="pre">
   cusolverDnXsyevdx
  </span>
  supports only the default algorithm.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/Xsyevdx">
   cuSOLVER Library Samples - Xsyevdx
  </a>
  for a code example.
 </p>
 <p>
  Table of algorithms supported by cusolverDnXsyevdx
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_ALG_0
     </span>
     or
     <span class="pre">
      NULL
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm.
    </p>
   </td>
  </tr>
 </table>
 <p>
  List of input arguments for
  <span class="pre">
   cusolverDnXsyevdx_bufferSize
  </span>
  and
  <span class="pre">
   cusolverDnXsyevdx
  </span>
  :
 </p>
 <p>
  API of cusolverDnXsyevdx
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverDN library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      params
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Structure with information collected by
     <span class="pre">
      cusolverDnSetAdvOptions
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      jobz
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies options to either compute eigenvalue only or compute eigen-pair:
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     : Compute eigenvalues only;
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     : Compute eigenvalues and eigenvectors.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      range
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies options to which selection of eigenvalues and optionally eigenvectors that need to be computed:
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_ALL
     </span>
     : all eigenvalues/eigenvectors will be found, will becomes the classical syevd/heevd routine;
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_V
     </span>
     : all eigenvalues/eigenvectors in the half-open interval (vl,vu] will be found;
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_I
     </span>
     : the il-th through iu-th eigenvalues/eigenvectors will be found;
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies which part of
     <span class="pre">
      A
     </span>
     is stored.
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     : Lower triangle of
     <span class="pre">
      A
     </span>
     is stored.
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     : Upper triangle of
     <span class="pre">
      A
     </span>
     is stored.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows (or columns) of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dataTypeA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of dimension
     <span class="pre">
      lda
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      n
     </span>
     with
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     . If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     , the leading n-by-n upper triangular part of
     <span class="pre">
      A
     </span>
     contains the upper triangular part of the matrix
     <span class="pre">
      A
     </span>
     . If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     , the leading n-by-n lower triangular part of
     <span class="pre">
      A
     </span>
     contains the lower triangular part of the matrix
     <span class="pre">
      A
     </span>
     . On exit, if
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     , and
     <span class="pre">
      info
     </span>
     = 0,
     <span class="pre">
      A
     </span>
     contains the orthonormal eigenvectors of the matrix
     <span class="pre">
      A
     </span>
     . If
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     , the contents of
     <span class="pre">
      A
     </span>
     are destroyed.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Leading dimension of two-dimensional array used to store matrix
     <span class="pre">
      A
     </span>
     .
     <span class="pre">
      lda
     </span>
     is not less than
     <span class="pre">
      max(1,n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      vl,vu
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_V
     </span>
     , the lower and upper bounds of the interval to be searched for eigenvalues. vl &gt; vu. Not referenced if
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_ALL
     </span>
     or
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_I
     </span>
     . Note that, if eigenvalues are very close to each other, it is well known that two different eigenvalues routines might find slightly different number of eigenvalues inside the same interval. This is due to the fact that different eigenvalue algorithms, or even same algorithm but different run might find eigenvalues within some rounding error close to the machine precision. Thus, if the user want to be sure not to miss any eigenvalue within the interval bound, we suggest that, the user subtract/add epsilon (machine precision) to the interval bound such as (vl=vl-eps, vu=vu+eps]. this suggestion is valid for any selective routine from cuSolver or LAPACK.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      il,iu
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer. If
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_I
     </span>
     , the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= il &lt;= iu &lt;= n, if n &gt; 0; il = 1 and iu = 0 if n = 0. Not referenced if
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_ALL
     </span>
     or
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_V
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      h_meig
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer. The total number of eigenvalues found. 0 &lt;= h_meig &lt;= n. If
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_ALL
     </span>
     , h_meig = n, and if
     <span class="pre">
      range
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_RANGE_I
     </span>
     , h_meig = iu-il+1.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dataTypeW
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of array
     <span class="pre">
      W
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      W
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     A real array of dimension
     <span class="pre">
      n
     </span>
     . The eigenvalue values of
     <span class="pre">
      A
     </span>
     , in ascending order, i.e., sorted so that
     <span class="pre">
      W(i)
     </span>
     <span class="pre">
      &lt;=
     </span>
     <span class="pre">
      W(i+1)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of computation.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bufferOnDevice
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Device workspace. Array of type
     <span class="pre">
      void
     </span>
     of size
     <span class="pre">
      workspaceInBytesOnDevice
     </span>
     bytes.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      workspaceInBytesOnDevice
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      bufferOnDevice
     </span>
     , returned by
     <span class="pre">
      cusolverDnXsyevdx_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bufferOnHost
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Host workspace. Array of type
     <span class="pre">
      void
     </span>
     of size
     <span class="pre">
      workspaceInBytesOnHost
     </span>
     bytes.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      workspaceInBytesOnHost
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      bufferOnHost
     </span>
     , returned by
     <span class="pre">
      cusolverDnXsyevdx_bufferSize
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the operation is successful. if
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     Â
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle). If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      i
     </span>
     <span class="pre">
      (&gt;
     </span>
     <span class="pre">
      0)
     </span>
     ,
     <span class="pre">
      info
     </span>
     indicates
     <span class="pre">
      i
     </span>
     off-diagonal elements of an intermediate tridiagonal form did not converge to zero.
    </p>
   </td>
  </tr>
 </table>
 <p>
  The generic API has three different types,
  <span class="pre">
   dataTypeA
  </span>
  is data type of the matrix
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   dataTypeW
  </span>
  is data type of the matrix
  <span class="pre">
   W
  </span>
  and
  <span class="pre">
   computeType
  </span>
  is compute type of the operation.
  <span class="pre">
   cusolverDnXsyevdx
  </span>
  only supports the following four combinations:
 </p>
 <p>
  Valid combination of data type and compute type
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     DataTypeA
    </p>
   </th>
   <th class="head">
    <p>
     DataTypeW
    </p>
   </th>
   <th class="head">
    <p>
     ComputeType
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      SSYEVDX
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      DSYEVDX
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CHEEVDX
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ZHEEVDX
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n&lt;0
     </span>
     , or
     <span class="pre">
      lda&lt;max(1,n)
     </span>
     , or
     <span class="pre">
      jobz
     </span>
     is not
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     or
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     , or
     <span class="pre">
      range
     </span>
     is not
     <span class="pre">
      CUSOLVER_EIG_RANGE_ALL
     </span>
     or
     <span class="pre">
      CUSOLVER_EIG_RANGE_V
     </span>
     or
     <span class="pre">
      CUSOLVER_EIG_RANGE_I
     </span>
     , or
     <span class="pre">
      uplo
     </span>
     is not
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     or
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h2>
  <span class="section-number">
   2.5.
  </span>
  cuSolverSP: sparse LAPACK Function Reference
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolversp-sparse-lapack-function-reference" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  This section describes the API of cuSolverSP, which provides a subset of LAPACK functions for sparse matrices in CSR or CSC format.
 </p>
 <h3>
  <span class="section-number">
   2.5.1.
  </span>
  Helper Function Reference
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#helper-function-reference" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <h4>
  <span class="section-number">
   2.5.1.1.
  </span>
  cusolverSpCreate()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverspcreate" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverSpCreate</span><span class="p">(</span><span class="n">cusolverSpHandle_t</span><span class="o">*</span><span class="n">handle</span><span class="p">)</span>
</pre>
 <p>
  This function initializes the cuSolverSP library and creates a handle on the cuSolver context. It must be called before any other cuSolverSP API function is invoked. It allocates hardware resources necessary for accessing the GPU.
 </p>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     The pointer to the handle to the cuSolverSP context.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The initialization succeeded.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The CUDA Runtime initialization failed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     The resources could not be allocated.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.5.1.2.
  </span>
  cusolverSpDestroy()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverspdestroy" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverSpDestroy</span><span class="p">(</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">)</span>
</pre>
 <p>
  This function releases CPU-side resources used by the cuSolverSP library.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSolverSP context.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The shutdown succeeded.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.5.1.3.
  </span>
  cusolverSpSetStream()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverspsetstream" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverSpSetStream</span><span class="p">(</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span><span class="n">cudaStream_t</span><span class="n">streamId</span><span class="p">)</span>
</pre>
 <p>
  This function sets the stream to be used by the cuSolverSP library to execute its routines.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSolverSP context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      streamId
     </span>
    </p>
   </td>
   <td>
    <p>
     The stream to be used by the library.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The stream was set successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.5.1.4.
  </span>
  cusolverSpXcsrissym()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverspxcsrissym" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverSpXcsrissymHost</span><span class="p">(</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrEndPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">issym</span><span class="p">);</span>
</pre>
 <p>
  This function checks if
  <span class="pre">
   A
  </span>
  has symmetric pattern or not. The output parameter
  <span class="pre">
   issym
  </span>
  reports 1 if
  <span class="pre">
   A
  </span>
  is symmetric; otherwise, it reports 0.
 </p>
 <p>
  The matrix
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   mÃm
  </span>
  sparse matrix that is defined in CSR storage format by the four arrays
  <span class="pre">
   csrValA
  </span>
  ,
  <span class="pre">
   csrRowPtrA
  </span>
  ,
  <span class="pre">
   csrEndPtrA
  </span>
  and
  <span class="pre">
   csrColIndA
  </span>
  .
 </p>
 <p>
  The supported matrix type is
  <span class="pre">
   CUSPARSE_MATRIX_TYPE_GENERAL
  </span>
  .
 </p>
 <p>
  The
  <span class="pre">
   csrlsvlu
  </span>
  and
  <span class="pre">
   csrlsvqr
  </span>
  do not accept non-general matrix. the user has to extend the matrix into its missing upper/lower part, otherwise the result is not expected. The user can use
  <span class="pre">
   csrissym
  </span>
  to check if the matrix has symmetric pattern or not.
 </p>
 <p>
  Remark 1: only CPU path is provided.
 </p>
 <p>
  Remark 2: the user has to check returned status to get valid information. The function converts
  <span class="pre">
   A
  </span>
  to CSC format and compare CSR and CSC format. If the CSC failed because of insufficient resources,
  <span class="pre">
   issym
  </span>
  is undefined, and this state can only be detected by the return status code.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     MemorySpace
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverSP library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of nonzeros of matrix
     <span class="pre">
      A
     </span>
     . It is the size of
     <span class="pre">
      csrValA
     </span>
     and
     <span class="pre">
      csrColIndA
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     The descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      m
     </span>
     elements that contains the start of every row.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrEndPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      m
     </span>
     elements that contains the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      nnzA
     </span>
     column indices of the nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     MemorySpace
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      issym
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     1 if
     <span class="pre">
      A
     </span>
     is symmetric; 0 otherwise.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     The resources could not be allocated.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      m,nnzA&lt;=0
     </span>
     ), base index is not 0 or 1.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix type is not supported.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.5.2.
  </span>
  High Level Function Reference
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#high-level-function-reference" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  This section describes high level API of cuSolverSP, including linear solver, least-square solver and eigenvalue solver. The high-level API is designed for ease-of-use, so it allocates any required memory under the hood automatically. If the host or GPU system memory is not enough, an error is returned.
 </p>
 <h4>
  <span class="section-number">
   2.5.2.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolver-lt-t-gt-csrlsvlu">
   cusolverSp&lt;t&gt;csrlsvlu()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolversp-t-csrlsvlu" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverSpScsrlsvlu</span><span class="p">[</span><span class="n">Host</span><span class="p">](</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">b</span><span class="p">,</span>
<span class="kt">float</span><span class="n">tol</span><span class="p">,</span>
<span class="kt">int</span><span class="n">reorder</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">singularity</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="n">cusolverSpDcsrlsvlu</span><span class="p">[</span><span class="n">Host</span><span class="p">](</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">b</span><span class="p">,</span>
<span class="kt">double</span><span class="n">tol</span><span class="p">,</span>
<span class="kt">int</span><span class="n">reorder</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">singularity</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="n">cusolverSpCcsrlsvlu</span><span class="p">[</span><span class="n">Host</span><span class="p">](</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">b</span><span class="p">,</span>
<span class="kt">float</span><span class="n">tol</span><span class="p">,</span>
<span class="kt">int</span><span class="n">reorder</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">singularity</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="n">cusolverSpZcsrlsvlu</span><span class="p">[</span><span class="n">Host</span><span class="p">](</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">b</span><span class="p">,</span>
<span class="kt">double</span><span class="n">tol</span><span class="p">,</span>
<span class="kt">int</span><span class="n">reorder</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">singularity</span><span class="p">);</span>
</pre>
 <p>
  This function solves the linear system
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A*x = b\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   nÃn
  </span>
  sparse matrix that is defined in CSR storage format by the three arrays
  <span class="pre">
   csrValA
  </span>
  ,
  <span class="pre">
   csrRowPtrA
  </span>
  , and
  <span class="pre">
   csrColIndA
  </span>
  .
  <span class="pre">
   b
  </span>
  is the right-hand-side vector of size
  <span class="pre">
   n
  </span>
  , and
  <span class="pre">
   x
  </span>
  is the solution vector of size
  <span class="pre">
   n
  </span>
  .
 </p>
 <p>
  The supported matrix type is
  <span class="pre">
   CUSPARSE_MATRIX_TYPE_GENERAL
  </span>
  . If matrix
  <span class="pre">
   A
  </span>
  is symmetric/Hermitian and only lower/upper part is used or meaningful, the user has to extend the matrix into its missing upper/lower part, otherwise the result would be wrong.
 </p>
 <p>
  The linear system is solved by sparse LU with partial pivoting:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(P*A = L*U\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusolver
  </span>
  library provides three reordering schemes,
  <span class="pre">
   symrcm
  </span>
  <span class="pre">
   symamd
  </span>
  , and
  <span class="pre">
   csrmetisnd
  </span>
  to reduce zero fill-in which dramatically affects the performance of LU factorization. The input parameter
  <span class="pre">
   reorder
  </span>
  can enable
  <span class="pre">
   symrcm
  </span>
  (
  <span class="pre">
   symamd
  </span>
  or
  <span class="pre">
   csrmetisnd
  </span>
  ) if
  <span class="pre">
   reorder
  </span>
  is 1 (2, or 3), otherwise, no reordering is performed.
 </p>
 <p>
  If
  <span class="pre">
   reorder
  </span>
  is nonzero,
  <span class="pre">
   csrlsvlu
  </span>
  does
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(P*A*Q^{T} = L*U\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="math notranslate nohighlight">
   \(Q = {symrcm}(A + A^{T})\)
  </span>
  .
 </p>
 <p>
  If
  <span class="pre">
   A
  </span>
  is singular under given tolerance (
  <span class="pre">
   max(tol,0)
  </span>
  ), then some diagonal elements of
  <span class="pre">
   U
  </span>
  is zero, i.e.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \({|U(j,j)|} &lt; {tol\ for\ some\ j}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The output parameter
  <span class="pre">
   singularity
  </span>
  is the smallest index of such
  <span class="pre">
   j
  </span>
  . If
  <span class="pre">
   A
  </span>
  is non-singular,
  <span class="pre">
   singularity
  </span>
  is -1. The index is base-0, independent of base index of
  <span class="pre">
   A
  </span>
  . For example, if 2nd column of
  <span class="pre">
   A
  </span>
  is the same as first column, then
  <span class="pre">
   A
  </span>
  is singular and
  <span class="pre">
   singularity
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   1
  </span>
  which means
  <span class="pre">
   U(1,1)â0
  </span>
  .
 </p>
 <p>
  Remark 1:
  <span class="pre">
   csrlsvlu
  </span>
  performs traditional LU with partial pivoting, the pivot of k-th column is determined dynamically based on the k-th column of intermediate matrix.
  <span class="pre">
   csrlsvlu
  </span>
  follows Gilbert and Peierlsâs algorithm [4] which uses depth-first-search and topological ordering to solve triangular system (Davis also describes this algorithm in detail in his book [1]). Since CUDA 10.1,
  <span class="pre">
   csrlsvlu
  </span>
  will incrementally reallocate the memory to store
  <span class="pre">
   L
  </span>
  and
  <span class="pre">
   U
  </span>
  . This feature can avoid over-estimate size from QR factorization. In some cases, zero fill-in of QR can be order of magnitude higher than LU.
 </p>
 <p>
  Remark 2: only CPU (Host) path is provided.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     cusolverSp MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     *Host MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverSP library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of nonzeros of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     The descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzA
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(n)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      n
     </span>
     <span class="math notranslate nohighlight">
      \(+ 1\)
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      nnzA
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(n)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      b
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Right hand side vector of size
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      tol
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Tolerance to decide if singular or not.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      reorder
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     No ordering if
     <span class="pre">
      reorder
     </span>
     =0. Otherwise,
     <span class="pre">
      symrcm
     </span>
     ,
     <span class="pre">
      symamd
     </span>
     , or
     <span class="pre">
      csrmetisnd
     </span>
     is used to reduce zero fill-in.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     cusolverSp MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     *Host MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      x
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Solution vector of size
     <span class="pre">
      n
     </span>
     , x = inv(A)*b.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      singularity
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     -1 if
     <span class="pre">
      A
     </span>
     is invertible. Otherwise, first index
     <span class="pre">
      j
     </span>
     such that
     <span class="pre">
      U(j,j)â0
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     The resources could not be allocated.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n,nnzA&lt;=0
     </span>
     , base index is not 0 or 1,
     <span class="pre">
      reorder
     </span>
     is not 0,1,2,3)
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix type is not supported.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.5.2.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolver-lt-t-gt-csrlsvqr">
   cusolverSp&lt;t&gt;csrlsvqr()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolversp-t-csrlsvqr" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverSpScsrlsvqr</span><span class="p">[</span><span class="n">Host</span><span class="p">](</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">b</span><span class="p">,</span>
<span class="kt">float</span><span class="n">tol</span><span class="p">,</span>
<span class="kt">int</span><span class="n">reorder</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">singularity</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="n">cusolverSpDcsrlsvqr</span><span class="p">[</span><span class="n">Host</span><span class="p">](</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">b</span><span class="p">,</span>
<span class="kt">double</span><span class="n">tol</span><span class="p">,</span>
<span class="kt">int</span><span class="n">reorder</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">singularity</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="n">cusolverSpCcsrlsvqr</span><span class="p">[</span><span class="n">Host</span><span class="p">](</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">b</span><span class="p">,</span>
<span class="kt">float</span><span class="n">tol</span><span class="p">,</span>
<span class="kt">int</span><span class="n">reorder</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">singularity</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="n">cusolverSpZcsrlsvqr</span><span class="p">[</span><span class="n">Host</span><span class="p">](</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">b</span><span class="p">,</span>
<span class="kt">double</span><span class="n">tol</span><span class="p">,</span>
<span class="kt">int</span><span class="n">reorder</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">singularity</span><span class="p">);</span>
</pre>
 <p>
  This function solves the linear system
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A*x = b\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   mÃm
  </span>
  sparse matrix that is defined in CSR storage format by the three arrays
  <span class="pre">
   csrValA
  </span>
  ,
  <span class="pre">
   csrRowPtrA
  </span>
  , and
  <span class="pre">
   csrColIndA
  </span>
  .
  <span class="pre">
   b
  </span>
  is the right-hand-side vector of size
  <span class="pre">
   m
  </span>
  , and
  <span class="pre">
   x
  </span>
  is the solution vector of size
  <span class="pre">
   m
  </span>
  .
 </p>
 <p>
  The supported matrix type is
  <span class="pre">
   CUSPARSE_MATRIX_TYPE_GENERAL
  </span>
  . If matrix
  <span class="pre">
   A
  </span>
  is symmetric/Hermitian and only lower/upper part is used or meaningful, the user has to extend the matrix into its missing upper/lower part, otherwise the result would be wrong.
 </p>
 <p>
  The linear system is solved by sparse QR factorization,
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A\ =\ Q*R\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  If
  <span class="pre">
   A
  </span>
  is singular under given tolerance (
  <span class="pre">
   max(tol,0)
  </span>
  ), then some diagonal elements of
  <span class="pre">
   R
  </span>
  is zero, i.e.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \({|R(j,j)|} &lt; {tol\ for\ some\ j}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The output parameter
  <span class="pre">
   singularity
  </span>
  is the smallest index of such
  <span class="pre">
   j
  </span>
  . If
  <span class="pre">
   A
  </span>
  is non-singular,
  <span class="pre">
   singularity
  </span>
  is -1. The
  <span class="pre">
   singularity
  </span>
  is base-0, independent of base index of
  <span class="pre">
   A
  </span>
  . For example, if 2nd column of
  <span class="pre">
   A
  </span>
  is the same as first column, then
  <span class="pre">
   A
  </span>
  is singular and
  <span class="pre">
   singularity
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   1
  </span>
  which means
  <span class="pre">
   R(1,1)â0
  </span>
  .
 </p>
 <p>
  <span class="pre">
   cusolver
  </span>
  library provides three reordering schemes,
  <span class="pre">
   symrcm
  </span>
  <span class="pre">
   symamd
  </span>
  , and
  <span class="pre">
   csrmetisnd
  </span>
  to reduce zero fill-in which dramatically affects the performance of QR factorization. The input parameter
  <span class="pre">
   reorder
  </span>
  can enable
  <span class="pre">
   symrcm
  </span>
  (
  <span class="pre">
   symamd
  </span>
  or
  <span class="pre">
   csrmetisnd
  </span>
  ) if
  <span class="pre">
   reorder
  </span>
  is 1 (2, or 3), otherwise, no reordering is performed.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     cusolverSp MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     *Host MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverSP library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of nonzeros of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     The descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnz
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      m
     </span>
     <span class="math notranslate nohighlight">
      \(+ 1\)
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      nnz
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      b
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Right hand side vector of size
     <span class="pre">
      m
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      tol
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Tolerance to decide if singular or not.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      reorder
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     No ordering if
     <span class="pre">
      reorder
     </span>
     =0. Otherwise,
     <span class="pre">
      symrcm
     </span>
     ,
     <span class="pre">
      symamd
     </span>
     , or
     <span class="pre">
      csrmetisnd
     </span>
     is used to reduce zero fill-in.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     cusolverSp MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     *Host MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      x
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Solution vector of size
     <span class="pre">
      m
     </span>
     , x = inv(A)*b.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      singularity
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     -1 if
     <span class="pre">
      A
     </span>
     is invertible. Otherwise, first index j such that
     <span class="pre">
      R(j,j)â0
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     The resources could not be allocated.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      m,nnz&lt;=0
     </span>
     , base index is not 0 or 1,
     <span class="pre">
      reorder
     </span>
     is not 0,1,2,3)
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix type is not supported.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.5.2.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolver-lt-t-gt-csrlsvchol">
   cusolverSp&lt;t&gt;csrlsvchol()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolversp-t-csrlsvchol" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverSpScsrlsvchol</span><span class="p">[</span><span class="n">Host</span><span class="p">](</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColInd</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">b</span><span class="p">,</span>
<span class="kt">float</span><span class="n">tol</span><span class="p">,</span>
<span class="kt">int</span><span class="n">reorder</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">singularity</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="n">cusolverSpDcsrlsvchol</span><span class="p">[</span><span class="n">Host</span><span class="p">](</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColInd</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">b</span><span class="p">,</span>
<span class="kt">double</span><span class="n">tol</span><span class="p">,</span>
<span class="kt">int</span><span class="n">reorder</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">singularity</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="n">cusolverSpCcsrlsvchol</span><span class="p">[</span><span class="n">Host</span><span class="p">](</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">csrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColInd</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">b</span><span class="p">,</span>
<span class="kt">float</span><span class="n">tol</span><span class="p">,</span>
<span class="kt">int</span><span class="n">reorder</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">singularity</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="n">cusolverSpZcsrlsvchol</span><span class="p">[</span><span class="n">Host</span><span class="p">](</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColInd</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">b</span><span class="p">,</span>
<span class="kt">double</span><span class="n">tol</span><span class="p">,</span>
<span class="kt">int</span><span class="n">reorder</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">singularity</span><span class="p">);</span>
</pre>
 <p>
  This function solves the linear system
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A*x = b\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   mÃm
  </span>
  symmetric positive definite sparse matrix that is defined in CSR storage format by the three arrays
  <span class="pre">
   csrValA
  </span>
  ,
  <span class="pre">
   csrRowPtrA
  </span>
  , and
  <span class="pre">
   csrColIndA
  </span>
  .
  <span class="pre">
   b
  </span>
  is the right-hand-side vector of size
  <span class="pre">
   m
  </span>
  , and
  <span class="pre">
   x
  </span>
  is the solution vector of size
  <span class="pre">
   m
  </span>
  .
 </p>
 <p>
  The supported matrix type is
  <span class="pre">
   CUSPARSE_MATRIX_TYPE_GENERAL
  </span>
  and upper triangular part of
  <span class="pre">
   A
  </span>
  is ignored (if parameter
  <span class="pre">
   reorder
  </span>
  is zero). In other words, suppose input matrix
  <span class="pre">
   A
  </span>
  is decomposed as
  <span class="math notranslate nohighlight">
   \(A = L + D + U\)
  </span>
  , where
  <span class="pre">
   L
  </span>
  is lower triangular,
  <span class="pre">
   D
  </span>
  is diagonal and
  <span class="pre">
   U
  </span>
  is upper triangular. The function would ignore
  <span class="pre">
   U
  </span>
  and regard
  <span class="pre">
   A
  </span>
  as a symmetric matrix with the formula
  <span class="math notranslate nohighlight">
   \(A = L + D + L^{H}\)
  </span>
  . If parameter
  <span class="pre">
   reorder
  </span>
  is nonzero, the user has to extend
  <span class="pre">
   A
  </span>
  to a full matrix, otherwise the solution would be wrong.
 </p>
 <p>
  The linear system is solved by sparse Cholesky factorization,
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = G*G^{H}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   G
  </span>
  is the Cholesky factor, a lower triangular matrix.
 </p>
 <p>
  The output parameter
  <span class="pre">
   singularity
  </span>
  has two meanings:
 </p>
 <ul class="simple">
  <li>
   <p>
    If
    <span class="pre">
     A
    </span>
    is not positive definite, there exists some integer
    <span class="pre">
     k
    </span>
    such that
    <span class="pre">
     A(0:k,
    </span>
    <span class="pre">
     0:k)
    </span>
    is not positive definite.
    <span class="pre">
     singularity
    </span>
    is the minimum of such
    <span class="pre">
     k
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    If
    <span class="pre">
     A
    </span>
    is positive definite but near singular under tolerance (
    <span class="pre">
     max(tol,0)
    </span>
    ), i.e. there exists some integer
    <span class="pre">
     k
    </span>
    such that
    <span class="math notranslate nohighlight">
     \(G\begin{pmatrix}
{k,k} \\
\end{pmatrix}&lt;={tol}\)
    </span>
    .
    <span class="pre">
     singularity
    </span>
    is the minimum of such
    <span class="pre">
     k
    </span>
    .
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   singularity
  </span>
  is base-0. If
  <span class="pre">
   A
  </span>
  is positive definite and not near singular under tolerance,
  <span class="pre">
   singularity
  </span>
  is -1. If the user wants to know if
  <span class="pre">
   A
  </span>
  is positive definite or not,
  <span class="pre">
   tol=0
  </span>
  is enough.
 </p>
 <p>
  <span class="pre">
   cusolver
  </span>
  library provides three reordering schemes,
  <span class="pre">
   symrcm
  </span>
  <span class="pre">
   symamd
  </span>
  , and
  <span class="pre">
   csrmetisnd
  </span>
  to reduce zero fill-in which dramatically affects the performance of Cholesky factorization. The input parameter
  <span class="pre">
   reorder
  </span>
  can enable
  <span class="pre">
   symrcm
  </span>
  (
  <span class="pre">
   symamd
  </span>
  or
  <span class="pre">
   csrmetisnd
  </span>
  ) if
  <span class="pre">
   reorder
  </span>
  is 1 (2, or 3), otherwise, no reordering is performed.
 </p>
 <p>
  Remark 1: the function works for in-place (
  <span class="pre">
   x
  </span>
  and
  <span class="pre">
   b
  </span>
  point to the same memory block) and out-of-place.
 </p>
 <p>
  Remark 2: the function only works on 32-bit index, if matrix
  <span class="pre">
   G
  </span>
  has large zero fill-in such that number of nonzeros is bigger than
  <span class="math notranslate nohighlight">
   \(2^{31}\)
  </span>
  , then
  <span class="pre">
   CUSOLVER_STATUS_ALLOC_FAILED
  </span>
  is returned.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     cusolverSp MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     *Host MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverSP library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of nonzeros of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     The descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnz
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      m
     </span>
     <span class="math notranslate nohighlight">
      \(+ 1\)
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      nnz
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      b
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Right hand side vector of size
     <span class="pre">
      m
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      tol
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Tolerance to decide singularity.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      reorder
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     No ordering if
     <span class="pre">
      reorder
     </span>
     =0. Otherwise,
     <span class="pre">
      symrcm
     </span>
     ,
     <span class="pre">
      symamd
     </span>
     , or
     <span class="pre">
      csrmetisnd
     </span>
     is used to reduce zero fill-in.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     cusolverSp MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     *Host MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      x
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Solution vector of size
     <span class="pre">
      m
     </span>
     , x = inv(A)*b.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      singularity
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     -1 if
     <span class="pre">
      A
     </span>
     is symmetric positive definite.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     The resources could not be allocated.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      m,nnz&lt;=0
     </span>
     , base index is not 0 or 1,
     <span class="pre">
      reorder
     </span>
     is not 0,1,2,3)
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix type is not supported.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.5.2.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolver-lt-t-gt-csrlsqvqr">
   cusolverSp&lt;t&gt;csrlsqvqr()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolversp-t-csrlsqvqr" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The S and D data types are real valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverSpScsrlsqvqr</span><span class="p">[</span><span class="n">Host</span><span class="p">](</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">b</span><span class="p">,</span>
<span class="kt">float</span><span class="n">tol</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">rankA</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">p</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">min_norm</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="n">cusolverSpDcsrlsqvqr</span><span class="p">[</span><span class="n">Host</span><span class="p">](</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">b</span><span class="p">,</span>
<span class="kt">double</span><span class="n">tol</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">rankA</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">p</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">min_norm</span><span class="p">);</span>
</pre>
 <p>
  The C and Z data types are complex valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverSpCcsrlsqvqr</span><span class="p">[</span><span class="n">Host</span><span class="p">](</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">b</span><span class="p">,</span>
<span class="kt">float</span><span class="n">tol</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">rankA</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">p</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">min_norm</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="n">cusolverSpZcsrlsqvqr</span><span class="p">[</span><span class="n">Host</span><span class="p">](</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">b</span><span class="p">,</span>
<span class="kt">double</span><span class="n">tol</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">rankA</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">p</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">min_norm</span><span class="p">);</span>
</pre>
 <p>
  This function solves the following least-square problem:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(x = {argmin}{||}A*z - b{||}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   mÃn
  </span>
  sparse matrix that is defined in CSR storage format by the three arrays
  <span class="pre">
   csrValA
  </span>
  ,
  <span class="pre">
   csrRowPtrA
  </span>
  , and
  <span class="pre">
   csrColIndA
  </span>
  .
  <span class="pre">
   b
  </span>
  is the right-hand-side vector of size
  <span class="pre">
   m
  </span>
  , and
  <span class="pre">
   x
  </span>
  is the least-square solution vector of size
  <span class="pre">
   n
  </span>
  .
 </p>
 <p>
  The supported matrix type is
  <span class="pre">
   CUSPARSE_MATRIX_TYPE_GENERAL
  </span>
  . If
  <span class="pre">
   A
  </span>
  is square, symmetric/Hermitian and only lower/upper part is used or meaningful, the user has to extend the matrix into its missing upper/lower part, otherwise the result is wrong.
 </p>
 <p>
  This function only works if
  <span class="pre">
   m
  </span>
  is greater or equal to
  <span class="pre">
   n
  </span>
  , in other words,
  <span class="pre">
   A
  </span>
  is a tall matrix.
 </p>
 <p>
  The least-square problem is solved by sparse QR factorization with column pivoting,
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A*P^{T} = Q*R\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  If
  <span class="pre">
   A
  </span>
  is of full rank (i.e. all columns of
  <span class="pre">
   A
  </span>
  are linear independent), then matrix
  <span class="pre">
   P
  </span>
  is an identity. Suppose rank of
  <span class="pre">
   A
  </span>
  is
  <span class="pre">
   k
  </span>
  , less than
  <span class="pre">
   n
  </span>
  , the permutation matrix
  <span class="pre">
   P
  </span>
  reorders columns of
  <span class="pre">
   A
  </span>
  in the following sense:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A*P^{T} = \begin{pmatrix}
A_{1} &amp; A_{2} \\
\end{pmatrix} = \begin{pmatrix}
Q_{1} &amp; Q_{2} \\
\end{pmatrix}\begin{pmatrix}
R_{11} &amp; R_{12} &amp; R_{22} \\
\end{pmatrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="math notranslate nohighlight">
   \(R_{11}\)
  </span>
  and
  <span class="pre">
   A
  </span>
  have the same rank, but
  <span class="math notranslate nohighlight">
   \(R_{22}\)
  </span>
  is almost zero, i.e. every column of
  <span class="math notranslate nohighlight">
   \(A_{2}\)
  </span>
  is linear combination of
  <span class="math notranslate nohighlight">
   \(A_{1}\)
  </span>
  .
 </p>
 <p>
  The input parameter
  <span class="pre">
   tol
  </span>
  decides numerical rank. The absolute value of every entry in
  <span class="math notranslate nohighlight">
   \(R_{22}\)
  </span>
  is less than or equal to
  <span class="pre">
   tolerance=max(tol,0)
  </span>
  .
 </p>
 <p>
  The output parameter
  <span class="pre">
   rankA
  </span>
  denotes numerical rank of
  <span class="pre">
   A
  </span>
  .
 </p>
 <p>
  Suppose
  <span class="math notranslate nohighlight">
   \(y = P*x\)
  </span>
  and
  <span class="math notranslate nohighlight">
   \(c = Q^{H}*b\)
  </span>
  , the least square problem can be reformed by
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\left. \min||A*x - b|| = \min||R*y - c \right.||\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  or in matrix form
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\begin{pmatrix}
R_{11} &amp; R_{12} &amp; R_{22} \\
\end{pmatrix}\begin{pmatrix}
y_{1} \\
y_{2} \\
\end{pmatrix} = \begin{pmatrix}
c_{1} \\
c_{2} \\
\end{pmatrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The output parameter
  <span class="pre">
   min_norm
  </span>
  is
  <span class="math notranslate nohighlight">
   \(\left. ||c_{2} \right.||\)
  </span>
  , which is minimum value of least-square problem.
 </p>
 <p>
  If
  <span class="pre">
   A
  </span>
  is not of full rank, above equation does not have a unique solution. The least-square problem is equivalent to
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\begin{matrix}
\left. \min||y \right.|| \\
{{subject\ to}R_{11}*y_{1} + R_{12}*y_{2} = c_{1}} \\
\end{matrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Or equivalently another least-square problem
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     min|| R 1 1 \ R 1 2 I * y 2 - R 1 1 \ c 1 O ||
    </p>
   </td>
  </tr>
 </table>
 <p>
  The output parameter
  <span class="pre">
   x
  </span>
  is
  <span class="math notranslate nohighlight">
   \(P^{T}*y\)
  </span>
  , the solution of least-square problem.
 </p>
 <p>
  The output parameter
  <span class="pre">
   p
  </span>
  is a vector of size
  <span class="pre">
   n
  </span>
  . It corresponds to a permutation matrix
  <span class="pre">
   P
  </span>
  .
  <span class="pre">
   p(i)=j
  </span>
  means
  <span class="pre">
   (P*x)(i)
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   x(j)
  </span>
  . If
  <span class="pre">
   A
  </span>
  is of full rank,
  <span class="pre">
   p=0:n-1
  </span>
  .
 </p>
 <p>
  Remark 1:
  <span class="pre">
   p
  </span>
  is always base 0, independent of base index of
  <span class="pre">
   A
  </span>
  .
 </p>
 <p>
  Remark 2: only CPU (Host) path is provided.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     cusolverSp MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     *Host MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolver library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of nonzeros of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     The descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnz
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      m
     </span>
     <span class="math notranslate nohighlight">
      \(+ 1\)
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      nnz
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      b
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Right hand side vector of size
     <span class="pre">
      m
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      tol
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Tolerance to decide rank of
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     cusolverSp MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     *Host MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      rankA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Numerical rank of
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      x
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Solution vector of size
     <span class="pre">
      n
     </span>
     , x=pinv(A)*b.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      p
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     A vector of size
     <span class="pre">
      n
     </span>
     , which represents the permutation matrix
     <span class="pre">
      P
     </span>
     satisfying A*P^T=Q*R.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      min_norm
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ||A*x-b||,
     </span>
     <span class="pre">
      x=pinv(A)*b
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     The resources could not be allocated.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      m,n,nnz&lt;=0
     </span>
     ), base index is not 0 or 1.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix type is not supported.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.5.2.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolver-lt-t-gt-csreigsi">
   cusolverSp&lt;t&gt;csreigvsi()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolversp-t-csreigvsi" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The S and D data types are real valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverSpScsreigvsi</span><span class="p">[</span><span class="n">Host</span><span class="p">](</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">float</span><span class="n">mu0</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">x0</span><span class="p">,</span>
<span class="kt">int</span><span class="n">maxite</span><span class="p">,</span>
<span class="kt">float</span><span class="n">tol</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">mu</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">x</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="n">cusolverSpDcsreigvsi</span><span class="p">[</span><span class="n">Host</span><span class="p">](</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">double</span><span class="n">mu0</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">x0</span><span class="p">,</span>
<span class="kt">int</span><span class="n">maxite</span><span class="p">,</span>
<span class="kt">double</span><span class="n">tol</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">mu</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">x</span><span class="p">);</span>
</pre>
 <p>
  The C and Z data types are complex valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverSpCcsreigvsi</span><span class="p">[</span><span class="n">Host</span><span class="p">](</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="n">mu0</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">x0</span><span class="p">,</span>
<span class="kt">int</span><span class="n">maxite</span><span class="p">,</span>
<span class="kt">float</span><span class="n">tol</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">mu</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">x</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverSpZcsreigvsi</span><span class="p">(</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="n">mu0</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">x0</span><span class="p">,</span>
<span class="kt">int</span><span class="n">maxite</span><span class="p">,</span>
<span class="kt">double</span><span class="n">tol</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">mu</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">x</span><span class="p">);</span>
</pre>
 <p>
  This function solves the simple eigenvalue problem
  <span class="math notranslate nohighlight">
   \(A*x = \lambda*x\)
  </span>
  by shift-inverse method.
 </p>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   mÃm
  </span>
  sparse matrix that is defined in CSR storage format by the three arrays
  <span class="pre">
   csrValA
  </span>
  ,
  <span class="pre">
   csrRowPtrA
  </span>
  , and
  <span class="pre">
   csrColIndA
  </span>
  . The output parameter
  <span class="pre">
   x
  </span>
  is the approximated eigenvector of size
  <span class="pre">
   m
  </span>
  ,
 </p>
 <p>
  The following shift-inverse method corrects eigenpair step-by-step until convergence.
 </p>
 <p>
  It accepts several parameters:
 </p>
 <p>
  <span class="pre">
   mu0
  </span>
  is an initial guess of eigenvalue. The shift-inverse method will converge to the eigenvalue
  <span class="pre">
   mu
  </span>
  nearest
  <span class="pre">
   mu0
  </span>
  if
  <span class="pre">
   mu
  </span>
  is a singleton. Otherwise, the shift-inverse method may not converge.
 </p>
 <p>
  <span class="pre">
   x0
  </span>
  is an initial eigenvector. If the user has no preference, just chose
  <span class="pre">
   x0
  </span>
  randomly.
  <span class="pre">
   x0
  </span>
  must be nonzero. It can be non-unit length.
 </p>
 <p>
  <span class="pre">
   tol
  </span>
  is the tolerance to decide convergence. If
  <span class="pre">
   tol
  </span>
  is less than zero, it would be treated as zero.
 </p>
 <p>
  <span class="pre">
   maxite
  </span>
  is maximum number of iterations. It is useful when shift-inverse method does not converge because the tolerance is too small or the desired eigenvalue is not a singleton.
 </p>
 <p>
  Shift-Inverse Method
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     Given a initial guess of eigenvalue Î¼0 and initial vector x0 x (0) = x0 of unit length for j = 0 : maxite â â solve ( A - Î¼0 * I ) * x (k+1) = x (k) â â normalize x (k+1) to unit length â â compute approx. eigenvalue Î¼ = x H * A * x where x = x (k+1) â â if || A * x (k+1) - Î¼ * x (k+1) || &lt; tolerance, then stop endfor
    </p>
   </td>
  </tr>
 </table>
 <p>
  The supported matrix type is
  <span class="pre">
   CUSPARSE_MATRIX_TYPE_GENERAL
  </span>
  . If
  <span class="pre">
   A
  </span>
  is symmetric/Hermitian and only lower/upper part is used or meaningful, the user has to extend the matrix into its missing upper/lower part, otherwise the result is wrong.
 </p>
 <p>
  Remark 1:
  <span class="pre">
   [cu|h]solver[S|D]csreigvsi
  </span>
  only allows
  <span class="pre">
   mu0
  </span>
  as a real number. This works if
  <span class="pre">
   A
  </span>
  is symmetric. Otherwise, the non-real eigenvalue has a conjugate counterpart on the complex plan, and shift-inverse method would not converge to such eigenvalue even the eigenvalue is a singleton. The user has to extend
  <span class="pre">
   A
  </span>
  to complex numbers and call
  <span class="pre">
   [cu|h]solver[C|Z]csreigvsi
  </span>
  with
  <span class="pre">
   mu0
  </span>
  not on real axis.
 </p>
 <p>
  Remark 2: the tolerance
  <span class="pre">
   tol
  </span>
  should not be smaller than |mu0|*eps, where eps is machine zero. Otherwise, shift-inverse may not converge because of small tolerance.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     cusolverSp MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     *Host MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolver library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of nonzeros of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     The descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnz
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      m
     </span>
     <span class="math notranslate nohighlight">
      \(+ 1\)
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      nnz
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      mu0
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Initial guess of eigenvalue.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      x0
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Initial guess of eigenvector, a vector of size
     <span class="pre">
      m
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      maxite
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Maximum iterations in shift-inverse method.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      tol
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Tolerance for convergence.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     cusolverSp MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     *Host MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      mu
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Approximated eigenvalue nearest
     <span class="pre">
      mu0
     </span>
     under tolerance.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      x
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Approximated eigenvector of size
     <span class="pre">
      m
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     The resources could not be allocated.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      m,nnz&lt;=0
     </span>
     ), base index is not 0 or 1.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix type is not supported.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.5.2.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolver-lt-t-gt-csreigs">
   cusolverSp&lt;t&gt;csreigs()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolversp-t-csreigs" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">solverspScsreigs</span><span class="p">[</span><span class="n">Host</span><span class="p">](</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="n">left_bottom_corner</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="n">right_upper_corner</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">num_eigs</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="n">cusolverSpDcsreigs</span><span class="p">[</span><span class="n">Host</span><span class="p">](</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="n">left_bottom_corner</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="n">right_upper_corner</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">num_eigs</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="n">cusolverSpCcsreigs</span><span class="p">[</span><span class="n">Host</span><span class="p">](</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="n">left_bottom_corner</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="n">right_upper_corner</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">num_eigs</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="n">cusolverSpZcsreigs</span><span class="p">[</span><span class="n">Host</span><span class="p">](</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="n">left_bottom_corner</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="n">right_upper_corner</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">num_eigs</span><span class="p">);</span>
</pre>
 <p>
  This function computes number of algebraic eigenvalues in a given box
  <span class="pre">
   B
  </span>
  by contour integral
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \({number\ of\ algebraic\ eigenvalues\ in\ box\ B} = \frac{1}{2*\pi*\sqrt{- 1}}\oint_{C}\frac{P^{\prime}{(z)}}{P(z)}dz\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where closed line
  <span class="pre">
   C
  </span>
  is boundary of the box
  <span class="pre">
   B
  </span>
  which is a rectangle specified by two points, one is left bottom corner (input parameter
  <span class="pre">
   left_bottom_corner
  </span>
  ) and the other is right upper corner (input parameter
  <span class="pre">
   right_upper_corner
  </span>
  ).
  <span class="pre">
   P(z)=det(A
  </span>
  <span class="pre">
   -
  </span>
  <span class="pre">
   z*I)
  </span>
  is the characteristic polynomial of
  <span class="pre">
   A
  </span>
  .
 </p>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   mÃm
  </span>
  sparse matrix that is defined in CSR storage format by the three arrays
  <span class="pre">
   csrValA
  </span>
  ,
  <span class="pre">
   csrRowPtrA
  </span>
  , and
  <span class="pre">
   csrColIndA
  </span>
  .
 </p>
 <p>
  The output parameter
  <span class="pre">
   num_eigs
  </span>
  is number of algebraic eigenvalues in the box
  <span class="pre">
   B
  </span>
  . This number may not be accurate due to several reasons:
 </p>
 <ol class="arabic simple">
  <li>
   <p>
    The contour
    <span class="pre">
     C
    </span>
    is close to some eigenvalues or even passes through some eigenvalues.
   </p>
  </li>
  <li>
   <p>
    The numerical integration is not accurate due to coarse grid size. The default resolution is 1200 grids along contour
    <span class="pre">
     C
    </span>
    uniformly.
   </p>
  </li>
 </ol>
 <p>
  Even though
  <span class="pre">
   csreigs
  </span>
  may not be accurate, it still can give the user some idea how many eigenvalues in a region where the resolution of disk theorem is bad. For example, standard 3-point stencil of finite difference of Laplacian operator is a tridiagonal matrix, and disk theorem would show âall eigenvalues are in the interval [0, 4*N^2]â where N is number of grids. In this case,
  <span class="pre">
   csreigs
  </span>
  is useful for any interval inside [0, 4*N^2].
 </p>
 <p>
  Remark 1: if
  <span class="pre">
   A
  </span>
  is symmetric in real or Hermitian in complex, all eigenvalues are real. The user still needs to specify a box, not an interval. The height of the box can be much smaller than the width.
 </p>
 <p>
  Remark 2: only CPU (Host) path is provided.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     cusolverSp MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     *Host MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverSP library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of nonzeros of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     The descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnz
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      m
     </span>
     <span class="math notranslate nohighlight">
      \(+ 1\)
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      nnz
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      left_bottom_corner
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Left bottom corner of the box.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      right_upper_corner
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Right upper corner of the box.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     cusolverSp MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     *Host MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      num_eigs
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of algebraic eigenvalues in a box.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     The resources could not be allocated.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      m,nnz&lt;=0
     </span>
     ), base index is not 0 or 1.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix type is not supported.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.5.3.
  </span>
  Low Level Function Reference
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#low-level-function-reference" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  This section describes low level API of cuSolverSP, including symrcm and batched QR.
 </p>
 <h4>
  <span class="section-number">
   2.5.3.1.
  </span>
  cusolverSpXcsrsymrcm()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverspxcsrsymrcm" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverSpXcsrsymrcmHost</span><span class="p">(</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
</pre>
 <p>
  This function implements Symmetric Reverse Cuthill-McKee permutation. It returns a permutation vector
  <span class="pre">
   p
  </span>
  such that
  <span class="pre">
   A(p,p)
  </span>
  would concentrate nonzeros to diagonal. This is equivalent to
  <span class="pre">
   symrcm
  </span>
  in MATLAB, however the result may not be the same because of different heuristics in the pseudoperipheral finder. The
  <span class="pre">
   cuSolverSP
  </span>
  library implements
  <span class="pre">
   symrcm
  </span>
  based on the following two papers:
 </p>
 <ul class="simple">
  <li>
   <p>
    E. Cuthill and J. McKee, Reducing the bandwidth of sparse symmetric matrices, ACM â69 Proceedings of the 1969 24th national conference, Pages 157-172
   </p>
  </li>
  <li>
   <p>
    Alan George, Joseph W. H. Liu, An Implementation of a Pseudoperipheral Node Finder, ACM Transactions on Mathematical Software (TOMS) Volume 5 Issue 3, Sept. 1979, Pages 284-295
   </p>
  </li>
 </ul>
 <p>
  The output parameter
  <span class="pre">
   p
  </span>
  is an integer array of
  <span class="pre">
   n
  </span>
  elements. It represents a permutation array and it indexed using the base-0 convention. The permutation array
  <span class="pre">
   p
  </span>
  corresponds to a permutation matrix
  <span class="pre">
   P
  </span>
  , and satisfies the following relation:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \({A(p,p)} = P*A*P^{T}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   nÃn
  </span>
  sparse matrix that is defined in CSR storage format by the three arrays
  <span class="pre">
   csrValA
  </span>
  ,
  <span class="pre">
   csrRowPtrA
  </span>
  , and
  <span class="pre">
   csrColIndA
  </span>
  .
 </p>
 <p>
  The supported matrix type is
  <span class="pre">
   CUSPARSE_MATRIX_TYPE_GENERAL
  </span>
  . Internally
  <span class="pre">
   rcm
  </span>
  works on
  <span class="math notranslate nohighlight">
   \(A + A^{T}\)
  </span>
  , the user does not need to extend the matrix if the matrix is not symmetric.
 </p>
 <p>
  Remark 1: only CPU (Host) path is provided.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     *Host MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverSP library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of nonzeros of matrix
     <span class="pre">
      A
     </span>
     . It is the size of
     <span class="pre">
      csrValA
     </span>
     and
     <span class="pre">
      csrColIndA
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     The descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      n+1
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      nnzA
     </span>
     column indices of the nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     hsolver
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      p
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Permutation vector of size
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     The resources could not be allocated.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n,nnzA&lt;=0
     </span>
     ), base index is not 0 or 1.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix type is not supported.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.5.3.2.
  </span>
  cusolverSpXcsrsymmdq()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverspxcsrsymmdq" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverSpXcsrsymmdqHost</span><span class="p">(</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
</pre>
 <p>
  This function implements Symmetric Minimum Degree Algorithm based on Quotient Graph. It returns a permutation vector
  <span class="pre">
   p
  </span>
  such that
  <span class="pre">
   A(p,p)
  </span>
  would have less zero fill-in during Cholesky factorization. The
  <span class="pre">
   cuSolverSP
  </span>
  library implements
  <span class="pre">
   symmdq
  </span>
  based on the following two papers:
 </p>
 <p>
  Patrick R. Amestoy, Timothy A. Davis, Iain S. Duff, An Approximate Minimum Degree Ordering Algorithm, SIAM J. Matrix Analysis Applic. Vol 17, no 4, pp. 886-905, Dec. 1996.
 </p>
 <p>
  Alan George, Joseph W. Liu, A Fast Implementation of the Minimum Degree Algorithm Using Quotient Graphs, ACM Transactions on Mathematical Software, Vol 6, No. 3, September 1980, page 337-358.
 </p>
 <p>
  The output parameter
  <span class="pre">
   p
  </span>
  is an integer array of
  <span class="pre">
   n
  </span>
  elements. It represents a permutation array with base-0 index. The permutation array
  <span class="pre">
   p
  </span>
  corresponds to a permutation matrix
  <span class="pre">
   P
  </span>
  , and satisfies the following relation:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \({A(p,p)} = P*A*P^{T}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   nÃn
  </span>
  sparse matrix that is defined in CSR storage format by the three arrays
  <span class="pre">
   csrValA
  </span>
  ,
  <span class="pre">
   csrRowPtrA
  </span>
  , and
  <span class="pre">
   csrColIndA
  </span>
  .
 </p>
 <p>
  The supported matrix type is
  <span class="pre">
   CUSPARSE_MATRIX_TYPE_GENERAL
  </span>
  . Internally
  <span class="pre">
   mdq
  </span>
  works on
  <span class="math notranslate nohighlight">
   \(A + A^{T}\)
  </span>
  , the user does not need to extend the matrix if the matrix is not symmetric.
 </p>
 <p>
  Remark 1: only CPU (Host) path is provided.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     *Host MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverSP library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of nonzeros of matrix
     <span class="pre">
      A
     </span>
     . It is the size of
     <span class="pre">
      csrValA
     </span>
     and
     <span class="pre">
      csrColIndA
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     The descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      n+1
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      nnzA
     </span>
     column indices of the nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     hsolver
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      p
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Permutation vector of size
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     The resources could not be allocated.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n,nnzA&lt;=0
     </span>
     ), base index is not 0 or 1.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix type is not supported.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.5.3.3.
  </span>
  cusolverSpXcsrsymamd()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverspxcsrsymamd" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverSpXcsrsymamdHost</span><span class="p">(</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
</pre>
 <p>
  This function implements Symmetric Approximate Minimum Degree Algorithm based on Quotient Graph. It returns a permutation vector
  <span class="pre">
   p
  </span>
  such that
  <span class="pre">
   A(p,p)
  </span>
  would have less zero fill-in during Cholesky factorization. The
  <span class="pre">
   cuSolverSP
  </span>
  library implements
  <span class="pre">
   symamd
  </span>
  based on the following paper:
 </p>
 <p>
  Patrick R. Amestoy, Timothy A. Davis, Iain S. Duff, An Approximate Minimum Degree Ordering Algorithm, SIAM J. Matrix Analysis Applic. Vol 17, no 4, pp. 886-905, Dec. 1996.
 </p>
 <p>
  The output parameter
  <span class="pre">
   p
  </span>
  is an integer array of
  <span class="pre">
   n
  </span>
  elements. It represents a permutation array with base-0 index. The permutation array
  <span class="pre">
   p
  </span>
  corresponds to a permutation matrix
  <span class="pre">
   P
  </span>
  , and satisfies the following relation:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \({A(p,p)} = P*A*P^{T}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   nÃn
  </span>
  sparse matrix that is defined in CSR storage format by the three arrays
  <span class="pre">
   csrValA
  </span>
  ,
  <span class="pre">
   csrRowPtrA
  </span>
  , and
  <span class="pre">
   csrColIndA
  </span>
  .
 </p>
 <p>
  The supported matrix type is
  <span class="pre">
   CUSPARSE_MATRIX_TYPE_GENERAL
  </span>
  . Internally
  <span class="pre">
   amd
  </span>
  works on
  <span class="math notranslate nohighlight">
   \(A + A^{T}\)
  </span>
  , the user does not need to extend the matrix if the matrix is not symmetric.
 </p>
 <p>
  Remark 1: only CPU (Host) path is provided.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     *Host MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverSP library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of nonzeros of matrix
     <span class="pre">
      A
     </span>
     . It is the size of
     <span class="pre">
      csrValA
     </span>
     and
     <span class="pre">
      csrColIndA
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     The descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      n+1
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      nnzA
     </span>
     column indices of the nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     hsolver
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      p
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Permutation vector of size
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     The resources could not be allocated.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n,nnzA&lt;=0
     </span>
     ), base index is not 0 or 1.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix type is not supported.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.5.3.4.
  </span>
  cusolverSpXcsrmetisnd()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverspxcsrmetisnd" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverSpXcsrmetisndHost</span><span class="p">(</span>
<span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int64_t</span><span class="o">*</span><span class="n">options</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
</pre>
 <p>
  This function is a wrapper of
  <span class="pre">
   METIS_NodeND
  </span>
  . It returns a permutation vector
  <span class="pre">
   p
  </span>
  such that
  <span class="pre">
   A(p,p)
  </span>
  would have less zero fill-in during nested dissection. The
  <span class="pre">
   cuSolverSP
  </span>
  library links
  <span class="pre">
   libcusolver_metis_static.a
  </span>
  which is 64-bit metis-5.1.0 .
 </p>
 <p>
  The parameter
  <span class="pre">
   options
  </span>
  is the configuration of
  <span class="pre">
   metis
  </span>
  . For those who do not have experiences of
  <span class="pre">
   metis
  </span>
  , set
  <span class="pre">
   options
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   NULL
  </span>
  for default setting.
 </p>
 <p>
  The output parameter
  <span class="pre">
   p
  </span>
  is an integer array of
  <span class="pre">
   n
  </span>
  elements. It represents a permutation array with base-0 index. The permutation array
  <span class="pre">
   p
  </span>
  corresponds to a permutation matrix
  <span class="pre">
   P
  </span>
  , and satisfies the following relation:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \({A(p,p)} = P*A*P^{T}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   nÃn
  </span>
  sparse matrix that is defined in CSR storage format by the three arrays
  <span class="pre">
   csrValA
  </span>
  ,
  <span class="pre">
   csrRowPtrA
  </span>
  , and
  <span class="pre">
   csrColIndA
  </span>
  .
 </p>
 <p>
  The supported matrix type is
  <span class="pre">
   CUSPARSE_MATRIX_TYPE_GENERAL
  </span>
  . Internally
  <span class="pre">
   csrmetisnd
  </span>
  works on
  <span class="math notranslate nohighlight">
   \(A + A^{T}\)
  </span>
  , the user does not need to extend the matrix if the matrix is not symmetric.
 </p>
 <p>
  Remark 1: only CPU (Host) path is provided.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     *Host MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverSP library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of nonzeros of matrix
     <span class="pre">
      A
     </span>
     . It is the size of
     <span class="pre">
      csrValA
     </span>
     and
     <span class="pre">
      csrColIndA
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     The descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      n+1
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      nnzA
     </span>
     column indices of the nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      options
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array to configure
     <span class="pre">
      metis
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     *Host MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      p
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Permutation vector of size
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     The resources could not be allocated.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n,nnzA&lt;=0
     </span>
     ), base index is not 0 or 1.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix type is not supported.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.5.3.5.
  </span>
  cusolverSpXcsrzfd()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverspxcsrzfd" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverSpScsrzfdHost</span><span class="p">(</span>
<span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">P</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">numnz</span><span class="p">)</span>

<span class="n">cusolverStatus_t</span>
<span class="n">cusolverSpDcsrzfdHost</span><span class="p">(</span>
<span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">P</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">numnz</span><span class="p">)</span>

<span class="n">cusolverStatus_t</span>
<span class="n">cusolverSpCcsrzfdHost</span><span class="p">(</span>
<span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">P</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">numnz</span><span class="p">)</span>

<span class="n">cusolverStatus_t</span>
<span class="n">cusolverSpZcsrzfdHost</span><span class="p">(</span>
<span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">P</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">numnz</span><span class="p">)</span>
</pre>
 <p>
  This function implements MC21, zero-free diagonal algorithm. It returns a permutation vector
  <span class="pre">
   p
  </span>
  such that
  <span class="pre">
   A(p,:)
  </span>
  has no zero diagonal.
 </p>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   nÃn
  </span>
  sparse matrix that is defined in CSR storage format by the three arrays
  <span class="pre">
   csrValA
  </span>
  ,
  <span class="pre">
   csrRowPtrA
  </span>
  , and
  <span class="pre">
   csrColIndA
  </span>
  . The supported matrix type is
  <span class="pre">
   CUSPARSE_MATRIX_TYPE_GENERAL
  </span>
  .
 </p>
 <p>
  The output parameter
  <span class="pre">
   p
  </span>
  is an integer array of
  <span class="pre">
   n
  </span>
  elements. It represents a permutation array with base-0 index. The permutation array
  <span class="pre">
   p
  </span>
  corresponds to a permutation matrix
  <span class="pre">
   P
  </span>
  , and satisfies the following relation:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \({A(p,:)} = P*A\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The output parameter
  <span class="pre">
   numnz
  </span>
  describes number of nonzero diagonal in permutated matrix
  <span class="pre">
   A(p,:)
  </span>
  . If
  <span class="pre">
   numnz
  </span>
  is less than
  <span class="pre">
   n
  </span>
  , matrix
  <span class="pre">
   A
  </span>
  has structural singularity.
 </p>
 <p>
  Remark 1: only CPU (Host) path is provided.
 </p>
 <p>
  Remark 2: this routine does not maximize diagonal value of permuted matrix. The user cannot expect this routine can make âLU without pivotingâ stable.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     *Host MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverSP library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of nonzeros of matrix
     <span class="pre">
      A
     </span>
     . It is the size of
     <span class="pre">
      csrValA
     </span>
     and
     <span class="pre">
      csrColIndA
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     The descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzA
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      n+1
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      nnzA
     </span>
     column indices of the nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     *Host MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      p
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Permutation vector of size
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      numnz
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of nonzeros on diagonal of permuted matrix.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     The resources could not be allocated.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      n,nnzA&lt;=0
     </span>
     ), base index is not 0 or 1.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix type is not supported.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.5.3.6.
  </span>
  cusolverSpXcsrperm()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverspxcsrperm" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverSpXcsrperm_bufferSizeHost</span><span class="p">(</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">p</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">q</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSizeInBytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverSpXcsrpermHost</span><span class="p">(</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">p</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">q</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">map</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">);</span>
</pre>
 <p>
  Given a left permutation vector
  <span class="pre">
   p
  </span>
  which corresponds to permutation matrix
  <span class="pre">
   P
  </span>
  and a right permutation vector
  <span class="pre">
   q
  </span>
  which corresponds to permutation matrix
  <span class="pre">
   Q
  </span>
  , this function computes permutation of matrix
  <span class="pre">
   A
  </span>
  by
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(B = P*A*Q^{T}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   mÃn
  </span>
  sparse matrix that is defined in CSR storage format by the three arrays
  <span class="pre">
   csrValA
  </span>
  ,
  <span class="pre">
   csrRowPtrA
  </span>
  and
  <span class="pre">
   csrColIndA
  </span>
  .
 </p>
 <p>
  The operation is in-place, i.e. the matrix
  <span class="pre">
   A
  </span>
  is overwritten by
  <span class="pre">
   B
  </span>
  .
 </p>
 <p>
  The permutation vector
  <span class="pre">
   p
  </span>
  and
  <span class="pre">
   q
  </span>
  are base 0.
  <span class="pre">
   p
  </span>
  performs row permutation while
  <span class="pre">
   q
  </span>
  performs column permutation. One can also use MATLAB command
  <span class="math notranslate nohighlight">
   \(B = {A(p,q)}\)
  </span>
  to permutate matrix
  <span class="pre">
   A
  </span>
  .
 </p>
 <p>
  This function only computes sparsity pattern of
  <span class="pre">
   B
  </span>
  . The user can use parameter
  <span class="pre">
   map
  </span>
  to get
  <span class="pre">
   csrValB
  </span>
  as well. The parameter
  <span class="pre">
   map
  </span>
  is an input/output. If the user sets
  <span class="pre">
   map=0:1:(nnzA-1)
  </span>
  before calling
  <span class="pre">
   csrperm
  </span>
  ,
  <span class="pre">
   csrValB=csrValA(map)
  </span>
  .
 </p>
 <p>
  The supported matrix type is
  <span class="pre">
   CUSPARSE_MATRIX_TYPE_GENERAL
  </span>
  . If
  <span class="pre">
   A
  </span>
  is symmetric and only lower/upper part is provided, the user has to pass
  <span class="math notranslate nohighlight">
   \(A + A^{T}\)
  </span>
  into this function.
 </p>
 <p>
  This function requires a buffer size returned by
  <span class="pre">
   csrperm_bufferSize()
  </span>
  . The address of
  <span class="pre">
   pBuffer
  </span>
  must be a multiple of 128 bytes. If it is not,
  <span class="pre">
   CUSOLVER_STATUS_INVALID_VALUE
  </span>
  is returned.
 </p>
 <p>
  For example, if matrix
  <span class="pre">
   A
  </span>
  is
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = \begin{pmatrix}
{1.0} &amp; {2.0} &amp; {3.0} \\
{4.0} &amp; {5.0} &amp; {6.0} \\
{7.0} &amp; {8.0} &amp; {9.0} \\
\end{pmatrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  and left permutation vector
  <span class="pre">
   p=(0,2,1)
  </span>
  , right permutation vector
  <span class="pre">
   q=(2,1,0)
  </span>
  , then
  <span class="math notranslate nohighlight">
   \(P*A*Q^{T}\)
  </span>
  is
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(P*A*Q^{T} = \begin{pmatrix}
{3.0} &amp; {2.0} &amp; {1.0} \\
{9.0} &amp; {8.0} &amp; {7.0} \\
{6.0} &amp; {5.0} &amp; {4.0} \\
\end{pmatrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Remark 1: only CPU (Host) path is provided.
 </p>
 <p>
  Remark 2: the user can combine
  <span class="pre">
   csrsymrcm
  </span>
  and
  <span class="pre">
   csrperm
  </span>
  to get
  <span class="math notranslate nohighlight">
   \(P*A*P^{T}\)
  </span>
  which has less zero fill-in during QR factorization.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     cusolverSp MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolver library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnzA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of nonzeros of matrix
     <span class="pre">
      A
     </span>
     . It is the size of
     <span class="pre">
      csrValA
     </span>
     and
     <span class="pre">
      csrColIndA
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     The descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      m+1
     </span>
     elements that contains the start of every row and end of last row plus one of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      nnzA
     </span>
     column indices of the nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      p
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Left permutation vector of size
     <span class="pre">
      m
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      q
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Right permutation vector of size
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      map
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      nnzA
     </span>
     indices. If the user wants to get relationship between
     <span class="pre">
      A
     </span>
     and
     <span class="pre">
      B
     </span>
     ,
     <span class="pre">
      map
     </span>
     must be set
     <span class="pre">
      0:1:(nnzA-1)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Buffer allocated by the user, the size is returned by
     <span class="pre">
      csrperm_bufferSize()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     hsolver
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      m+1
     </span>
     elements that contains the start of every row and end of last row plus one of matrix
     <span class="pre">
      B
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      nnzA
     </span>
     column indices of the nonzero elements of matrix
     <span class="pre">
      B
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      map
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      nnzA
     </span>
     indices that maps matrix
     <span class="pre">
      A
     </span>
     to matrix
     <span class="pre">
      B
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      pBufferSizeInBytes
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of bytes of the buffer.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     The resources could not be allocated.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      m,n,nnzA&lt;=0
     </span>
     ), base index is not 0 or 1.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix type is not supported.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   2.5.3.7.
  </span>
  cusolverSpXcsrqrBatched()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverspxcsrqrbatched" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The create and destroy methods start and end the lifetime of a csrqrInfo object.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverSpCreateCsrqrInfo</span><span class="p">(</span><span class="n">csrqrInfo_t</span><span class="o">*</span><span class="n">info</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverSpDestroyCsrqrInfo</span><span class="p">(</span><span class="n">csrqrInfo_t</span><span class="n">info</span><span class="p">);</span>
</pre>
 <p>
  Analysis is the same for all data types, but each data type has a unique buffer size.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverSpXcsrqrAnalysisBatched</span><span class="p">(</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">csrqrInfo_t</span><span class="n">info</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverSpScsrqrBufferInfoBatched</span><span class="p">(</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">,</span>
<span class="n">csrqrInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">internalDataInBytes</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverSpDcsrqrBufferInfoBatched</span><span class="p">(</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">,</span>
<span class="n">csrqrInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">internalDataInBytes</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytes</span><span class="p">);</span>
</pre>
 <p>
  Calculate buffer sizes for complex valued data types.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverSpCcsrqrBufferInfoBatched</span><span class="p">(</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">,</span>
<span class="n">csrqrInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">internalDataInBytes</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytes</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverSpZcsrqrBufferInfoBatched</span><span class="p">(</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">,</span>
<span class="n">csrqrInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">internalDataInBytes</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">workspaceInBytes</span><span class="p">);</span>
</pre>
 <p>
  The S and D data types are real valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverSpScsrqrsvBatched</span><span class="p">(</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">b</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">,</span>
<span class="n">csrqrInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverSpDcsrqrsvBatched</span><span class="p">(</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">b</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">,</span>
<span class="n">csrqrInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">);</span>
</pre>
 <p>
  The C and Z data types are complex valued single and double precision, respectively.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverSpCcsrqrsvBatched</span><span class="p">(</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">b</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">,</span>
<span class="n">csrqrInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">);</span>

<span class="n">cusolverStatus_t</span>
<span class="nf">cusolverSpZcsrqrsvBatched</span><span class="p">(</span><span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">b</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">,</span>
<span class="n">csrqrInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">);</span>
</pre>
 <p>
  The batched sparse QR factorization is used to solve either a set of least-squares problems
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(x_{j} = {argmin}{||}A_{j}*z - b_{j}{||}{,\ j\ =\ 1,2,...,\ batchSize}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  or a set of linear systems
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A_{j}x_{j} = b_{j}{,\ j\ =\ 1,2,...,\ batchSize}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where each
  <span class="math notranslate nohighlight">
   \(A_{j}\)
  </span>
  is a
  <span class="pre">
   mÃn
  </span>
  sparse matrix that is defined in CSR storage format by the four arrays
  <span class="pre">
   csrValA
  </span>
  ,
  <span class="pre">
   csrRowPtrA
  </span>
  and
  <span class="pre">
   csrColIndA
  </span>
  .
 </p>
 <p>
  The supported matrix type is
  <span class="pre">
   CUSPARSE_MATRIX_TYPE_GENERAL
  </span>
  . If
  <span class="pre">
   A
  </span>
  is symmetric and only lower/upper part is provided, the user has to pass
  <span class="math notranslate nohighlight">
   \(A + A^{H}\)
  </span>
  into this function.
 </p>
 <p>
  The prerequisite to use batched sparse QR has two-folds. First all matrices
  <span class="math notranslate nohighlight">
   \(A_{j}\)
  </span>
  must have the same sparsity pattern. Second, no column pivoting is used in least-square problem, so the solution is valid only if
  <span class="math notranslate nohighlight">
   \(A_{j}\)
  </span>
  is of full rank for all
  <span class="pre">
   j
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   1,2,...,
  </span>
  <span class="pre">
   batchSize
  </span>
  . All matrices have the same sparsity pattern, so only one copy of
  <span class="pre">
   csrRowPtrA
  </span>
  and
  <span class="pre">
   csrColIndA
  </span>
  is used. But the array
  <span class="pre">
   csrValA
  </span>
  stores coefficients of
  <span class="math notranslate nohighlight">
   \(A_{j}\)
  </span>
  one after another. In other words,
  <span class="pre">
   csrValA[k*nnzA
  </span>
  <span class="pre">
   :
  </span>
  <span class="pre">
   (k+1)*nnzA]
  </span>
  is the value of
  <span class="math notranslate nohighlight">
   \(A_{k}\)
  </span>
  .
 </p>
 <p>
  The batched QR uses opaque data structure
  <span class="pre">
   csrqrInfo
  </span>
  to keep intermediate data, for example, matrix
  <span class="pre">
   Q
  </span>
  and matrix
  <span class="pre">
   R
  </span>
  of QR factorization. The user needs to create
  <span class="pre">
   csrqrInfo
  </span>
  first by
  <span class="pre">
   cusolverSpCreateCsrqrInfo
  </span>
  before any function in batched QR operation. The
  <span class="pre">
   csrqrInfo
  </span>
  would not release internal data until
  <span class="pre">
   cusolverSpDestroyCsrqrInfo
  </span>
  is called.
 </p>
 <p>
  There are three routines in batched sparse QR,
  <span class="pre">
   cusolverSpXcsrqrAnalysisBatched
  </span>
  ,
  <span class="pre">
   cusolverSp[S|D|C|Z]csrqrBufferInfoBatched
  </span>
  and
  <span class="pre">
   cusolverSp[S|D|C|Z]csrqrsvBatched
  </span>
  .
 </p>
 <p>
  First,
  <span class="pre">
   cusolverSpXcsrqrAnalysisBatched
  </span>
  is the analysis phase, used to analyze sparsity pattern of matrix
  <span class="pre">
   Q
  </span>
  and matrix
  <span class="pre">
   R
  </span>
  of QR factorization. Also parallelism is extracted during analysis phase. Once analysis phase is done, the size of working space to perform QR is known. However
  <span class="pre">
   cusolverSpXcsrqrAnalysisBatched
  </span>
  uses CPU to analyze the structure of matrix
  <span class="pre">
   A
  </span>
  , and this may consume a lot of memory. If host memory is not sufficient to finish the analysis,
  <span class="pre">
   CUSOLVER_STATUS_ALLOC_FAILED
  </span>
  is returned. The required memory for analysis is proportional to zero fill-in in QR factorization. The user may need to perform some kind of reordering to minimize zero fill-in, for example,
  <span class="pre">
   colamd
  </span>
  or
  <span class="pre">
   symrcm
  </span>
  in MATLAB.
  <span class="pre">
   cuSolverSP
  </span>
  library provides
  <span class="pre">
   symrcm
  </span>
  (
  <span class="pre">
   cusolverSpXcsrsymrcm
  </span>
  ).
 </p>
 <p>
  Second, the user needs to choose proper
  <span class="pre">
   batchSize
  </span>
  and to prepare working space for sparse QR. There are two memory blocks used in batched sparse QR. One is internal memory block used to store matrix
  <span class="pre">
   Q
  </span>
  and matrix
  <span class="pre">
   R
  </span>
  . The other is working space used to perform numerical factorization. The size of the former is proportional to
  <span class="pre">
   batchSize
  </span>
  , and the size is specified by returned parameter
  <span class="pre">
   internalDataInBytes
  </span>
  of
  <span class="pre">
   cusolverSp[S|D|C|Z]csrqrBufferInfoBatched
  </span>
  . while the size of the latter is almost independent of
  <span class="pre">
   batchSize
  </span>
  , and the size is specified by returned parameter
  <span class="pre">
   workspaceInBytes
  </span>
  of
  <span class="pre">
   cusolverSp[S|D|C|Z]csrqrBufferInfoBatched
  </span>
  . The internal memory block is allocated implicitly during first call of
  <span class="pre">
   cusolverSp[S|D|C|Z]csrqrsvBatched
  </span>
  . The user only needs to allocate working space for
  <span class="pre">
   cusolverSp[S|D|C|Z]csrqrsvBatched
  </span>
  .
 </p>
 <p>
  Instead of trying all batched matrices, the user can find maximum
  <span class="pre">
   batchSize
  </span>
  by querying
  <span class="pre">
   cusolverSp[S|D|C|Z]csrqrBufferInfoBatched
  </span>
  . For example, the user can increase
  <span class="pre">
   batchSize
  </span>
  till summation of
  <span class="pre">
   internalDataInBytes
  </span>
  and
  <span class="pre">
   workspaceInBytes
  </span>
  is greater than size of available device memory.
 </p>
 <p>
  Suppose that the user needs to perform 253 linear solvers and available device memory is 2GB. if
  <span class="pre">
   cusolverSp[S|D|C|Z]csrqrsvBatched
  </span>
  can only afford
  <span class="pre">
   batchSize
  </span>
  100, the user has to call
  <span class="pre">
   cusolverSp[S|D|C|Z]csrqrsvBatched
  </span>
  three times to finish all. The user calls
  <span class="pre">
   cusolverSp[S|D|C|Z]csrqrBufferInfoBatched
  </span>
  with
  <span class="pre">
   batchSize
  </span>
  100. The opaque
  <span class="pre">
   info
  </span>
  would remember this
  <span class="pre">
   batchSize
  </span>
  and any subsequent call of
  <span class="pre">
   cusolverSp[S|D|C|Z]csrqrsvBatched
  </span>
  cannot exceed this value. In this example, the first two calls of
  <span class="pre">
   cusolverSp[S|D|C|Z]csrqrsvBatched
  </span>
  will use
  <span class="pre">
   batchSize
  </span>
  100, and last call of
  <span class="pre">
   cusolverSp[S|D|C|Z]csrqrsvBatched
  </span>
  will use
  <span class="pre">
   batchSize
  </span>
  53.
 </p>
 <p>
  Example: suppose that A0, A1, .., A9 have the same sparsity pattern, the following code solves 10 linear systems
  <span class="math notranslate nohighlight">
   \(A_{j}x_{j} = b_{j}{,\ j\ =\ 0,2,...,\ 9}\)
  </span>
  by batched sparse QR.
 </p>
 <pre><span class="c1">// Suppose that A0, A1, .., A9 are m x m sparse matrix represented by CSR format,</span>
<span class="c1">// Each matrix Aj has nonzero nnzA, and shares the same csrRowPtrA and csrColIndA.</span>
<span class="c1">// csrValA is aggregation of A0, A1, ..., A9.</span>
<span class="kt">int</span><span class="n">m</span><span class="p">;</span><span class="c1">// number of rows and columns of each Aj</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">;</span><span class="c1">// number of nonzeros of each Aj</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">;</span><span class="c1">// each Aj has the same csrRowPtrA</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">;</span><span class="c1">// each Aj has the same csrColIndA</span>
<span class="kt">double</span><span class="o">*</span><span class="n">csrValA</span><span class="p">;</span><span class="c1">// aggregation of A0,A1,...,A9</span>
<span class="k">const</span><span class="kt">int</span><span class="n">batchSize</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span><span class="c1">// 10 linear systems</span>

<span class="n">cusolverSpHandle_t</span><span class="n">handle</span><span class="p">;</span><span class="c1">// handle to cusolver library</span>
<span class="n">csrqrInfo_t</span><span class="n">info</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
<span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span><span class="c1">// working space for numerical factorization</span>

<span class="c1">// step 1: create a descriptor</span>
<span class="n">cusparseCreateMatDescr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">descrA</span><span class="p">);</span>
<span class="n">cusparseSetMatIndexBase</span><span class="p">(</span><span class="n">descrA</span><span class="p">,</span><span class="n">CUSPARSE_INDEX_BASE_ONE</span><span class="p">);</span><span class="c1">// A is base-1</span>
<span class="n">cusparseSetMatType</span><span class="p">(</span><span class="n">descrA</span><span class="p">,</span><span class="n">CUSPARSE_MATRIX_TYPE_GENERAL</span><span class="p">);</span><span class="c1">// A is a general matrix</span>

<span class="c1">// step 2: create empty info structure</span>
<span class="n">cusolverSpCreateCsrqrInfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>

<span class="c1">// step 3: symbolic analysis</span>
<span class="n">cusolverSpXcsrqrAnalysisBatched</span><span class="p">(</span>
<span class="n">handle</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">nnzA</span><span class="p">,</span>
<span class="n">descrA</span><span class="p">,</span><span class="n">csrRowPtrA</span><span class="p">,</span><span class="n">csrColIndA</span><span class="p">,</span><span class="n">info</span><span class="p">);</span>
</pre>
 <pre><span class="c1">// step 4: allocate working space for Aj*xj=bj</span>
<span class="n">cusolverSpDcsrqrBufferInfoBatched</span><span class="p">(</span>
<span class="n">handle</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">nnzA</span><span class="p">,</span>
<span class="n">descrA</span><span class="p">,</span>
<span class="n">csrValA</span><span class="p">,</span><span class="n">csrRowPtrA</span><span class="p">,</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">batchSize</span><span class="p">,</span>
<span class="n">info</span><span class="p">,</span>
<span class="o">&amp;</span><span class="n">internalDataInBytes</span><span class="p">,</span>
<span class="o">&amp;</span><span class="n">workspaceInBytes</span><span class="p">);</span>

<span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pBuffer</span><span class="p">,</span><span class="n">workspaceInBytes</span><span class="p">);</span>

<span class="c1">// step 5: solve Aj*xj = bj</span>
<span class="n">cusolverSpDcsrqrsvBatched</span><span class="p">(</span>
<span class="n">handle</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">nnzA</span><span class="p">,</span>
<span class="n">descrA</span><span class="p">,</span><span class="n">csrValA</span><span class="p">,</span><span class="n">csrRowPtrA</span><span class="p">,</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">b</span><span class="p">,</span>
<span class="n">x</span><span class="p">,</span>
<span class="n">batchSize</span><span class="p">,</span>
<span class="n">info</span><span class="p">,</span>
<span class="n">pBuffer</span><span class="p">);</span>

<span class="c1">// step 7: destroy info</span>
<span class="n">cusolverSpDestroyCsrqrInfo</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
</pre>
 <p>
  Please refer to
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/csrqr">
   cuSOLVER Library Samples - csrqr
  </a>
  for a code example.
 </p>
 <p>
  Remark 1: only GPU (device) path is provided.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     cusolverSp MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverSP library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows of each matrix
     <span class="pre">
      Aj
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of each matrix
     <span class="pre">
      Aj
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnzA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of nonzeros of each matrix
     <span class="pre">
      Aj
     </span>
     . It is the size
     <span class="pre">
      csrColIndA
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     The descriptor of each matrix
     <span class="pre">
      Aj
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzA*batchSize
     </span>
     nonzero elements of matrices
     <span class="pre">
      A0,
     </span>
     <span class="pre">
      A1,
     </span>
     <span class="pre">
      ...
     </span>
     . All matrices are aggregated one after another.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      m+1
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of
     <span class="pre">
      nnzA
     </span>
     column indices of the nonzero elements of each matrix
     <span class="pre">
      Aj
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      b
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      m*batchSize
     </span>
     of right-hand-side vectors
     <span class="pre">
      b0,
     </span>
     <span class="pre">
      b1,
     </span>
     <span class="pre">
      ...
     </span>
     . All vectors are aggregated one after another.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      batchSize
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of systems to be solved.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Opaque structure for QR factorization.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     Buffer allocated by the user, the size is returned by
     <span class="pre">
      cusolverSpXcsrqrBufferInfoBatched()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     cusolverSp MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      x
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      m*batchSize
     </span>
     of solution vectors
     <span class="pre">
      x0,
     </span>
     <span class="pre">
      x1,
     </span>
     <span class="pre">
      ...
     </span>
     . All vectors are aggregated one after another.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      internalDataInBytes
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of bytes of the internal data.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      workspaceInBytes
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of bytes of the buffer in numerical factorization.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     The resources could not be allocated.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      m,n,nnzA&lt;=0
     </span>
     ), base index is not 0 or 1.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix type is not supported.
    </p>
   </td>
  </tr>
 </table>
 <h2>
  <span class="section-number">
   2.6.
  </span>
  cuSolverRF: Refactorization Reference
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrf-refactorization-reference" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  This section describes API of cuSolverRF, a library for fast refactorization.
 </p>
 <h3>
  <span class="section-number">
   2.6.1.
  </span>
  cusolverRfAccessBundledFactors()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfaccessbundledfactors" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverRfAccessBundledFactors</span><span class="p">(</span><span class="cm">/* Input */</span>
<span class="n">cusolverRfHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="cm">/* Output (in the host memory)</span><span class="o">*/</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzM</span><span class="p">,</span>
<span class="cm">/* Output (in the device memory) */</span>
<span class="kt">int</span><span class="o">**</span><span class="n">Mp</span><span class="p">,</span>
<span class="kt">int</span><span class="o">**</span><span class="n">Mi</span><span class="p">,</span>
<span class="kt">double</span><span class="o">**</span><span class="n">Mx</span><span class="p">);</span>
</pre>
 <p>
  This routine allows direct access to the lower
  <span class="pre">
   L
  </span>
  and upper
  <span class="pre">
   U
  </span>
  triangular factors stored in the cuSolverRF library handle. The factors are compressed into a single matrix
  <span class="pre">
   M=(L-I)+U
  </span>
  , where the unitary diagonal of
  <span class="pre">
   L
  </span>
  is not stored. It is assumed that a prior call to the
  <span class="pre">
   cusolverRfRefactor()
  </span>
  was done in order to generate these triangular factors.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSolverRF library.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnzM
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of non-zero elements of matrix
     <span class="pre">
      M
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      Mp
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of offsets corresponding to the start of each row in the arrays
     <span class="pre">
      Mi
     </span>
     and
     <span class="pre">
      Mx
     </span>
     . This array has also an extra entry at the end that stores the number of non-zero elements in the matrix $M$. The array size is
     <span class="pre">
      n+1
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      Mi
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of column indices corresponding to the non-zero elements in the matrix
     <span class="pre">
      M
     </span>
     . It is assumed that this array is sorted by row and by column within each row. The array size is
     <span class="pre">
      nnzM
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      Mx
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of values corresponding to the non-zero elements in the matrix
     <span class="pre">
      M
     </span>
     . It is assumed that this array is sorted by row and by column within each row. The array size is
     <span class="pre">
      nnzM
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_EXECUTION_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     A kernel failed to launch on the GPU.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.6.2.
  </span>
  cusolverRfAnalyze()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfanalyze" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverRfAnalyze</span><span class="p">(</span><span class="n">cusolverRfHandle_t</span><span class="n">handle</span><span class="p">);</span>
</pre>
 <p>
  This routine performs the appropriate analysis of parallelism available in the LU re-factorization depending upon the algorithm chosen by the user.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = L*U\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  It is assumed that a prior call to the
  <span class="pre">
   cusolverRfSetup[Host|Device]()
  </span>
  was done in order to create internal data structures needed for the analysis.
 </p>
 <p>
  This routine needs to be called only once for a single linear system
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A_{i}x_{i} = f_{i}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSolverRF library.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_EXECUTION_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     A kernel failed to launch on the GPU.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     An allocation of memory failed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.6.3.
  </span>
  cusolverRfSetupDevice()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfsetupdevice" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverRfSetupDevice</span><span class="p">(</span><span class="cm">/* Input (in the device memory)</span><span class="o">*/</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzL</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrL</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColIndL</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">csrValL</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzU</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrU</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColIndU</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">csrValU</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">P</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">Q</span><span class="p">,</span>
<span class="cm">/* Output */</span>
<span class="n">cusolverRfHandle_t</span><span class="n">handle</span><span class="p">);</span>
</pre>
 <p>
  This routine assembles the internal data structures of the cuSolverRF library. It is often the first routine to be called after the call to the
  <span class="pre">
   cusolverRfCreate()
  </span>
  routine.
 </p>
 <p>
  This routine accepts as input (on the device) the original matrix
  <span class="pre">
   A
  </span>
  , the lower
  <span class="pre">
   (L)
  </span>
  and upper
  <span class="pre">
   (U)
  </span>
  triangular factors, as well as the left
  <span class="pre">
   (P)
  </span>
  and the right
  <span class="pre">
   (Q)
  </span>
  permutations resulting from the full LU factorization of the first
  <span class="pre">
   (i=1)
  </span>
  linear system
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A_{i}x_{i} = f_{i}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The permutations
  <span class="pre">
   P
  </span>
  and
  <span class="pre">
   Q
  </span>
  represent the final composition of all the left and right reorderings applied to the original matrix
  <span class="pre">
   A
  </span>
  , respectively. However, these permutations are often associated with partial pivoting and reordering to minimize fill-in, respectively.
 </p>
 <p>
  This routine needs to be called only once for a single linear system
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A_{i}x_{i} = f_{i}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of rows (and columns) of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnzA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of non-zero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of offsets corresponding to the start of each row in the arrays
     <span class="pre">
      csrColIndA
     </span>
     and
     <span class="pre">
      csrValA
     </span>
     . This array has also an extra entry at the end that stores the number of non-zero elements in the matrix. The array size is
     <span class="pre">
      n+1
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of column indices corresponding to the non-zero elements in the matrix. It is assumed that this array is sorted by row and by column within each row. The array size is
     <span class="pre">
      nnzA
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of values corresponding to the non-zero elements in the matrix. It is assumed that this array is sorted by row and by column within each row. The array size is
     <span class="pre">
      nnzA
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnzL
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of non-zero elements of matrix
     <span class="pre">
      L
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowPtrL
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of offsets corresponding to the start of each row in the arrays
     <span class="pre">
      csrColIndL
     </span>
     and
     <span class="pre">
      csrValL
     </span>
     . This array has also an extra entry at the end that stores the number of non-zero elements in the matrix
     <span class="pre">
      L
     </span>
     . The array size is
     <span class="pre">
      n+1
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColIndL
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of column indices corresponding to the non-zero elements in the matrix
     <span class="pre">
      L
     </span>
     . It is assumed that this array is sorted by row and by column within each row. The array size is
     <span class="pre">
      nnzL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrValL
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of values corresponding to the non-zero elements in the matrix
     <span class="pre">
      L
     </span>
     . It is assumed that this array is sorted by row and by column within each row. The array size is
     <span class="pre">
      nnzL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnzU
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of non-zero elements of matrix
     <span class="pre">
      U
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowPtrU
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of offsets corresponding to the start of each row in the arrays
     <span class="pre">
      csrColIndU
     </span>
     and
     <span class="pre">
      csrValU
     </span>
     . This array has also an extra entry at the end that stores the number of non-zero elements in the matrix
     <span class="pre">
      U
     </span>
     . The array size is
     <span class="pre">
      n+1
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColIndU
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of column indices corresponding to the non-zero elements in the matrix
     <span class="pre">
      U
     </span>
     . It is assumed that this array is sorted by row and by column within each row. The array size is
     <span class="pre">
      nnzU
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrValU
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of values corresponding to the non-zero elements in the matrix
     <span class="pre">
      U
     </span>
     . It is assumed that this array is sorted by row and by column within each row. The array size is
     <span class="pre">
      nnzU
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      P
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The left permutation (often associated with pivoting). The array size in
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      Q
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The right permutation (often associated with reordering). The array size in
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSolverRF library.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     An unsupported value or parameter was passed.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     An allocation of memory failed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_EXECUTION_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     A kernel failed to launch on the GPU.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.6.4.
  </span>
  cusolverRfSetupHost()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfsetuphost" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverRfSetupHost</span><span class="p">(</span><span class="cm">/* Input (in the host memory)</span><span class="o">*/</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_csrRowPtrA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_csrColIndA</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">h_csrValA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzL</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_csrRowPtrL</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_csrColIndL</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">h_csrValL</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzU</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_csrRowPtrU</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_csrColIndU</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">h_csrValU</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_P</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_Q</span><span class="p">,</span>
<span class="cm">/* Output */</span>
<span class="n">cusolverRfHandle_t</span><span class="n">handle</span><span class="p">);</span>
</pre>
 <p>
  This routine assembles the internal data structures of the cuSolverRF library. It is often the first routine to be called after the call to the
  <span class="pre">
   cusolverRfCreate()
  </span>
  routine.
 </p>
 <p>
  This routine accepts as input (on the host) the original matrix
  <span class="pre">
   A
  </span>
  , the lower
  <span class="pre">
   (L)
  </span>
  and upper
  <span class="pre">
   (U)
  </span>
  triangular factors, as well as the left
  <span class="pre">
   (P)
  </span>
  and the right
  <span class="pre">
   (Q)
  </span>
  permutations resulting from the full LU factorization of the first
  <span class="pre">
   (i=1)
  </span>
  linear system
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A_{i}x_{i} = f_{i}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The permutations
  <span class="pre">
   P
  </span>
  and
  <span class="pre">
   Q
  </span>
  represent the final composition of all the left and right reorderings applied to the original matrix
  <span class="pre">
   A
  </span>
  , respectively. However, these permutations are often associated with partial pivoting and reordering to minimize fill-in, respectively.
 </p>
 <p>
  This routine needs to be called only once for a single linear system
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A_{i}x_{i} = f_{i}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of rows (and columns) of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnzA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of non-zero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      h_csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of offsets corresponding to the start of each row in the arrays
     <span class="pre">
      h_csrColIndA
     </span>
     and
     <span class="pre">
      h_csrValA
     </span>
     . This array has also an extra entry at the end that stores the number of non-zero elements in the matrix. The array size is
     <span class="pre">
      n+1
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      h_csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of column indices corresponding to the non-zero elements in the matrix. It is assumed that this array is sorted by row and by column within each row. The array size is
     <span class="pre">
      nnzA
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      h_csrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of values corresponding to the non-zero elements in the matrix. It is assumed that this array is sorted by row and by column within each row. The array size is
     <span class="pre">
      nnzA
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnzL
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of non-zero elements of matrix
     <span class="pre">
      L
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      h_csrRowPtrL
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of offsets corresponding to the start of each row in the arrays
     <span class="pre">
      h_csrColIndL
     </span>
     and
     <span class="pre">
      h_csrValL
     </span>
     . This array has also an extra entry at the end that stores the number of non-zero elements in the matrix
     <span class="pre">
      L
     </span>
     . The array size is
     <span class="pre">
      n+1
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      h_csrColIndL
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of column indices corresponding to the non-zero elements in the matrix
     <span class="pre">
      L
     </span>
     . It is assumed that this array is sorted by row and by column within each row. The array size is
     <span class="pre">
      nnzL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      h_csrValL
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of values corresponding to the non-zero elements in the matrix
     <span class="pre">
      L
     </span>
     . It is assumed that this array is sorted by row and by column within each row. The array size is
     <span class="pre">
      nnzL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnzU
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of non-zero elements of matrix
     <span class="pre">
      U
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      h_csrRowPtrU
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of offsets corresponding to the start of each row in the arrays
     <span class="pre">
      h_csrColIndU
     </span>
     and
     <span class="pre">
      h_csrValU
     </span>
     . This array has also an extra entry at the end that stores the number of non-zero elements in the matrix
     <span class="pre">
      U
     </span>
     . The array size is
     <span class="pre">
      n+1
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      h_csrColIndU
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of column indices corresponding to the non-zero elements in the matrix
     <span class="pre">
      U
     </span>
     . It is assumed that this array is sorted by row and by column within each row. The array size is
     <span class="pre">
      nnzU
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      h_csrValU
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of values corresponding to the non-zero elements in the matrix
     <span class="pre">
      U
     </span>
     . It is assumed that this array is sorted by row and by column within each row. The array size is
     <span class="pre">
      nnzU
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      h_P
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The left permutation (often associated with pivoting). The array size in
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      h_Q
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The right permutation (often associated with reordering). The array size in
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSolverRF library.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     An unsupported value or parameter was passed.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     An allocation of memory failed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_EXECUTION_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     A kernel failed to launch on the GPU.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.6.5.
  </span>
  cusolverRfCreate()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfcreate" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span><span class="nf">cusolverRfCreate</span><span class="p">(</span><span class="n">cusolverRfHandle_t</span><span class="o">*</span><span class="n">handle</span><span class="p">);</span>
</pre>
 <p>
  This routine initializes the cuSolverRF library. It allocates required resources and must be called prior to any other cuSolverRF library routine.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The pointer to the cuSolverRF library handle.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     An allocation of memory failed.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.6.6.
  </span>
  cusolverRfExtractBundledFactorsHost()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfextractbundledfactorshost" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverRfExtractBundledFactorsHost</span><span class="p">(</span><span class="cm">/* Input */</span>
<span class="n">cusolverRfHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="cm">/* Output (in the host memory)</span><span class="o">*/</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_nnzM</span><span class="p">,</span>
<span class="kt">int</span><span class="o">**</span><span class="n">h_Mp</span><span class="p">,</span>
<span class="kt">int</span><span class="o">**</span><span class="n">h_Mi</span><span class="p">,</span>
<span class="kt">double</span><span class="o">**</span><span class="n">h_Mx</span><span class="p">);</span>
</pre>
 <p>
  This routine extracts lower
  <span class="pre">
   (L)
  </span>
  and upper
  <span class="pre">
   (U)
  </span>
  triangular factors from the cuSolverRF library handle into the host memory. The factors are compressed into a single matrix
  <span class="pre">
   M=(L-I)+U
  </span>
  , where the unitary diagonal of
  <span class="pre">
   (L)
  </span>
  is not stored. It is assumed that a prior call to the
  <span class="pre">
   cusolverRfRefactor()
  </span>
  was done in order to generate these triangular factors.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSolverRF library.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      h_nnzM
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of non-zero elements of matrix
     <span class="pre">
      M
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      h_Mp
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of offsets corresponding to the start of each row in the arrays
     <span class="pre">
      h_Mi
     </span>
     and
     <span class="pre">
      h_Mx
     </span>
     . This array has also an extra entry at the end that stores the number of non-zero elements in the matrix
     <span class="pre">
      M
     </span>
     . The array size is
     <span class="pre">
      n+1
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      h_Mi
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of column indices corresponding to the non-zero elements in the matrix. It is assumed that this array is sorted by row and by column within each row. The array size is
     <span class="pre">
      h_nnzM
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      h_Mx
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of values corresponding to the non-zero elements in the matrix. It is assumed that this array is sorted by row and by column within each row. The array size is
     <span class="pre">
      h_nnzM
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     An allocation of memory failed.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_EXECUTION_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     A kernel failed to launch on the GPU.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.6.7.
  </span>
  cusolverRfExtractSplitFactorsHost()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfextractsplitfactorshost" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverRfExtractSplitFactorsHost</span><span class="p">(</span><span class="cm">/* Input */</span>
<span class="n">cusolverRfHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="cm">/* Output (in the host memory)</span><span class="o">*/</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_nnzL</span><span class="p">,</span>
<span class="kt">int</span><span class="o">**</span><span class="n">h_Lp</span><span class="p">,</span>
<span class="kt">int</span><span class="o">**</span><span class="n">h_Li</span><span class="p">,</span>
<span class="kt">double</span><span class="o">**</span><span class="n">h_Lx</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_nnzU</span><span class="p">,</span>
<span class="kt">int</span><span class="o">**</span><span class="n">h_Up</span><span class="p">,</span>
<span class="kt">int</span><span class="o">**</span><span class="n">h_Ui</span><span class="p">,</span>
<span class="kt">double</span><span class="o">**</span><span class="n">h_Ux</span><span class="p">);</span>
</pre>
 <p>
  This routine extracts lower
  <span class="pre">
   (L)
  </span>
  and upper
  <span class="pre">
   (U)
  </span>
  triangular factors from the cuSolverRF library handle into the host memory. It is assumed that a prior call to the
  <span class="pre">
   cusolverRfRefactor()
  </span>
  was done in order to generate these triangular factors.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSolverRF library.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      h_nnzL
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of non-zero elements of matrix
     <span class="pre">
      L
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      h_Lp
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of offsets corresponding to the start of each row in the arrays
     <span class="pre">
      h_Li
     </span>
     and
     <span class="pre">
      h_Lx
     </span>
     . This array has also an extra entry at the end that stores the number of non-zero elements in the matrix
     <span class="pre">
      L
     </span>
     . The array size is
     <span class="pre">
      n+1
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      h_Li
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of column indices corresponding to the non-zero elements in the matrix
     <span class="pre">
      L
     </span>
     . It is assumed that this array is sorted by row and by column within each row. The array size is
     <span class="pre">
      h_nnzL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      h_Lx
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of values corresponding to the non-zero elements in the matrix
     <span class="pre">
      L
     </span>
     . It is assumed that this array is sorted by row and by column within each row. The array size is
     <span class="pre">
      h_nnzL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      h_nnzU
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of non-zero elements of matrix
     <span class="pre">
      U
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      h_Up
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of offsets corresponding to the start of each row in the arrays
     <span class="pre">
      h_Ui
     </span>
     and
     <span class="pre">
      h_Ux
     </span>
     . This array has also an extra entry at the end that stores the number of non-zero elements in the matrix
     <span class="pre">
      U
     </span>
     . The array size is
     <span class="pre">
      n+1
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      h_Ui
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of column indices corresponding to the non-zero elements in the matrix
     <span class="pre">
      U
     </span>
     . It is assumed that this array is sorted by row and by column within each row. The array size is
     <span class="pre">
      h_nnzU
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      h_Ux
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of values corresponding to the non-zero elements in the matrix
     <span class="pre">
      U
     </span>
     . It is assumed that this array is sorted by row and by column within each row. The array size is
     <span class="pre">
      h_nnzU
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     An allocation of memory failed.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_EXECUTION_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     A kernel failed to launch on the GPU.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.6.8.
  </span>
  cusolverRfDestroy()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfdestroy" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span><span class="nf">cusolverRfDestroy</span><span class="p">(</span><span class="n">cusolverRfHandle_t</span><span class="n">handle</span><span class="p">);</span>
</pre>
 <p>
  This routine shuts down the cuSolverRF library. It releases acquired resources and must be called after all the cuSolverRF library routines.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The cuSolverRF library handle.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.6.9.
  </span>
  cusolverRfGetMatrixFormat()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfgetmatrixformat" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverRfGetMatrixFormat</span><span class="p">(</span><span class="n">cusolverRfHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverRfMatrixFormat_t</span><span class="o">*</span><span class="n">format</span><span class="p">,</span>
<span class="n">cusolverRfUnitDiagonal_t</span><span class="o">*</span><span class="n">diag</span><span class="p">);</span>
</pre>
 <p>
  This routine gets the matrix format used in the
  <span class="pre">
   cusolverRfSetupDevice()
  </span>
  ,
  <span class="pre">
   cusolverRfSetupHost()
  </span>
  ,
  <span class="pre">
   cusolverRfResetValues()
  </span>
  ,
  <span class="pre">
   cusolverRfExtractBundledFactorsHost()
  </span>
  and
  <span class="pre">
   cusolverRfExtractSplitFactorsHost()
  </span>
  routines.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSolverRF library.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      format
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The enumerated matrix format type.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      diag
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The enumerated unit diagonal type.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.6.10.
  </span>
  cusolverRfGetNumericProperties()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfgetnumericproperties" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverRfGetNumericProperties</span><span class="p">(</span><span class="n">cusolverRfHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">zero</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">boost</span><span class="p">);</span>
</pre>
 <p>
  This routine gets the numeric values used for checking for ââzeroââ pivot and for boosting it in the
  <span class="pre">
   cusolverRfRefactor()
  </span>
  and
  <span class="pre">
   cusolverRfSolve()
  </span>
  routines. The numeric boosting will be used only if
  <span class="pre">
   boost
  </span>
  <span class="pre">
   &gt;
  </span>
  <span class="pre">
   0.0
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSolverRF library.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      zero
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The value below which zero pivot is flagged.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      boost
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The value which is substituted for zero pivot (if the later is flagged).
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.6.11.
  </span>
  cusolverRfGetNumericBoostReport()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfgetnumericboostreport" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverRfGetNumericBoostReport</span><span class="p">(</span><span class="n">cusolverRfHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverRfNumericBoostReport_t</span><span class="o">*</span><span class="n">report</span><span class="p">);</span>
</pre>
 <p>
  This routine gets the report whether numeric boosting was used in the
  <span class="pre">
   cusolverRfRefactor()
  </span>
  and
  <span class="pre">
   cusolverRfSolve()
  </span>
  routines.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSolverRF library.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      report
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The enumerated boosting report type.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.6.12.
  </span>
  cusolverRfGetResetValuesFastMode()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfgetresetvaluesfastmode" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverRfGetResetValuesFastMode</span><span class="p">(</span><span class="n">cusolverRfHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverRfResetValuesFastMode_t</span><span class="o">*</span><span class="n">fastMode</span><span class="p">);</span>
</pre>
 <p>
  This routine gets the mode used in the
  <span class="pre">
   cusolverRfResetValues
  </span>
  routine.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSolverRF library.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      fastMode
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The enumerated mode type.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.6.13.
  </span>
  cusolverRfGet_Algs()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfget-algs" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverRfGet_Algs</span><span class="p">(</span><span class="n">cusolverRfHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverRfFactorization_t</span><span class="o">*</span><span class="n">fact_alg</span><span class="p">,</span>
<span class="n">cusolverRfTriangularSolve_t</span><span class="o">*</span><span class="n">solve_alg</span><span class="p">);</span>
</pre>
 <p>
  This routine gets the algorithm used for the refactorization in
  <span class="pre">
   cusolverRfRefactor()
  </span>
  and the triangular solve in
  <span class="pre">
   cusolverRfSolve()
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSolverRF library.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      alg
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The enumerated algorithm type.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.6.14.
  </span>
  cusolverRfRefactor()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfrefactor" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span><span class="nf">cusolverRfRefactor</span><span class="p">(</span><span class="n">cusolverRfHandle_t</span><span class="n">handle</span><span class="p">);</span>
</pre>
 <p>
  This routine performs the LU re-factorization:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = L*U\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  exploring the available parallelism on the GPU. It is assumed that a prior call to the
  <span class="pre">
   cusolverRfAnalyze()
  </span>
  was done in order to find the available parallelism.
 </p>
 <p>
  This routine may be called multiple times, once for each of the linear systems:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A_{i}x_{i} = f_{i}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  There are some constraints to the combination of algorithms used for refactorization and solving routines,
  <span class="pre">
   cusolverRfRefactor()
  </span>
  and
  <span class="pre">
   cusolverRfSolve()
  </span>
  . The wrong combination generates the error code
  <span class="pre">
   CUSOLVER_STATUS_INVALID_VALUE
  </span>
  . The table below summarizes the supported combinations of algorithms:
 </p>
 <p>
  Compatible algorithms for solving and refactorization routines.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Factorization
    </p>
   </th>
   <th class="head">
    <p>
     Solving
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVERRF_FACTORIZATION_ALG0
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      TRIANGULAR_SOLVE_ALG1
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVERRF_FACTORIZATION_ALG1
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      TRIANGULAR_SOLVE_ALG2,
     </span>
     <span class="pre">
      TRIANGULAR_SOLVE_ALG3
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVERRF_FACTORIZATION_ALG2
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      TRIANGULAR_SOLVE_ALG2,
     </span>
     <span class="pre">
      TRIANGULAR_SOLVE_ALG3
     </span>
    </p>
   </td>
  </tr>
 </table>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSolverRF library.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_EXECUTION_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     A kernel failed to launch on the GPU.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ZERO_PIVOT
     </span>
    </p>
   </td>
   <td>
    <p>
     A zero pivot was encountered during the computation.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.6.15.
  </span>
  cusolverRfResetValues()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfresetvalues" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverRfResetValues</span><span class="p">(</span><span class="cm">/* Input (in the device memory)</span><span class="o">*/</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">P</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">Q</span><span class="p">,</span>
<span class="cm">/* Output */</span>
<span class="n">cusolverRfHandle_t</span><span class="n">handle</span><span class="p">);</span>
</pre>
 <p>
  This routine updates internal data structures with the values of the new coefficient matrix. It is assumed that the arrays
  <span class="pre">
   csrRowPtrA
  </span>
  ,
  <span class="pre">
   csrColIndA
  </span>
  ,
  <span class="pre">
   P
  </span>
  and
  <span class="pre">
   Q
  </span>
  have not changed since the last call to the
  <span class="pre">
   cusolverRfSetup[Host|Device]
  </span>
  routine. This assumption reflects the fact that the sparsity pattern of coefficient matrices as well as reordering to minimize fill-in and pivoting remain the same in the set of linear systems:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A_{i}x_{i} = f_{i}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  This routine may be called multiple times, once for each of the linear systems:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A_{i}x_{i} = f_{i}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of rows (and columns) of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnzA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of non-zero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of offsets corresponding to the start of each row in the arrays
     <span class="pre">
      csrColIndA
     </span>
     and
     <span class="pre">
      csrValA
     </span>
     . This array has also an extra entry at the end that stores the number of non-zero elements in the matrix. The array size is
     <span class="pre">
      n+1
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of column indices corresponding to the non-zero elements in the matrix. It is assumed that this array is sorted by row and by column within each row. The array size is
     <span class="pre">
      nnzA
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of values corresponding to the non-zero elements in the matrix. It is assumed that this array is sorted by row and by column within each row. The array size is
     <span class="pre">
      nnzA
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      P
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The left permutation (often associated with pivoting). The array size in
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      Q
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The right permutation (often associated with reordering). The array size in
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSolverRF library.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     An unsupported value or parameter was passed.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_EXECUTION_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     A kernel failed to launch on the GPU.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.6.16.
  </span>
  cusolverRfSetMatrixFormat()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfsetmatrixformat" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverRfSetMatrixFormat</span><span class="p">(</span><span class="n">cusolverRfHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverRfMatrixFormat_t</span><span class="n">format</span><span class="p">,</span>
<span class="n">cusolverRfUnitDiagonal_t</span><span class="n">diag</span><span class="p">);</span>
</pre>
 <p>
  This routine sets the matrix format used in the
  <span class="pre">
   cusolverRfSetupDevice()
  </span>
  ,
  <span class="pre">
   cusolverRfSetupHost()
  </span>
  ,
  <span class="pre">
   cusolverRfResetValues()
  </span>
  ,
  <span class="pre">
   cusolverRfExtractBundledFactorsHost()
  </span>
  and
  <span class="pre">
   cusolverRfExtractSplitFactorsHost()
  </span>
  routines. It may be called once prior to
  <span class="pre">
   cusolverRfSetupDevice()
  </span>
  and
  <span class="pre">
   cusolverRfSetupHost()
  </span>
  routines.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSolverRF library.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      format
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The enumerated matrix format type.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      diag
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The enumerated unit diagonal type.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     An enumerated mode parameter is wrong.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.6.17.
  </span>
  cusolverRfSetNumericProperties()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfsetnumericproperties" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverRfSetNumericProperties</span><span class="p">(</span><span class="n">cusolverRfHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">double</span><span class="n">zero</span><span class="p">,</span>
<span class="kt">double</span><span class="n">boost</span><span class="p">);</span>
</pre>
 <p>
  This routine sets the numeric values used for checking for ââzeroââ pivot and for boosting it in the
  <span class="pre">
   cusolverRfRefactor()
  </span>
  and
  <span class="pre">
   cusolverRfSolve()
  </span>
  routines. It may be called multiple times prior to
  <span class="pre">
   cusolverRfRefactor()
  </span>
  and
  <span class="pre">
   cusolverRfSolve()
  </span>
  routines. The numeric boosting will be used only if
  <span class="pre">
   boost
  </span>
  <span class="pre">
   &gt;
  </span>
  <span class="pre">
   0.0
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSolverRF library.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      zero
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The value below which zero pivot is flagged.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      boost
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The value which is substituted for zero pivot (if the later is flagged).
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.6.18.
  </span>
  cusolverRfSetResetValuesFastMode()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfsetresetvaluesfastmode" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverRfSetResetValuesFastMode</span><span class="p">(</span><span class="n">cusolverRfHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverRfResetValuesFastMode_t</span><span class="n">fastMode</span><span class="p">);</span>
</pre>
 <p>
  This routine sets the mode used in the
  <span class="pre">
   cusolverRfResetValues
  </span>
  routine. The fast mode requires extra memory and is recommended only if very fast calls to
  <span class="pre">
   cusolverRfResetValues()
  </span>
  are needed. It may be called once prior to
  <span class="pre">
   cusolverRfAnalyze()
  </span>
  routine.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSolverRF library.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      fastMode
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The enumerated mode type.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     An enumerated mode parameter is wrong.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.6.19.
  </span>
  cusolverRfSetAlgs()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfsetalgs" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverRfSetAlgs</span><span class="p">(</span><span class="n">cusolverRfHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverRfFactorization_t</span><span class="n">fact_alg</span><span class="p">,</span>
<span class="n">cusolverRfTriangularSolve_t</span><span class="n">alg</span><span class="p">);</span>
</pre>
 <p>
  This routine sets the algorithm used for the refactorization in
  <span class="pre">
   cusolverRfRefactor()
  </span>
  and the triangular solve in
  <span class="pre">
   cusolverRfSolve()
  </span>
  . It may be called once prior to
  <span class="pre">
   cusolverRfAnalyze()
  </span>
  routine.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSolverRF library.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      alg
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The enumerated algorithm type.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.6.20.
  </span>
  cusolverRfSolve()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfsolve" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverRfSolve</span><span class="p">(</span><span class="cm">/* Input (in the device memory)</span><span class="o">*/</span>
<span class="n">cusolverRfHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">P</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">Q</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">Temp</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldt</span><span class="p">,</span>
<span class="cm">/* Input/Output (in the device memory) */</span>
<span class="kt">double</span><span class="o">*</span><span class="n">XF</span><span class="p">,</span>
<span class="cm">/* Input */</span>
<span class="kt">int</span><span class="n">ldxf</span><span class="p">);</span>
</pre>
 <p>
  This routine performs the forward and backward solve with the lower
  <span class="math notranslate nohighlight">
   \(L\in R^{nxn}\)
  </span>
  and upper
  <span class="math notranslate nohighlight">
   \(U\in R^{nxn}\)
  </span>
  triangular factors resulting from the LU re-factorization:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = L*U\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  which is assumed to have been computed by a prior call to the
  <span class="pre">
   cusolverRfRefactor()
  </span>
  routine.
 </p>
 <p>
  The routine can solve linear systems with multiple right-hand-sides (RHS):
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(AX = {(LU)}X = L{(UX)} = LY = F~{where}~UX = Y\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  even though currently only a single RHS is supported.
 </p>
 <p>
  This routine may be called multiple times, once for each of the linear systems:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A_{i}x_{i} = f_{i}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSolverRF library.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      P
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The left permutation (often associated with pivoting). The array size in
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      Q
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The right permutation (often associated with reordering). The array size in
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nrhs
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The number right-hand-sides to be solved.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      Temp
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The dense matrix that contains temporary workspace (of size
     <span class="pre">
      ldt*nrhs
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ldt
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The leading dimension of dense matrix Temp (
     <span class="pre">
      ldt
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      n
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      XF
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     The dense matrix that contains the right-hand-sides
     <span class="pre">
      F
     </span>
     and solutions
     <span class="pre">
      X
     </span>
     (of size
     <span class="pre">
      ldxf*nrhs
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ldxf
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The leading dimension of dense matrix
     <span class="pre">
      XF
     </span>
     (
     <span class="pre">
      ldxf
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      n
     </span>
     ).
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     An unsupported value or parameter was passed.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_EXECUTION_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     A kernel failed to launch on the GPU.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.6.21.
  </span>
  cusolverRfBatchSetupHost()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfbatchsetuphost" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverRfBatchSetupHost</span><span class="p">(</span><span class="cm">/* Input (in the host memory)</span><span class="o">*/</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_csrRowPtrA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_csrColIndA</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">h_csrValA_array</span><span class="p">[],</span>
<span class="kt">int</span><span class="n">nnzL</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_csrRowPtrL</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_csrColIndL</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">h_csrValL</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzU</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_csrRowPtrU</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_csrColIndU</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">h_csrValU</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_P</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">h_Q</span><span class="p">,</span>
<span class="cm">/* Output */</span>
<span class="n">cusolverRfHandle_t</span><span class="n">handle</span><span class="p">);</span>
</pre>
 <p>
  This routine assembles the internal data structures of the cuSolverRF library for batched operation. It is called after the call to the
  <span class="pre">
   cusolverRfCreate()
  </span>
  routine, and before any other batched routines.
 </p>
 <p>
  The batched operation assumes that the user has the following linear systems:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A_{j}x_{j} = b_{j}{,\ j\ =\ 1,2,...,\ batchSize}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where each matrix in the set:
  <span class="math notranslate nohighlight">
   \(\{ A_{j}\}\)
  </span>
  has the same sparsity pattern, and quite similar such that factorization can be done by the same permutation
  <span class="pre">
   P
  </span>
  and
  <span class="pre">
   Q
  </span>
  . In other words,
  <span class="math notranslate nohighlight">
   \(A_{j}{,\ j&gt;1}\)
  </span>
  is a small perturbation of
  <span class="math notranslate nohighlight">
   \(A_{1}\)
  </span>
  .
 </p>
 <p>
  This routine accepts as input (on the host) the original matrix
  <span class="pre">
   A
  </span>
  (sparsity pattern and batched values), the lower
  <span class="pre">
   (L)
  </span>
  and upper
  <span class="pre">
   (U)
  </span>
  triangular factors, as well as the left
  <span class="pre">
   (P)
  </span>
  and the right
  <span class="pre">
   (Q)
  </span>
  permutations resulting from the full LU factorization of the first
  <span class="pre">
   (i=1)
  </span>
  linear system:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A_{i}x_{i} = f_{i}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The permutations
  <span class="pre">
   P
  </span>
  and
  <span class="pre">
   Q
  </span>
  represent the final composition of all the left and right reorderings applied to the original matrix
  <span class="pre">
   A
  </span>
  , respectively. However, these permutations are often associated with partial pivoting and reordering to minimize fill-in, respectively.
 </p>
 <p>
  Remark 1: the matrices
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   L
  </span>
  and
  <span class="pre">
   U
  </span>
  must be CSR format and base-0.
 </p>
 <p>
  Remark 2: to get best performance,
  <span class="pre">
   batchSize
  </span>
  should be multiple of 32 and greater or equal to 32. The algorithm is memory-bound, once bandwidth limit is reached, there is no room to improve performance by large
  <span class="pre">
   batchSize
  </span>
  . In practice,
  <span class="pre">
   batchSize
  </span>
  of 32 - 128 is often enough to obtain good performance, but in some cases larger
  <span class="pre">
   batchSize
  </span>
  might be beneficial.
 </p>
 <p>
  The following routine needs to be called only once for a single linear system:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A_{i}x_{i} = f_{i}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      batchSize
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of matrices in the batched mode.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of rows (and columns) of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of non-zero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      h_csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of offsets corresponding to the start of each row in the arrays
     <span class="pre">
      h_csrColIndA
     </span>
     and
     <span class="pre">
      h_csrValA
     </span>
     . This array has also an extra entry at the end that stores the number of non-zero elements in the matrix. The array size is
     <span class="pre">
      n+1
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      h_csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of column indices corresponding to the non-zero elements in the matrix. It is assumed that this array is sorted by row and by column within each row. The array size is
     <span class="pre">
      nnzA
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      h_csrValA_array
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of pointers of size
     <span class="pre">
      batchSize
     </span>
     , each pointer points to the array of values corresponding to the non-zero elements in the matrix.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzL
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of non-zero elements of matrix
     <span class="pre">
      L
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      h_csrRowPtrL
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of offsets corresponding to the start of each row in the arrays
     <span class="pre">
      h_csrColIndL
     </span>
     and
     <span class="pre">
      h_csrValL
     </span>
     . This array has also an extra entry at the end that stores the number of non-zero elements in the matrix
     <span class="pre">
      L
     </span>
     . The array size is
     <span class="pre">
      n+1
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      h_csrColIndL
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of column indices corresponding to the non-zero elements in the matrix
     <span class="pre">
      L
     </span>
     . It is assumed that this array is sorted by row and by column within each row. The array size is
     <span class="pre">
      nnzL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      h_csrValL
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of values corresponding to the non-zero elements in the matrix
     <span class="pre">
      L
     </span>
     . It is assumed that this array is sorted by row and by column within each row. The array size is
     <span class="pre">
      nnzL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzU
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of non-zero elements of matrix
     <span class="pre">
      U
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      h_csrRowPtrU
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of offsets corresponding to the start of each row in the arrays
     <span class="pre">
      h_csrColIndU
     </span>
     and
     <span class="pre">
      h_csrValU
     </span>
     . This array has also an extra entry at the end that stores the number of non-zero elements in the matrix
     <span class="pre">
      U
     </span>
     . The array size is
     <span class="pre">
      n+1
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      h_csrColIndU
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of column indices corresponding to the non-zero elements in the matrix
     <span class="pre">
      U
     </span>
     . It is assumed that this array is sorted by row and by column within each row. The array size is
     <span class="pre">
      nnzU
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      h_csrValU
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of values corresponding to the non-zero elements in the matrix
     <span class="pre">
      U
     </span>
     . It is assumed that this array is sorted by row and by column within each row. The array size is
     <span class="pre">
      nnzU
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      h_P
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The left permutation (often associated with pivoting). The array size in
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      h_Q
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The right permutation (often associated with reordering). The array size in
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSolverRF library.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     An unsupported value or parameter was passed.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     An allocation of memory failed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_EXECUTION_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     A kernel failed to launch on the GPU.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.6.22.
  </span>
  cusolverRfBatchAnalyze()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfbatchanalyze" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span><span class="nf">cusolverRfBatchAnalyze</span><span class="p">(</span><span class="n">cusolverRfHandle_t</span><span class="n">handle</span><span class="p">);</span>
</pre>
 <p>
  This routine performs the appropriate analysis of parallelism available in the batched LU re-factorization.
 </p>
 <p>
  It is assumed that a prior call to the
  <span class="pre">
   cusolverRfBatchSetup[Host]()
  </span>
  was done in order to create internal data structures needed for the analysis.
 </p>
 <p>
  The following routine needs to be called only once for a single linear system:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A_{j}x_{j} = b_{j}{,\ j\ =\ 1,2,...,\ batchSize}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSolverRF library.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_EXECUTION_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     A kernel failed to launch on the GPU.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     An allocation of memory failed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.6.23.
  </span>
  cusolverRfBatchResetValues()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfbatchresetvalues" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverRfBatchResetValues</span><span class="p">(</span><span class="cm">/* Input (in the device memory)</span><span class="o">*/</span>
<span class="kt">int</span><span class="n">batchSize</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">csrValA_array</span><span class="p">[],</span>
<span class="kt">int</span><span class="o">*</span><span class="n">P</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">Q</span><span class="p">,</span>
<span class="cm">/* Output */</span>
<span class="n">cusolverRfHandle_t</span><span class="n">handle</span><span class="p">);</span>
</pre>
 <p>
  This routine updates internal data structures with the values of the new coefficient matrix. It is assumed that the arrays
  <span class="pre">
   csrRowPtrA
  </span>
  ,
  <span class="pre">
   csrColIndA
  </span>
  ,
  <span class="pre">
   P
  </span>
  and
  <span class="pre">
   Q
  </span>
  have not changed since the last call to the
  <span class="pre">
   cusolverRfbatch_setup_host
  </span>
  routine.
 </p>
 <p>
  This assumption reflects the fact that the sparsity pattern of coefficient matrices as well as reordering to minimize fill-in and pivoting remain the same in the set of linear systems:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A_{j}x_{j} = b_{j}{,\ j\ =\ 1,2,...,\ batchSize}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The input parameter
  <span class="pre">
   csrValA_array
  </span>
  is an array of pointers on device memory.
  <span class="pre">
   csrValA_array(j)
  </span>
  points to matrix:
  <span class="math notranslate nohighlight">
   \(A_{j}\)
  </span>
  which is also on device memory.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      batchSize
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of matrices in batched mode.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of rows (and columns) of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of non-zero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of offsets corresponding to the start of each row in the arrays
     <span class="pre">
      csrColIndA
     </span>
     and
     <span class="pre">
      csrValA
     </span>
     . This array has also an extra entry at the end that stores the number of non-zero elements in the matrix. The array size is
     <span class="pre">
      n+1
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The array of column indices corresponding to the non-zero elements in the matrix. It is assumed that this array is sorted by row and by column within each row. The array size is
     <span class="pre">
      nnzA
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrValA_array
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of pointers of size
     <span class="pre">
      batchSize
     </span>
     , each pointer points to the array of values corresponding to the non-zero elements in the matrix.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      P
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The left permutation (often associated with pivoting). The array size in
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      Q
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The right permutation (often associated with reordering). The array size in
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSolverRF library.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     An unsupported value or parameter was passed.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_EXECUTION_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     A kernel failed to launch on the GPU.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.6.24.
  </span>
  cusolverRfBatchRefactor()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfbatchrefactor" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span><span class="nf">cusolverRfBatchRefactor</span><span class="p">(</span><span class="n">cusolverRfHandle_t</span><span class="n">handle</span><span class="p">);</span>
</pre>
 <p>
  This routine performs the LU re-factorization:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(M_{j} = P*A_{j}*Q^{T} = L_{j}*U_{j}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  exploring the available parallelism on the GPU. It is assumed that a prior call to the
  <span class="pre">
   cusolverRfBatchAnalyze()
  </span>
  was done in order to find the available parallelism.
 </p>
 <p>
  Remark:
  <span class="pre">
   cusolverRfBatchRefactor()
  </span>
  would not report any failure of LU refactorization. The user has to call
  <span class="pre">
   cusolverRfBatchZeroPivot()
  </span>
  to know which matrix failed the LU refactorization.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSolverRF library.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_EXECUTION_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     A kernel failed to launch on the GPU.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.6.25.
  </span>
  cusolverRfBatchSolve()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfbatchsolve" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverRfBatchSolve</span><span class="p">(</span><span class="cm">/* Input (in the device memory)</span><span class="o">*/</span>
<span class="n">cusolverRfHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">P</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">Q</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">Temp</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldt</span><span class="p">,</span>
<span class="cm">/* Input/Output (in the device memory) */</span>
<span class="kt">double</span><span class="o">*</span><span class="n">XF_array</span><span class="p">[],</span>
<span class="cm">/* Input */</span>
<span class="kt">int</span><span class="n">ldxf</span><span class="p">);</span>
</pre>
 <p>
  To solve
  <span class="math notranslate nohighlight">
   \(A_{j}*x_{j} = b_{j}\)
  </span>
  , first we reform the equation by
  <span class="math notranslate nohighlight">
   \(M_{j}*Q*x_{j} = P*b_{j}\)
  </span>
  where
  <span class="math notranslate nohighlight">
   \(M_{j} = P*A_{j}*Q^{T}\)
  </span>
  . Then do refactorization
  <span class="math notranslate nohighlight">
   \(M_{j} = L_{j}*U_{j}\)
  </span>
  by
  <span class="pre">
   cusolverRfBatch_Refactor()
  </span>
  . Further
  <span class="pre">
   cusolverRfBatch_Solve()
  </span>
  takes over the remaining steps, including:
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(z_{j} = P*b_{j}\)
  </span>
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(M_{j}*y_{j} = z_{j}\)
  </span>
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(x_{j} = Q^{T}*y_{j}\)
  </span>
 </p>
 <p>
  The input parameter
  <span class="pre">
   XF_array
  </span>
  is an array of pointers on device memory.
  <span class="pre">
   XF_array(j)
  </span>
  points to matrix
  <span class="math notranslate nohighlight">
   \(x_{j}\)
  </span>
  which is also on device memory.
 </p>
 <p>
  Remark 1: only a single rhs is supported.
 </p>
 <p>
  Remark 2: no singularity is reported during backward solve. If some matrix
  <span class="math notranslate nohighlight">
   \(A_{j}\)
  </span>
  failed the refactorization and
  <span class="math notranslate nohighlight">
   \(U_{j}\)
  </span>
  has some zero diagonal, backward solve would compute NAN. The user has to call
  <span class="pre">
   cusolverRfBatch_Zero_Pivot
  </span>
  to check if refactorization is successful or not.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSolverRF library.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      P
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The left permutation (often associated with pivoting). The array size in
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      Q
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The right permutation (often associated with reordering). The array size in
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nrhs
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The number right-hand-sides to be solved.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      Temp
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The dense matrix that contains temporary workspace (of size
     <span class="pre">
      ldt*nrhs
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ldt
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The leading dimension of dense matrix Temp (
     <span class="pre">
      ldt
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      n
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      XF_array
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     Array of pointers of size
     <span class="pre">
      batchSize
     </span>
     , each pointer points to the dense matrix that contains the right-hand-sides
     <span class="pre">
      F
     </span>
     and solutions
     <span class="pre">
      X
     </span>
     (of size
     <span class="pre">
      ldxf*nrhs
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ldxf
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The leading dimension of dense matrix
     <span class="pre">
      XF
     </span>
     (
     <span class="pre">
      ldxf
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      n
     </span>
     ).
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     An unsupported value or parameter was passed.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_EXECUTION_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     A kernel failed to launch on the GPU.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   2.6.26.
  </span>
  cusolverRfBatchZeroPivot()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverrfbatchzeropivot" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverRfBatchZeroPivot</span><span class="p">(</span><span class="cm">/* Input */</span>
<span class="n">cusolverRfHandle_t</span><span class="n">handle</span>
<span class="cm">/* Output (in the host memory)</span><span class="o">*/</span>
<span class="kt">int</span><span class="o">*</span><span class="n">position</span><span class="p">);</span>
</pre>
 <p>
  Although
  <span class="math notranslate nohighlight">
   \(A_{j}\)
  </span>
  is close to each other, it does not mean
  <span class="math notranslate nohighlight">
   \(M_{j} = P*A_{j}*Q^{T} = L_{j}*U_{j}\)
  </span>
  exists for every j. The user can query which matrix failed LU refactorization by checking corresponding value in
  <span class="pre">
   position
  </span>
  array. The input parameter
  <span class="pre">
   position
  </span>
  is an integer array of size
  <span class="pre">
   batchSize
  </span>
  .
 </p>
 <p>
  The
  <span class="pre">
   j-th
  </span>
  component denotes the refactorization result of matrix
  <span class="math notranslate nohighlight">
   \(A_{j}\)
  </span>
  . If
  <span class="pre">
   position(j)
  </span>
  is -1, the LU refactorization of matrix
  <span class="math notranslate nohighlight">
   \(A_{j}\)
  </span>
  is successful. If
  <span class="pre">
   position(j)
  </span>
  is
  <span class="pre">
   k
  </span>
  <span class="pre">
   &gt;=
  </span>
  <span class="pre">
   0
  </span>
  , matrix
  <span class="math notranslate nohighlight">
   \(A_{j}\)
  </span>
  is not LU factorizable and its matrix
  <span class="math notranslate nohighlight">
   \(U_{j}{(j,j)}\)
  </span>
  is zero.
 </p>
 <p>
  The return value of
  <span class="pre">
   cusolverRfBatch_Zero_Pivot
  </span>
  is
  <span class="pre">
   CUSOLVER_STATUS_ZERO_PIVOT
  </span>
  if there exists one
  <span class="math notranslate nohighlight">
   \(A_{j}\)
  </span>
  which failed LU refactorization. The user can redo LU factorization to get new permutation
  <span class="pre">
   P
  </span>
  and
  <span class="pre">
   Q
  </span>
  if error code
  <span class="pre">
   CUSOLVER_STATUS_ZERO_PIVOT
  </span>
  is returned.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSolverRF library.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      position
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of size
     <span class="pre">
      batchSize
     </span>
     . The value of
     <span class="pre">
      position(j)
     </span>
     reports singularity of matrix
     <span class="pre">
      Aj
     </span>
     , -1 if no structural/numerical zero,
     <span class="pre">
      k
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      0
     </span>
     if
     <span class="pre">
      Aj(k,k)
     </span>
     is either structural zero or numerical zero.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ZERO_PIVOT
     </span>
    </p>
   </td>
   <td>
    <p>
     A zero pivot was encountered during the computation.
    </p>
   </td>
  </tr>
 </table>
 <h1>
  <span class="section-number">
   3.
  </span>
  Using the CUSOLVERMG API
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#using-the-cusolvermg-api" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <h2>
  <span class="section-number">
   3.1.
  </span>
  General Description
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#id17" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  This section describes how to use the cuSolverMG library API. It is not a reference for the cuSolverMG API data types and functions; that is provided in subsequent chapters.
 </p>
 <h3>
  <span class="section-number">
   3.1.1.
  </span>
  Thread Safety
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#id18" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The library is thread-safe only if there is one cuSolverMG context per thread.
 </p>
 <h3>
  <span class="section-number">
   3.1.2.
  </span>
  Determinism
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#determinism" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Currently all cuSolverMG API routines from a given toolkit version generate the same bit-wise results when the following conditions are respected :
 </p>
 <ul class="simple">
  <li>
   <p>
    all GPUs participating to the computation have the same compute-capabilities and the same number of SMs.
   </p>
  </li>
  <li>
   <p>
    the tiles size is kept the same between run.
   </p>
  </li>
  <li>
   <p>
    number of logical GPUs is kept the same. The order of GPUs are not important because all have the same compute-capabilities.
   </p>
  </li>
 </ul>
 <h3>
  <span class="section-number">
   3.1.3.
  </span>
  Tile Strategy
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#tile-strategy" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The tiling strategy of cuSolverMG is compatible with ScaLAPACK. The current release only supports 1-D column block cyclic, column-major PACKED format.
 </p>
 <p>
  Figure 1.a shows a partition of the matrix A of dimension
  <span class="pre">
   M_A
  </span>
  by
  <span class="pre">
   N_A
  </span>
  . Each column tile has
  <span class="pre">
   T_A
  </span>
  columns. There are seven columns of tiles, labeled as 0,1,2,3,4,5,6, distributed into three GPUs in a
  <span class="pre">
   cyclic
  </span>
  way, i.e. each GPU takes one column tile in turn. For example, GPU 0 has column tile 0, 3, 6 (yellow tiles) and GPU 1 takes column tiles next to GPU 0 (blue tiles). Not all GPUs have the same number of tiles; in this example, GPU 0 has three tiles, others have only two tiles.
 </p>
 <p>
  Figure 1.b shows two possible formats to store those column tiles locally in each GPU. Left side is called PACKED format and right side is UNPACKED format. PACKED format aggregates three column tiles in a contiguous memory block while UNPACKED format distributes these three column tiles into different memory blocks. The only difference between them is that PACKED format can have a big GEMM call instead of three GEMM calls in UNPACKED format. So theoretically speaking, PACKED format can deliver better performance than UNPACKED format.
  <span class="pre">
   cuSolverMG
  </span>
  only supports PACKED format in the API. In order to achieve maximal performance, the user just needs to choose the proper tile size
  <span class="pre">
   T_A
  </span>
  to partition the matrix, not too small, for example 256 or above is enough.
 </p>
 <p>
  There is another parameter, called
  <span class="pre">
   LLD_A
  </span>
  , to control the leading dimension of the local matrix in each GPU.
  <span class="pre">
   LLD_A
  </span>
  must be greater or equal to
  <span class="pre">
   M_A
  </span>
  . The purpose of
  <span class="pre">
   LLD_A
  </span>
  is for better performance of GEMM. For small problems, GEMM is faster if
  <span class="pre">
   LLD_A
  </span>
  is power of 2. However for big problems,
  <span class="pre">
   LLD_A
  </span>
  does not show significant improvement.
  <span class="pre">
   cuSolverMG
  </span>
  only supports
  <span class="pre">
   LLD_A=M_A
  </span>
  .
 </p>
 <p>
  <span class="caption-text">
   Example of
   <span class="pre">
    cuSolverMG
   </span>
   tiling for 3 GPUs
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#mg-tile-info-example-of-mg-tiling-for-3-gpus" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  The processing grid in
  <span class="pre">
   cuSolverMG
  </span>
  is a list of GPU IDs, similar to the process ID in
  <span class="pre">
   ScaLAPACK
  </span>
  .
  <span class="pre">
   cuSolverMG
  </span>
  only supports 1D column block cyclic, so only 1D grid is supported as well. Suppose
  <span class="pre">
   deviceId
  </span>
  is a list of GPU IDs, both
  <span class="pre">
   deviceId=1,1,1
  </span>
  and
  <span class="pre">
   deviceId=2,1,0
  </span>
  are valid. The former describes three logical devices that are selected to run
  <span class="pre">
   cuSolverMG
  </span>
  routines, and all have the same physical ID, 0. The latter still uses three logical devices, but each has a different physical ID. The current design only accepts 32 logical devices, that is, the length of
  <span class="pre">
   deviceId
  </span>
  is less or equal to 32. Figure 1 uses
  <span class="pre">
   deviceId=0,1,2
  </span>
  .
 </p>
 <p>
  In practice, the matrix A is distributed into GPUs listed in
  <span class="pre">
   deviceId
  </span>
  . If the user chooses
  <span class="pre">
   deviceId=1,1,1
  </span>
  , all columns tile are located in GPU 1, this will limit the size of the problem because of memory capacity of one GPU. Besides, multiGPU routine adds extra overhead on data communication through the off-chip bus, which has a big performance impact if NVLINK is not supported or used. It would be faster to run on a single GPU instead of running multiGPU version with devices of the same GPU ID.
 </p>
 <h3>
  <span class="section-number">
   3.1.4.
  </span>
  Global Matrix Versus Local Matrix
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#global-matrix-versus-local-matrix" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Operating a submatrix of the matrix A is simple in dense linear algebra, just shift the pointer to the starting point of the submatrix relative to A. For example,
  <span class="pre">
   gesvd(10,10,
  </span>
  <span class="pre">
   A)
  </span>
  is SVD of
  <span class="pre">
   A(0:9,0:9)
  </span>
  .
  <span class="pre">
   gesvd(10,10,
  </span>
  <span class="pre">
   A
  </span>
  <span class="pre">
   +
  </span>
  <span class="pre">
   5
  </span>
  <span class="pre">
   +
  </span>
  <span class="pre">
   2*lda
  </span>
  <span class="pre">
   )
  </span>
  is SVD of 10-by-10 submatrix starting at
  <span class="pre">
   A(5,2)
  </span>
  .
 </p>
 <p>
  However it is not simple to operate on a submatrix of a distributed matrix because different starting point of the submatrix changes the distribution of the layout of that submatrix.
  <span class="pre">
   ScaLAPACK
  </span>
  introduces two parameters,
  <span class="pre">
   IA
  </span>
  and
  <span class="pre">
   JA
  </span>
  , to locate the submatrix. Figure 2 shows (global) matrix A of dimension
  <span class="pre">
   M_A
  </span>
  by
  <span class="pre">
   N_A
  </span>
  . The
  <span class="pre">
   sub(A)
  </span>
  is a
  <span class="pre">
   M
  </span>
  by
  <span class="pre">
   N
  </span>
  submatrix of A, starting at
  <span class="pre">
   IA
  </span>
  and
  <span class="pre">
   JA
  </span>
  . Please be aware that
  <span class="pre">
   IA
  </span>
  and
  <span class="pre">
   JA
  </span>
  are base-1.
 </p>
 <p>
  Given a distributed matrix
  <span class="pre">
   A
  </span>
  , the user can compute eigenvalues of the submatrix
  <span class="pre">
   sub(A)
  </span>
  by either calling
  <span class="pre">
   syevd(A,
  </span>
  <span class="pre">
   IA,
  </span>
  <span class="pre">
   JA)
  </span>
  or gathering
  <span class="pre">
   sub(A)
  </span>
  to another distributed matrix
  <span class="pre">
   B
  </span>
  and calling
  <span class="pre">
   syevd(B,
  </span>
  <span class="pre">
   IB=1,
  </span>
  <span class="pre">
   JB=1)
  </span>
  .
 </p>
 <p>
  <span class="caption-text">
   global matrix and local matrix
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#mg-global-matrix-example-of-mg-global-matrix" title="Permalink to this image">
   ï
  </a>
 </p>
 <h3>
  <span class="section-number">
   3.1.5.
  </span>
  Usage of _bufferSize
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#id19" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  There is no cudaMalloc inside
  <span class="pre">
   cuSolverMG
  </span>
  library, so the user must allocate the device workspace explicitly. The routine
  <span class="pre">
   xyz_bufferSize
  </span>
  is to query the size of workspace of the routine
  <span class="pre">
   xyz
  </span>
  , for example
  <span class="pre">
   xyz
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   syevd
  </span>
  . To make the API simple,
  <span class="pre">
   xyz_bufferSize
  </span>
  follows almost the same signature of
  <span class="pre">
   xyz
  </span>
  even it only depends on some parameters, for example, the device pointer is not used to decide the size of workspace. In most cases,
  <span class="pre">
   xyz_bufferSize
  </span>
  is called in the beginning before actual device data (pointing by a device pointer) is prepared or before the device pointer is allocated. In such cases, the user can pass a null pointer to
  <span class="pre">
   xyz_bufferSize
  </span>
  without breaking the functionality.
 </p>
 <p>
  <span class="pre">
   xyz_bufferSize
  </span>
  returns bufferSize for each device. The size is number of elements, not number of bytes.
 </p>
 <h3>
  <span class="section-number">
   3.1.6.
  </span>
  Synchronization
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#synchronization" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  All routines are in synchronous (blocking call) manner. The data is ready after the routine. However the user has to prepare the distributed data before calling the routine. For example, if the user has multiple streams to set up the matrix, stream synchronization or device synchronization is necessary to guarantee the distributed matrix is ready.
 </p>
 <h3>
  <span class="section-number">
   3.1.7.
  </span>
  Context Switch
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#context-switch" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The user does not need to restore the device by
  <span class="pre">
   cudaSetDevice()
  </span>
  after each cuSolverMG call. All routines set the device back to what the caller has.
 </p>
 <h3>
  <span class="section-number">
   3.1.8.
  </span>
  NVLINK
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#nvlink" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The peer-to-peer communication via NVLINK can dramatically reduce the overhead of data exchange among GPUs.
  <span class="pre">
   cuSolverMG
  </span>
  does not enable NVLINK implicitly, instead, it gives this option back to the user, not to interfere with other libraries. The example code H.1 shows how to enable peer-to-peer communication.
 </p>
 <h2>
  <span class="section-number">
   3.2.
  </span>
  cuSolverMG Types Reference
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermg-types-reference" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <h3>
  <span class="section-number">
   3.2.1.
  </span>
  cuSolverMG Types
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermg-types" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The
  <span class="pre">
   float
  </span>
  ,
  <span class="pre">
   double
  </span>
  ,
  <span class="pre">
   cuComplex
  </span>
  , and
  <span class="pre">
   cuDoubleComplex
  </span>
  data types are supported. The first two are standard C data types, while the last two are exported from
  <span class="pre">
   cuComplex.h
  </span>
  . In addition, cuSolverMG uses some familiar types from cuBLAS.
 </p>
 <h3>
  <span class="section-number">
   3.2.2.
  </span>
  cusolverMgHandle_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermghandle-t" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  This is a pointer type to an opaque cuSolverMG context, which the user must initialize by calling
  <span class="pre">
   cusolverMgCreate()
  </span>
  prior to calling any other library function. An un-initialized handle object will lead to unexpected behavior, including crashes of cuSolverMG. The handle created and returned by
  <span class="pre">
   cusolverMgCreate()
  </span>
  must be passed to every cuSolverMG function.
 </p>
 <h3>
  <span class="section-number">
   3.2.3.
  </span>
  cusolverMgGridMapping_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermggridmapping-t" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The type indicates layout of grids.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDALIBMG_GRID_MAPPING_ROW_MAJOR
     </span>
    </p>
   </td>
   <td>
    <p>
     Row-major ordering.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDALIBMG_GRID_MAPPING_COL_MAJOR
     </span>
    </p>
   </td>
   <td>
    <p>
     Column-major ordering.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   3.2.4.
  </span>
  cudaLibMgGrid_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cudalibmggrid-t" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Opaque structure of the distributed grid.
 </p>
 <h3>
  <span class="section-number">
   3.2.5.
  </span>
  cudaLibMgMatrixDesc_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cudalibmgmatrixdesc-t" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Opaque structure of the distributed matrix descriptor.
 </p>
 <h2>
  <span class="section-number">
   3.3.
  </span>
  Helper Function Reference
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#id20" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <h3>
  <span class="section-number">
   3.3.1.
  </span>
  cusolverMgCreate()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermgcreate" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverMgCreate</span><span class="p">(</span><span class="n">cusolverMgHandle_t</span><span class="o">*</span><span class="n">handle</span><span class="p">)</span>
</pre>
 <p>
  This function initializes the cuSolverMG library and creates a handle on the cuSolverMG context. It must be called before any other cuSolverMG API function is invoked. It allocates hardware resources necessary for accessing the GPU.
 </p>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     The pointer to the handle to the cuSolverMG context.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The initialization succeeded.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     The resources could not be allocated.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   3.3.2.
  </span>
  cusolverMgDestroy()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermgdestroy" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverMgDestroy</span><span class="p">(</span><span class="n">cusolverMgHandle_t</span><span class="n">handle</span><span class="p">)</span>
</pre>
 <p>
  This function releases CPU-side resources used by the cuSolverMG library.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSolverMG context.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The shutdown succeeded.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   3.3.3.
  </span>
  cusolverMgDeviceSelect()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermgdeviceselect" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverMgDeviceSelect</span><span class="p">(</span>
<span class="n">cusolverMgHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nbDevices</span><span class="p">,</span>
<span class="kt">int</span><span class="n">deviceId</span><span class="p">[]</span><span class="p">)</span>
</pre>
 <p>
  This function registers a subset of devices (GPUs) to
  <span class="pre">
   cuSolverMG
  </span>
  handle. Such subset of devices is used in subsequent API calls. The array
  <span class="pre">
   deviceId
  </span>
  contains a list of logical device ID. The term
  <span class="pre">
   logical
  </span>
  means repeated device ID are permitted. For example, suppose the user has only one GPU in the system, say device 0. If the user sets
  <span class="pre">
   deviceId=0,0,0
  </span>
  , then
  <span class="pre">
   cuSolverMG
  </span>
  treats them as three independent GPUs, one stream each, so concurrent kernel launches still hold. The current design only supports up to 32 logical devices.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     The pointer to the handle to the cuSolverMG context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nbDevices
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of logical devices.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      deviceId
     </span>
    </p>
   </td>
   <td>
    <p>
     An integer array of size
     <span class="pre">
      nbDevices
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The initialization succeeded.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      nbDevices
     </span>
     must be greater than zero, and less or equal to 32.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     The resources could not be allocated.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     Internal error occurred when setting internal streams and events.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   3.3.4.
  </span>
  cusolverMgCreateDeviceGrid()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermgcreatedevicegrid" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverMgCreateDeviceGrid</span><span class="p">(</span>
<span class="n">cusolverMgGrid_t</span><span class="o">*</span><span class="n">grid</span><span class="p">,</span>
<span class="kt">int32_t</span><span class="n">numRowDevices</span><span class="p">,</span>
<span class="kt">int32_t</span><span class="n">numColDevices</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int32_t</span><span class="n">deviceId</span><span class="p">[],</span>
<span class="n">cusolverMgGridMapping_t</span><span class="n">mapping</span><span class="p">)</span>
</pre>
 <p>
  This function sets up a grid of devices.
 </p>
 <p>
  Only 1-D column block cyclic is supported, so
  <span class="pre">
   numRowDevices
  </span>
  must be equal to 1.
 </p>
 <p>
  WARNING:
  <span class="pre">
   cusolverMgCreateDeviceGrid()
  </span>
  must be consistent with
  <span class="pre">
   cusolverMgDeviceSelect()
  </span>
  , i.e.
  <span class="pre">
   numColDevices
  </span>
  must be equal to
  <span class="pre">
   nbDevices
  </span>
  in
  <span class="pre">
   cusolverMgDeviceSelect()
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      grid
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The pointer to the opaque structure.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      numRowDevices
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of devices in the row.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      numColDevices
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of devices in the column.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      deviceId
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of size
     <span class="pre">
      numColDevices
     </span>
     , containing device IDs.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      mapping
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Row-major or column-major ordering.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      numColDevices
     </span>
     is not greater than 0.
     <span class="pre">
      numRowDevices
     </span>
     is not 1.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   3.3.5.
  </span>
  cusolverMgDestroyGrid()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermgdestroygrid" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverMgDestroyGrid</span><span class="p">(</span>
<span class="n">cusolverMgGrid_t</span><span class="n">grid</span><span class="p">)</span>
</pre>
 <p>
  This function releases resources of a grid.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     MemSpace
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      grid
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input/output
     </span>
    </p>
   </td>
   <td>
    <p>
     The pointer to the opaque structure.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   3.3.6.
  </span>
  cusolverMgCreateMatDescr()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermgcreatematdescr" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverMgCreateMatrixDesc</span><span class="p">(</span>
<span class="n">cusolverMgMatrixDesc_t</span><span class="o">*</span><span class="n">desc</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">numRows</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">numCols</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">rowBlockSize</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">colBlockSize</span><span class="p">,</span>
<span class="n">cudaDataType_t</span><span class="n">dataType</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusolverMgGrid_t</span><span class="n">grid</span><span class="p">)</span>
</pre>
 <p>
  This function sets up the matrix descriptor
  <span class="pre">
   desc
  </span>
  .
 </p>
 <p>
  Only 1-D column block cyclic is supported, so
  <span class="pre">
   numRows
  </span>
  must be equal to
  <span class="pre">
   rowBlockSize
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      desc
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix descriptor.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      numRows
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of rows of global A.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      numCols
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of columns of global A.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      rowBlockSize
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of rows per tile.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      colBlockSize
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of columns per tile.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dataType
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of the matrix.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      grid
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The pointer to structure of grid.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      numRows
     </span>
     ,
     <span class="pre">
      numCols
     </span>
     , or
     <span class="pre">
      rowBlockSize
     </span>
     or
     <span class="pre">
      colBlockSize
     </span>
     is less than 0.
     <span class="pre">
      numRows
     </span>
     is not equal to
     <span class="pre">
      rowBlockSize
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   3.3.7.
  </span>
  cusolverMgDestroyMatrixDesc()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermgdestroymatrixdesc" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverMgDestroyMatrixDesc</span><span class="p">(</span>
<span class="n">cusolverMgMatrixDesc_t</span><span class="n">desc</span><span class="p">)</span>
</pre>
 <p>
  This function releases the matrix descriptor
  <span class="pre">
   desc
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      desc
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input/output
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix descriptor.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
 </table>
 <h2>
  <span class="section-number">
   3.4.
  </span>
  Dense Linear Solver Reference
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#dense-linear-solver-reference" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  This section describes the linear solver API of cuSolverMG.
 </p>
 <h3>
  <span class="section-number">
   3.4.1.
  </span>
  cusolverMgPotrf()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermgpotrf" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The following helper function can calculate the sizes needed for pre-allocated buffer for
  <span class="pre">
   cusolverMgPotrf
  </span>
  :
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverMgPotrf_bufferSize</span><span class="p">(</span>
<span class="n">cusolverMgHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">N</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">array_d_A</span><span class="p">[],</span>
<span class="kt">int</span><span class="n">IA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">JA</span><span class="p">,</span>
<span class="n">cudaLibMgMatrixDesc_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">lwork</span><span class="p">)</span>
</pre>
 <p>
  The following routine:
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverMgPotrf</span><span class="p">(</span>
<span class="n">cusolverMgHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">N</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">array_d_A</span><span class="p">[],</span>
<span class="kt">int</span><span class="n">IA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">JA</span><span class="p">,</span>
<span class="n">cudaLibMgMatrixDesc_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">array_d_work</span><span class="p">[],</span>
<span class="kt">int64_t</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">)</span>
</pre>
 <p>
  computes the Cholesky factorization of a Hermitian positive-definite matrix using the generic API interface.
 </p>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   nÃn
  </span>
  Hermitian matrix; only lower or upper part is meaningful. The input parameter
  <span class="pre">
   uplo
  </span>
  indicates which part of the matrix is used. The function would leave other parts untouched.
 </p>
 <p>
  If input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_LOWER
  </span>
  , only lower triangular part of
  <span class="pre">
   A
  </span>
  is processed, and replaced by lower triangular Cholesky factor
  <span class="pre">
   L
  </span>
  :
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = L*L^{H}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  If input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_UPPER
  </span>
  , only upper triangular part of
  <span class="pre">
   A
  </span>
  is processed, and replaced by upper triangular Cholesky factor
  <span class="pre">
   U
  </span>
  :
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = U^{H}*U\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The user has to provide device working space in
  <span class="pre">
   array_d_work
  </span>
  .
  <span class="pre">
   array_d_work
  </span>
  is a host pointer array of dimension
  <span class="pre">
   G
  </span>
  , where
  <span class="pre">
   G
  </span>
  is number of devices.
  <span class="pre">
   array_d_work[j]
  </span>
  is a device pointer pointing to a device memory in j-th device. The data type of
  <span class="pre">
   array_d_work[j]
  </span>
  is
  <span class="pre">
   computeType
  </span>
  . The size of
  <span class="pre">
   array_d_work[j]
  </span>
  is
  <span class="pre">
   lwork
  </span>
  which is the number of elements per device, returned by
  <span class="pre">
   cusolverMgPotrf_bufferSize()
  </span>
  .
 </p>
 <p>
  If Cholesky factorization failed, i.e. some leading minor of
  <span class="pre">
   A
  </span>
  is not positive definite, or equivalently some diagonal elements of
  <span class="pre">
   L
  </span>
  or
  <span class="pre">
   U
  </span>
  is not a real number. The output parameter
  <span class="pre">
   info
  </span>
  would indicate smallest leading minor of
  <span class="pre">
   A
  </span>
  which is not positive definite.
 </p>
 <p>
  If output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  The generic API has two different types,
  <span class="pre">
   dataTypeA
  </span>
  is data type of the matrix
  <span class="pre">
   A
  </span>
  , and
  <span class="pre">
   computeType
  </span>
  is compute type of the operation and data type of the workspace (
  <span class="pre">
   array_d_work
  </span>
  )
  <span class="pre">
   descrA
  </span>
  contains
  <span class="pre">
   dataTypeA
  </span>
  , so there is no explicit parameter of
  <span class="pre">
   dataTypeA
  </span>
  .
  <span class="pre">
   cusolverMgPotrf
  </span>
  only supports the following four combinations.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/MgPotrf">
   cuSOLVER Library Samples - MgPotrf
  </a>
  for a code example.
 </p>
 <p>
  valid combination of data type and compute type
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     DataTypeA
    </p>
   </th>
   <th class="head">
    <p>
     ComputeType
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      SPOTRF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      DPOTRF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CPOTRF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ZPOTRF
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  API of potrf
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverMg library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Indicates if matrix
     <span class="pre">
      A
     </span>
     lower or upper part is stored, the other part is not referenced. Only
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     is supported.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      N
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      sub(A)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      array_d_A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     A host pointer array of dimension
     <span class="pre">
      G
     </span>
     . It contains a distributed &lt;type&gt; array containing
     <span class="pre">
      sub(A)
     </span>
     of dimension
     <span class="pre">
      N
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      N
     </span>
     . On exit,
     <span class="pre">
      sub(A)
     </span>
     contains the factors
     <span class="pre">
      L
     </span>
     or
     <span class="pre">
      U
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      IA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The row index in the global array A indicating the first row of
     <span class="pre">
      sub(A)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      JA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The column index in the global array A indicating the first column of
     <span class="pre">
      sub(A)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Matrix descriptor for the distributed matrix A.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type used for computation.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      array_d_work
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     A host pointer array of dimension
     <span class="pre">
      G
     </span>
     .
     <span class="pre">
      array_d_work[j]
     </span>
     points to a device working space in
     <span class="pre">
      j-th
     </span>
     device, &lt;type&gt; array of size
     <span class="pre">
      lwork
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Sze of
     <span class="pre">
      array_d_work[j]
     </span>
     , returned by
     <span class="pre">
      cusolverMgPotrf_bufferSize
     </span>
     .
     <span class="pre">
      lwork
     </span>
     denotes number of elements, not number of bytes.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the Cholesky factorization is successful.
    </p>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle).
    </p>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      i
     </span>
     , the leading minor of order
     <span class="pre">
      i
     </span>
     is not positive definite.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      M,N&lt;0
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   3.4.2.
  </span>
  cusolverMgPotrs()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermgpotrs" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The helper function below can calculate the sizes needed for pre-allocated buffer for
  <span class="pre">
   cusolverMgPotrs
  </span>
  .
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverMgPotrs_bufferSize</span><span class="p">(</span>
<span class="n">cusolverMgHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">array_d_A</span><span class="p">[],</span>
<span class="kt">int</span><span class="n">IA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">JA</span><span class="p">,</span>
<span class="n">cudaLibMgMatrixDesc_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">array_d_B</span><span class="p">[],</span>
<span class="kt">int</span><span class="n">IB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">JB</span><span class="p">,</span>
<span class="n">cudaLibMgMatrixDesc_t</span><span class="n">descrB</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">lwork</span><span class="p">)</span>
</pre>
 <p>
  The following routine:
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverMgPotrs</span><span class="p">(</span>
<span class="n">cusolverMgHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nrhs</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">array_d_A</span><span class="p">[],</span>
<span class="kt">int</span><span class="n">IA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">JA</span><span class="p">,</span>
<span class="n">cudaLibMgMatrixDesc_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">array_d_B</span><span class="p">[],</span>
<span class="kt">int</span><span class="n">IB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">JB</span><span class="p">,</span>
<span class="n">cudaLibMgMatrixDesc_t</span><span class="n">descrB</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">array_d_work</span><span class="p">[],</span>
<span class="kt">int64_t</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">)</span>
</pre>
 <p>
  This function solves a system of linear equations:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A*X = B\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   A
  </span>
  is a
  <span class="pre">
   nÃn
  </span>
  Hermitian matrix, only lower or upper part is meaningful using the generic API interface. The input parameter
  <span class="pre">
   uplo
  </span>
  indicates which part of the matrix is used. The function would leave other parts untouched.
 </p>
 <p>
  If input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_LOWER
  </span>
  , the matrix should
  <span class="pre">
   A
  </span>
  contain the lower triangular factor for Cholesky decomposition previously computed by
  <span class="pre">
   cusolverMgPotrf
  </span>
  routine.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = L*L^{H}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  If input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_UPPER
  </span>
  , the matrix should
  <span class="pre">
   A
  </span>
  contain the upper triangular factor for Cholesky decomposition previously computed by the
  <span class="pre">
   cusolverMgPotrf
  </span>
  routine.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = U^{H}*U\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The operation is in-place, i.e. matrix
  <span class="pre">
   B
  </span>
  contains the solution of the linear system on exit.
 </p>
 <p>
  If output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  The user has to provide device working space in
  <span class="pre">
   array_d_work
  </span>
  .
  <span class="pre">
   array_d_work
  </span>
  is a host pointer array of dimension
  <span class="pre">
   G
  </span>
  , where
  <span class="pre">
   G
  </span>
  is the number of devices.
  <span class="pre">
   array_d_work[j]
  </span>
  is a device pointer pointing to a device memory in the
  <span class="pre">
   j
  </span>
  -th device. The data type of
  <span class="pre">
   array_d_work[j]
  </span>
  is
  <span class="pre">
   computeType
  </span>
  . The size of
  <span class="pre">
   array_d_work[j]
  </span>
  is
  <span class="pre">
   lwork
  </span>
  which is number of elements per device, returned by
  <span class="pre">
   cusolverMgPotrs_bufferSize()
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i
  </span>
  -th parameter is wrong (not counting handle).
 </p>
 <p>
  The generic API has four different types:
  <span class="pre">
   dataTypeA
  </span>
  is data type of the matrix
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   dataTypeB
  </span>
  is data type of the matrix
  <span class="pre">
   B
  </span>
  ,
  <span class="pre">
   computeType
  </span>
  is compute type of the operation and data type of the workspace (
  <span class="pre">
   array_d_work
  </span>
  )
  <span class="pre">
   descrA
  </span>
  contains
  <span class="pre">
   dataTypeA
  </span>
  and
  <span class="pre">
   descrB
  </span>
  contains
  <span class="pre">
   dataTypeB
  </span>
  and so there is no explicit parameter of
  <span class="pre">
   dataTypeA
  </span>
  and
  <span class="pre">
   dataTypeB
  </span>
  .
  <span class="pre">
   cusolverMgPotrs
  </span>
  only supports the following four combinations.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/MgPotrf">
   cuSOLVER Library Samples - MgPotrf
  </a>
  for a code example.
 </p>
 <p>
  valid combination of data type and compute type
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     DataTypeA
    </p>
   </th>
   <th class="head">
    <p>
     DataTypeB
    </p>
   </th>
   <th class="head">
    <p>
     ComputeType
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      SPOTRS
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      DPOTRS
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CPOTRS
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ZPOTRS
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  API of potrs
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverMg library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Indicates if matrix
     <span class="pre">
      A
     </span>
     lower or upper part is stored, the other part is not referenced. Only
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     is supported.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      N
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      sub(A)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      NRHS
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of matrix
     <span class="pre">
      sub(A)
     </span>
     and
     <span class="pre">
      sub(B)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      array_d_A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     A host pointer array of dimension
     <span class="pre">
      G
     </span>
     . It contains a distributed &lt;type&gt; array containing
     <span class="pre">
      sub(A)
     </span>
     of dimension
     <span class="pre">
      M
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      N
     </span>
     . On exit,
     <span class="pre">
      sub(A)
     </span>
     contains the factors
     <span class="pre">
      L
     </span>
     and
     <span class="pre">
      U
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      IA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The row index in the global array A indicating the first row of
     <span class="pre">
      sub(A)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      JA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The column index in the global array A indicating the first column of
     <span class="pre">
      sub(A)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Matrix descriptor for the distributed matrix A.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      array_d_B
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     A host pointer array of dimension
     <span class="pre">
      G
     </span>
     . It contains a distributed &lt;type&gt; array containing
     <span class="pre">
      sub(B)
     </span>
     of dimension
     <span class="pre">
      N
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      NRHS
     </span>
     . On exit,
     <span class="pre">
      sub(A)
     </span>
     contains the solution to the linear system.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      IB
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The row index in the global array B indicating the first row of
     <span class="pre">
      sub(B)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      JB
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The column index in the global array B indicating the first column of
     <span class="pre">
      sub(B)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrB
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Matrix descriptor for the distributed matrix B.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type used for computation.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      array_d_work
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     A host pointer array of dimension
     <span class="pre">
      G
     </span>
     .
     <span class="pre">
      array_d_work[j]
     </span>
     points to a device working space in
     <span class="pre">
      j-th
     </span>
     device, &lt;type&gt; array of size
     <span class="pre">
      lwork
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of
     <span class="pre">
      array_d_work[j]
     </span>
     , returned by
     <span class="pre">
      cusolverMgPotrs_bufferSize
     </span>
     .
     <span class="pre">
      lwork
     </span>
     denotes number of elements, not number of bytes.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the routine successful.
    </p>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle).
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      M,N&lt;0
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   3.4.3.
  </span>
  cusolverMgPotri()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermgpotri" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The helper function below can calculate the sizes needed for pre-allocated buffer for
  <span class="pre">
   cusolverMgPotri
  </span>
  .
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverMgPotri_bufferSize</span><span class="p">(</span>
<span class="n">cusolverMgHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">N</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">array_d_A</span><span class="p">[],</span>
<span class="kt">int</span><span class="n">IA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">JA</span><span class="p">,</span>
<span class="n">cudaLibMgMatrixDesc_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">lwork</span><span class="p">)</span>
</pre>
 <p>
  The following routine:
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="n">cusolverMgPotri</span><span class="p">(</span>
<span class="n">cusolverMgHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">N</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">array_d_A</span><span class="p">[],</span>
<span class="kt">int</span><span class="n">IA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">JA</span><span class="p">,</span>
<span class="n">cudaLibMgMatrixDesc_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">array_d_work</span><span class="p">[],</span>
<span class="kt">int64_t</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">)</span>
</pre>
 <p>
  This function computes the inverse of a Hermitian positive-definite matrix
  <span class="pre">
   A
  </span>
  using the Cholesky factorization
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A = L*L^{H} = U^{H}*U\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  computed by
  <span class="pre">
   cusolverMgPotrf()
  </span>
  .
 </p>
 <p>
  If the input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_LOWER
  </span>
  , on input, matrix
  <span class="pre">
   A
  </span>
  contains the lower triangular factor of
  <span class="pre">
   A
  </span>
  computed by
  <span class="pre">
   cusolverMgPotrf
  </span>
  . Only lower triangular part of
  <span class="pre">
   A
  </span>
  is processed, and replaced the by lower triangular part of the inverse of
  <span class="pre">
   A
  </span>
  .
 </p>
 <p>
  If the input parameter
  <span class="pre">
   uplo
  </span>
  is
  <span class="pre">
   CUBLAS_FILL_MODE_UPPER
  </span>
  , on input, matrix
  <span class="pre">
   A
  </span>
  contains the upper triangular factor of
  <span class="pre">
   A
  </span>
  computed by
  <span class="pre">
   cusolverMgPotrf
  </span>
  . Only upper triangular part of
  <span class="pre">
   A
  </span>
  is processed, and replaced the by upper triangular part of the inverse of
  <span class="pre">
   A
  </span>
  .
 </p>
 <p>
  The user has to provide device working space in
  <span class="pre">
   array_d_work
  </span>
  .
  <span class="pre">
   array_d_work
  </span>
  is a host pointer array of dimension
  <span class="pre">
   G
  </span>
  , where
  <span class="pre">
   G
  </span>
  is number of devices.
  <span class="pre">
   array_d_work[j]
  </span>
  is a device pointer pointing to a device memory in the
  <span class="pre">
   j
  </span>
  -th device. The data type of
  <span class="pre">
   array_d_work[j]
  </span>
  is
  <span class="pre">
   computeType
  </span>
  . The size of
  <span class="pre">
   array_d_work[j]
  </span>
  is
  <span class="pre">
   lwork
  </span>
  which is number of elements per device, returned by
  <span class="pre">
   cusolverMgPotri_bufferSize()
  </span>
  .
 </p>
 <p>
  If the computation of the inverse fails, i.e. some leading minor of
  <span class="pre">
   L
  </span>
  or
  <span class="pre">
   U
  </span>
  , is null, the output parameter
  <span class="pre">
   info
  </span>
  would indicate the smallest leading minor of
  <span class="pre">
   L
  </span>
  or
  <span class="pre">
   U
  </span>
  which is not positive definite.
 </p>
 <p>
  If the output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting the handle).
 </p>
 <p>
  The generic API has two different types,
  <span class="pre">
   dataTypeA
  </span>
  is data type of the matrix
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   computeType
  </span>
  is compute type of the operation and data type of the workspace (
  <span class="pre">
   array_d_work
  </span>
  )
  <span class="pre">
   descrA
  </span>
  contains
  <span class="pre">
   dataTypeA
  </span>
  , so there is no explicit parameter of
  <span class="pre">
   dataTypeA
  </span>
  .
  <span class="pre">
   cusolverMgPotri
  </span>
  only supports the following four combinations.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/MgPotrf">
   cuSOLVER Library Samples - MgPotrf
  </a>
  for a code example.
 </p>
 <p>
  valid combination of data type and compute type
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     DataTypeA
    </p>
   </th>
   <th class="head">
    <p>
     ComputeType
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      SPOTRI
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      DPOTRI
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CPOTRI
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ZPOTRI
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  API of potrf
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverMg library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Indicates if matrix
     <span class="pre">
      A
     </span>
     lower or upper part is stored, the other part is not referenced. Only
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     is supported.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      N
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      sub(A)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      array_d_A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     A host pointer array of dimension
     <span class="pre">
      G
     </span>
     . It contains a distributed &lt;type&gt; array containing
     <span class="pre">
      sub(A)
     </span>
     of dimension
     <span class="pre">
      N
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      N
     </span>
     . On exit,
     <span class="pre">
      sub(A)
     </span>
     contains the upper or lower triangular part of the inverse of A depending on the value of
     <span class="pre">
      uplo
     </span>
     argument.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      IA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The row index in the global array A indicating the first row of
     <span class="pre">
      sub(A)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      JA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The column index in the global array A indicating the first column of
     <span class="pre">
      sub(A)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Matrix descriptor for the distributed matrix A.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type used for computation.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      array_d_work
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     A host pointer array of dimension
     <span class="pre">
      G
     </span>
     .
     <span class="pre">
      array_d_work[j]
     </span>
     points to a device working space in
     <span class="pre">
      j-th
     </span>
     device, &lt;type&gt; array of size
     <span class="pre">
      lwork
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of
     <span class="pre">
      array_d_work[j]
     </span>
     , returned by
     <span class="pre">
      cusolverMgPotri_bufferSize
     </span>
     .
     <span class="pre">
      lwork
     </span>
     denotes number of elements, not number of bytes.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the Cholesky factorization is successful.
    </p>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle).
    </p>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     Â
     <span class="pre">
      i
     </span>
     , the leading minor of order i is zero.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      M,N&lt;0
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The device only supports compute capability 5.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   3.4.4.
  </span>
  cusolverMgGetrf()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermggetrf" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The helper functions below can calculate the sizes needed for pre-allocated buffer.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverMgGetrf_bufferSize</span><span class="p">(</span>
<span class="n">cusolverMgHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">M</span><span class="p">,</span>
<span class="kt">int</span><span class="n">N</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">array_d_A</span><span class="p">[],</span>
<span class="kt">int</span><span class="n">IA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">JA</span><span class="p">,</span>
<span class="n">cudaLibMgMatrixDesc_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">array_d_IPIV</span><span class="p">[],</span>
<span class="n">cudaDataType_t</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>
</pre>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverMgGetrf</span><span class="p">(</span>
<span class="n">cusolverMgHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">M</span><span class="p">,</span>
<span class="kt">int</span><span class="n">N</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">array_d_A</span><span class="p">[],</span>
<span class="kt">int</span><span class="n">IA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">JA</span><span class="p">,</span>
<span class="n">cudaLibMgMatrixDesc_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">array_d_IPIV</span><span class="p">[],</span>
<span class="n">cudaDataType_t</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">array_d_work</span><span class="p">[],</span>
<span class="kt">int64_t</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">);</span>
</pre>
 <p>
  This function computes the LU factorization of a
  <span class="pre">
   MÃN
  </span>
  matrix
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(P*A = L*U\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   A
  </span>
  is a
  <span class="pre">
   MÃN
  </span>
  matrix,
  <span class="pre">
   P
  </span>
  is a permutation matrix,
  <span class="pre">
   L
  </span>
  is a lower triangular matrix with unit diagonal, and
  <span class="pre">
   U
  </span>
  is an upper triangular matrix.
 </p>
 <p>
  The user has to provide device working space in
  <span class="pre">
   array_d_work
  </span>
  .
  <span class="pre">
   array_d_work
  </span>
  is a host pointer array of dimension
  <span class="pre">
   G
  </span>
  , where
  <span class="pre">
   G
  </span>
  is number of devices.
  <span class="pre">
   array_d_work[j]
  </span>
  is a device pointer pointing to a device memory in j-th device. The data type of
  <span class="pre">
   array_d_work[j]
  </span>
  is
  <span class="pre">
   computeType
  </span>
  . The size of
  <span class="pre">
   array_d_work[j]
  </span>
  is
  <span class="pre">
   lwork
  </span>
  which is number of elements per device, returned by
  <span class="pre">
   cusolverMgGetrf_bufferSize()
  </span>
  .
 </p>
 <p>
  If LU factorization failed, i.e. matrix
  <span class="pre">
   A
  </span>
  (
  <span class="pre">
   U
  </span>
  ) is singular, The output parameter
  <span class="pre">
   info=i
  </span>
  indicates
  <span class="pre">
   U(i,i)
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   0
  </span>
  .
 </p>
 <p>
  If output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  If
  <span class="pre">
   array_d_IPIV
  </span>
  is null, no pivoting is performed. The factorization is
  <span class="pre">
   A=L*U
  </span>
  , which is not numerically stable.
 </p>
 <p>
  <span class="pre">
   array_d_IPIV
  </span>
  must be consistent with
  <span class="pre">
   array_d_A
  </span>
  , i.e.
  <span class="pre">
   JA
  </span>
  is the first column of
  <span class="pre">
   sub(A)
  </span>
  , also the first column of
  <span class="pre">
   sub(IPIV)
  </span>
  .
 </p>
 <p>
  No matter LU factorization failed or not, the output parameter
  <span class="pre">
   array_d_IPIV
  </span>
  contains pivoting sequence, row
  <span class="pre">
   i
  </span>
  is interchanged with row
  <span class="pre">
   array_d_IPIV(i)
  </span>
  .
 </p>
 <p>
  The generic API has three different types,
  <span class="pre">
   dataTypeA
  </span>
  is data type of the matrix
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   computeType
  </span>
  is compute type of the operation and data type of the workspace (
  <span class="pre">
   array_d_work
  </span>
  )
  <span class="pre">
   descrA
  </span>
  contains
  <span class="pre">
   dataTypeA
  </span>
  , so there is no explicit parameter of
  <span class="pre">
   dataTypeA
  </span>
  .
  <span class="pre">
   cusolverMgGetrf
  </span>
  only supports the following four combinations.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/MgGetrf">
   cuSOLVER Library Samples - MgGetrf
  </a>
  for a code example.
 </p>
 <p>
  valid combination of data type and compute type
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     DataTypeA
    </p>
   </th>
   <th class="head">
    <p>
     ComputeType
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      SGETRF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      DGETRF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CGETRF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ZGETRF
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Remark 1: tile size
  <span class="pre">
   TA
  </span>
  must be less or equal to 512.
 </p>
 <p>
  API of getrf
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverMg library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      M
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows of matrix
     <span class="pre">
      sub(A)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      N
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of matrix
     <span class="pre">
      sub(A)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      array_d_A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     A host pointer array of dimension
     <span class="pre">
      G
     </span>
     . It contains a distributed &lt;type&gt; array containing
     <span class="pre">
      sub(A)
     </span>
     of dimension
     <span class="pre">
      M
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      N
     </span>
     . On exit,
     <span class="pre">
      sub(A)
     </span>
     contains the factors
     <span class="pre">
      L
     </span>
     and
     <span class="pre">
      U
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      IA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The row index in the global array A indicating the first row of
     <span class="pre">
      sub(A)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      JA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The column index in the global array A indicating the first column of
     <span class="pre">
      sub(A)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Matrix descriptor for the distributed matrix A.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      array_d_IPIV
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     A host pointer array of dimension
     <span class="pre">
      G
     </span>
     . it contains a distributed integer array containing
     <span class="pre">
      sub(IPIV)
     </span>
     of size
     <span class="pre">
      min(M,N)
     </span>
     .
     <span class="pre">
      sub(IPIV)
     </span>
     contains pivot indices.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type used for computation.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      array_d_work
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     A host pointer array of dimension
     <span class="pre">
      G
     </span>
     .
     <span class="pre">
      array_d_work[j]
     </span>
     points to a device working space in
     <span class="pre">
      j-th
     </span>
     device, &lt;type&gt; array of size
     <span class="pre">
      lwork
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of
     <span class="pre">
      array_d_work[j]
     </span>
     , returned by
     <span class="pre">
      cusolverMgGetrf_bufferSize
     </span>
     .
     <span class="pre">
      lwork
     </span>
     denotes number of elements, not number of bytes.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the LU factorization is successful.
    </p>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle).
    </p>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     Â
     <span class="pre">
      i
     </span>
     , the
     <span class="pre">
      U(i,i)
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      M,N&lt;0
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   3.4.5.
  </span>
  cusolverMgGetrs()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermggetrs" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The helper functions below can calculate the sizes needed for pre-allocated buffer.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverMgGetrs_bufferSize</span><span class="p">(</span>
<span class="n">cusolverMgHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasOperation_t</span><span class="n">TRANS</span><span class="p">,</span>
<span class="kt">int</span><span class="n">N</span><span class="p">,</span>
<span class="kt">int</span><span class="n">NRHS</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">array_d_A</span><span class="p">[],</span>
<span class="kt">int</span><span class="n">IA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">JA</span><span class="p">,</span>
<span class="n">cudaLibMgMatrixDesc_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">array_d_IPIV</span><span class="p">[],</span>
<span class="kt">void</span><span class="o">*</span><span class="n">array_d_B</span><span class="p">[],</span>
<span class="kt">int</span><span class="n">IB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">JB</span><span class="p">,</span>
<span class="n">cudaLibMgMatrixDesc_t</span><span class="n">descrB</span><span class="p">,</span>
<span class="n">cudaDataType_t</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">lwork</span><span class="p">);</span>
</pre>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverMgGetrs</span><span class="p">(</span>
<span class="n">cusolverMgHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cublasOperation_t</span><span class="n">TRANS</span><span class="p">,</span>
<span class="kt">int</span><span class="n">N</span><span class="p">,</span>
<span class="kt">int</span><span class="n">NRHS</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">array_d_A</span><span class="p">[],</span>
<span class="kt">int</span><span class="n">IA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">JA</span><span class="p">,</span>
<span class="n">cudaLibMgMatrixDesc_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">array_d_IPIV</span><span class="p">[],</span>
<span class="kt">void</span><span class="o">*</span><span class="n">array_d_B</span><span class="p">[],</span>
<span class="kt">int</span><span class="n">IB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">JB</span><span class="p">,</span>
<span class="n">cudaLibMgMatrixDesc_t</span><span class="n">descrB</span><span class="p">,</span>
<span class="n">cudaDataType_t</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">array_d_work</span><span class="p">[],</span>
<span class="kt">int64_t</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">);</span>
</pre>
 <p>
  This function solves a linear system of multiple right-hand sides
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \({op(A)}*X = B\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   A
  </span>
  is a
  <span class="pre">
   NÃN
  </span>
  matrix, and was LU-factored by
  <span class="pre">
   getrf
  </span>
  , that is, lower triangular part of A is
  <span class="pre">
   L
  </span>
  , and upper triangular part (including diagonal elements) of
  <span class="pre">
   A
  </span>
  is
  <span class="pre">
   U
  </span>
  .
  <span class="pre">
   B
  </span>
  is a
  <span class="pre">
   NÃNRHS
  </span>
  right-hand side matrix. The solution matrix
  <span class="pre">
   X
  </span>
  overwrites the right-hand-side matrix
  <span class="pre">
   B
  </span>
  .
 </p>
 <p>
  The input parameter
  <span class="pre">
   TRANS
  </span>
  is defined by
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(\text{op}(A) = \left\{ \begin{matrix}
A &amp; {\text{if~}\textsf{TRANS\ ==\ CUBLAS\_OP\_N}} \\
A^{T} &amp; {\text{if~}\textsf{TRANS\ ==\ CUBLAS\_OP\_T}} \\
A^{H} &amp; {\text{if~}\textsf{TRANS\ ==\ CUBLAS\_OP\_C}} \\
\end{matrix} \right.\)
  </span>
 </p>
 <p>
  The user has to provide device working space in
  <span class="pre">
   array_d_work
  </span>
  .
  <span class="pre">
   array_d_work
  </span>
  is a host pointer array of dimension
  <span class="pre">
   G
  </span>
  , where
  <span class="pre">
   G
  </span>
  is number of devices.
  <span class="pre">
   array_d_work[j]
  </span>
  is a device pointer pointing to a device memory in j-th device. The data type of
  <span class="pre">
   array_d_work[j]
  </span>
  is
  <span class="pre">
   computeType
  </span>
  . The size of
  <span class="pre">
   array_d_work[j]
  </span>
  is
  <span class="pre">
   lwork
  </span>
  which is number of elements per device, returned by
  <span class="pre">
   cusolverMgGetrs_bufferSize()
  </span>
  .
 </p>
 <p>
  If
  <span class="pre">
   array_d_IPIV
  </span>
  is null, no pivoting is performed. Otherwise,
  <span class="pre">
   array_d_IPIV
  </span>
  is an output of
  <span class="pre">
   getrf
  </span>
  . It contains pivot indices, which are used to permutate right-hand sides.
 </p>
 <p>
  If output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle).
 </p>
 <p>
  The generic API has three different types,
  <span class="pre">
   dataTypeA
  </span>
  is data type of the matrix
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   dataTypeB
  </span>
  is data type of the matrix
  <span class="pre">
   B
  </span>
  , and
  <span class="pre">
   computeType
  </span>
  is compute type of the operation and data type of the workspace (
  <span class="pre">
   array_d_work
  </span>
  )
  <span class="pre">
   descrA
  </span>
  contains
  <span class="pre">
   dataTypeA
  </span>
  , so there is no explicit parameter of
  <span class="pre">
   dataTypeA
  </span>
  .
  <span class="pre">
   descrB
  </span>
  contains
  <span class="pre">
   dataTypeB
  </span>
  , so there is no explicit parameter of
  <span class="pre">
   dataTypeB
  </span>
  .
  <span class="pre">
   cusolverMgGetrs
  </span>
  only supports the following four combinations.
 </p>
 <p>
  Valid combinations of data type and compute type
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     DataTypeA
    </p>
   </th>
   <th class="head">
    <p>
     DataTypeB
    </p>
   </th>
   <th class="head">
    <p>
     ComputeType
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      SGETRS
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      DGETRS
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CGETRS
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ZGETRS
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Remark 1: tile size
  <span class="pre">
   TA
  </span>
  must be less or equal to 512.
 </p>
 <p>
  Remark 2: only support
  <span class="pre">
   TRANS=CUBLAS_OP_N
  </span>
  .
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/MgGetrf">
   cuSOLVER Library Samples - MgGetrf
  </a>
  for a code example.
 </p>
 <p>
  API of getrs
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverMG library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      TRANS
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Operation
     <span class="pre">
      op(A)
     </span>
     that is non- or (conj.) transpose.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      N
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows and columns of matrix
     <span class="pre">
      sub(A)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      NRHS
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of matrix
     <span class="pre">
      sub(B)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      array_d_A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     A host pointer array of dimension
     <span class="pre">
      G
     </span>
     . It contains a distributed &lt;type&gt; array containing
     <span class="pre">
      sub(A)
     </span>
     of dimension
     <span class="pre">
      M
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      N
     </span>
     .
     <span class="pre">
      sub(A)
     </span>
     contains the factors
     <span class="pre">
      L
     </span>
     and
     <span class="pre">
      U
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      IA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The row index in the global array A indicating the first row of
     <span class="pre">
      sub(A)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      JA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The column index in the global array A indicating the first column of
     <span class="pre">
      sub(A)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Matrix descriptor for the distributed matrix A.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      array_d_IPIV
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     A host pointer array of dimension
     <span class="pre">
      G
     </span>
     . it contains a distributed integer array containing
     <span class="pre">
      sub(IPIV)
     </span>
     of dimension
     <span class="pre">
      min(M,N)
     </span>
     .
     <span class="pre">
      sub(IPIV)
     </span>
     contains pivot indices.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      array_d_B
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     A host pointer array of dimension
     <span class="pre">
      G
     </span>
     . It contains a distributed &lt;type&gt; array containing
     <span class="pre">
      sub(B)
     </span>
     of dimension
     <span class="pre">
      N
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      NRHS
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      IB
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The row index in the global array B indicating the first row of
     <span class="pre">
      sub(B)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      JB
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The column index in the global array B indicating the first column of
     <span class="pre">
      sub(B)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descrB
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Matrix descriptor for the distributed matrix B.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type used for computation.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      array_d_work
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     A host pointer array of dimension
     <span class="pre">
      G
     </span>
     .
     <span class="pre">
      array_d_work[j]
     </span>
     points to a device working space in
     <span class="pre">
      j-th
     </span>
     device, &lt;type&gt; array of size
     <span class="pre">
      lwork
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of
     <span class="pre">
      array_d_work[j]
     </span>
     , returned by
     <span class="pre">
      cusolverMgGetrs_bufferSize
     </span>
     .
     <span class="pre">
      lwork
     </span>
     denotes number of elements, not number of bytes.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the operation is successful.
    </p>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle).
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      N&lt;0
     </span>
     or
     <span class="pre">
      NRHS&lt;0
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h2>
  <span class="section-number">
   3.5.
  </span>
  Dense Eigenvalue Solver Reference
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#dense-eigenvalue-solver-reference" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  This section describes the eigenvalue solver API of cuSolverMG.
 </p>
 <h3>
  <span class="section-number">
   3.5.1.
  </span>
  cusolverMgSyevd()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolvermgsyevd" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The helper functions below can calculate the sizes needed for pre-allocated buffer.
 </p>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverMgSyevd_bufferSize</span><span class="p">(</span>
<span class="n">cusolverMgHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">N</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">array_d_A</span><span class="p">[],</span>
<span class="kt">int</span><span class="n">IA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">JA</span><span class="p">,</span>
<span class="n">cudaLibMgMatrixDesc_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="n">cudaDataType_t</span><span class="n">dataTypeW</span><span class="p">,</span>
<span class="n">cudaDataType_t</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">lwork</span>
<span class="p">);</span>
</pre>
 <pre><span class="n">cusolverStatus_t</span>
<span class="nf">cusolverMgSyevd</span><span class="p">(</span>
<span class="n">cusolverMgHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusolverEigMode_t</span><span class="n">jobz</span><span class="p">,</span>
<span class="n">cublasFillMode_t</span><span class="n">uplo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">N</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">array_d_A</span><span class="p">[],</span>
<span class="kt">int</span><span class="n">IA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">JA</span><span class="p">,</span>
<span class="n">cudaLibMgMatrixDesc_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">W</span><span class="p">,</span>
<span class="n">cudaDataType_t</span><span class="n">dataTypeW</span><span class="p">,</span>
<span class="n">cudaDataType_t</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">array_d_work</span><span class="p">[],</span>
<span class="kt">int64_t</span><span class="n">lwork</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">info</span><span class="p">);</span>
</pre>
 <p>
  This function computes eigenvalues and eigenvectors of a symmetric (Hermitian)
  <span class="pre">
   NÃN
  </span>
  matrix
  <span class="pre">
   A
  </span>
  . The standard symmetric eigenvalue problem is:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A*V = V*\Lambda\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   Î
  </span>
  is a real
  <span class="pre">
   NÃN
  </span>
  diagonal matrix.
  <span class="pre">
   V
  </span>
  is an
  <span class="pre">
   NÃN
  </span>
  unitary matrix. The diagonal elements of
  <span class="pre">
   Î
  </span>
  are the eigenvalues of
  <span class="pre">
   A
  </span>
  in ascending order.
 </p>
 <p>
  <span class="pre">
   cusolverMgSyevd
  </span>
  returns the eigenvalues in
  <span class="pre">
   W
  </span>
  and overwrites the eigenvectors in
  <span class="pre">
   A
  </span>
  .
  <span class="pre">
   W
  </span>
  is a host
  <span class="pre">
   1ÃN
  </span>
  vector.
 </p>
 <p>
  The generic API has three different types,
  <span class="pre">
   dataTypeA
  </span>
  is data type of the matrix
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   dataTypeW
  </span>
  is data type of the vector
  <span class="pre">
   W
  </span>
  , and
  <span class="pre">
   computeType
  </span>
  is compute type of the operation and data type of the workspace (
  <span class="pre">
   array_d_work
  </span>
  )
  <span class="pre">
   descrA
  </span>
  contains
  <span class="pre">
   dataTypeA
  </span>
  , so there is no explicit parameter of
  <span class="pre">
   dataTypeA
  </span>
  .
  <span class="pre">
   cusolverMgSyevd
  </span>
  only supports the following four combinations.
 </p>
 <p>
  Valid combination of data type and compute type
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     DataTypeA
    </p>
   </th>
   <th class="head">
    <p>
     DataTypeW
    </p>
   </th>
   <th class="head">
    <p>
     ComputeType
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      SSYEVD
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      DSYEVD
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CHEEVD
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ZHEEVD
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The user has to provide device working space in
  <span class="pre">
   array_d_work
  </span>
  .
  <span class="pre">
   array_d_work
  </span>
  is a host pointer array of dimension
  <span class="pre">
   G
  </span>
  , where
  <span class="pre">
   G
  </span>
  is number of devices.
  <span class="pre">
   array_d_work[j]
  </span>
  is a device pointer pointing to a device memory in j-th device. The data type of
  <span class="pre">
   array_d_work[j]
  </span>
  is
  <span class="pre">
   computeType
  </span>
  . The size of
  <span class="pre">
   array_d_work[j]
  </span>
  is
  <span class="pre">
   lwork
  </span>
  which is number of elements per device, returned by
  <span class="pre">
   cusolverMgSyevd_bufferSize()
  </span>
  .
 </p>
 <p>
  <span class="pre">
   array_d_A
  </span>
  is also a host pointer array of dimension
  <span class="pre">
   G
  </span>
  .
  <span class="pre">
   array_d_A[j]
  </span>
  is a device pointer pointing to a device memory in j-th device. The data type of
  <span class="pre">
   array_d_A[j]
  </span>
  is
  <span class="pre">
   dataTypeA
  </span>
  . The size of
  <span class="pre">
   array_d_A[j]
  </span>
  is about
  <span class="pre">
   N*TA*(blocks
  </span>
  <span class="pre">
   per
  </span>
  Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â
  <span class="pre">
   device)
  </span>
  . The user has to prepare
  <span class="pre">
   array_d_A
  </span>
  manually (see
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/MgSyevd">
   cuSOLVER Library Samples - MgSyevd
  </a>
  for a code example.).
 </p>
 <p>
  If output parameter
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   -i
  </span>
  (less than zero), the
  <span class="pre">
   i-th
  </span>
  parameter is wrong (not counting handle). If
  <span class="pre">
   info
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   i
  </span>
  (greater than zero),
  <span class="pre">
   i
  </span>
  off-diagonal elements of an intermediate tridiagonal form did not converge to zero.
 </p>
 <p>
  If
  <span class="pre">
   jobz
  </span>
  = CUSOLVER_EIG_MODE_VECTOR,
  <span class="pre">
   A
  </span>
  contains the orthonormal eigenvectors of the matrix
  <span class="pre">
   A
  </span>
  . The eigenvectors are computed by a divide and conquer algorithm.
 </p>
 <p>
  Remark 1: only
  <span class="pre">
   CUBLAS_FILL_MODE_LOWER
  </span>
  is supported, so the user has to prepare lower triangle of
  <span class="pre">
   A
  </span>
  .
 </p>
 <p>
  Remark 2: only
  <span class="pre">
   IA=1
  </span>
  and
  <span class="pre">
   JA=1
  </span>
  are supported.
 </p>
 <p>
  Remark 3: tile size
  <span class="pre">
   TA
  </span>
  must be less or equal to 1024. To achieve best performance,
  <span class="pre">
   TA
  </span>
  should be 256 or 512.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSOLVER/MgSyevd">
   cuSOLVER Library Samples - MgSyevd
  </a>
  for a code example.
 </p>
 <p>
  API of syevd
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Parameter
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSolverMG library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      jobz
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies options to either compute eigenvalue only or compute eigen-pair:
    </p>
    <p>
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     : Compute eigenvalues only
    </p>
    <p>
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     : Compute eigenvalues and eigenvectors
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      uplo
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Specifies which part of
     <span class="pre">
      A
     </span>
     is stored.
    </p>
    <p>
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     : Lower triangle of
     <span class="pre">
      A
     </span>
     is stored.
    </p>
    <p>
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     : Upper triangle of
     <span class="pre">
      A
     </span>
     is stored.
    </p>
    <p>
     Only
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     is supported.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      N
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows (or columns) of matrix
     <span class="pre">
      sub(A)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      array_d_A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     A host pointer array of dimension
     <span class="pre">
      G
     </span>
     . It contains a distributed &lt;type&gt; array containing
     <span class="pre">
      sub(A)
     </span>
     of dimension
     <span class="pre">
      N
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      N
     </span>
     .
    </p>
    <p>
     If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_UPPER
     </span>
     , the leading N-by-N upper triangular part of
     <span class="pre">
      sub(A)
     </span>
     contains the upper triangular part of the matrix
     <span class="pre">
      sub(A)
     </span>
     .
    </p>
    <p>
     If
     <span class="pre">
      uplo
     </span>
     =
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     , the leading N-by-N lower triangular part of
     <span class="pre">
      sub(A)
     </span>
     contains the lower triangular part of the matrix
     <span class="pre">
      sub(A)
     </span>
     . On exit, if
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     , and
     <span class="pre">
      info
     </span>
     = 0,
     <span class="pre">
      sub(A)
     </span>
     contains the orthonormal eigenvectors of the matrix
     <span class="pre">
      sub(A)
     </span>
     .
    </p>
    <p>
     If
     <span class="pre">
      jobz
     </span>
     =
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     , the contents of
     <span class="pre">
      A
     </span>
     are destroyed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      IA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The row index in the global array A indicating the first row of
     <span class="pre">
      sub(A)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      JA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     The column index in the global array A indicating the first column of
     <span class="pre">
      sub(A)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Matrix descriptor for the distributed matrix A.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      W
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     A real array of dimension
     <span class="pre">
      N
     </span>
     . The eigenvalue values of
     <span class="pre">
      sub(A)
     </span>
     , in ascending order ie, sorted so that
     <span class="pre">
      W(i)
     </span>
     <span class="pre">
      &lt;=
     </span>
     Â
     <span class="pre">
      W(i+1)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dataTypeW
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type of the vector W.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Data type used for computation.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      array_d_work
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      in/out
     </span>
    </p>
   </td>
   <td>
    <p>
     A host pointer array of dimension
     <span class="pre">
      G
     </span>
     .
     <span class="pre">
      array_d_work[j]
     </span>
     points to a device working space in
     <span class="pre">
      j-th
     </span>
     device, &lt;type&gt; array of size
     <span class="pre">
      lwork
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lwork
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      input
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of
     <span class="pre">
      array_d_work[j]
     </span>
     , returned by
     <span class="pre">
      cusolverMgSyevd_bufferSize
     </span>
     .
     <span class="pre">
      lwork
     </span>
     denotes number of elements, not number of bytes.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      output
     </span>
    </p>
   </td>
   <td>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      0
     </span>
     , the operation is successful.
    </p>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     <span class="pre">
      -i
     </span>
     , the
     <span class="pre">
      i-th
     </span>
     parameter is wrong (not counting handle).
    </p>
    <p>
     If
     <span class="pre">
      info
     </span>
     <span class="pre">
      =
     </span>
     Â
     <span class="pre">
      i
     </span>
     <span class="pre">
      (&gt;
     </span>
     <span class="pre">
      0)
     </span>
     ,
     <span class="pre">
      info
     </span>
     indicates
     <span class="pre">
      i
     </span>
     off-diagonal elements of an intermediate tridiagonal form did not converge to zero.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     Invalid parameters were passed (
     <span class="pre">
      N&lt;0
     </span>
     , or
     <span class="pre">
      lda&lt;max(1,N)
     </span>
     , or
     <span class="pre">
      jobz
     </span>
     is not
     <span class="pre">
      CUSOLVER_EIG_MODE_NOVECTOR
     </span>
     or
     <span class="pre">
      CUSOLVER_EIG_MODE_VECTOR
     </span>
     , or
     <span class="pre">
      uplo
     </span>
     is not
     <span class="pre">
      CUBLAS_FILL_MODE_LOWER
     </span>
     , or
     <span class="pre">
      IA
     </span>
     and
     <span class="pre">
      JA
     </span>
     are not 1, or
     <span class="pre">
      N
     </span>
     is bigger than dimension of global
     <span class="pre">
      A
     </span>
     , or the combination of
     <span class="pre">
      dataType
     </span>
     and
     <span class="pre">
      computeType
     </span>
     is not valid.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSOLVER_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal operation failed.
    </p>
   </td>
  </tr>
 </table>
 <h1>
  <span class="section-number">
   4.
  </span>
  Acknowledgements
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#acknowledgements" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <p>
  NVIDIA would like to thank the following individuals and institutions for their contributions:
 </p>
 <ul class="simple">
  <li>
   <p>
    CPU LAPACK routines from netlib, CLAPACK-3.2.1 (
    <a class="reference external" href="http://www.netlib.org/clapack/">
     http://www.netlib.org/clapack/
    </a>
    )
   </p>
  </li>
 </ul>
 <p>
  The following is license of CLAPACK-3.2.1.
 </p>
 <p>
  Copyright (c) 1992-2008 The University of Tennessee. All rights reserved.
 </p>
 <p>
  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 </p>
 <ul class="simple">
  <li>
   <p>
    Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
   </p>
  </li>
  <li>
   <p>
    Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer listed in this license in the documentation and/or other materials provided with the distribution.
   </p>
  </li>
  <li>
   <p>
    Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
   </p>
  </li>
 </ul>
 <p>
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS âAS ISâ AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 </p>
 <ul class="simple">
  <li>
   <p>
    METIS-5.1.0 (
    <a class="reference external" href="http://glaros.dtc.umn.edu/gkhome/metis/metis/overview">
     http://glaros.dtc.umn.edu/gkhome/metis/metis/overview
    </a>
    )
   </p>
  </li>
 </ul>
 <p>
  The following is license of METIS (Apache 2.0 license).
 </p>
 <p>
  Copyright 1995-2013, Regents of the University of Minnesota
 </p>
 <p>
  Licensed under the Apache License, Version 2.0 (the âLicenseâ); you may not use this file except in compliance with the License. You may obtain a copy of the License at
 </p>
 <p>
  <a class="reference external" href="http://www.apache.org/licenses/LICENSE-2.0">
   http://www.apache.org/licenses/LICENSE-2.0
  </a>
 </p>
 <p>
  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an âAS ISâ BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 </p>
 <ul class="simple">
  <li>
   <p>
    QD (A C++/fortran-90 double-double and quad-double package) (
    <a class="reference external" href="http://crd-legacy.lbl.gov/~dhbailey/mpdist/">
     http://crd-legacy.lbl.gov/~dhbailey/mpdist/
    </a>
    )
   </p>
  </li>
 </ul>
 <p>
  The following is license of QD (modified BSD license).
 </p>
 <p>
  Copyright (c) 2003-2009, The Regents of the University of California, through Lawrence Berkeley National Laboratory (subject to receipt of any required approvals from U.S. Dept. of Energy) All rights reserved.
 </p>
 <ol class="arabic simple">
  <li>
   <p>
    Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
   </p>
  </li>
 </ol>
 <ol class="arabic simple">
  <li>
   <p>
    Redistributions of source code must retain the copyright notice, this list of conditions and the following disclaimer.
   </p>
  </li>
  <li>
   <p>
    Redistributions in binary form must reproduce the copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
   </p>
  </li>
  <li>
   <p>
    Neither the name of the University of California, Lawrence Berkeley National Laboratory, U.S. Dept. of Energy nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
   </p>
  </li>
 </ol>
 <ol class="arabic simple" start="2">
  <li>
   <p>
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS âAS ISâ AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   </p>
  </li>
  <li>
   <p>
    You are under no obligation whatsoever to provide any bug fixes, patches, or upgrades to the features, functionality or performance of the source code (âEnhancementsâ) to anyone; however, if you choose to make your Enhancements available either publicly, or directly to Lawrence Berkeley National Laboratory, without imposing a separate written license agreement for such Enhancements, then you hereby grant the following license: a non-exclusive, royalty-free perpetual license to install, use, modify, prepare derivative works, incorporate into other computer software, distribute, and sublicense such enhancements or derivative works thereof, in binary and source code form.
   </p>
  </li>
 </ol>
 <h1>
  <span class="section-number">
   5.
  </span>
  Bibliography
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#bibliography" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <p>
  [1] Timothy A. Davis, Direct Methods for sparse Linear Systems, siam 2006.
 </p>
 <p>
  [2] E. Chuthill and J. McKee, reducing the bandwidth of sparse symmetric matrices, ACM â69 Proceedings of the 1969 24th national conference, Pages 157-172.
 </p>
 <p>
  [3] Alan George, Joseph W. H. Liu, An Implementation of a Pseudoperipheral Node Finder, ACM Transactions on Mathematical Software (TOMS) Volume 5 Issue 3, Sept. 1979 Pages 284-295.
 </p>
 <p>
  [4] J. R. Gilbert and T. Peierls, Sparse partial pivoting in time proportional to arithmetic operations, SIAM J. Sci. Statist. Comput., 9 (1988), pp. 862-874.
 </p>
 <p>
  [5] Alan George and Esmond Ng, An Implementation of Gaussian Elimination with Partial Pivoting for Sparse Systems, SIAM J. Sci. and Stat. Comput., 6(2), 390-409.
 </p>
 <p>
  [6] Alan George and Esmond Ng, Symbolic Factorization for Sparse Gaussian Elimination with Partial Pivoting, SIAM J. Sci. and Stat. Comput., 8(6), 877-898.
 </p>
 <p>
  [7] John R. Gilbert, Xiaoye S. Li, Esmond G. Ng, Barry W. Peyton, Computing Row and Column Counts for Sparse QR and LU Factorization, BIT 2001, Vol. 41, No. 4, pp. 693-711.
 </p>
 <p>
  [8] Patrick R. Amestoy, Timothy A. Davis, Iain S. Duff, An Approximate Minimum Degree Ordering Algorithm, SIAM J. Matrix Analysis Applic. Vol 17, no 4, pp. 886-905, Dec. 1996.
 </p>
 <p>
  [9] Alan George, Joseph W. Liu, A Fast Implementation of the Minimum Degree Algorithm Using Quotient Graphs, ACM Transactions on Mathematical Software, Vol 6, No. 3, September 1980, page 337-358.
 </p>
 <p>
  [10] Alan George, Joseph W. Liu, Computer Solution of Large Sparse Positive Definite Systems, Englewood Cliffs, New Jersey: Prentice-Hall, 1981.
 </p>
 <p>
  [11] Iain S. Duff, ALGORITHM 575 Permutations for a Zero-Free Diagonal, ACM Transactions on Mathematical Software, Vol 7, No 3, September 1981, Page 387-390
 </p>
 <p>
  [12] Iain S. Duff and Jacko Koster, On algorithms for permuting large entries to the diagonal of a sparse matrix, SIAM Journal on Matrix Analysis and Applications, 2001, Vol. 22, No. 4 : pp. 973-996
 </p>
 <p>
  [13] âA Fast and Highly Quality Multilevel Scheme for Partitioning Irregular Graphsâ. George Karypis and Vipin Kumar. SIAM Journal on Scientific Computing, Vol. 20, No. 1, pp. 359-392, 1999.
 </p>
 <p>
  [14] YUJI NAKATSUKASA, ZHAOJUN BAI, AND FRANCÂ¸OIS GYGI, OPTIMIZING HALLEYâS ITERATION FOR COMPUTING THE MATRIX POLAR DECOMPOSITION, SIAM J. Matrix Anal. Appl., 31 (5): 2700-2720,2010
 </p>
 <p>
  [15] Halko, Nathan, Per-Gunnar Martinsson, and Joel A. Tropp. âFinding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions.â SIAM review 53.2 (2011): 217-288.
 </p>
 <h1>
  <span class="section-number">
   6.
  </span>
  Notices
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#notices" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <h2>
  <span class="section-number">
   6.1.
  </span>
  Notice
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#notice" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  This document is provided for information purposes only and shall not be regarded as a warranty of a certain functionality, condition, or quality of a product. NVIDIA Corporation (âNVIDIAâ) makes no representations or warranties, expressed or implied, as to the accuracy or completeness of the information contained in this document and assumes no responsibility for any errors contained herein. NVIDIA shall have no liability for the consequences or use of such information or for any infringement of patents or other rights of third parties that may result from its use. This document is not a commitment to develop, release, or deliver any Material (defined below), code, or functionality.
 </p>
 <p>
  NVIDIA reserves the right to make corrections, modifications, enhancements, improvements, and any other changes to this document, at any time without notice.
 </p>
 <p>
  Customer should obtain the latest relevant information before placing orders and should verify that such information is current and complete.
 </p>
 <p>
  NVIDIA products are sold subject to the NVIDIA standard terms and conditions of sale supplied at the time of order acknowledgement, unless otherwise agreed in an individual sales agreement signed by authorized representatives of NVIDIA and customer (âTerms of Saleâ). NVIDIA hereby expressly objects to applying any customer general terms and conditions with regards to the purchase of the NVIDIA product referenced in this document. No contractual obligations are formed either directly or indirectly by this document.
 </p>
 <p>
  NVIDIA products are not designed, authorized, or warranted to be suitable for use in medical, military, aircraft, space, or life support equipment, nor in applications where failure or malfunction of the NVIDIA product can reasonably be expected to result in personal injury, death, or property or environmental damage. NVIDIA accepts no liability for inclusion and/or use of NVIDIA products in such equipment or applications and therefore such inclusion and/or use is at customerâs own risk.
 </p>
 <p>
  NVIDIA makes no representation or warranty that products based on this document will be suitable for any specified use. Testing of all parameters of each product is not necessarily performed by NVIDIA. It is customerâs sole responsibility to evaluate and determine the applicability of any information contained in this document, ensure the product is suitable and fit for the application planned by customer, and perform the necessary testing for the application in order to avoid a default of the application or the product. Weaknesses in customerâs product designs may affect the quality and reliability of the NVIDIA product and may result in additional or different conditions and/or requirements beyond those contained in this document. NVIDIA accepts no liability related to any default, damage, costs, or problem which may be based on or attributable to: (i) the use of the NVIDIA product in any manner that is contrary to this document or (ii) customer product designs.
 </p>
 <p>
  No license, either expressed or implied, is granted under any NVIDIA patent right, copyright, or other NVIDIA intellectual property right under this document. Information published by NVIDIA regarding third-party products or services does not constitute a license from NVIDIA to use such products or services or a warranty or endorsement thereof. Use of such information may require a license from a third party under the patents or other intellectual property rights of the third party, or a license from NVIDIA under the patents or other intellectual property rights of NVIDIA.
 </p>
 <p>
  Reproduction of information in this document is permissible only if approved in advance by NVIDIA in writing, reproduced without alteration and in full compliance with all applicable export laws and regulations, and accompanied by all associated conditions, limitations, and notices.
 </p>
 <p>
  THIS DOCUMENT AND ALL NVIDIA DESIGN SPECIFICATIONS, REFERENCE BOARDS, FILES, DRAWINGS, DIAGNOSTICS, LISTS, AND OTHER DOCUMENTS (TOGETHER AND SEPARATELY, âMATERIALSâ) ARE BEING PROVIDED âAS IS.â NVIDIA MAKES NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL NVIDIA BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF ANY USE OF THIS DOCUMENT, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. Notwithstanding any damages that customer might incur for any reason whatsoever, NVIDIAâs aggregate and cumulative liability towards customer for the products described herein shall be limited in accordance with the Terms of Sale for the product.
 </p>
 <h2>
  <span class="section-number">
   6.2.
  </span>
  OpenCL
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#opencl" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  OpenCL is a trademark of Apple Inc. used under license to the Khronos Group Inc.
 </p>
 <h2>
  <span class="section-number">
   6.3.
  </span>
  Trademarks
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusolver/index.html#trademarks" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  NVIDIA and the NVIDIA logo are trademarks or registered trademarks of NVIDIA Corporation in the U.S. and other countries. Other company and product names may be trademarks of the respective companies with which they are associated.
 </p>
 <p class="notices">
  <a href="https://www.nvidia.com/en-us/about-nvidia/privacy-policy/" target="_blank">
   Privacy Policy
  </a>
  |
  <a href="https://www.nvidia.com/en-us/about-nvidia/privacy-center/" target="_blank">
   Manage My Privacy
  </a>
  |
  <a href="https://www.nvidia.com/en-us/preferences/start/" target="_blank">
   Do Not Sell or Share My Data
  </a>
  |
  <a href="https://www.nvidia.com/en-us/about-nvidia/terms-of-service/" target="_blank">
   Terms of Service
  </a>
  |
  <a href="https://www.nvidia.com/en-us/about-nvidia/accessibility/" target="_blank">
   Accessibility
  </a>
  |
  <a href="https://www.nvidia.com/en-us/about-nvidia/company-policies/" target="_blank">
   Corporate Policies
  </a>
  |
  <a href="https://www.nvidia.com/en-us/product-security/" target="_blank">
   Product Security
  </a>
  |
  <a href="https://www.nvidia.com/en-us/contact/" target="_blank">
   Contact
  </a>
 </p>
 <p>
  Copyright Â© 2014-2024, NVIDIA Corporation &amp; affiliates. All rights reserved.
 </p>
 <p>
  <span class="lastupdated">
   Last updated on Jul 1, 2024.
  </span>
 </p>
</body>
</body></html>