<html><head><title>Inline PTX Assembly</title></head><body><body class="wy-body-for-nav">
 <a href="https://docs.nvidia.com/cuda/inline-ptx-assembly/contents.html">
 </a>
 <ul class="current">
  <li class="toctree-l1 current">
   <a class="current reference internal" href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html">
    1. Using Inline PTX Assembly in CUDA
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html#assembler-asm-statements">
      1.1. Assembler (ASM) Statements
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html#parameters">
        1.1.1. Parameters
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html#constraints">
        1.1.2. Constraints
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html#pitfalls">
      1.2. Pitfalls
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html#namespace-conflicts">
        1.2.1. Namespace Conflicts
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html#memory-space-conflicts">
        1.2.2. Memory Space Conflicts
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html#incorrect-optimization">
        1.2.3. Incorrect Optimization
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html#incorrect-ptx">
        1.2.4. Incorrect PTX
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html#error-checking">
      1.3. Error Checking
     </a>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html#notices">
    2. Notices
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html#notice">
      2.1. Notice
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html#opencl">
      2.2. OpenCL
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html#trademarks">
      2.3. Trademarks
     </a>
    </li>
   </ul>
  </li>
 </ul>
 <a href="https://docs.nvidia.com/cuda/inline-ptx-assembly/contents.html">
  Inline PTX Assembly in CUDA
 </a>
 <ul class="wy-breadcrumbs">
  <li>
   <a class="icon icon-home" href="https://docs.nvidia.com/cuda/index.html">
   </a>
   Â»
  </li>
  <li>
   <span class="section-number">
    1.
   </span>
   Using Inline PTX Assembly in CUDA
  </li>
  <li class="wy-breadcrumbs-aside">
   <span>
    v12.5 |
   </span>
   <a class="reference external" href="https://docs.nvidia.com/cuda/pdf/Inline_PTX_Assembly.pdf">
    PDF
   </a>
   <span>
    |
   </span>
   <a class="reference external" href="https://developer.nvidia.com/cuda-toolkit-archive">
    Archive
   </a>
   <span>
    Â
   </span>
  </li>
 </ul>
 <p class="rubric-h1 rubric">
  Inline PTX Assembly in CUDA
 </p>
 <p>
  The reference guide for inlining PTX (parallel thread execution) assembly statements into CUDA.
 </p>
 <h1>
  <span class="section-number">
   1.
  </span>
  Using Inline PTX Assembly in CUDA
  <a class="headerlink" href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html#using-inline-ptx-assembly-in-cuda" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <p>
  The NVIDIA
  Â®
  CUDA
  Â®
  programming environment provides a parallel thread execution (PTX) instruction set architecture (ISA) for using the GPU as a data-parallel computing device. For more information on the PTX ISA, refer to the latest version of the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html">
   PTX ISA reference document
  </a>
  .
 </p>
 <p>
  This application note describes how to inline PTX assembly language statements into CUDA code.
 </p>
 <h2>
  <span class="section-number">
   1.1.
  </span>
  Assembler (ASM) Statements
  <a class="headerlink" href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html#assembler-asm-statements" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  Assembler statements,
  <span class="pre">
   asm()
  </span>
  , provide a way to insert arbitrary PTX code into your CUDA program. A simple example is:
 </p>
 <pre><span class="k">asm</span><span class="p">(</span><span class="s">"membar.gl;"</span><span class="p">);</span>
</pre>
 <p>
  This inserts a PTX
  <span class="pre">
   membar.gl
  </span>
  into your generated PTX code at the point of the
  <span class="pre">
   asm()
  </span>
  statement.
 </p>
 <h3>
  <span class="section-number">
   1.1.1.
  </span>
  Parameters
  <a class="headerlink" href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html#parameters" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  An
  <span class="pre">
   asm()
  </span>
  statement becomes more complicated, and more useful, when we pass values in and out of the asm. The basic syntax is as follows:
 </p>
 <pre><span class="k">asm</span><span class="p">(</span><span class="s">"template-string"</span><span class="o">:</span><span class="s">"constraint"</span><span class="p">(</span><span class="n">output</span><span class="p">)</span><span class="o">:</span><span class="s">"constraint"</span><span class="p">(</span><span class="n">input</span><span class="p">));</span>
</pre>
 <p>
  where you can have multiple input or output operands separated by commas. The template string contains PTX instructions with references to the operands. Multiple PTX instructions can be given by separating them with semicolons.
 </p>
 <p>
  A simple example is as follows:
 </p>
 <pre><span class="k">asm</span><span class="p">(</span><span class="s">"add.s32 %0, %1, %2;"</span><span class="o">:</span><span class="s">"=r"</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">:</span><span class="s">"r"</span><span class="p">(</span><span class="n">j</span><span class="p">),</span><span class="s">"r"</span><span class="p">(</span><span class="n">k</span><span class="p">));</span>
</pre>
 <p>
  Each
  <span class="pre">
   %n
  </span>
  in the template string is an index into the following list of operands, in text order. So
  <span class="pre">
   %0
  </span>
  refers to the first operand,
  <span class="pre">
   %1
  </span>
  to the second operand, and so on. Since the output operands are always listed ahead of the input operands, they are assigned the smallest indices. This example is conceptually equivalent to the following:
 </p>
 <pre><span class="n">add</span><span class="p">.</span><span class="n">s32</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">;</span>
</pre>
 <p>
  Note that the numbered references in the string can be in arbitrary order. The following is equivalent to the above example:
 </p>
 <pre><span class="k">asm</span><span class="p">(</span><span class="s">"add.s32 %0, %2, %1;"</span><span class="o">:</span><span class="s">"=r"</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">:</span><span class="s">"r"</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="s">"r"</span><span class="p">(</span><span class="n">j</span><span class="p">));</span>
</pre>
 <p>
  You can also repeat a reference, e.g.:
 </p>
 <pre><span class="k">asm</span><span class="p">(</span><span class="s">"add.s32 %0, %1, %1;"</span><span class="o">:</span><span class="s">"=r"</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">:</span><span class="s">"r"</span><span class="p">(</span><span class="n">k</span><span class="p">));</span>
</pre>
 <p>
  is conceptually
 </p>
 <pre><span class="n">add</span><span class="p">.</span><span class="n">s32</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">k</span><span class="p">;</span>
</pre>
 <p>
  If there is no input operand, you can drop the final colon, e.g.:
 </p>
 <pre><span class="k">asm</span><span class="p">(</span><span class="s">"mov.s32 %0, 2;"</span><span class="o">:</span><span class="s">"=r"</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
</pre>
 <p>
  If there is no output operand, the colon separators are adjacent, e.g.:
 </p>
 <pre><span class="k">asm</span><span class="p">(</span><span class="s">"mov.s32 r1, %0;"</span><span class="o">::</span><span class="s">"r"</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
</pre>
 <p>
  If you want the
  <span class="pre">
   %
  </span>
  in a ptx instruction, then you should escape it with double
  <span class="pre">
   %%
  </span>
  , e.g.:
 </p>
 <pre><span class="k">asm</span><span class="p">(</span><span class="s">"mov.u32 %0, %%clock;"</span><span class="o">:</span><span class="s">"=r"</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</pre>
 <p>
  The above was simplified to explain the ordering of the string
  <span class="pre">
   %
  </span>
  references. In reality, the operand values are passed via whatever mechanism the constraint specifies. The full list of constraints will be explained later, but the ârâ constraint refers to a 32bit integer register. So the earlier example
  <span class="pre">
   asm()
  </span>
  statement:
 </p>
 <pre><span class="k">asm</span><span class="p">(</span><span class="s">"add.s32 %0, %1, %2;"</span><span class="o">:</span><span class="s">"=r"</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">:</span><span class="s">"r"</span><span class="p">(</span><span class="n">j</span><span class="p">),</span><span class="s">"r"</span><span class="p">(</span><span class="n">k</span><span class="p">));</span>
</pre>
 <p>
  produces the following code sequence in the output generated by the compiler:
 </p>
 <pre><span class="n">ld</span><span class="p">.</span><span class="n">s32</span><span class="n">r1</span><span class="p">,</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
<span class="n">ld</span><span class="p">.</span><span class="n">s32</span><span class="n">r2</span><span class="p">,</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
<span class="n">add</span><span class="p">.</span><span class="n">s32</span><span class="n">r3</span><span class="p">,</span><span class="n">r1</span><span class="p">,</span><span class="n">r2</span><span class="p">;</span>
<span class="n">st</span><span class="p">.</span><span class="n">s32</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">r3</span><span class="p">;</span>
</pre>
 <p>
  This is where the distinction between input and output operands becomes important. The input operands are loaded into registers before the
  <span class="pre">
   asm()
  </span>
  statement, then the result register is stored to the output operand. The â=â modifier in â=râ specifies that the register is written to. There is also available a â+â modifier that specifies the register is both read and written, e.g.:
 </p>
 <pre><span class="k">asm</span><span class="p">(</span><span class="s">"add.s32 %0, %0, %1;"</span><span class="o">:</span><span class="s">"+r"</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">:</span><span class="s">"r"</span><span class="p">(</span><span class="n">j</span><span class="p">));</span>
</pre>
 <p>
  Multiple instructions can be combined into a single
  <span class="pre">
   asm()
  </span>
  statement; basically, anything legal can be put into the asm string. Multiple instructions can be split across multiple lines by making use of C/C++âs implicit string concatenation. Both C++ style line end comments â//â and classical C-style comments â/**/â can be interspersed with these strings. To generate readable output in the PTX intermediate file it is best practice to terminate each instruction string except the last one with ântâ.
 </p>
 <p>
  For example, a cube routine could be written as:
 </p>
 <pre><span class="n">__device__</span><span class="kt">int</span><span class="n">cube</span><span class="p">(</span><span class="kt">int</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="kt">int</span><span class="n">y</span><span class="p">;</span>
<span class="k">asm</span><span class="p">(</span><span class="s">".reg .u32 t1;</span><span class="se">\n\t</span><span class="s">"</span><span class="c1">// temp reg t1</span>
<span class="s">" mul.lo.u32 t1, %1, %1;</span><span class="se">\n\t</span><span class="s">"</span><span class="c1">// t1 = x * x</span>
<span class="s">" mul.lo.u32 %0, t1, %1;"</span><span class="c1">// y = t1 * x</span>
<span class="o">:</span><span class="s">"=r"</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">:</span><span class="s">"r"</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="k">return</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</pre>
 <p>
  If an output operand is conditionally updated by the asm instructions, then the â+â modifier should be used. There is an implicit use of the output operand in such a case. For example,
 </p>
 <pre><span class="n">__device__</span><span class="kt">int</span><span class="n">cond</span><span class="p">(</span><span class="kt">int</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="kt">int</span><span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="k">asm</span><span class="p">(</span><span class="s">"{</span><span class="se">\n\t</span><span class="s">"</span>
<span class="s">" .reg .pred %p;</span><span class="se">\n\t</span><span class="s">"</span>
<span class="s">" setp.eq.s32 %p, %1, 34;</span><span class="se">\n\t</span><span class="s">"</span><span class="c1">// x == 34?</span>
<span class="s">" @%p mov.s32 %0, 1;</span><span class="se">\n\t</span><span class="s">"</span><span class="c1">// set y to 1 if true</span>
<span class="s">"}"</span><span class="c1">// conceptually y = (x==34)?1:y</span>
<span class="o">:</span><span class="s">"+r"</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">:</span><span class="s">"r"</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="k">return</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</pre>
 <h3>
  <span class="section-number">
   1.1.2.
  </span>
  Constraints
  <a class="headerlink" href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html#constraints" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  There is a separate constraint letter for each PTX register type:
 </p>
 <pre><span class="s">"h"</span><span class="o">=</span><span class="p">.</span><span class="n">u16</span><span class="n">reg</span>
<span class="s">"r"</span><span class="o">=</span><span class="p">.</span><span class="n">u32</span><span class="n">reg</span>
<span class="s">"l"</span><span class="o">=</span><span class="p">.</span><span class="n">u64</span><span class="n">reg</span>
<span class="s">"f"</span><span class="o">=</span><span class="p">.</span><span class="n">f32</span><span class="n">reg</span>
<span class="s">"d"</span><span class="o">=</span><span class="p">.</span><span class="n">f64</span><span class="n">reg</span>
</pre>
 <p>
  Example:
 </p>
 <pre><span class="k">asm</span><span class="p">(</span><span class="s">"cvt.f32.s64 %0, %1;"</span><span class="o">:</span><span class="s">"=f"</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="s">"l"</span><span class="p">(</span><span class="n">y</span><span class="p">));</span>
</pre>
 <p>
  generates:
 </p>
 <pre><span class="n">ld</span><span class="p">.</span><span class="n">s64</span><span class="n">rd1</span><span class="p">,</span><span class="p">[</span><span class="n">y</span><span class="p">];</span>
<span class="n">cvt</span><span class="p">.</span><span class="n">f32</span><span class="p">.</span><span class="n">s64</span><span class="n">f1</span><span class="p">,</span><span class="n">rd1</span><span class="p">;</span>
<span class="n">st</span><span class="p">.</span><span class="n">f32</span><span class="p">[</span><span class="n">x</span><span class="p">],</span><span class="n">f1</span><span class="p">;</span>
</pre>
 <p>
  The constraint
  <span class="pre">
   "n"
  </span>
  may be used for immediate integer operands with a known value. Example:
 </p>
 <pre><span class="k">asm</span><span class="p">(</span><span class="s">"add.u32 %0, %0, %1;"</span><span class="o">:</span><span class="s">"=r"</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="s">"n"</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
</pre>
 <p>
  generates:
 </p>
 <pre><span class="n">add</span><span class="p">.</span><span class="n">u32</span><span class="n">r1</span><span class="p">,</span><span class="n">r1</span><span class="p">,</span><span class="mi">42</span><span class="p">;</span>
</pre>
 <p>
  The constraint
  <span class="pre">
   "C"
  </span>
  can be used for operand of type âarray of const charâ, where the array contents are known at compile time.
It is intended to allow customization of PTX instruction modes based on compile time computation (see examples). Here is the specification
for the
  <span class="pre">
   "C"
  </span>
  constraint:
 </p>
 <pre><span class="sc">'C'</span><span class="p">(</span><span class="n">constant</span><span class="o">-</span><span class="n">expression</span><span class="p">)</span>
</pre>
 <p>
  The
  constant-expression
  is evaluated during compilation and shall generate the address of a variable
  <span class="pre">
   V
  </span>
  , where:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     V
    </span>
    has
    static storage duration
    .
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     V
    </span>
    has type âarray of const charâ.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     V
    </span>
    is
    constant-initialized
    .
   </p>
  </li>
  <li>
   <p>
    If
    <span class="pre">
     V
    </span>
    is a static class member, then
    <span class="pre">
     V
    </span>
    âs
    initializing declaration
    is the declaration within the class.
   </p>
  </li>
 </ul>
 <p>
  During translation, the compiler will replace a reference to the operand within the
  Assembler Template
  with the contents of
  <span class="pre">
   V
  </span>
  âs initializer, except for the last trailing zero.
No constraint modifiers are allowed for this constraint. This constraint can only be used in device code.
 </p>
 <p>
  (terms in
  italics
  are C++ standard terms and/or terms from the GNU inline asm specification).
 </p>
 <p>
  Hereâs an example of the use of
  <span class="pre">
   C
  </span>
  constraint to generate different PTX instruction modes based on compile time computation:
 </p>
 <pre><span class="k">constexpr</span><span class="kt">int</span><span class="n">mode_rz</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="k">constexpr</span><span class="kt">int</span><span class="n">mode_rn</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span><span class="n">mode</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="nc">helper</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;&gt;</span><span class="k">struct</span><span class="nc">helper</span><span class="o">&lt;</span><span class="n">mode_rz</span><span class="o">&gt;</span><span class="p">{</span>
<span class="k">static</span><span class="k">constexpr</span><span class="k">const</span><span class="kt">char</span><span class="n">mode</span><span class="p">[]</span><span class="o">=</span><span class="s">".rz"</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;&gt;</span><span class="k">struct</span><span class="nc">helper</span><span class="o">&lt;</span><span class="n">mode_rn</span><span class="o">&gt;</span><span class="p">{</span>
<span class="k">static</span><span class="k">constexpr</span><span class="k">const</span><span class="kt">char</span><span class="n">mode</span><span class="p">[]</span><span class="o">=</span><span class="s">".rn"</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span><span class="n">rounding_mode</span><span class="o">&gt;</span>
<span class="n">__device__</span><span class="kt">float</span><span class="n">compute_add</span><span class="p">(</span><span class="kt">float</span><span class="n">a</span><span class="p">,</span><span class="kt">float</span><span class="n">b</span><span class="p">)</span><span class="p">{</span>
<span class="kt">float</span><span class="n">result</span><span class="p">;</span>
<span class="k">asm</span><span class="p">(</span><span class="s">"add.f32%1 %0,%2,%3;"</span><span class="o">:</span><span class="s">"=f"</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="o">:</span><span class="s">"C"</span><span class="p">(</span><span class="n">helper</span><span class="o">&lt;</span><span class="n">rounding_mode</span><span class="o">&gt;::</span><span class="n">mode</span><span class="p">),</span>
<span class="s">"f"</span><span class="p">(</span><span class="n">a</span><span class="p">),</span><span class="s">"f"</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
<span class="k">return</span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__global__</span><span class="kt">void</span><span class="n">kern</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="kt">float</span><span class="n">a</span><span class="p">,</span><span class="kt">float</span><span class="n">b</span><span class="p">)</span><span class="p">{</span>
<span class="o">*</span><span class="n">result</span><span class="o">++</span><span class="o">=</span><span class="n">compute_add</span><span class="o">&lt;</span><span class="n">mode_rn</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span><span class="c1">// generates add.f32.rn</span>
<span class="o">*</span><span class="n">result</span><span class="o">=</span><span class="n">compute_add</span><span class="o">&lt;</span><span class="n">mode_rz</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span><span class="c1">// generates add.f32.rz</span>
<span class="p">}</span>
</pre>
 <p>
  Other examples (compile in C++17 or later dialect):
 </p>
 <pre><span class="k">struct</span><span class="nc">S1</span><span class="p">{</span>
<span class="k">static</span><span class="k">constexpr</span><span class="kt">char</span><span class="n">buf1</span><span class="p">[]</span><span class="o">=</span><span class="s">"Jumped"</span><span class="p">;</span>
<span class="k">static</span><span class="k">constexpr</span><span class="kt">char</span><span class="n">buf2</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="sc">'O'</span><span class="p">,</span><span class="sc">'v'</span><span class="p">,</span><span class="sc">'e'</span><span class="p">,</span><span class="sc">'r'</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">const</span><span class="kt">char</span><span class="o">*</span><span class="n">p1</span><span class="p">,</span><span class="k">const</span><span class="kt">char</span><span class="o">*</span><span class="n">p2</span><span class="p">,</span><span class="k">const</span><span class="kt">char</span><span class="o">*</span><span class="n">p3</span><span class="o">&gt;</span>
<span class="n">__device__</span><span class="kt">void</span><span class="n">doit</span><span class="p">()</span><span class="p">{</span>
<span class="k">asm</span><span class="k">volatile</span><span class="p">(</span><span class="s">"%0 %1 %2"</span><span class="o">:</span><span class="o">:</span><span class="s">"C"</span><span class="p">(</span><span class="n">p1</span><span class="p">),</span><span class="s">"C"</span><span class="p">(</span><span class="n">p2</span><span class="p">),</span><span class="s">"C"</span><span class="p">(</span><span class="n">p3</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">struct</span><span class="nc">S2</span><span class="p">{</span>
<span class="k">static</span><span class="k">const</span><span class="kt">char</span><span class="n">buf</span><span class="p">[];</span>
<span class="p">};</span>
<span class="k">const</span><span class="kt">char</span><span class="n">S2</span><span class="o">::</span><span class="n">buf</span><span class="p">[]</span><span class="o">=</span><span class="s">"this"</span><span class="p">;</span>

<span class="k">const</span><span class="kt">char</span><span class="n">buf3</span><span class="p">[]</span><span class="o">=</span><span class="s">"Jumped"</span><span class="p">;</span>
<span class="k">extern</span><span class="k">const</span><span class="kt">char</span><span class="n">buf4</span><span class="p">[];</span>

<span class="n">__global__</span><span class="kt">void</span><span class="n">foo</span><span class="p">()</span><span class="p">{</span>
<span class="k">static</span><span class="k">const</span><span class="kt">char</span><span class="n">v1</span><span class="p">[]</span><span class="o">=</span><span class="s">"The"</span><span class="p">;</span>
<span class="k">static</span><span class="k">constexpr</span><span class="kt">char</span><span class="n">v2</span><span class="p">[]</span><span class="o">=</span><span class="s">"Quick"</span><span class="p">;</span>
<span class="k">static</span><span class="k">const</span><span class="kt">char</span><span class="n">v3</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="sc">'B'</span><span class="p">,</span><span class="sc">'r'</span><span class="p">,</span><span class="sc">'o'</span><span class="p">,</span><span class="sc">'w'</span><span class="p">,</span><span class="sc">'n'</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>
<span class="k">static</span><span class="k">constexpr</span><span class="kt">char</span><span class="n">v4</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="sc">'F'</span><span class="p">,</span><span class="sc">'o'</span><span class="p">,</span><span class="sc">'x'</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>

<span class="c1">//OK: generates 'The Quick Brown Fox Jumped Over' in PTX</span>
<span class="k">asm</span><span class="k">volatile</span><span class="p">(</span><span class="s">"%0 %1 %2 %3 %4 %5"</span><span class="o">:</span><span class="o">:</span><span class="s">"C"</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span><span class="p">,</span><span class="s">"C"</span><span class="p">(</span><span class="n">v2</span><span class="p">),</span><span class="s">"C"</span><span class="p">(</span><span class="n">v3</span><span class="p">),</span><span class="s">"C"</span><span class="p">(</span><span class="n">v4</span><span class="p">),</span><span class="s">"C"</span><span class="p">(</span><span class="n">S1</span><span class="o">::</span><span class="n">buf1</span><span class="p">),</span><span class="s">"C"</span><span class="p">(</span><span class="n">S1</span><span class="o">::</span><span class="n">buf2</span><span class="p">)</span><span class="p">);</span>

<span class="c1">//OK: generates 'Brown Fox Jumped' in PTX</span>
<span class="n">doit</span><span class="o">&lt;</span><span class="n">v3</span><span class="p">,</span><span class="n">v4</span><span class="p">,</span><span class="n">buf3</span><span class="o">&gt;</span><span class="p">();</span>


<span class="c1">//error cases</span>

<span class="k">const</span><span class="kt">char</span><span class="n">n1</span><span class="p">[]</span><span class="o">=</span><span class="s">"hi"</span><span class="p">;</span>

<span class="c1">//error: argument to "C" constraint is not a constant expression</span>
<span class="k">asm</span><span class="k">volatile</span><span class="p">(</span><span class="s">"%0"</span><span class="o">::</span><span class="s">"C"</span><span class="p">(</span><span class="n">n1</span><span class="p">));</span>

<span class="c1">//error: S2::buf was not initialized at point of declaration</span>
<span class="k">asm</span><span class="k">volatile</span><span class="p">(</span><span class="s">"%0"</span><span class="o">::</span><span class="s">"C"</span><span class="p">(</span><span class="n">S2</span><span class="o">::</span><span class="n">buf</span><span class="p">));</span>

<span class="c1">//error: buf4 was not initialized</span>
<span class="k">asm</span><span class="k">volatile</span><span class="p">(</span><span class="s">"%0"</span><span class="o">::</span><span class="s">"C"</span><span class="p">(</span><span class="n">buf4</span><span class="p">));</span>
<span class="p">}</span>
</pre>
 <p>
  There is no constraint letter for 8-bit wide PTX registers. PTX instructions types accepting 8-bit wide types
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#restricted-use-of-sub-word-sizes">
   permit operands to be wider than the instruction-type size
  </a>
  . Example:
 </p>
 <pre><span class="n">__device__</span><span class="kt">void</span><span class="n">copy_u8</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="n">in</span><span class="p">,</span><span class="kt">char</span><span class="o">*</span><span class="n">out</span><span class="p">)</span><span class="p">{</span>
<span class="kt">int</span><span class="n">d</span><span class="p">;</span>
<span class="k">asm</span><span class="p">(</span><span class="s">"ld.u8 %0, [%1];"</span><span class="o">:</span><span class="s">"=r"</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">:</span><span class="s">"l"</span><span class="p">(</span><span class="n">in</span><span class="p">));</span>
<span class="o">*</span><span class="n">out</span><span class="o">=</span><span class="n">d</span><span class="p">;</span>
<span class="p">}</span>
</pre>
 <p>
  generates:
 </p>
 <pre><span class="n">ld</span><span class="p">.</span><span class="n">u8</span><span class="n">r1</span><span class="p">,</span><span class="p">[</span><span class="n">rd1</span><span class="p">];</span>
<span class="n">st</span><span class="p">.</span><span class="n">u8</span><span class="p">[</span><span class="n">rd2</span><span class="p">],</span><span class="n">r1</span><span class="p">;</span>
</pre>
 <p>
  The behavior of using a constraint string that is not one of those specified above is undefined.
 </p>
 <h2>
  <span class="section-number">
   1.2.
  </span>
  Pitfalls
  <a class="headerlink" href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html#pitfalls" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  Although
  <span class="pre">
   asm()
  </span>
  statements are very flexible and powerful, you may encounter some pitfallsâthese are listed in this section.
 </p>
 <h3>
  <span class="section-number">
   1.2.1.
  </span>
  Namespace Conflicts
  <a class="headerlink" href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html#namespace-conflicts" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  If the cube function (described before) is called and inlined multiple times in the code, it generates an error about duplicate definitions of the temp register t1. To avoid this error you need to:
 </p>
 <ul>
  <li>
   <p>
    not inline the cube function, or,
   </p>
  </li>
  <li>
   <p>
    nest the t1 use inside
    <span class="pre">
     {}
    </span>
    so that it has a separate scope for each invocation, e.g.:
   </p>
   <pre><span class="n">__device__</span><span class="kt">int</span><span class="n">cube</span><span class="p">(</span><span class="kt">int</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="kt">int</span><span class="n">y</span><span class="p">;</span>
<span class="k">asm</span><span class="p">(</span><span class="s">"{</span><span class="se">\n\t</span><span class="s">"</span><span class="c1">// use braces for local scope</span>
<span class="s">" reg .u32 t1;</span><span class="se">\n\t</span><span class="s">"</span><span class="c1">// temp reg t1,</span>
<span class="s">" mul.lo.u32 t1, %1, %1;</span><span class="se">\n\t</span><span class="s">"</span><span class="c1">// t1 = x * x</span>
<span class="s">" mul.lo.u32 %0, t1, %1;</span><span class="se">\n\t</span><span class="s">"</span><span class="c1">// y = t1 * x</span>
<span class="s">"}"</span>
<span class="o">:</span><span class="s">"=r"</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">:</span><span class="s">"r"</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="k">return</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</pre>
  </li>
 </ul>
 <p>
  Note that you can similarly use braces for local labels inside the
  <span class="pre">
   asm()
  </span>
  statement.
 </p>
 <h3>
  <span class="section-number">
   1.2.2.
  </span>
  Memory Space Conflicts
  <a class="headerlink" href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html#memory-space-conflicts" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Since
  <span class="pre">
   asm()
  </span>
  statements have no way of knowing what memory space a register is in, the user must make sure that the appropriate PTX instruction is used. For
  <span class="pre">
   sm_20
  </span>
  and greater, any pointer argument to an
  <span class="pre">
   asm()
  </span>
  statement is passed as a generic address.
 </p>
 <h3>
  <span class="section-number">
   1.2.3.
  </span>
  Incorrect Optimization
  <a class="headerlink" href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html#incorrect-optimization" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The compiler assumes that an
  <span class="pre">
   asm()
  </span>
  statement has no side effects except to change the output operands. To ensure that the asm is not deleted or moved during generation of PTX, you should use the volatile keyword, e.g.:
 </p>
 <pre><span class="k">asm</span><span class="k">volatile</span><span class="p">(</span><span class="s">"mov.u32 %0, %%clock;"</span><span class="o">:</span><span class="s">"=r"</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</pre>
 <p>
  Normally any memory that is written to will be specified as an out operand, but if there is a hidden side effect on user memory (for example, indirect access of a memory location via an operand), or if you want to stop any memory optimizations around the
  <span class="pre">
   asm()
  </span>
  statement performed during generation of PTX, you can add a âmemoryâ clobbers specification after a 3rd colon, e.g.:
 </p>
 <pre><span class="k">asm</span><span class="k">volatile</span><span class="p">(</span><span class="s">"mov.u32 %0, %%clock;"</span><span class="o">:</span><span class="s">"=r"</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">::</span><span class="s">"memory"</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">"st.u32 [%0], %1;"</span><span class="o">::</span><span class="s">"l"</span><span class="p">(</span><span class="n">p</span><span class="p">),</span><span class="s">"r"</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="s">"memory"</span><span class="p">);</span>
</pre>
 <h3>
  <span class="section-number">
   1.2.4.
  </span>
  Incorrect PTX
  <a class="headerlink" href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html#incorrect-ptx" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The compiler front end does not parse the
  <span class="pre">
   asm()
  </span>
  statement template string and does not know what it means or even whether it is valid PTX input. So if there are any errors in the string it will not show up until
  <span class="pre">
   ptxas
  </span>
  . For example, if you pass a value with an ârâ constraint but use it in an
  <span class="pre">
   add.f64
  </span>
  you will get a parse error from ptxas. Similarly, operand modifiers are not supported. For example, in
 </p>
 <pre><span class="k">asm</span><span class="p">(</span><span class="s">"mov.u32 %0, %n1;"</span><span class="o">:</span><span class="s">"=r"</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">:</span><span class="s">"r"</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</pre>
 <p>
  the ânâ modifier in â%n1â is not supported and will be passed to
  <span class="pre">
   ptxas
  </span>
  , where it can cause undefined behavior. Refer to the document nvcc.pdf for further compiler related details.
 </p>
 <h2>
  <span class="section-number">
   1.3.
  </span>
  Error Checking
  <a class="headerlink" href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html#error-checking" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  The following are some of the error checks that the compiler will do on inlinePTXasm:
 </p>
 <ul>
  <li>
   <p>
    Multiple constraint letters for a single asm operand are not allowed, e.g.:
   </p>
   <pre><span class="k">asm</span><span class="p">(</span><span class="s">"add.s32 %0, %1, %2;"</span><span class="o">:</span><span class="s">"=r"</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">:</span><span class="s">"rf"</span><span class="p">(</span><span class="n">j</span><span class="p">),</span><span class="s">"r"</span><span class="p">(</span><span class="n">k</span><span class="p">));</span>
</pre>
   <p>
    error: an asm operand may specify only one constraint letter in a __device__/__global__ function
   </p>
  </li>
  <li>
   <p>
    Only scalar variables are allowed as asm operands. Specifically aggregates like âstructâ type variables are not allowed, e.g.
   </p>
   <pre><span class="n">int4</span><span class="n">i4</span><span class="p">;</span>
<span class="k">asm</span><span class="p">(</span><span class="s">"add.s32 %0, %1, %2;"</span><span class="o">:</span><span class="s">"=r"</span><span class="p">(</span><span class="n">i4</span><span class="p">)</span><span class="o">:</span><span class="s">"r"</span><span class="p">(</span><span class="n">j</span><span class="p">),</span><span class="s">"r"</span><span class="p">(</span><span class="n">k</span><span class="p">));</span>
</pre>
   <p>
    error: an asm operand must have scalar type
   </p>
  </li>
  <li>
   <p>
    The type and size implied by a PTX asm constraint must match that of the associated operand. Example where size does not match:
   </p>
   <p>
    For âcharâ type variable âciâ,
   </p>
   <pre><span class="k">asm</span><span class="p">(</span><span class="s">"add.s32 %0,%1,%2;"</span><span class="o">:</span><span class="s">"=r"</span><span class="p">(</span><span class="n">ci</span><span class="p">)</span><span class="o">:</span><span class="s">"r"</span><span class="p">(</span><span class="n">j</span><span class="p">),</span><span class="s">"r"</span><span class="p">(</span><span class="n">k</span><span class="p">));</span>
</pre>
   <p>
    error: asm operand type size(1) does not match type/size implied by constraint ârâ
   </p>
   <p>
    In order to use âcharâ type variables âciâ, âcjâ, and âckâ in the above asm statement, code segment similar to the following may be used,
   </p>
   <pre><span class="kt">int</span><span class="n">temp</span><span class="o">=</span><span class="n">ci</span><span class="p">;</span>
<span class="k">asm</span><span class="p">(</span><span class="s">"add.s32 %0,%1,%2;"</span><span class="o">:</span><span class="s">"=r"</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span><span class="o">:</span><span class="s">"r"</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">cj</span><span class="p">),</span><span class="s">"r"</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">ck</span><span class="p">));</span>
<span class="n">ci</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
</pre>
   <p>
    Another example where type does not match:
   </p>
   <p>
    For âfloatâ type variable âfiâ,
   </p>
   <pre><span class="k">asm</span><span class="p">(</span><span class="s">"add.s32 %0,%1,%2;"</span><span class="o">:</span><span class="s">"=r"</span><span class="p">(</span><span class="n">fi</span><span class="p">)</span><span class="o">:</span><span class="s">"r"</span><span class="p">(</span><span class="n">j</span><span class="p">),</span><span class="s">"r"</span><span class="p">(</span><span class="n">k</span><span class="p">));</span>
</pre>
   <p>
    error: asm operand type size(4) does not match type/size implied by constraint ârâ
   </p>
  </li>
 </ul>
 <h1>
  <span class="section-number">
   2.
  </span>
  Notices
  <a class="headerlink" href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html#notices" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <h2>
  <span class="section-number">
   2.1.
  </span>
  Notice
  <a class="headerlink" href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html#notice" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  This document is provided for information purposes only and shall not be regarded as a warranty of a certain functionality, condition, or quality of a product. NVIDIA Corporation (âNVIDIAâ) makes no representations or warranties, expressed or implied, as to the accuracy or completeness of the information contained in this document and assumes no responsibility for any errors contained herein. NVIDIA shall have no liability for the consequences or use of such information or for any infringement of patents or other rights of third parties that may result from its use. This document is not a commitment to develop, release, or deliver any Material (defined below), code, or functionality.
 </p>
 <p>
  NVIDIA reserves the right to make corrections, modifications, enhancements, improvements, and any other changes to this document, at any time without notice.
 </p>
 <p>
  Customer should obtain the latest relevant information before placing orders and should verify that such information is current and complete.
 </p>
 <p>
  NVIDIA products are sold subject to the NVIDIA standard terms and conditions of sale supplied at the time of order acknowledgement, unless otherwise agreed in an individual sales agreement signed by authorized representatives of NVIDIA and customer (âTerms of Saleâ). NVIDIA hereby expressly objects to applying any customer general terms and conditions with regards to the purchase of the NVIDIA product referenced in this document. No contractual obligations are formed either directly or indirectly by this document.
 </p>
 <p>
  NVIDIA products are not designed, authorized, or warranted to be suitable for use in medical, military, aircraft, space, or life support equipment, nor in applications where failure or malfunction of the NVIDIA product can reasonably be expected to result in personal injury, death, or property or environmental damage. NVIDIA accepts no liability for inclusion and/or use of NVIDIA products in such equipment or applications and therefore such inclusion and/or use is at customerâs own risk.
 </p>
 <p>
  NVIDIA makes no representation or warranty that products based on this document will be suitable for any specified use. Testing of all parameters of each product is not necessarily performed by NVIDIA. It is customerâs sole responsibility to evaluate and determine the applicability of any information contained in this document, ensure the product is suitable and fit for the application planned by customer, and perform the necessary testing for the application in order to avoid a default of the application or the product. Weaknesses in customerâs product designs may affect the quality and reliability of the NVIDIA product and may result in additional or different conditions and/or requirements beyond those contained in this document. NVIDIA accepts no liability related to any default, damage, costs, or problem which may be based on or attributable to: (i) the use of the NVIDIA product in any manner that is contrary to this document or (ii) customer product designs.
 </p>
 <p>
  No license, either expressed or implied, is granted under any NVIDIA patent right, copyright, or other NVIDIA intellectual property right under this document. Information published by NVIDIA regarding third-party products or services does not constitute a license from NVIDIA to use such products or services or a warranty or endorsement thereof. Use of such information may require a license from a third party under the patents or other intellectual property rights of the third party, or a license from NVIDIA under the patents or other intellectual property rights of NVIDIA.
 </p>
 <p>
  Reproduction of information in this document is permissible only if approved in advance by NVIDIA in writing, reproduced without alteration and in full compliance with all applicable export laws and regulations, and accompanied by all associated conditions, limitations, and notices.
 </p>
 <p>
  THIS DOCUMENT AND ALL NVIDIA DESIGN SPECIFICATIONS, REFERENCE BOARDS, FILES, DRAWINGS, DIAGNOSTICS, LISTS, AND OTHER DOCUMENTS (TOGETHER AND SEPARATELY, âMATERIALSâ) ARE BEING PROVIDED âAS IS.â NVIDIA MAKES NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL NVIDIA BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF ANY USE OF THIS DOCUMENT, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. Notwithstanding any damages that customer might incur for any reason whatsoever, NVIDIAâs aggregate and cumulative liability towards customer for the products described herein shall be limited in accordance with the Terms of Sale for the product.
 </p>
 <h2>
  <span class="section-number">
   2.2.
  </span>
  OpenCL
  <a class="headerlink" href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html#opencl" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  OpenCL is a trademark of Apple Inc. used under license to the Khronos Group Inc.
 </p>
 <h2>
  <span class="section-number">
   2.3.
  </span>
  Trademarks
  <a class="headerlink" href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html#trademarks" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  NVIDIA and the NVIDIA logo are trademarks or registered trademarks of NVIDIA Corporation in the U.S. and other countries. Other company and product names may be trademarks of the respective companies with which they are associated.
 </p>
 <p class="notices">
  <a href="https://www.nvidia.com/en-us/about-nvidia/privacy-policy/" target="_blank">
   Privacy Policy
  </a>
  |
  <a href="https://www.nvidia.com/en-us/about-nvidia/privacy-center/" target="_blank">
   Manage My Privacy
  </a>
  |
  <a href="https://www.nvidia.com/en-us/preferences/start/" target="_blank">
   Do Not Sell or Share My Data
  </a>
  |
  <a href="https://www.nvidia.com/en-us/about-nvidia/terms-of-service/" target="_blank">
   Terms of Service
  </a>
  |
  <a href="https://www.nvidia.com/en-us/about-nvidia/accessibility/" target="_blank">
   Accessibility
  </a>
  |
  <a href="https://www.nvidia.com/en-us/about-nvidia/company-policies/" target="_blank">
   Corporate Policies
  </a>
  |
  <a href="https://www.nvidia.com/en-us/product-security/" target="_blank">
   Product Security
  </a>
  |
  <a href="https://www.nvidia.com/en-us/contact/" target="_blank">
   Contact
  </a>
 </p>
 <p>
  Copyright Â© 2012-2024, NVIDIA Corporation &amp; affiliates. All rights reserved.
 </p>
 <p>
  <span class="lastupdated">
   Last updated on Jul 1, 2024.
  </span>
 </p>
</body>
</body></html>