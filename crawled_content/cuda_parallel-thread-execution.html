<html><head><title>PTX ISA 8.5</title></head><body><body class="wy-body-for-nav">
 <a href="https://docs.nvidia.com/cuda/parallel-thread-execution/contents.html">
 </a>
 <ul class="current">
  <li class="toctree-l1 current">
   <a class="current reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/">
    1. Introduction
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#scalable-data-parallel-computing-using-gpus">
      1.1. Scalable Data-Parallel Computing using GPUs
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#goals-of-ptx">
      1.2. Goals of PTX
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#ptx-isa-version-8-5">
      1.3. PTX ISA Version 8.5
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#document-structure">
      1.4. Document Structure
     </a>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#programming-model">
    2. Programming Model
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#a-highly-multithreaded-coprocessor">
      2.1. A Highly Multithreaded Coprocessor
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#thread-hierarchy">
      2.2. Thread Hierarchy
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#cooperative-thread-arrays">
        2.2.1. Cooperative Thread Arrays
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#cluster-of-cooperative-thread-arrays">
        2.2.2. Cluster of Cooperative Thread Arrays
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#grid-of-clusters">
        2.2.3. Grid of Clusters
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-hierarchy">
      2.3. Memory Hierarchy
     </a>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#ptx-machine-model">
    3. PTX Machine Model
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#a-set-of-simt-multiprocessors">
      3.1. A Set of SIMT Multiprocessors
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#independent-thread-scheduling">
      3.2. Independent Thread Scheduling
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#on-chip-shared-memory">
      3.3. On-chip Shared Memory
     </a>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#syntax">
    4. Syntax
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#source-format">
      4.1. Source Format
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#comments">
      4.2. Comments
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#statements">
      4.3. Statements
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#directive-statements">
        4.3.1. Directive Statements
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#instruction-statements">
        4.3.2. Instruction Statements
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#identifiers">
      4.4. Identifiers
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#constants">
      4.5. Constants
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-constants">
        4.5.1. Integer Constants
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-constants">
        4.5.2. Floating-Point Constants
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#predicate-constants">
        4.5.3. Predicate Constants
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#constant-expressions">
        4.5.4. Constant Expressions
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-constant-expression-evaluation">
        4.5.5. Integer Constant Expression Evaluation
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#summary-of-constant-expression-evaluation-rules">
        4.5.6. Summary of Constant Expression Evaluation Rules
       </a>
      </li>
     </ul>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#state-spaces-types-and-variables">
    5. State Spaces, Types, and Variables
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#state-spaces">
      5.1. State Spaces
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#register-state-space">
        5.1.1. Register State Space
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-register-state-space">
        5.1.2. Special Register State Space
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#constant-state-space">
        5.1.3. Constant State Space
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#banked-constant-state-space-deprecated">
          5.1.3.1. Banked Constant State Space (deprecated)
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#global-state-space">
        5.1.4. Global State Space
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#local-state-space">
        5.1.5. Local State Space
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parameter-state-space">
        5.1.6. Parameter State Space
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-function-parameters">
          5.1.6.1. Kernel Function Parameters
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-function-parameter-attributes">
          5.1.6.2. Kernel Function Parameter Attributes
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-parameter-attribute-ptr">
          5.1.6.3. Kernel Parameter Attribute: .ptr
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#device-function-parameters">
          5.1.6.4. Device Function Parameters
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#shared-state-space">
        5.1.7. Shared State Space
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texture-state-space-deprecated">
        5.1.8. Texture State Space (deprecated)
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#types">
      5.2. Types
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#fundamental-types">
        5.2.1. Fundamental Types
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#restricted-use-of-sub-word-sizes">
        5.2.2. Restricted Use of Sub-Word Sizes
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#alternate-floating-point-data-formats">
        5.2.3. Alternate Floating-Point Data Formats
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#packed-data-types">
        5.2.4. Packed Data Types
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#packed-floating-point-data-types">
          5.2.4.1. Packed Floating Point Data Types
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#packed-integer-data-types">
          5.2.4.2. Packed Integer Data Types
         </a>
        </li>
       </ul>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texture-sampler-and-surface-types">
      5.3. Texture Sampler and Surface Types
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texture-and-surface-properties">
        5.3.1. Texture and Surface Properties
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sampler-properties">
        5.3.2. Sampler Properties
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#channel-data-type-and-channel-order-fields">
        5.3.3. Channel Data Type and Channel Order Fields
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#variables">
      5.4. Variables
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#variable-declarations">
        5.4.1. Variable Declarations
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#vectors">
        5.4.2. Vectors
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#array-declarations">
        5.4.3. Array Declarations
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#initializers">
        5.4.4. Initializers
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#alignment">
        5.4.5. Alignment
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parameterized-variable-names">
        5.4.6. Parameterized Variable Names
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#variable-attributes">
        5.4.7. Variable Attributes
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#variable-and-function-attribute-directive-attribute">
        5.4.8. Variable and Function Attribute Directive: .attribute
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensors">
      5.5. Tensors
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-dimension-size-and-format">
        5.5.1. Tensor Dimension, size and format
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-access-modes">
        5.5.2. Tensor Access Modes
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tiled-mode">
        5.5.3. Tiled Mode
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#bounding-box">
          5.5.3.1. Bounding Box
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#traversal-stride">
          5.5.3.2. Traversal-Stride
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#out-of-boundary-access">
          5.5.3.3. Out of Boundary Access
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#im2col-mode">
        5.5.4. Im2col mode
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-im2col-mode-bounding-box">
          5.5.4.1. Bounding Box
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-im2col-mode-traversal-stride">
          5.5.4.2. Traversal Stride
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-im2col-mode-oob-access">
          5.5.4.3. Out of Boundary Access
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#interleave-layout">
        5.5.5. Interleave layout
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#swizzling-modes">
        5.5.6. Swizzling Modes
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-map">
        5.5.7. Tensor-map
       </a>
      </li>
     </ul>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#instruction-operands">
    6. Instruction Operands
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#operand-type-information">
      6.1. Operand Type Information
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#source-operands">
      6.2. Source Operands
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#destination-operands">
      6.3. Destination Operands
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#using-addresses-arrays-and-vectors">
      6.4. Using Addresses, Arrays, and Vectors
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#addresses-as-operands">
        6.4.1. Addresses as Operands
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#generic-addressing">
          6.4.1.1. Generic Addressing
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#arrays-as-operands">
        6.4.2. Arrays as Operands
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#vectors-as-operands">
        6.4.3. Vectors as Operands
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#labels-and-function-names-as-operands">
        6.4.4. Labels and Function Names as Operands
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#type-conversion">
      6.5. Type Conversion
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#scalar-conversions">
        6.5.1. Scalar Conversions
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#rounding-modifiers">
        6.5.2. Rounding Modifiers
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#operand-costs">
      6.6. Operand Costs
     </a>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#abstracting-the-abi">
    7. Abstracting the ABI
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#function-declarations-and-definitions">
      7.1. Function Declarations and Definitions
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-from-ptx-isa-version-1-x">
        7.1.1. Changes from PTX ISA Version 1.x
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#variadic-functions">
      7.2. Variadic Functions
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#alloca">
      7.3. Alloca
     </a>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
    8. Memory Consistency Model
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#scope-and-applicability-of-the-model">
      8.1. Scope and applicability of the model
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#limitations-on-atomicity-at-system-scope">
        8.1.1. Limitations on atomicity at system scope
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-operations">
      8.2. Memory operations
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#overlap">
        8.2.1. Overlap
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#aliases">
        8.2.2. Aliases
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#multimem-addresses">
        8.2.3. Multimem Addresses
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-operations-on-vector-data-types">
        8.2.4. Memory Operations on Vector Data Types
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-operations-on-packed-data-types">
        8.2.5. Memory Operations on Packed Data Types
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#initialization">
        8.2.6. Initialization
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-state-spaces">
      8.3. State spaces
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#operation-types">
      8.4. Operation types
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mmio-operation">
        8.4.1. mmio Operation
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#scope">
      8.5. Scope
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#proxies">
      8.6. Proxies
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#morally-strong-operations">
      8.7. Morally strong operations
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#conflict-and-data-races">
        8.7.1. Conflict and Data-races
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#limitations-on-mixed-size-data-races">
        8.7.2. Limitations on Mixed-size Data-races
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#release-and-acquire-patterns">
      8.8. Release and Acquire Patterns
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#ordering-of-memory-operations">
      8.9. Ordering of memory operations
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#program-order">
        8.9.1. Program Order
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-operations">
          8.9.1.1. Asynchronous Operations
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#observation-order">
        8.9.2. Observation Order
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#fence-sc-order">
        8.9.3. Fence-SC Order
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-synchronization">
        8.9.4. Memory synchronization
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#causality-order">
        8.9.5. Causality Order
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#coherence-order">
        8.9.6. Coherence Order
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#communication-order">
        8.9.7. Communication Order
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#axioms">
      8.10. Axioms
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#coherence">
        8.10.1. Coherence
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#fence-sc">
        8.10.2. Fence-SC
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#atomicity">
        8.10.3. Atomicity
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#no-thin-air">
        8.10.4. No Thin Air
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sequential-consistency-per-location">
        8.10.5. Sequential Consistency Per Location
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#causality">
        8.10.6. Causality
       </a>
      </li>
     </ul>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#instruction-set">
    9. Instruction Set
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#format-and-semantics-of-instruction-descriptions">
      9.1. Format and Semantics of Instruction Descriptions
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#ptx-instructions">
      9.2. PTX Instructions
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#predicated-execution">
      9.3. Predicated Execution
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#comparisons">
        9.3.1. Comparisons
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-and-bit-size-comparisons">
          9.3.1.1. Integer and Bit-Size Comparisons
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-comparisons">
          9.3.1.2. Floating Point Comparisons
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#manipulating-predicates">
        9.3.2. Manipulating Predicates
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#type-information-for-instructions-and-operands">
      9.4. Type Information for Instructions and Operands
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#operand-size-exceeding-instruction-type-size">
        9.4.1. Operand Size Exceeding Instruction-Type Size
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#divergence-of-threads-in-control-constructs">
      9.5. Divergence of Threads in Control Constructs
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#semantics">
      9.6. Semantics
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#machine-specific-semantics-of-16-bit-code">
        9.6.1. Machine-Specific Semantics of 16-bit Code
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#instructions">
      9.7. Instructions
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions">
        9.7.1. Integer Arithmetic Instructions
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-add">
          9.7.1.1. Integer Arithmetic Instructions: add
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-sub">
          9.7.1.2. Integer Arithmetic Instructions: sub
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-mul">
          9.7.1.3. Integer Arithmetic Instructions: mul
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-mad">
          9.7.1.4. Integer Arithmetic Instructions: mad
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-mul24">
          9.7.1.5. Integer Arithmetic Instructions: mul24
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-mad24">
          9.7.1.6. Integer Arithmetic Instructions: mad24
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-sad">
          9.7.1.7. Integer Arithmetic Instructions: sad
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-div">
          9.7.1.8. Integer Arithmetic Instructions: div
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-rem">
          9.7.1.9. Integer Arithmetic Instructions: rem
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-abs">
          9.7.1.10. Integer Arithmetic Instructions: abs
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-neg">
          9.7.1.11. Integer Arithmetic Instructions: neg
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-min">
          9.7.1.12. Integer Arithmetic Instructions: min
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-max">
          9.7.1.13. Integer Arithmetic Instructions: max
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-popc">
          9.7.1.14. Integer Arithmetic Instructions: popc
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-clz">
          9.7.1.15. Integer Arithmetic Instructions: clz
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-bfind">
          9.7.1.16. Integer Arithmetic Instructions: bfind
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-fns">
          9.7.1.17. Integer Arithmetic Instructions: fns
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-brev">
          9.7.1.18. Integer Arithmetic Instructions: brev
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-bfe">
          9.7.1.19. Integer Arithmetic Instructions: bfe
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-bfi">
          9.7.1.20. Integer Arithmetic Instructions: bfi
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-szext">
          9.7.1.21. Integer Arithmetic Instructions: szext
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-bmsk">
          9.7.1.22. Integer Arithmetic Instructions: bmsk
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-dp4a">
          9.7.1.23. Integer Arithmetic Instructions: dp4a
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-dp2a">
          9.7.1.24. Integer Arithmetic Instructions: dp2a
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#extended-precision-integer-arithmetic-instructions">
        9.7.2. Extended-Precision Integer Arithmetic Instructions
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#extended-precision-arithmetic-instructions-add-cc">
          9.7.2.1. Extended-Precision Arithmetic Instructions: add.cc
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#extended-precision-arithmetic-instructions-addc">
          9.7.2.2. Extended-Precision Arithmetic Instructions: addc
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#extended-precision-arithmetic-instructions-sub-cc">
          9.7.2.3. Extended-Precision Arithmetic Instructions: sub.cc
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#extended-precision-arithmetic-instructions-subc">
          9.7.2.4. Extended-Precision Arithmetic Instructions: subc
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#extended-precision-arithmetic-instructions-mad-cc">
          9.7.2.5. Extended-Precision Arithmetic Instructions: mad.cc
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#extended-precision-arithmetic-instructions-madc">
          9.7.2.6. Extended-Precision Arithmetic Instructions: madc
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions">
        9.7.3. Floating-Point Instructions
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-testp">
          9.7.3.1. Floating Point Instructions: testp
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-copysign">
          9.7.3.2. Floating Point Instructions: copysign
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-add">
          9.7.3.3. Floating Point Instructions: add
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-sub">
          9.7.3.4. Floating Point Instructions: sub
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-mul">
          9.7.3.5. Floating Point Instructions: mul
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-fma">
          9.7.3.6. Floating Point Instructions: fma
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-mad">
          9.7.3.7. Floating Point Instructions: mad
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-div">
          9.7.3.8. Floating Point Instructions: div
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-abs">
          9.7.3.9. Floating Point Instructions: abs
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-neg">
          9.7.3.10. Floating Point Instructions: neg
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-min">
          9.7.3.11. Floating Point Instructions: min
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-max">
          9.7.3.12. Floating Point Instructions: max
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-rcp">
          9.7.3.13. Floating Point Instructions: rcp
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-rcp-approx-ftz-f64">
          9.7.3.14. Floating Point Instructions: rcp.approx.ftz.f64
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-sqrt">
          9.7.3.15. Floating Point Instructions: sqrt
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-rsqrt">
          9.7.3.16. Floating Point Instructions: rsqrt
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-rsqrt-approx-ftz-f64">
          9.7.3.17. Floating Point Instructions: rsqrt.approx.ftz.f64
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-sin">
          9.7.3.18. Floating Point Instructions: sin
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-cos">
          9.7.3.19. Floating Point Instructions: cos
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-lg2">
          9.7.3.20. Floating Point Instructions: lg2
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-ex2">
          9.7.3.21. Floating Point Instructions: ex2
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-tanh">
          9.7.3.22. Floating Point Instructions: tanh
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions">
        9.7.4. Half Precision Floating-Point Instructions
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-add">
          9.7.4.1. Half Precision Floating Point Instructions: add
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-sub">
          9.7.4.2. Half Precision Floating Point Instructions: sub
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-mul">
          9.7.4.3. Half Precision Floating Point Instructions: mul
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-fma">
          9.7.4.4. Half Precision Floating Point Instructions: fma
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-neg">
          9.7.4.5. Half Precision Floating Point Instructions: neg
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-abs">
          9.7.4.6. Half Precision Floating Point Instructions: abs
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-min">
          9.7.4.7. Half Precision Floating Point Instructions: min
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-max">
          9.7.4.8. Half Precision Floating Point Instructions: max
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-tanh">
          9.7.4.9. Half Precision Floating Point Instructions: tanh
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-ex2">
          9.7.4.10. Half Precision Floating Point Instructions: ex2
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#comparison-and-selection-instructions">
        9.7.5. Comparison and Selection Instructions
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#comparison-and-selection-instructions-set">
          9.7.5.1. Comparison and Selection Instructions: set
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#comparison-and-selection-instructions-setp">
          9.7.5.2. Comparison and Selection Instructions: setp
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#comparison-and-selection-instructions-selp">
          9.7.5.3. Comparison and Selection Instructions: selp
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#comparison-and-selection-instructions-slct">
          9.7.5.4. Comparison and Selection Instructions: slct
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-comparison-instructions">
        9.7.6. Half Precision Comparison Instructions
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-comparison-instructions-set">
          9.7.6.1. Half Precision Comparison Instructions: set
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-comparison-instructions-setp">
          9.7.6.2. Half Precision Comparison Instructions: setp
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions">
        9.7.7. Logic and Shift Instructions
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions-and">
          9.7.7.1. Logic and Shift Instructions: and
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions-or">
          9.7.7.2. Logic and Shift Instructions: or
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions-xor">
          9.7.7.3. Logic and Shift Instructions: xor
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions-not">
          9.7.7.4. Logic and Shift Instructions: not
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions-cnot">
          9.7.7.5. Logic and Shift Instructions: cnot
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions-lop3">
          9.7.7.6. Logic and Shift Instructions: lop3
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions-shf">
          9.7.7.7. Logic and Shift Instructions: shf
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions-shl">
          9.7.7.8. Logic and Shift Instructions: shl
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions-shr">
          9.7.7.9. Logic and Shift Instructions: shr
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions">
        9.7.8. Data Movement and Conversion Instructions
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#cache-operators">
          9.7.8.1. Cache Operators
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#cache-eviction-priority-hints">
          9.7.8.2. Cache Eviction Priority Hints
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-mov">
          9.7.8.3. Data Movement and Conversion Instructions: mov
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-mov-2">
          9.7.8.4. Data Movement and Conversion Instructions: mov
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-shfl-deprecated">
          9.7.8.5. Data Movement and Conversion Instructions: shfl (deprecated)
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-shfl-sync">
          9.7.8.6. Data Movement and Conversion Instructions: shfl.sync
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-prmt">
          9.7.8.7. Data Movement and Conversion Instructions: prmt
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-ld">
          9.7.8.8. Data Movement and Conversion Instructions: ld
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-ld-global-nc">
          9.7.8.9. Data Movement and Conversion Instructions: ld.global.nc
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-ldu">
          9.7.8.10. Data Movement and Conversion Instructions: ldu
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-st">
          9.7.8.11. Data Movement and Conversion Instructions: st
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-st-async">
          9.7.8.12. Data Movement and Conversion Instructions: st.async
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-multimem-ld-reduce-multimem-st-multimem-red">
          9.7.8.13. Data Movement and Conversion Instructions: multimem.ld_reduce, multimem.st, multimem.red
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-prefetch-prefetchu">
          9.7.8.14. Data Movement and Conversion Instructions: prefetch, prefetchu
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-applypriority">
          9.7.8.15. Data Movement and Conversion Instructions: applypriority
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-discard">
          9.7.8.16. Data Movement and Conversion Instructions: discard
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-createpolicy">
          9.7.8.17. Data Movement and Conversion Instructions: createpolicy
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-isspacep">
          9.7.8.18. Data Movement and Conversion Instructions: isspacep
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cvta">
          9.7.8.19. Data Movement and Conversion Instructions: cvta
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cvt">
          9.7.8.20. Data Movement and Conversion Instructions: cvt
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cvt-pack">
          9.7.8.21. Data Movement and Conversion Instructions: cvt.pack
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-mapa">
          9.7.8.22. Data Movement and Conversion Instructions: mapa
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-getctarank">
          9.7.8.23. Data Movement and Conversion Instructions: getctarank
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-asynchronous-copy">
          9.7.8.24. Data Movement and Conversion Instructions: Asynchronous copy
         </a>
         <ul>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#completion-mechanisms-for-asynchronous-copy-operations">
            9.7.8.24.1. Completion Mechanisms for Asynchronous Copy Operations
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#async-proxy">
            9.7.8.24.2. Async Proxy
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async">
            9.7.8.24.3. Data Movement and Conversion Instructions: cp.async
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-commit-group">
            9.7.8.24.4. Data Movement and Conversion Instructions: cp.async.commit_group
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-wait-group-cp-async-wait-all">
            9.7.8.24.5. Data Movement and Conversion Instructions: cp.async.wait_group / cp.async.wait_all
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk">
            9.7.8.24.6. Data Movement and Conversion Instructions: cp.async.bulk
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-reduce-async-bulk">
            9.7.8.24.7. Data Movement and Conversion Instructions: cp.reduce.async.bulk
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk-prefetch">
            9.7.8.24.8. Data Movement and Conversion Instructions: cp.async.bulk.prefetch
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk-tensor">
            9.7.8.24.9. Data Movement and Conversion Instructions: cp.async.bulk.tensor
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-reduce-async-bulk-tensor">
            9.7.8.24.10. Data Movement and Conversion Instructions: cp.reduce.async.bulk.tensor
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk-prefetch-tensor">
            9.7.8.24.11. Data Movement and Conversion Instructions: cp.async.bulk.prefetch.tensor
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk-commit-group">
            9.7.8.24.12. Data Movement and Conversion Instructions: cp.async.bulk.commit_group
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk-wait-group">
            9.7.8.24.13. Data Movement and Conversion Instructions: cp.async.bulk.wait_group
           </a>
          </li>
         </ul>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-tensormap-replace">
          9.7.8.25. Data Movement and Conversion Instructions: tensormap.replace
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texture-instructions">
        9.7.9. Texture Instructions
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texturing-modes">
          9.7.9.1. Texturing Modes
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mipmaps">
          9.7.9.2. Mipmaps
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texture-instructions-tex">
          9.7.9.3. Texture Instructions: tex
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texture-instructions-tld4">
          9.7.9.4. Texture Instructions: tld4
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texture-instructions-txq">
          9.7.9.5. Texture Instructions: txq
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texture-instructions-istypep">
          9.7.9.6. Texture Instructions: istypep
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#surface-instructions">
        9.7.10. Surface Instructions
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#surface-instructions-suld">
          9.7.10.1. Surface Instructions: suld
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#surface-instructions-sust">
          9.7.10.2. Surface Instructions: sust
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#surface-instructions-sured">
          9.7.10.3. Surface Instructions: sured
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#surface-instructions-suq">
          9.7.10.4. Surface Instructions: suq
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-instructions">
        9.7.11. Control Flow Instructions
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-instructions-curly-braces">
          9.7.11.1. Control Flow Instructions: {}
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-instructions-at">
          9.7.11.2. Control Flow Instructions: @
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-instructions-bra">
          9.7.11.3. Control Flow Instructions: bra
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-instructions-brx-idx">
          9.7.11.4. Control Flow Instructions: brx.idx
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-instructions-call">
          9.7.11.5. Control Flow Instructions: call
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-instructions-ret">
          9.7.11.6. Control Flow Instructions: ret
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-instructions-exit">
          9.7.11.7. Control Flow Instructions: exit
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions">
        9.7.12. Parallel Synchronization and Communication Instructions
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-bar-barrier">
          9.7.12.1. Parallel Synchronization and Communication Instructions: bar, barrier
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-bar-warp-sync">
          9.7.12.2. Parallel Synchronization and Communication Instructions: bar.warp.sync
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-barrier-cluster">
          9.7.12.3. Parallel Synchronization and Communication Instructions: barrier.cluster
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-membar-fence">
          9.7.12.4. Parallel Synchronization and Communication Instructions: membar/fence
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-atom">
          9.7.12.5. Parallel Synchronization and Communication Instructions: atom
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-red">
          9.7.12.6. Parallel Synchronization and Communication Instructions: red
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-red-async">
          9.7.12.7. Parallel Synchronization and Communication Instructions: red.async
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-vote-deprecated">
          9.7.12.8. Parallel Synchronization and Communication Instructions: vote (deprecated)
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-vote-sync">
          9.7.12.9. Parallel Synchronization and Communication Instructions: vote.sync
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-match-sync">
          9.7.12.10. Parallel Synchronization and Communication Instructions: match.sync
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-activemask">
          9.7.12.11. Parallel Synchronization and Communication Instructions: activemask
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-redux-sync">
          9.7.12.12. Parallel Synchronization and Communication Instructions: redux.sync
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-griddepcontrol">
          9.7.12.13. Parallel Synchronization and Communication Instructions: griddepcontrol
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-elect-sync">
          9.7.12.14. Parallel Synchronization and Communication Instructions: elect.sync
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier">
          9.7.12.15. Parallel Synchronization and Communication Instructions: mbarrier
         </a>
         <ul>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#size-and-alignment-of-mbarrier-object">
            9.7.12.15.1. Size and alignment of mbarrier object
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#contents-of-the-mbarrier-object">
            9.7.12.15.2. Contents of the mbarrier object
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#lifecycle-of-the-mbarrier-object">
            9.7.12.15.3. Lifecycle of the mbarrier object
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#phase-of-the-mbarrier-object">
            9.7.12.15.4. Phase of the mbarrier object
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tracking-asynchronous-operations-by-the-mbarrier-object">
            9.7.12.15.5. Tracking asynchronous operations by the mbarrier object
           </a>
           <ul>
            <li class="toctree-l6">
             <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#expect-tx-operation">
              9.7.12.15.5.1. expect-tx operation
             </a>
            </li>
            <li class="toctree-l6">
             <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#complete-tx-operation">
              9.7.12.15.5.2. complete-tx operation
             </a>
            </li>
           </ul>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#phase-completion-of-the-mbarrier-object">
            9.7.12.15.6. Phase Completion of the mbarrier object
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#arrive-on-operation-on-mbarrier-object">
            9.7.12.15.7. Arrive-on operation on mbarrier object
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mbarrier-support-with-shared-memory">
            9.7.12.15.8. mbarrier support with shared memory
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-init">
            9.7.12.15.9. Parallel Synchronization and Communication Instructions: mbarrier.init
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-inval">
            9.7.12.15.10. Parallel Synchronization and Communication Instructions: mbarrier.inval
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-expect-tx">
            9.7.12.15.11. Parallel Synchronization and Communication Instructions: mbarrier.expect_tx
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-complete-tx">
            9.7.12.15.12. Parallel Synchronization and Communication Instructions: mbarrier.complete_tx
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-arrive">
            9.7.12.15.13. Parallel Synchronization and Communication Instructions: mbarrier.arrive
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-arrive-drop">
            9.7.12.15.14. Parallel Synchronization and Communication Instructions: mbarrier.arrive_drop
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-cp-async-mbarrier-arrive">
            9.7.12.15.15. Parallel Synchronization and Communication Instructions: cp.async.mbarrier.arrive
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-test-wait-mbarrier-try-wait">
            9.7.12.15.16. Parallel Synchronization and Communication Instructions: mbarrier.test_wait/mbarrier.try_wait
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-pending-count">
            9.7.12.15.17. Parallel Synchronization and Communication Instructions: mbarrier.pending_count
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-tensormap-cp-fenceproxy">
            9.7.12.15.18. Parallel Synchronization and Communication Instructions: tensormap.cp_fenceproxy
           </a>
          </li>
         </ul>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-multiply-accumulate-instructions">
        9.7.13. Warp Level Matrix Multiply-Accumulate Instructions
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-shape">
          9.7.13.1. Matrix Shape
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-data-types">
          9.7.13.2. Matrix Data-types
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-multiply-accumulate-operation-using-wmma-instructions">
          9.7.13.3. Matrix multiply-accumulate operation using wmma instructions
         </a>
         <ul>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-wmma">
            9.7.13.3.1. Matrix Fragments for WMMA
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-storage-for-wmma">
            9.7.13.3.2. Matrix Storage for WMMA
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-load-instruction-wmma-load">
            9.7.13.3.3. Warp-level Matrix Load Instruction: wmma.load
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-store-instruction-wmma-store">
            9.7.13.3.4. Warp-level Matrix Store Instruction: wmma.store
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-multiply-and-accumulate-instruction-wmma-mma">
            9.7.13.3.5. Warp-level Matrix Multiply-and-Accumulate Instruction: wmma.mma
           </a>
          </li>
         </ul>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-multiply-accumulate-operation-using-mma-instruction">
          9.7.13.4. Matrix multiply-accumulate operation using mma instruction
         </a>
         <ul>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-mma-m8n8k4-with-f16-floating-point-type">
            9.7.13.4.1. Matrix Fragments for mma.m8n8k4 with .f16 floating point type
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-mma-m8n8k4-with-f64-floating-point-type">
            9.7.13.4.2. Matrix Fragments for mma.m8n8k4 with .f64 floating point type
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-mma-m8n8k16">
            9.7.13.4.3. Matrix Fragments for mma.m8n8k16
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-mma-m8n8k32">
            9.7.13.4.4. Matrix Fragments for mma.m8n8k32
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-mma-m8n8k128">
            9.7.13.4.5. Matrix Fragments for mma.m8n8k128
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-mma-m16n8k4">
            9.7.13.4.6. Matrix Fragments for mma.m16n8k4
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-mma-m16n8k8">
            9.7.13.4.7. Matrix Fragments for mma.m16n8k8
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-mma-m16n8k16-with-floating-point-type">
            9.7.13.4.8. Matrix Fragments for mma.m16n8k16 with floating point type
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-mma-m16n8k16-with-integer-type">
            9.7.13.4.9. Matrix Fragments for mma.m16n8k16 with integer type
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-mma-m16n8k32">
            9.7.13.4.10. Matrix Fragments for mma.m16n8k32
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-mma-m16n8k64">
            9.7.13.4.11. Matrix Fragments for mma.m16n8k64
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-mma-m16n8k128">
            9.7.13.4.12. Matrix Fragments for mma.m16n8k128
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-mma-m16n8k256">
            9.7.13.4.13. Matrix Fragments for mma.m16n8k256
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#multiply-and-accumulate-instruction-mma">
            9.7.13.4.14. Multiply-and-Accumulate Instruction: mma
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-load-instruction-ldmatrix">
            9.7.13.4.15. Warp-level matrix load instruction: ldmatrix
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-store-instruction-stmatrix">
            9.7.13.4.16. Warp-level matrix store instruction: stmatrix
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-transpose-instruction-movmatrix">
            9.7.13.4.17. Warp-level matrix transpose instruction: movmatrix
           </a>
          </li>
         </ul>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-multiply-accumulate-operation-using-mma-sp-instruction-with-sparse-matrix-a">
          9.7.13.5. Matrix multiply-accumulate operation using mma.sp instruction with sparse matrix A
         </a>
         <ul>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-matrix-storage">
            9.7.13.5.1. Sparse matrix storage
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-multiply-accumulate-operation-with-sparse-matrix-a">
            9.7.13.5.2. Matrix fragments for multiply-accumulate operation with sparse matrix A
           </a>
           <ul>
            <li class="toctree-l6">
             <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-sparse-mma-m16n8k16-with-f16-and-bf16-types">
              9.7.13.5.2.1. Matrix Fragments for sparse mma.m16n8k16 with .f16 and .bf16 types
             </a>
            </li>
            <li class="toctree-l6">
             <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-sparse-mma-m16n8k32-with-f16-and-bf16-types">
              9.7.13.5.2.2. Matrix Fragments for sparse mma.m16n8k32 with .f16 and .bf16 types
             </a>
            </li>
            <li class="toctree-l6">
             <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-sparse-mma-m16n8k16-with-tf32-floating-point-type">
              9.7.13.5.2.3. Matrix Fragments for sparse mma.m16n8k16 with .tf32 floating point type
             </a>
            </li>
            <li class="toctree-l6">
             <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-sparse-mma-m16n8k8-with-tf32-floating-point-type">
              9.7.13.5.2.4. Matrix Fragments for sparse mma.m16n8k8 with .tf32 floating point type
             </a>
            </li>
            <li class="toctree-l6">
             <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-sparse-mma-m16n8k32-with-u8-s8-integer-type">
              9.7.13.5.2.5. Matrix Fragments for sparse mma.m16n8k32 with .u8/.s8 integer type
             </a>
            </li>
            <li class="toctree-l6">
             <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-sparse-mma-m16n8k64-with-u8-s8-e4m3-e5m2-type">
              9.7.13.5.2.6. Matrix Fragments for sparse mma.m16n8k64 with .u8/.s8/.e4m3/.e5m2 type
             </a>
            </li>
            <li class="toctree-l6">
             <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-sparse-mma-m16n8k64-with-u4-s4-integer-type">
              9.7.13.5.2.7. Matrix Fragments for sparse mma.m16n8k64 with .u4/.s4 integer type
             </a>
            </li>
            <li class="toctree-l6">
             <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-sparse-mma-m16n8k128-with-u4-s4-integer-type">
              9.7.13.5.2.8. Matrix Fragments for sparse mma.m16n8k128 with .u4/.s4 integer type
             </a>
            </li>
           </ul>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#multiply-and-accumulate-instruction-mma-sp-mma-sp-ordered-metadata">
            9.7.13.5.3. Multiply-and-Accumulate Instruction: mma.sp/mma.sp::ordered_metadata
           </a>
          </li>
         </ul>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-multiply-accumulate-instructions">
        9.7.14. Asynchronous Warpgroup Level Matrix Multiply-Accumulate Instructions
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warpgroup">
          9.7.14.1. Warpgroup
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shape">
          9.7.14.2. Matrix Shape
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-data-types">
          9.7.14.3. Matrix Data-types
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-async-proxy">
          9.7.14.4. Async Proxy
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-multiply-accumulate-operation-using-wgmma-mma-async-instruction">
          9.7.14.5. Asynchronous Warpgroup Level Matrix Multiply-Accumulate Operation using wgmma.mma_async instruction
         </a>
         <ul>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#register-fragments-and-shared-memory-matrix-layouts">
            9.7.14.5.1. Register Fragments and Shared Memory Matrix Layouts
           </a>
           <ul>
            <li class="toctree-l6">
             <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#register-fragments">
              9.7.14.5.1.1. Register Fragments
             </a>
             <ul>
              <li class="toctree-l7">
               <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-wgmma-mma-async-m64nnk16">
                9.7.14.5.1.1.1. Matrix Fragments for wgmma.mma_async.m64nNk16
               </a>
              </li>
              <li class="toctree-l7">
               <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-wgmma-mma-async-m64nnk8">
                9.7.14.5.1.1.2. Matrix Fragments for wgmma.mma_async.m64nNk8
               </a>
              </li>
              <li class="toctree-l7">
               <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-wgmma-mma-async-m64nnk32">
                9.7.14.5.1.1.3. Matrix Fragments for wgmma.mma_async.m64nNk32
               </a>
              </li>
              <li class="toctree-l7">
               <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-wgmma-mma-async-m64nnk256">
                9.7.14.5.1.1.4. Matrix Fragments for wgmma.mma_async.m64nNk256
               </a>
              </li>
             </ul>
            </li>
            <li class="toctree-l6">
             <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#shared-memory-matrix-layout">
              9.7.14.5.1.2. Shared Memory Matrix Layout
             </a>
             <ul>
              <li class="toctree-l7">
               <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#shared-memory-layout-for-wgmma-mma-async-m64nnk16">
                9.7.14.5.1.2.1. Shared Memory Layout for wgmma.mma_async.m64nNk16
               </a>
              </li>
              <li class="toctree-l7">
               <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#shared-memory-layout-for-wgmma-mma-async-m64nnk8">
                9.7.14.5.1.2.2. Shared Memory Layout for wgmma.mma_async.m64nNk8
               </a>
              </li>
              <li class="toctree-l7">
               <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#shared-memory-layout-for-wgmma-mma-async-m64nnk32">
                9.7.14.5.1.2.3. Shared Memory Layout for wgmma.mma_async.m64nNk32
               </a>
              </li>
              <li class="toctree-l7">
               <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#shared-memory-layout-for-wgmma-mma-async-m64nnk256">
                9.7.14.5.1.2.4. Shared Memory Layout for wgmma.mma_async.m64nNk256
               </a>
              </li>
              <li class="toctree-l7">
               <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#strides">
                9.7.14.5.1.2.5. Strides
               </a>
              </li>
              <li class="toctree-l7">
               <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shared-memory-layout-swizzling-modes">
                9.7.14.5.1.2.6. Swizzling Modes
               </a>
              </li>
              <li class="toctree-l7">
               <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-descriptor-format">
                9.7.14.5.1.2.7. Matrix Descriptor Format
               </a>
              </li>
             </ul>
            </li>
           </ul>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-multiply-and-accumulate-instruction-wgmma-mma-async">
            9.7.14.5.2. Asynchronous Multiply-and-Accumulate Instruction: wgmma.mma_async
           </a>
          </li>
         </ul>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-multiply-and-accumulate-operation-using-wgmma-mma-async-sp-instruction">
          9.7.14.6. Asynchronous Warpgroup Level Multiply-and-Accumulate Operation using wgmma.mma_async.sp instruction
         </a>
         <ul>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-sparse-matrix-storage">
            9.7.14.6.1. Sparse matrix storage
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-warpgroup-level-multiply-accumulate-operation-with-sparse-matrix-a">
            9.7.14.6.2. Matrix fragments for warpgroup-level multiply-accumulate operation with sparse matrix A
           </a>
           <ul>
            <li class="toctree-l6">
             <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-sparse-wgmma-mma-async-m64nnk32">
              9.7.14.6.2.1. Matrix Fragments for sparse wgmma.mma_async.m64nNk32
             </a>
            </li>
            <li class="toctree-l6">
             <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-sparse-wgmma-mma-async-m64nnk16">
              9.7.14.6.2.2. Matrix Fragments for sparse wgmma.mma_async.m64nNk16
             </a>
            </li>
            <li class="toctree-l6">
             <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-sparse-wgmma-mma-async-m64nnk64">
              9.7.14.6.2.3. Matrix Fragments for sparse wgmma.mma_async.m64nNk64
             </a>
            </li>
           </ul>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-shared-memory-layout-for-sparse-wgmma">
            9.7.14.6.3. Shared Memory Matrix Layout
           </a>
           <ul>
            <li class="toctree-l6">
             <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#shared-memory-layout-for-wgmma-mma-async-sp-m64nnk32">
              9.7.14.6.3.1. Shared Memory Layout for wgmma.mma_async.sp.m64nNk32
             </a>
            </li>
            <li class="toctree-l6">
             <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#shared-memory-layout-for-wgmma-mma-async-sp-m64nnk16">
              9.7.14.6.3.2. Shared Memory Layout for wgmma.mma_async.sp.m64nNk16
             </a>
            </li>
            <li class="toctree-l6">
             <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#shared-memory-layout-for-wgmma-mma-async-sp-m64nnk64">
              9.7.14.6.3.3. Shared Memory Layout for wgmma.mma_async.sp.m64nNk64
             </a>
            </li>
           </ul>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-multiply-and-accumulate-instruction-wgmma-mma-async-sp">
            9.7.14.6.4. Asynchronous Multiply-and-Accumulate Instruction: wgmma.mma_async.sp
           </a>
          </li>
         </ul>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-wgmma-proxy-operations">
          9.7.14.7. Asynchronous wgmma Proxy Operations
         </a>
         <ul>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-multiply-and-accumulate-instruction-wgmma-fence">
            9.7.14.7.1. Asynchronous Multiply-and-Accumulate Instruction: wgmma.fence
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-multiply-and-accumulate-instruction-wgmma-commit-group">
            9.7.14.7.2. Asynchronous Multiply-and-Accumulate Instruction: wgmma.commit_group
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-multiply-and-accumulate-instruction-wgmma-wait-group">
            9.7.14.7.3. Asynchronous Multiply-and-Accumulate Instruction: wgmma.wait_group
           </a>
          </li>
         </ul>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#stack-manipulation-instructions">
        9.7.15. Stack Manipulation Instructions
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#stack-manipulation-instructions-stacksave">
          9.7.15.1. Stack Manipulation Instructions: stacksave
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#stack-manipulation-instructions-stackrestore">
          9.7.15.2. Stack Manipulation Instructions: stackrestore
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#stack-manipulation-instructions-alloca">
          9.7.15.3. Stack Manipulation Instructions: alloca
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#video-instructions">
        9.7.16. Video Instructions
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#scalar-video-instructions">
          9.7.16.1. Scalar Video Instructions
         </a>
         <ul>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#scalar-video-instructions-vadd-vsub-vabsdiff-vmin-vmax">
            9.7.16.1.1. Scalar Video Instructions: vadd, vsub, vabsdiff, vmin, vmax
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#scalar-video-instructions-vshl-vshr">
            9.7.16.1.2. Scalar Video Instructions: vshl, vshr
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#scalar-video-instructions-vmad">
            9.7.16.1.3. Scalar Video Instructions: vmad
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#scalar-video-instructions-vset">
            9.7.16.1.4. Scalar Video Instructions: vset
           </a>
          </li>
         </ul>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#simd-video-instructions">
          9.7.16.2. SIMD Video Instructions
         </a>
         <ul>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#simd-video-instructions-vadd2-vsub2-vavrg2-vabsdiff2-vmin2-vmax2">
            9.7.16.2.1. SIMD Video Instructions: vadd2, vsub2, vavrg2, vabsdiff2, vmin2, vmax2
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#simd-video-instructions-vset2">
            9.7.16.2.2. SIMD Video Instructions: vset2
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#simd-video-instructions-vadd4-vsub4-vavrg4-vabsdiff4-vmin4-vmax4">
            9.7.16.2.3. SIMD Video Instructions: vadd4, vsub4, vavrg4, vabsdiff4, vmin4, vmax4
           </a>
          </li>
          <li class="toctree-l5">
           <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#simd-video-instructions-vset4">
            9.7.16.2.4. SIMD Video Instructions: vset4
           </a>
          </li>
         </ul>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#miscellaneous-instructions">
        9.7.17. Miscellaneous Instructions
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#miscellaneous-instructions-brkpt">
          9.7.17.1. Miscellaneous Instructions: brkpt
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#miscellaneous-instructions-nanosleep">
          9.7.17.2. Miscellaneous Instructions: nanosleep
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#miscellaneous-instructions-pmevent">
          9.7.17.3. Miscellaneous Instructions: pmevent
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#miscellaneous-instructions-trap">
          9.7.17.4. Miscellaneous Instructions: trap
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#miscellaneous-instructions-setmaxnreg">
          9.7.17.5. Miscellaneous Instructions: setmaxnreg
         </a>
        </li>
       </ul>
      </li>
     </ul>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers">
    10. Special Registers
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-tid">
      10.1. Special Registers: %tid
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-ntid">
      10.2. Special Registers: %ntid
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-laneid">
      10.3. Special Registers: %laneid
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-warpid">
      10.4. Special Registers: %warpid
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-nwarpid">
      10.5. Special Registers: %nwarpid
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-ctaid">
      10.6. Special Registers: %ctaid
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-nctaid">
      10.7. Special Registers: %nctaid
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-smid">
      10.8. Special Registers: %smid
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-nsmid">
      10.9. Special Registers: %nsmid
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-gridid">
      10.10. Special Registers: %gridid
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-is-explicit-cluster">
      10.11. Special Registers: %is_explicit_cluster
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-clusterid">
      10.12. Special Registers: %clusterid
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-nclusterid">
      10.13. Special Registers: %nclusterid
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-cluster-ctaid">
      10.14. Special Registers: %cluster_ctaid
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-cluster-nctaid">
      10.15. Special Registers: %cluster_nctaid
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-cluster-ctarank">
      10.16. Special Registers: %cluster_ctarank
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-cluster-nctarank">
      10.17. Special Registers: %cluster_nctarank
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-lanemask-eq">
      10.18. Special Registers: %lanemask_eq
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-lanemask-le">
      10.19. Special Registers: %lanemask_le
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-lanemask-lt">
      10.20. Special Registers: %lanemask_lt
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-lanemask-ge">
      10.21. Special Registers: %lanemask_ge
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-lanemask-gt">
      10.22. Special Registers: %lanemask_gt
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-clock-clock-hi">
      10.23. Special Registers: %clock, %clock_hi
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-clock64">
      10.24. Special Registers: %clock64
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-pm0-pm7">
      10.25. Special Registers: %pm0..%pm7
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-pm0-64-pm7-64">
      10.26. Special Registers: %pm0_64..%pm7_64
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-envreg-32">
      10.27. Special Registers: %envreg&lt;32&gt;
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-globaltimer-globaltimer-lo-globaltimer-hi">
      10.28. Special Registers: %globaltimer, %globaltimer_lo, %globaltimer_hi
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-reserved-smem-offset-begin-reserved-smem-offset-end-reserved-smem-offset-cap-reserved-smem-offset-2">
      10.29. Special Registers: %reserved_smem_offset_begin, %reserved_smem_offset_end, %reserved_smem_offset_cap, %reserved_smem_offset_&lt;2&gt;
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-total-smem-size">
      10.30. Special Registers: %total_smem_size
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-aggr-smem-size">
      10.31. Special Registers: %aggr_smem_size
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-dynamic-smem-size">
      10.32. Special Registers: %dynamic_smem_size
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-current-graph-exec">
      10.33. Special Registers: %current_graph_exec
     </a>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#directives">
    11. Directives
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#ptx-module-directives">
      11.1. PTX Module Directives
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#ptx-module-directives-version">
        11.1.1. PTX Module Directives: .version
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#ptx-module-directives-target">
        11.1.2. PTX Module Directives: .target
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#ptx-module-directives-address-size">
        11.1.3. PTX Module Directives: .address_size
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#specifying-kernel-entry-points-and-functions">
      11.2. Specifying Kernel Entry Points and Functions
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-and-function-directives-entry">
        11.2.1. Kernel and Function Directives: .entry
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-and-function-directives-func">
        11.2.2. Kernel and Function Directives: .func
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-and-function-directives-alias">
        11.2.3. Kernel and Function Directives: .alias
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-directives">
      11.3. Control Flow Directives
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-directives-branchtargets">
        11.3.1. Control Flow Directives: .branchtargets
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-directives-calltargets">
        11.3.2. Control Flow Directives: .calltargets
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-directives-callprototype">
        11.3.3. Control Flow Directives: .callprototype
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#performance-tuning-directives">
      11.4. Performance-Tuning Directives
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#performance-tuning-directives-maxnreg">
        11.4.1. Performance-Tuning Directives: .maxnreg
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#performance-tuning-directives-maxntid">
        11.4.2. Performance-Tuning Directives: .maxntid
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#performance-tuning-directives-reqntid">
        11.4.3. Performance-Tuning Directives: .reqntid
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#performance-tuning-directives-minnctapersm">
        11.4.4. Performance-Tuning Directives: .minnctapersm
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#performance-tuning-directives-maxnctapersm-deprecated">
        11.4.5. Performance-Tuning Directives: .maxnctapersm (deprecated)
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#performance-tuning-directives-noreturn">
        11.4.6. Performance-Tuning Directives: .noreturn
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#performance-tuning-directives-pragma">
        11.4.7. Performance-Tuning Directives: .pragma
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#debugging-directives">
      11.5. Debugging Directives
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#debugging-directives-dwarf">
        11.5.1. Debugging Directives: @@dwarf
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#debugging-directives-section">
        11.5.2. Debugging Directives: .section
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#debugging-directives-file">
        11.5.3. Debugging Directives: .file
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#debugging-directives-loc">
        11.5.4. Debugging Directives: .loc
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#linking-directives">
      11.6. Linking Directives
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#linking-directives-extern">
        11.6.1. Linking Directives: .extern
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#linking-directives-visible">
        11.6.2. Linking Directives: .visible
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#linking-directives-weak">
        11.6.3. Linking Directives: .weak
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#linking-directives-common">
        11.6.4. Linking Directives: .common
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#cluster-dimension-directives">
      11.7. Cluster Dimension Directives
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#cluster-dimension-directives-reqnctapercluster">
        11.7.1. Cluster Dimension Directives: .reqnctapercluster
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#cluster-dimension-directives-explicitcluster">
        11.7.2. Cluster Dimension Directives: .explicitcluster
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#cluster-dimension-directives-maxclusterrank">
        11.7.3. Cluster Dimension Directives: .maxclusterrank
       </a>
      </li>
     </ul>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#release-notes">
    12. Release Notes
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-8-5">
      12.1. Changes in PTX ISA Version 8.5
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-8-4">
      12.2. Changes in PTX ISA Version 8.4
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-8-3">
      12.3. Changes in PTX ISA Version 8.3
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-8-2">
      12.4. Changes in PTX ISA Version 8.2
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-8-1">
      12.5. Changes in PTX ISA Version 8.1
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-8-0">
      12.6. Changes in PTX ISA Version 8.0
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-7-8">
      12.7. Changes in PTX ISA Version 7.8
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-7-7">
      12.8. Changes in PTX ISA Version 7.7
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-7-6">
      12.9. Changes in PTX ISA Version 7.6
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-7-5">
      12.10. Changes in PTX ISA Version 7.5
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-7-4">
      12.11. Changes in PTX ISA Version 7.4
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-7-3">
      12.12. Changes in PTX ISA Version 7.3
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-7-2">
      12.13. Changes in PTX ISA Version 7.2
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-7-1">
      12.14. Changes in PTX ISA Version 7.1
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-7-0">
      12.15. Changes in PTX ISA Version 7.0
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-6-5">
      12.16. Changes in PTX ISA Version 6.5
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-6-4">
      12.17. Changes in PTX ISA Version 6.4
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-6-3">
      12.18. Changes in PTX ISA Version 6.3
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-6-2">
      12.19. Changes in PTX ISA Version 6.2
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-6-1">
      12.20. Changes in PTX ISA Version 6.1
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-6-0">
      12.21. Changes in PTX ISA Version 6.0
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-5-0">
      12.22. Changes in PTX ISA Version 5.0
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-4-3">
      12.23. Changes in PTX ISA Version 4.3
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-4-2">
      12.24. Changes in PTX ISA Version 4.2
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-4-1">
      12.25. Changes in PTX ISA Version 4.1
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-4-0">
      12.26. Changes in PTX ISA Version 4.0
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-3-2">
      12.27. Changes in PTX ISA Version 3.2
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-3-1">
      12.28. Changes in PTX ISA Version 3.1
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-3-0">
      12.29. Changes in PTX ISA Version 3.0
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-2-3">
      12.30. Changes in PTX ISA Version 2.3
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-2-2">
      12.31. Changes in PTX ISA Version 2.2
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-2-1">
      12.32. Changes in PTX ISA Version 2.1
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-2-0">
      12.33. Changes in PTX ISA Version 2.0
     </a>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#descriptions-of-pragma-strings">
    14. Descriptions of .pragma Strings
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#pragma-strings-nounroll">
      14.1. Pragma Strings: ânounrollâ
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#pragma-strings-used-bytes-mask">
      14.2. Pragma Strings: âused_bytes_maskâ
     </a>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#notices">
    15. Notices
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#notice">
      15.1. Notice
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#opencl">
      15.2. OpenCL
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#trademarks">
      15.3. Trademarks
     </a>
    </li>
   </ul>
  </li>
 </ul>
 <a href="https://docs.nvidia.com/cuda/parallel-thread-execution/contents.html">
  PTX ISA
 </a>
 <ul class="wy-breadcrumbs">
  <li>
   <a class="icon icon-home" href="https://docs.nvidia.com/cuda/index.html">
   </a>
   Â»
  </li>
  <li>
   <span class="section-number">
    1.
   </span>
   Introduction
  </li>
  <li class="wy-breadcrumbs-aside">
   <span>
    v8.5 |
   </span>
   <a class="reference external" href="https://docs.nvidia.com/cuda/pdf/ptx_isa_8.5.pdf">
    PDF
   </a>
   <span>
    |
   </span>
   <a class="reference external" href="https://developer.nvidia.com/cuda-toolkit-archive">
    Archive
   </a>
   <span>
    Â
   </span>
  </li>
 </ul>
 <p class="rubric-h1 rubric">
  Parallel Thread Execution ISA Version 8.5
 </p>
 <p>
  The programming guide to using PTX (Parallel Thread Execution) and ISA (Instruction Set Architecture).
 </p>
 <h1>
  <span class="section-number">
   1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#introduction">
   Introduction
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#introduction" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <p>
  This document describes PTX, a low-level
  parallel thread execution
  virtual machine and instruction
set architecture (ISA). PTX exposes the GPU as a data-parallel computing
  device
  .
 </p>
 <h2>
  <span class="section-number">
   1.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#scalable-data-parallel-computing-using-gpus">
   Scalable Data-Parallel Computing using GPUs
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#scalable-data-parallel-computing-using-gpus" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  Driven by the insatiable market demand for real-time, high-definition 3D graphics, the programmable
GPU has evolved into a highly parallel, multithreaded, many-core processor with tremendous
computational horsepower and very high memory bandwidth. The GPU is especially well-suited to
address problems that can be expressed as data-parallel computations - the same program is executed
on many data elements in parallel - with high arithmetic intensity - the ratio of arithmetic
operations to memory operations. Because the same program is executed for each data element, there
is a lower requirement for sophisticated flow control; and because it is executed on many data
elements and has high arithmetic intensity, the memory access latency can be hidden with
calculations instead of big data caches.
 </p>
 <p>
  Data-parallel processing maps data elements to parallel processing threads. Many applications that
process large data sets can use a data-parallel programming model to speed up the computations. In
3D rendering large sets of pixels and vertices are mapped to parallel threads. Similarly, image and
media processing applications such as post-processing of rendered images, video encoding and
decoding, image scaling, stereo vision, and pattern recognition can map image blocks and pixels to
parallel processing threads. In fact, many algorithms outside the field of image rendering and
processing are accelerated by data-parallel processing, from general signal processing or physics
simulation to computational finance or computational biology.
 </p>
 <p>
  PTX
  defines a virtual machine and ISA for general purpose parallel thread execution. PTX programs
are translated at install time to the target hardware instruction set. The PTX-to-GPU translator
and driver enable NVIDIA GPUs to be used as programmable parallel computers.
 </p>
 <h2>
  <span class="section-number">
   1.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#goals-of-ptx">
   Goals of PTX
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#goals-of-ptx" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  PTX
  provides a stable programming model and instruction set for general purpose parallel
programming. It is designed to be efficient on NVIDIA GPUs supporting the computation features
defined by the NVIDIA Tesla architecture. High level language compilers for languages such as CUDA
and C/C++ generate PTX instructions, which are optimized for and translated to native
target-architecture instructions.
 </p>
 <p>
  The goals for PTX include the following:
 </p>
 <ul class="simple">
  <li>
   <p>
    Provide a stable ISA that spans multiple GPU generations.
   </p>
  </li>
  <li>
   <p>
    Achieve performance in compiled applications comparable to native GPU performance.
   </p>
  </li>
  <li>
   <p>
    Provide a machine-independent ISA for C/C++ and other compilers to target.
   </p>
  </li>
  <li>
   <p>
    Provide a code distribution ISA for application and middleware developers.
   </p>
  </li>
  <li>
   <p>
    Provide a common source-level ISA for optimizing code generators and translators, which map PTX to
specific target machines.
   </p>
  </li>
  <li>
   <p>
    Facilitate hand-coding of libraries, performance kernels, and architecture tests.
   </p>
  </li>
  <li>
   <p>
    Provide a scalable programming model that spans GPU sizes from a single unit to many parallel units.
   </p>
  </li>
 </ul>
 <h2>
  <span class="section-number">
   1.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#ptx-isa-version-8-5">
   PTX ISA Version 8.5
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#ptx-isa-version-8-5" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  PTX ISA version 8.5 introduces the following new features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Adds support for
    <span class="pre">
     mma.sp::ordered_metadata
    </span>
    instruction.
   </p>
  </li>
 </ul>
 <h2>
  <span class="section-number">
   1.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#document-structure">
   Document Structure
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#document-structure" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  The information in this document is organized into the following Chapters:
 </p>
 <ul class="simple">
  <li>
   <p>
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#programming-model">
     Programming Model
    </a>
    outlines the programming model.
   </p>
  </li>
  <li>
   <p>
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#ptx-machine-model">
     PTX Machine Model
    </a>
    gives an overview of the PTX virtual machine model.
   </p>
  </li>
  <li>
   <p>
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#syntax">
     Syntax
    </a>
    describes the basic syntax of the PTX language.
   </p>
  </li>
  <li>
   <p>
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#state-spaces-types-and-variables">
     State Spaces, Types, and Variables
    </a>
    describes
state spaces, types, and variable declarations.
   </p>
  </li>
  <li>
   <p>
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#instruction-operands">
     Instruction Operands
    </a>
    describes instruction operands.
   </p>
  </li>
  <li>
   <p>
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#abstracting-abi">
     Abstracting the ABI
    </a>
    describes the function and call syntax,
calling convention, and PTX support for abstracting the
    Application Binary Interface (ABI)
    .
   </p>
  </li>
  <li>
   <p>
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#instruction-set">
     Instruction Set
    </a>
    describes the instruction set.
   </p>
  </li>
  <li>
   <p>
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers">
     Special Registers
    </a>
    lists special registers.
   </p>
  </li>
  <li>
   <p>
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#directives">
     Directives
    </a>
    lists the assembly directives supported in PTX.
   </p>
  </li>
  <li>
   <p>
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#release-notes">
     Release Notes
    </a>
    provides release notes for PTX ISA versions 2.x and
beyond.
   </p>
  </li>
 </ul>
 <p>
  References
 </p>
 <ul>
  <li>
   <p>
    754-2008 IEEE Standard for Floating-Point Arithmetic. ISBN 978-0-7381-5752-8, 2008.
   </p>
   <p>
    <a class="reference external" href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">
     http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    </a>
   </p>
  </li>
  <li>
   <p>
    The OpenCL Specification, Version: 1.1, Document Revision: 44, June 1, 2011.
   </p>
   <p>
    <a class="reference external" href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf">
     http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf
    </a>
   </p>
  </li>
  <li>
   <p>
    CUDA Programming Guide.
   </p>
   <p>
    <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html">
     https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html
    </a>
   </p>
  </li>
  <li>
   <p>
    CUDA Dynamic Parallelism Programming Guide.
   </p>
   <p>
    <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#cuda-dynamic-parallelism">
     https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#cuda-dynamic-parallelism
    </a>
   </p>
  </li>
  <li>
   <p>
    CUDA Atomicity Requirements.
   </p>
   <p>
    <a class="reference external" href="https://nvidia.github.io/cccl/libcudacxx/extended_api/memory_model.html#atomicity">
     https://nvidia.github.io/cccl/libcudacxx/extended_api/memory_model.html#atomicity
    </a>
   </p>
  </li>
  <li>
   <p>
    PTX Writers Guide to Interoperability.
   </p>
   <p>
    <a class="reference external" href="https://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability/index.html">
     https://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability/index.html
    </a>
   </p>
  </li>
 </ul>
 <h1>
  <span class="section-number">
   2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#programming-model">
   Programming Model
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#programming-model" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <h2>
  <span class="section-number">
   2.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#highly-multithreaded-coprocessor">
   A Highly Multithreaded Coprocessor
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#a-highly-multithreaded-coprocessor" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  The GPU is a compute device capable of executing a very large number of threads in parallel. It
operates as a coprocessor to the main CPU, or host: In other words, data-parallel, compute-intensive
portions of applications running on the host are off-loaded onto the device.
 </p>
 <p>
  More precisely, a portion of an application that is executed many times, but independently on
different data, can be isolated into a kernel function that is executed on the GPU as many different
threads. To that effect, such a function is compiled to the PTX instruction set and the resulting
kernel is translated at install time to the target GPU instruction set.
 </p>
 <h2>
  <span class="section-number">
   2.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#thread-hierarchy">
   Thread Hierarchy
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#thread-hierarchy" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  The batch of threads that executes a kernel is organized as a grid. A grid consists of either
cooperative thread arrays or clusters of cooperative thread arrays as described in this section and
illustrated in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#grid-of-clusters-grid-with-ctas">
   <span class="std std-numref">
    Figure 1
   </span>
  </a>
  and
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#grid-of-clusters-grid-with-clusters">
   <span class="std std-numref">
    Figure 2
   </span>
  </a>
  .
  Cooperative thread arrays (CTAs)
  implement CUDA
thread blocks and clusters implement CUDA thread block clusters.
 </p>
 <h3>
  <span class="section-number">
   2.2.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#cooperative-thread-arrays">
   Cooperative Thread Arrays
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#cooperative-thread-arrays" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The
  Parallel Thread Execution (PTX)
  programming model is explicitly parallel: a PTX program
specifies the execution of a given thread of a parallel thread array. A
  cooperative thread array
  ,
or CTA, is an array of threads that execute a kernel concurrently or in parallel.
 </p>
 <p>
  Threads within a CTA can communicate with each other. To coordinate the communication of the threads
within the CTA, one can specify synchronization points where threads wait until all threads in the
CTA have arrived.
 </p>
 <p>
  Each thread has a unique thread identifier within the CTA. Programs use a data parallel
decomposition to partition inputs, work, and results across the threads of the CTA. Each CTA thread
uses its thread identifier to determine its assigned role, assign specific input and output
positions, compute addresses, and select work to perform. The thread identifier is a three-element
vector
  <span class="pre">
   tid
  </span>
  , (with elements
  <span class="pre">
   tid.x
  </span>
  ,
  <span class="pre">
   tid.y
  </span>
  , and
  <span class="pre">
   tid.z
  </span>
  ) that specifies the threadâs
position within a 1D, 2D, or 3D CTA. Each thread identifier component ranges from zero up to the
number of thread ids in that CTA dimension.
 </p>
 <p>
  Each CTA has a 1D, 2D, or 3D shape specified by a three-element vector
  <span class="pre">
   ntid
  </span>
  (with elements
  <span class="pre">
   ntid.x
  </span>
  ,
  <span class="pre">
   ntid.y
  </span>
  , and
  <span class="pre">
   ntid.z
  </span>
  ). The vector
  <span class="pre">
   ntid
  </span>
  specifies the number of threads in each
CTA dimension.
 </p>
 <p>
  Threads within a CTA execute in SIMT (single-instruction, multiple-thread) fashion in groups called
  warps
  . A
  warp
  is a maximal subset of threads from a single CTA, such that the threads execute
the same instructions at the same time. Threads within a warp are sequentially numbered. The warp
size is a machine-dependent constant. Typically, a warp has 32 threads. Some applications may be
able to maximize performance with knowledge of the warp size, so PTX includes a run-time immediate
constant,
  <span class="pre">
   WARP_SZ
  </span>
  , which may be used in any instruction where an immediate operand is allowed.
 </p>
 <h3>
  <span class="section-number">
   2.2.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#cluster-of-cooperative-thread-arrays">
   Cluster of Cooperative Thread Arrays
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#cluster-of-cooperative-thread-arrays" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Cluster is a group of CTAs that run concurrently or in parallel and can synchronize and communicate
with each other via shared memory. The executing CTA has to make sure that the shared memory of the
peer CTA exists before communicating with it via shared memory and the peer CTA hasnât exited before
completing the shared memory operation.
 </p>
 <p>
  Threads within the different CTAs in a cluster can synchronize and communicate with each other via
shared memory. Cluster-wide barriers can be used to synchronize all the threads within the
cluster. Each CTA in a cluster has a unique CTA identifier within its cluster
(
  cluster_ctaid
  ). Each cluster of CTAs has 1D, 2D or 3D shape specified by the parameter
  cluster_nctaid
  . Each CTA in the cluster also has a unique CTA identifier (
  cluster_ctarank
  )
across all dimensions. The total number of CTAs across all the dimensions in the cluster is
specified by
  cluster_nctarank
  . Threads may read and use these values through predefined, read-only
special registers
  <span class="pre">
   %cluster_ctaid
  </span>
  ,
  <span class="pre">
   %cluster_nctaid
  </span>
  ,
  <span class="pre">
   %cluster_ctarank
  </span>
  ,
  <span class="pre">
   %cluster_nctarank
  </span>
  .
 </p>
 <p>
  Cluster level is applicable only on target architecture
  <span class="pre">
   sm_90
  </span>
  or higher. Specifying cluster
level during launch time is optional. If the user specifies the cluster dimensions at launch time
then it will be treated as explicit cluster launch, otherwise it will be treated as implicit cluster
launch with default dimension 1x1x1. PTX provides read-only special register
  <span class="pre">
   %is_explicit_cluster
  </span>
  to differentiate between explicit and implicit cluster launch.
 </p>
 <h3>
  <span class="section-number">
   2.2.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#grid-of-clusters">
   Grid of Clusters
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#grid-of-clusters" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  There is a maximum number of threads that a CTA can contain and a maximum number of CTAs that a
cluster can contain. However, clusters with CTAs that execute the same kernel can be batched
together into a grid of clusters, so that the total number of threads that can be launched in a
single kernel invocation is very large. This comes at the expense of reduced thread communication
and synchronization, because threads in different clusters cannot communicate and synchronize with
each other.
 </p>
 <p>
  Each cluster has a unique cluster identifier (
  clusterid
  ) within a grid of clusters. Each grid of
clusters has a 1D, 2D , or 3D shape specified by the parameter
  nclusterid
  . Each grid also has a
unique temporal grid identifier (
  gridid
  ). Threads may read and use these values through
predefined, read-only special registers
  <span class="pre">
   %tid
  </span>
  ,
  <span class="pre">
   %ntid
  </span>
  ,
  <span class="pre">
   %clusterid
  </span>
  ,
  <span class="pre">
   %nclusterid
  </span>
  , and
  <span class="pre">
   %gridid
  </span>
  .
 </p>
 <p>
  Each CTA has a unique identifier (
  ctaid
  ) within a grid. Each grid of CTAs has 1D, 2D, or 3D shape
specified by the parameter
  nctaid
  . Thread may use and read these values through predefined,
read-only special registers
  <span class="pre">
   %ctaid
  </span>
  and
  <span class="pre">
   %nctaid
  </span>
  .
 </p>
 <p>
  Each kernel is executed as a batch of threads organized as a grid of clusters consisting of CTAs
where cluster is optional level and is applicable only for target architectures
  <span class="pre">
   sm_90
  </span>
  and
higher.
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#grid-of-clusters-grid-with-ctas">
   <span class="std std-numref">
    Figure 1
   </span>
  </a>
  shows a grid consisting of CTAs and
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#grid-of-clusters-grid-with-clusters">
   <span class="std std-numref">
    Figure 2
   </span>
  </a>
  shows a grid consisting of clusters.
 </p>
 <p>
  Grids may be launched with dependencies between one another - a grid may be a dependent grid and/or
a prerequisite grid. To understand how grid dependencies may be defined, refer to the section on
  CUDA Graphs
  in the
  Cuda Programming Guide
  .
 </p>
 <p>
  <span class="caption-number">
   Figure 1
  </span>
  <span class="caption-text">
   Grid with CTAs
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#grid-of-clusters-grid-with-ctas" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  <span class="caption-number">
   Figure 2
  </span>
  <span class="caption-text">
   Grid with clusters
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#grid-of-clusters-grid-with-clusters" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  A cluster is a set of cooperative thread arrays (CTAs) where a CTA is a set of concurrent threads
that execute the same kernel program. A grid is a set of clusters consisting of CTAs that
execute independently.
 </p>
 <h2>
  <span class="section-number">
   2.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-hierarchy">
   Memory Hierarchy
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-hierarchy" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  PTX threads may access data from multiple state spaces during their execution as illustrated by
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-hierarchy-memory-hierarchy-with-clusters">
   <span class="std std-numref">
    Figure 3
   </span>
  </a>
  where cluster level is introduced from
target architecture
  <span class="pre">
   sm_90
  </span>
  onwards. Each thread has a private local memory. Each thread block
(CTA) has a shared memory visible to all threads of the block and to all active blocks in the
cluster and with the same lifetime as the block. Finally, all threads have access to the same global
memory.
 </p>
 <p>
  There are additional state spaces accessible by all threads: the constant, param, texture, and
surface state spaces.  Constant and texture memory are read-only; surface memory is readable and
writable. The global, constant, param, texture, and surface state spaces are optimized for different
memory usages. For example, texture memory offers different addressing modes as well as data
filtering for specific data formats. Note that texture and surface memory is cached, and within the
same kernel call, the cache is not kept coherent with respect to global memory writes and surface
memory writes, so any texture fetch or surface read to an address that has been written to via a
global or a surface write in the same kernel call returns undefined data. In other words, a thread
can safely read some texture or surface memory location only if this memory location has been
updated by a previous kernel call or memory copy, but not if it has been previously updated by the
same thread or another thread from the same kernel call.
 </p>
 <p>
  The global, constant, and texture state spaces are persistent across kernel launches by the same
application.
 </p>
 <p>
  Both the host and the device maintain their own local memory, referred to as
  host memory
  and
  device memory
  , respectively. The device memory may be mapped and read or written by the host, or,
for more efficient transfer, copied from the host memory through optimized API calls that utilize
the deviceâs high-performance
  Direct Memory Access (DMA)
  engine.
 </p>
 <p>
  <span class="caption-number">
   Figure 3
  </span>
  <span class="caption-text">
   Memory Hierarchy
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-hierarchy-memory-hierarchy-with-clusters" title="Permalink to this image">
   ï
  </a>
 </p>
 <h1>
  <span class="section-number">
   3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#ptx-machine-model">
   PTX Machine Model
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#ptx-machine-model" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <h2>
  <span class="section-number">
   3.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#set-of-simt-multiprocessors">
   A Set of SIMT Multiprocessors
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#a-set-of-simt-multiprocessors" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  The NVIDIA GPU architecture is built around a scalable array of multithreaded
  Streaming
Multiprocessors (SMs)
  . When a host program invokes a kernel grid, the blocks of the grid are
enumerated and distributed to multiprocessors with available execution capacity. The threads of a
thread block execute concurrently on one multiprocessor. As thread blocks terminate, new blocks are
launched on the vacated multiprocessors.
 </p>
 <p>
  A multiprocessor consists of multiple
  Scalar Processor (SP)
  cores, a multithreaded instruction
unit, and on-chip shared memory. The multiprocessor creates, manages, and executes concurrent
threads in hardware with zero scheduling overhead. It implements a single-instruction barrier
synchronization. Fast barrier synchronization together with lightweight thread creation and
zero-overhead thread scheduling efficiently support very fine-grained parallelism, allowing, for
example, a low granularity decomposition of problems by assigning one thread to each data element
(such as a pixel in an image, a voxel in a volume, a cell in a grid-based computation).
 </p>
 <p>
  To manage hundreds of threads running several different programs, the multiprocessor employs an
architecture we call
  SIMT (single-instruction, multiple-thread)
  . The multiprocessor maps each
thread to one scalar processor core, and each scalar thread executes independently with its own
instruction address and register state. The multiprocessor SIMT unit creates, manages, schedules,
and executes threads in groups of parallel threads called
  warps
  . (This term originates from
weaving, the first parallel thread technology.) Individual threads composing a SIMT warp start
together at the same program address but are otherwise free to branch and execute independently.
 </p>
 <p>
  When a multiprocessor is given one or more thread blocks to execute, it splits them into warps that
get scheduled by the SIMT unit. The way a block is split into warps is always the same; each warp
contains threads of consecutive, increasing thread IDs with the first warp containing thread 0.
 </p>
 <p>
  At every instruction issue time, the SIMT unit selects a warp that is ready to execute and issues
the next instruction to the active threads of the warp. A warp executes one common instruction at a
time, so full efficiency is realized when all threads of a warp agree on their execution path. If
threads of a warp diverge via a data-dependent conditional branch, the warp serially executes each
branch path taken, disabling threads that are not on that path, and when all paths complete, the
threads converge back to the same execution path. Branch divergence occurs only within a warp;
different warps execute independently regardless of whether they are executing common or disjointed
code paths.
 </p>
 <p>
  SIMT architecture is akin to SIMD (Single Instruction, Multiple Data) vector organizations in that a
single instruction controls multiple processing elements. A key difference is that SIMD vector
organizations expose the SIMD width to the software, whereas SIMT instructions specify the execution
and branching behavior of a single thread. In contrast with SIMD vector machines, SIMT enables
programmers to write thread-level parallel code for independent, scalar threads, as well as
data-parallel code for coordinated threads. For the purposes of correctness, the programmer can
essentially ignore the SIMT behavior; however, substantial performance improvements can be realized
by taking care that the code seldom requires threads in a warp to diverge. In practice, this is
analogous to the role of cache lines in traditional code: Cache line size can be safely ignored when
designing for correctness but must be considered in the code structure when designing for peak
performance. Vector architectures, on the other hand, require the software to coalesce loads into
vectors and manage divergence manually.
 </p>
 <p>
  How many blocks a multiprocessor can process at once depends on how many registers per thread and
how much shared memory per block are required for a given kernel since the multiprocessorâs
registers and shared memory are split among all the threads of the batch of blocks. If there are not
enough registers or shared memory available per multiprocessor to process at least one block, the
kernel will fail to launch.
 </p>
 <p>
  <span class="caption-number">
   Figure 4
  </span>
  <span class="caption-text">
   Hardware Model
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#set-of-simt-multiprocessors-hardware-model" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  A set of SIMT multiprocessors with on-chip shared memory.
 </p>
 <h2>
  <span class="section-number">
   3.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#independent-thread-scheduling">
   Independent Thread Scheduling
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#independent-thread-scheduling" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  On architectures prior to Volta, warps used a single program counter shared amongst all 32 threads
in the warp together with an active mask specifying the active threads of the warp. As a result,
threads from the same warp in divergent regions or different states of execution cannot signal each
other or exchange data, and algorithms requiring fine-grained sharing of data guarded by locks or
mutexes can easily lead to deadlock, depending on which warp the contending threads come from.
 </p>
 <p>
  Starting with the Volta architecture,
  Independent Thread Scheduling
  allows full concurrency
between threads, regardless of warp. With
  Independent Thread Scheduling
  , the GPU maintains
execution state per thread, including a program counter and call stack, and can yield execution at a
per-thread granularity, either to make better use of execution resources or to allow one thread to
wait for data to be produced by another. A schedule optimizer determines how to group active threads
from the same warp together into SIMT units. This retains the high throughput of SIMT execution as
in prior NVIDIA GPUs, but with much more flexibility: threads can now diverge and reconverge at
sub-warp granularity.
 </p>
 <p>
  Independent Thread Scheduling
  can lead to a rather different set of threads participating in the
executed code than intended if the developer made assumptions about warp-synchronicity of previous
hardware architectures. In particular, any warp-synchronous code (such as synchronization-free,
intra-warp reductions) should be revisited to ensure compatibility with Volta and beyond. See the
section on Compute Capability 7.x in the
  Cuda Programming Guide
  for further details.
 </p>
 <h2>
  <span class="section-number">
   3.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#on-chip-shared-memory">
   On-chip Shared Memory
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#on-chip-shared-memory" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  As illustrated by
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#set-of-simt-multiprocessors-hardware-model">
   <span class="std std-numref">
    Figure 4
   </span>
  </a>
  , each multiprocessor has
on-chip memory of the four following types:
 </p>
 <ul class="simple">
  <li>
   <p>
    One set of local 32-bit
    registers
    per processor,
   </p>
  </li>
  <li>
   <p>
    A parallel data cache or
    shared memory
    that is shared by all scalar processor cores and is where
the shared memory space resides,
   </p>
  </li>
  <li>
   <p>
    A read-only
    constant cache
    that is shared by all scalar processor cores and speeds up reads from
the constant memory space, which is a read-only region of device memory,
   </p>
  </li>
  <li>
   <p>
    A read-only
    texture cache
    that is shared by all scalar processor cores and speeds up reads from
the texture memory space, which is a read-only region of device memory; each multiprocessor
accesses the texture cache via a
    texture unit
    that implements the various addressing modes and
data filtering.
   </p>
  </li>
 </ul>
 <p>
  The local and global memory spaces are read-write regions of device memory.
 </p>
 <h1>
  <span class="section-number">
   4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#syntax">
   Syntax
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#syntax" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <p>
  PTX programs are a collection of text source modules (files). PTX source modules have an
assembly-language style syntax with instruction operation codes and operands. Pseudo-operations
specify symbol and addressing management. The ptxas optimizing backend compiler optimizes and
assembles PTX source modules to produce corresponding binary object files.
 </p>
 <h2>
  <span class="section-number">
   4.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#source-format">
   Source Format
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#source-format" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  Source modules are ASCII text. Lines are separated by the newline character (
  <span class="pre">
   \n
  </span>
  ).
 </p>
 <p>
  All whitespace characters are equivalent; whitespace is ignored except for its use in separating
tokens in the language.
 </p>
 <p>
  The C preprocessor cpp may be used to process PTX source modules. Lines beginning with
  <span class="pre">
   #
  </span>
  are
preprocessor directives. The following are common preprocessor directives:
 </p>
 <p>
  <span class="pre">
   #include
  </span>
  ,
  <span class="pre">
   #define
  </span>
  ,
  <span class="pre">
   #if
  </span>
  ,
  <span class="pre">
   #ifdef
  </span>
  ,
  <span class="pre">
   #else
  </span>
  ,
  <span class="pre">
   #endif
  </span>
  ,
  <span class="pre">
   #line
  </span>
  ,
  <span class="pre">
   #file
  </span>
 </p>
 <p>
  C: A Reference Manual
  by Harbison and Steele provides a good description of the C preprocessor.
 </p>
 <p>
  PTX is case sensitive and uses lowercase for keywords.
 </p>
 <p>
  Each PTX module must begin with a
  <span class="pre">
   .version
  </span>
  directive specifying the PTX language version,
followed by a
  <span class="pre">
   .target
  </span>
  directive specifying the target architecture assumed. See
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#ptx-module-directives">
   PTX Module
Directives
  </a>
  for a more information on these directives.
 </p>
 <h2>
  <span class="section-number">
   4.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#comments">
   Comments
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#comments" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  Comments in PTX follow C/C++ syntax, using non-nested
  <span class="pre">
   /*
  </span>
  and
  <span class="pre">
   */
  </span>
  for comments that may span
multiple lines, and using
  <span class="pre">
   //
  </span>
  to begin a comment that extends up to the next newline character,
which terminates the current line. Comments cannot occur within character constants, string
literals, or within other comments.
 </p>
 <p>
  Comments in PTX are treated as whitespace.
 </p>
 <h2>
  <span class="section-number">
   4.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#statements">
   Statements
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#statements" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  A PTX statement is either a directive or an instruction. Statements begin with an optional label and
end with a semicolon.
 </p>
 <p>
  Examples
 </p>
 <pre>        .reg     .b32 r1, r2;
        .global  .f32  array[N];

start:  mov.b32   r1, %tid.x;
        shl.b32   r1, r1, 2;          // shift thread id by 2 bits
        ld.global.b32 r2, array[r1];  // thread[tid] gets array[tid]
        add.f32   r2, r2, 0.5;        // add 1/2
</pre>
 <h3>
  <span class="section-number">
   4.3.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#directive-statements">
   Directive Statements
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#directive-statements" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Directive keywords begin with a dot, so no conflict is possible with user-defined identifiers. The
directives in PTX are listed in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#directive-statements-ptx-directives">
   <span class="std std-numref">
    Table 1
   </span>
  </a>
  and
described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#state-spaces-types-and-variables">
   State Spaces, Types, and Variables
  </a>
  and
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#directives">
   Directives
  </a>
  .
 </p>
 <table class="table-no-stripes docutils align-default" id="directive-statements-ptx-directives">
  <span class="caption-number">
   Table 1
  </span>
  <span class="caption-text">
   PTX Directives
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#directive-statements-ptx-directives" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .address_size
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .explicitcluster
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .maxnreg
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .section
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .alias
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .extern
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .maxntid
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .shared
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .align
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .file
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .minnctapersm
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .sreg
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .branchtargets
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .func
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .noreturn
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .target
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .callprototype
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .global
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .param
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .tex
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .calltargets
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .loc
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .pragma
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .version
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .common
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .local
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .reg
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .visible
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .const
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .maxclusterrank
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .reqnctapercluster
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .weak
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .entry
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .maxnctapersm
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .reqntid
     </span>
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   4.3.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#instruction-statements">
   Instruction Statements
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#instruction-statements" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Instructions are formed from an instruction opcode followed by a comma-separated list of zero or
more operands, and terminated with a semicolon. Operands may be register variables, constant
expressions, address expressions, or label names. Instructions have an optional guard predicate
which controls conditional execution. The guard predicate follows the optional label and precedes
the opcode, and is written as
  <span class="pre">
   @p
  </span>
  , where
  <span class="pre">
   p
  </span>
  is a predicate register. The guard predicate may
be optionally negated, written as
  <span class="pre">
   @!p
  </span>
  .
 </p>
 <p>
  The destination operand is first, followed by source operands.
 </p>
 <p>
  Instruction keywords are listed in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#instruction-statements-reserved-instruction-keywords">
   <span class="std std-numref">
    Table 2
   </span>
  </a>
  . All instruction keywords are
reserved tokens in PTX.
 </p>
 <table class="table-no-stripes docutils align-default" id="instruction-statements-reserved-instruction-keywords">
  <span class="caption-number">
   Table 2
  </span>
  <span class="caption-text">
   Reserved Instruction Keywords
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#instruction-statements-reserved-instruction-keywords" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      abs
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      discard
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      min
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      shf
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      vadd
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      activemask
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      div
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      mma
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      shfl
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      vadd2
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      add
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      dp2a
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      mov
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      shl
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      vadd4
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      addc
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      dp4a
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      movmatrix
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      shr
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      vavrg2
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      alloca
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      elect
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      mul
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sin
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      vavrg4
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      and
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ex2
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      mul24
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      slct
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      vmad
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      applypriority
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      exit
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      multimem
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sqrt
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      vmax
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      atom
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      fence
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      nanosleep
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      st
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      vmax2
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bar
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      fma
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      neg
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      stackrestore
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      vmax4
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      barrier
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      fns
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      not
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      stacksave
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      vmin
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bfe
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      getctarank
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      or
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      stmatrix
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      vmin2
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bfi
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      griddepcontrol
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      pmevent
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sub
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      vmin4
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bfind
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      isspacep
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      popc
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      subc
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      vote
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bmsk
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      istypep
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      prefetch
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      suld
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      vset
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bra
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ld
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      prefetchu
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      suq
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      vset2
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      brev
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ldmatrix
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      prmt
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sured
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      vset4
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      brkpt
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ldu
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      rcp
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sust
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      vshl
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      brx
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      lg2
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      red
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      szext
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      vshr
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      call
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      lop3
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      redux
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      tanh
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      vsub
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      clz
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      mad
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      rem
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      testp
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      vsub2
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cnot
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      mad24
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ret
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      tex
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      vsub4
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      copysign
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      madc
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      rsqrt
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      tld4
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      wgmma
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cos
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      mapa
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sad
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      trap
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      wmma
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cp
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      match
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      selp
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      txq
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      xor
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      createpolicy
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      max
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      set
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      vabsdiff
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cvt
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      mbarrier
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      setmaxnreg
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      vabsdiff2
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cvta
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      membar
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      setp
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      vabsdiff4
     </span>
    </p>
   </td>
  </tr>
 </table>
 <h2>
  <span class="section-number">
   4.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#identifiers">
   Identifiers
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#identifiers" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  User-defined identifiers follow extended C++ rules: they either start with a letter followed by zero
or more letters, digits, underscore, or dollar characters; or they start with an underscore, dollar,
or percentage character followed by one or more letters, digits, underscore, or dollar characters:
 </p>
 <pre>followsym:   [a-zA-Z0-9_$]
identifier:  [a-zA-Z]{followsym}* | {[_$%]{followsym}+
</pre>
 <p>
  PTX does not specify a maximum length for identifiers and suggests that all implementations support
a minimum length of at least 1024 characters.
 </p>
 <p>
  Many high-level languages such as C and C++ follow similar rules for identifier names, except that
the percentage sign is not allowed. PTX allows the percentage sign as the first character of an
identifier. The percentage sign can be used to avoid name conflicts, e.g., between user-defined
variable names and compiler-generated names.
 </p>
 <p>
  PTX predefines one constant and a small number of special registers that begin with the percentage
sign, listed in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#identifiers-predefined-identifiers">
   <span class="std std-numref">
    Table 3
   </span>
  </a>
  .
 </p>
 <table class="table-no-stripes docutils align-default" id="identifiers-predefined-identifiers">
  <span class="caption-number">
   Table 3
  </span>
  <span class="caption-text">
   Predefined Identifiers
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#identifiers-predefined-identifiers" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      %clock
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      %laneid
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      %lanemask_gt
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      %pm0,
     </span>
     <span class="pre">
      ...,
     </span>
     <span class="pre">
      %pm7
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      %clock64
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      %lanemask_eq
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      %nctaid
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      %smid
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      %ctaid
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      %lanemask_le
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      %ntid
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      %tid
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      %envreg&lt;32&gt;
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      %lanemask_lt
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      %nsmid
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      %warpid
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      %gridid
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      %lanemask_ge
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      %nwarpid
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      WARP_SZ
     </span>
    </p>
   </td>
  </tr>
 </table>
 <h2>
  <span class="section-number">
   4.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#constants">
   Constants
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#constants" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  PTX supports integer and floating-point constants and constant expressions. These constants may be
used in data initialization and as operands to instructions. Type checking rules remain the same for
integer, floating-point, and bit-size types. For predicate-type data and instructions, integer
constants are allowed and are interpreted as in C, i.e., zero values are
  <span class="pre">
   False
  </span>
  and non-zero
values are
  <span class="pre">
   True
  </span>
  .
 </p>
 <h3>
  <span class="section-number">
   4.5.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-constants">
   Integer Constants
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-constants" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Integer constants are 64-bits in size and are either signed or unsigned, i.e., every integer
constant has type
  <span class="pre">
   .s64
  </span>
  or
  <span class="pre">
   .u64
  </span>
  . The signed/unsigned nature of an integer constant is needed
to correctly evaluate constant expressions containing operations such as division and ordered
comparisons, where the behavior of the operation depends on the operand types. When used in an
instruction or data initialization, each integer constant is converted to the appropriate size based
on the data or instruction type at its use.
 </p>
 <p>
  Integer literals may be written in decimal, hexadecimal, octal, or binary notation. The syntax
follows that of C. Integer literals may be followed immediately by the letter
  <span class="pre">
   U
  </span>
  to indicate that
the literal is unsigned.
 </p>
 <pre>hexadecimal literal:  0[xX]{hexdigit}+U?
octal literal:        0{octal digit}+U?
binary literal:       0[bB]{bit}+U?
decimal literal       {nonzero-digit}{digit}*U?
</pre>
 <p>
  Integer literals are non-negative and have a type determined by their magnitude and optional type
suffix as follows: literals are signed (
  <span class="pre">
   .s64
  </span>
  ) unless the value cannot be fully represented in
  <span class="pre">
   .s64
  </span>
  or the unsigned suffix is specified, in which case the literal is unsigned (
  <span class="pre">
   .u64
  </span>
  ).
 </p>
 <p>
  The predefined integer constant
  <span class="pre">
   WARP_SZ
  </span>
  specifies the number of threads per warp for the target
platform; to date, all target architectures have a
  <span class="pre">
   WARP_SZ
  </span>
  value of 32.
 </p>
 <h3>
  <span class="section-number">
   4.5.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-constants">
   Floating-Point Constants
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-constants" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Floating-point constants are represented as 64-bit double-precision values, and all floating-point
constant expressions are evaluated using 64-bit double precision arithmetic. The only exception is
the 32-bit hex notation for expressing an exact single-precision floating-point value; such values
retain their exact 32-bit single-precision value and may not be used in constant expressions. Each
64-bit floating-point constant is converted to the appropriate floating-point size based on the data
or instruction type at its use.
 </p>
 <p>
  Floating-point literals may be written with an optional decimal point and an optional signed
exponent. Unlike C and C++, there is no suffix letter to specify size; literals are always
represented in 64-bit double-precision format.
 </p>
 <p>
  PTX includes a second representation of floating-point constants for specifying the exact machine
representation using a hexadecimal constant. To specify IEEE 754 double-precision floating point
values, the constant begins with
  <span class="pre">
   0d
  </span>
  or
  <span class="pre">
   0D
  </span>
  followed by 16 hex digits. To specify IEEE 754
single-precision floating point values, the constant begins with
  <span class="pre">
   0f
  </span>
  or
  <span class="pre">
   0F
  </span>
  followed by 8 hex
digits.
 </p>
 <pre>0[fF]{hexdigit}{8}      // single-precision floating point
0[dD]{hexdigit}{16}     // double-precision floating point
</pre>
 <p>
  Example
 </p>
 <pre>mov.f32  $f3, 0F3f800000;       //  1.0
</pre>
 <h3>
  <span class="section-number">
   4.5.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#predicate-constants">
   Predicate Constants
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#predicate-constants" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  In PTX, integer constants may be used as predicates. For predicate-type data initializers and
instruction operands, integer constants are interpreted as in C, i.e., zero values are
  <span class="pre">
   False
  </span>
  and
non-zero values are
  <span class="pre">
   True
  </span>
  .
 </p>
 <h3>
  <span class="section-number">
   4.5.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#constant-expressions">
   Constant Expressions
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#constant-expressions" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  In PTX, constant expressions are formed using operators as in C and are evaluated using rules
similar to those in C, but simplified by restricting types and sizes, removing most casts, and
defining full semantics to eliminate cases where expression evaluation in C is implementation
dependent.
 </p>
 <p>
  Constant expressions are formed from constant literals, unary plus and minus, basic arithmetic
operators (addition, subtraction, multiplication, division), comparison operators, the conditional
ternary operator (
  <span class="pre">
   ?:
  </span>
  ), and parentheses. Integer constant expressions also allow unary logical
negation (
  <span class="pre">
   !
  </span>
  ), bitwise complement (
  <span class="pre">
   ~
  </span>
  ), remainder (
  <span class="pre">
   %
  </span>
  ), shift operators (
  <span class="pre">
   &lt;&lt;
  </span>
  and
  <span class="pre">
   &gt;&gt;
  </span>
  ), bit-type operators (
  <span class="pre">
   &amp;
  </span>
  ,
  <span class="pre">
   |
  </span>
  , and
  <span class="pre">
   ^
  </span>
  ), and logical operators (
  <span class="pre">
   &amp;&amp;
  </span>
  ,
  <span class="pre">
   ||
  </span>
  ).
 </p>
 <p>
  Constant expressions in PTX do not support casts between integer and floating-point.
 </p>
 <p>
  Constant expressions are evaluated using the same operator precedence as
in C.
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#constant-expressions-operator-precedence">
   <span class="std std-numref">
    Table 4
   </span>
  </a>
  gives operator precedence and
associativity. Operator precedence is highest for unary operators and decreases with each line in
the chart. Operators on the same line have the same precedence and are evaluated right-to-left for
unary operators and left-to-right for binary operators.
 </p>
 <table class="table-no-stripes docutils align-default" id="constant-expressions-operator-precedence">
  <span class="caption-number">
   Table 4
  </span>
  <span class="caption-text">
   Operator Precedence
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#constant-expressions-operator-precedence" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Kind
    </p>
   </th>
   <th class="head">
    <p>
     Operator Symbols
    </p>
   </th>
   <th class="head">
    <p>
     Operator Names
    </p>
   </th>
   <th class="head">
    <p>
     Associates
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     Primary
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ()
     </span>
    </p>
   </td>
   <td>
    <p>
     parenthesis
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td rowspan="2">
    <p>
     Unary
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      +-
     </span>
     <span class="pre">
      !
     </span>
     <span class="pre">
      ~
     </span>
    </p>
   </td>
   <td>
    <p>
     plus, minus, negation, complement
    </p>
   </td>
   <td>
    <p>
     right
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      (.s64)
     </span>
     <span class="pre">
      (.u64)
     </span>
    </p>
   </td>
   <td>
    <p>
     casts
    </p>
   </td>
   <td>
    <p>
     right
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td rowspan="10">
    <p>
     Binary
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      */
     </span>
     <span class="pre">
      %
     </span>
    </p>
   </td>
   <td>
    <p>
     multiplication, division, remainder
    </p>
   </td>
   <td rowspan="10">
    <p>
     left
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      +-
     </span>
    </p>
   </td>
   <td>
    <p>
     addition, subtraction
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      &gt;&gt;
     </span>
     <span class="pre">
      &lt;&lt;
     </span>
    </p>
   </td>
   <td>
    <p>
     shifts
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      &lt;
     </span>
     <span class="pre">
      &gt;
     </span>
     <span class="pre">
      &lt;=
     </span>
     <span class="pre">
      &gt;=
     </span>
    </p>
   </td>
   <td>
    <p>
     ordered comparisons
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ==
     </span>
     <span class="pre">
      !=
     </span>
    </p>
   </td>
   <td>
    <p>
     equal, not equal
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      &amp;
     </span>
    </p>
   </td>
   <td>
    <p>
     bitwise AND
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ^
     </span>
    </p>
   </td>
   <td>
    <p>
     bitwise XOR
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      |
     </span>
    </p>
   </td>
   <td>
    <p>
     bitwise OR
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      &amp;&amp;
     </span>
    </p>
   </td>
   <td>
    <p>
     logical AND
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ||
     </span>
    </p>
   </td>
   <td>
    <p>
     logical OR
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     Ternary
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ?:
     </span>
    </p>
   </td>
   <td>
    <p>
     conditional
    </p>
   </td>
   <td>
    <p>
     right
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   4.5.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-constant-expression-evaluation">
   Integer Constant Expression Evaluation
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-constant-expression-evaluation" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Integer constant expressions are evaluated at compile time according to a set of rules that
determine the type (signed
  <span class="pre">
   .s64
  </span>
  versus unsigned
  <span class="pre">
   .u64
  </span>
  ) of each sub-expression. These rules
are based on the rules in C, but theyâve been simplified to apply only to 64-bit integers, and
behavior is fully defined in all cases (specifically, for remainder and shift operators).
 </p>
 <ul class="simple">
  <li>
   <p>
    Literals are signed unless unsigned is needed to prevent overflow, or unless the literal uses a
    <span class="pre">
     U
    </span>
    suffix. For example:
   </p>
   <ul>
    <li>
     <p>
      <span class="pre">
       42
      </span>
      ,
      <span class="pre">
       0x1234
      </span>
      ,
      <span class="pre">
       0123
      </span>
      are signed.
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       0xfabc123400000000
      </span>
      ,
      <span class="pre">
       42U
      </span>
      ,
      <span class="pre">
       0x1234U
      </span>
      are unsigned.
     </p>
    </li>
   </ul>
  </li>
  <li>
   <p>
    Unary plus and minus preserve the type of the input operand. For example:
   </p>
   <ul>
    <li>
     <p>
      <span class="pre">
       +123
      </span>
      ,
      <span class="pre">
       -1
      </span>
      ,
      <span class="pre">
       -(-42)
      </span>
      are signed.
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       -1U
      </span>
      ,
      <span class="pre">
       -0xfabc123400000000
      </span>
      are unsigned.
     </p>
    </li>
   </ul>
  </li>
  <li>
   <p>
    Unary logical negation (
    <span class="pre">
     !
    </span>
    ) produces a signed result with value
    <span class="pre">
     0
    </span>
    or
    <span class="pre">
     1
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Unary bitwise complement (
    <span class="pre">
     ~
    </span>
    ) interprets the source operand as unsigned and produces an
unsigned result.
   </p>
  </li>
  <li>
   <p>
    Some binary operators require normalization of source operands. This normalization is known as
    the usual arithmetic conversions
    and simply converts both operands to unsigned type if either
operand is unsigned.
   </p>
  </li>
  <li>
   <p>
    Addition, subtraction, multiplication, and division perform the usual arithmetic conversions and
produce a result with the same type as the converted operands. That is, the operands and result
are unsigned if either source operand is unsigned, and is otherwise signed.
   </p>
  </li>
  <li>
   <p>
    Remainder (
    <span class="pre">
     %
    </span>
    ) interprets the operands as unsigned. Note that this differs from C, which allows
a negative divisor but defines the behavior to be implementation dependent.
   </p>
  </li>
  <li>
   <p>
    Left and right shift interpret the second operand as unsigned and produce a result with the same
type as the first operand. Note that the behavior of right-shift is determined by the type of the
first operand: right shift of a signed value is arithmetic and preserves the sign, and right shift
of an unsigned value is logical and shifts in a zero bit.
   </p>
  </li>
  <li>
   <p>
    AND (
    <span class="pre">
     &amp;
    </span>
    ), OR (
    <span class="pre">
     |
    </span>
    ), and XOR (
    <span class="pre">
     ^
    </span>
    ) perform the usual arithmetic conversions and produce a
result with the same type as the converted operands.
   </p>
  </li>
  <li>
   <p>
    AND_OP (
    <span class="pre">
     &amp;&amp;
    </span>
    ), OR_OP (
    <span class="pre">
     ||
    </span>
    ), Equal (
    <span class="pre">
     ==
    </span>
    ), and Not_Equal (
    <span class="pre">
     !=
    </span>
    ) produce a signed
result. The result value is 0 or 1.
   </p>
  </li>
  <li>
   <p>
    Ordered comparisons (
    <span class="pre">
     &lt;
    </span>
    ,
    <span class="pre">
     &lt;=
    </span>
    ,
    <span class="pre">
     &gt;
    </span>
    ,
    <span class="pre">
     &gt;=
    </span>
    ) perform the usual arithmetic conversions on
source operands and produce a signed result. The result value is
    <span class="pre">
     0
    </span>
    or
    <span class="pre">
     1
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Casting of expressions to signed or unsigned is supported using (
    <span class="pre">
     .s64
    </span>
    ) and (
    <span class="pre">
     .u64
    </span>
    ) casts.
   </p>
  </li>
  <li>
   <p>
    For the conditional operator (
    <span class="pre">
     ?
    </span>
    <span class="pre">
     :
    </span>
    ) , the first operand must be an integer, and the second
and third operands are either both integers or both floating-point. The usual arithmetic
conversions are performed on the second and third operands, and the result type is the same as the
converted type.
   </p>
  </li>
 </ul>
 <h3>
  <span class="section-number">
   4.5.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#summary-of-constant-expression-evaluation-rules">
   Summary of Constant Expression Evaluation Rules
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#summary-of-constant-expression-evaluation-rules" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#summary-of-constant-expression-evaluation-rules-constant-expression-evaluation-rules">
   <span class="std std-numref">
    Table 5
   </span>
  </a>
  contains a summary of the constant expression evaluation rules.
 </p>
 <table class="table-no-stripes docutils align-default" id="summary-of-constant-expression-evaluation-rules-constant-expression-evaluation-rules">
  <span class="caption-number">
   Table 5
  </span>
  <span class="caption-text">
   Constant Expression Evaluation Rules
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#summary-of-constant-expression-evaluation-rules-constant-expression-evaluation-rules" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Kind
    </p>
   </th>
   <th class="head">
    <p>
     Operator
    </p>
   </th>
   <th class="head">
    <p>
     Operand Types
    </p>
   </th>
   <th class="head">
    <p>
     Operand Interpretation
    </p>
   </th>
   <th class="head">
    <p>
     Result Type
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td rowspan="2">
    <p>
     Primary
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ()
     </span>
    </p>
   </td>
   <td>
    <p>
     any type
    </p>
   </td>
   <td>
    <p>
     same as source
    </p>
   </td>
   <td>
    <p>
     same as source
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     constant literal
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .u64
     </span>
     ,
     <span class="pre">
      .s64
     </span>
     , or
     <span class="pre">
      .f64
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td rowspan="3">
    <p>
     Unary
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      +-
     </span>
    </p>
   </td>
   <td>
    <p>
     any type
    </p>
   </td>
   <td>
    <p>
     same as source
    </p>
   </td>
   <td>
    <p>
     same as source
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      !
     </span>
    </p>
   </td>
   <td>
    <p>
     integer
    </p>
   </td>
   <td>
    <p>
     zero or non-zero
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .s64
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ~
     </span>
    </p>
   </td>
   <td>
    <p>
     integer
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .u64
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .u64
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td rowspan="2">
    <p>
     Cast
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      (.u64)
     </span>
    </p>
   </td>
   <td>
    <p>
     integer
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .u64
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .u64
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      (.s64)
     </span>
    </p>
   </td>
   <td>
    <p>
     integer
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .s64
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .s64
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td rowspan="10">
    <p>
     Binary
    </p>
   </td>
   <td rowspan="2">
    <p>
     <span class="pre">
      +-
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      /
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .f64
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .f64
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .f64
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     integer
    </p>
   </td>
   <td>
    <p>
     use usual conversions
    </p>
   </td>
   <td>
    <p>
     converted type
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td rowspan="2">
    <p>
     <span class="pre">
      &lt;
     </span>
     <span class="pre">
      &gt;
     </span>
     <span class="pre">
      &lt;=
     </span>
     <span class="pre">
      &gt;=
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .f64
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .f64
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .s64
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     integer
    </p>
   </td>
   <td>
    <p>
     use usual conversions
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .s64
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td rowspan="2">
    <p>
     <span class="pre">
      ==
     </span>
     <span class="pre">
      !=
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .f64
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .f64
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .s64
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     integer
    </p>
   </td>
   <td>
    <p>
     use usual conversions
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .s64
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      %
     </span>
    </p>
   </td>
   <td>
    <p>
     integer
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .u64
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .s64
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      &gt;&gt;
     </span>
     <span class="pre">
      &lt;&lt;
     </span>
    </p>
   </td>
   <td>
    <p>
     integer
    </p>
   </td>
   <td>
    <p>
     1st unchanged, 2nd is
     <span class="pre">
      .u64
     </span>
    </p>
   </td>
   <td>
    <p>
     same as 1st operand
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      &amp;
     </span>
     <span class="pre">
      |
     </span>
     <span class="pre">
      ^
     </span>
    </p>
   </td>
   <td>
    <p>
     integer
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .u64
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .u64
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      &amp;&amp;
     </span>
     <span class="pre">
      ||
     </span>
    </p>
   </td>
   <td>
    <p>
     integer
    </p>
   </td>
   <td>
    <p>
     zero or non-zero
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .s64
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td rowspan="2">
    <p>
     Ternary
    </p>
   </td>
   <td rowspan="2">
    <p>
     <span class="pre">
      ?:
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      int
     </span>
     <span class="pre">
      ?
     </span>
     <span class="pre">
      .f64
     </span>
     <span class="pre">
      :
     </span>
     <span class="pre">
      .f64
     </span>
    </p>
   </td>
   <td>
    <p>
     same as sources
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .f64
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      int
     </span>
     <span class="pre">
      ?
     </span>
     <span class="pre">
      int
     </span>
     <span class="pre">
      :
     </span>
     <span class="pre">
      int
     </span>
    </p>
   </td>
   <td>
    <p>
     use usual conversions
    </p>
   </td>
   <td>
    <p>
     converted type
    </p>
   </td>
  </tr>
 </table>
 <h1>
  <span class="section-number">
   5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#state-spaces-types-and-variables">
   State Spaces, Types, and Variables
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#state-spaces-types-and-variables" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <p>
  While the specific resources available in a given target GPU will vary, the kinds of resources will
be common across platforms, and these resources are abstracted in PTX through state spaces and data
types.
 </p>
 <h2>
  <span class="section-number">
   5.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#state-spaces">
   State Spaces
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#state-spaces" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  A state space is a storage area with particular characteristics. All variables reside in some state
space. The characteristics of a state space include its size, addressability, access speed, access
rights, and level of sharing between threads.
 </p>
 <p>
  The state spaces defined in PTX are a byproduct of parallel programming and graphics
programming. The list of state spaces is shown in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#state-spaces-state-spaces-tab">
   <span class="std std-numref">
    Table 6
   </span>
  </a>
  ,and
properties of state spaces are shown in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#state-spaces-properties-state-spaces">
   <span class="std std-numref">
    Table 7
   </span>
  </a>
  .
 </p>
 <table class="table-no-stripes docutils align-default" id="state-spaces-state-spaces-tab">
  <span class="caption-number">
   Table 6
  </span>
  <span class="caption-text">
   State Spaces
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#state-spaces-state-spaces-tab" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Name
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .reg
     </span>
    </p>
   </td>
   <td>
    <p>
     Registers, fast.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .sreg
     </span>
    </p>
   </td>
   <td>
    <p>
     Special registers. Read-only; pre-defined; platform-specific.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .const
     </span>
    </p>
   </td>
   <td>
    <p>
     Shared, read-only memory.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .global
     </span>
    </p>
   </td>
   <td>
    <p>
     Global memory, shared by all threads.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .local
     </span>
    </p>
   </td>
   <td>
    <p>
     Local memory, private to each thread.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .param
     </span>
    </p>
   </td>
   <td>
    <p>
     Kernel parameters, defined per-grid; or
    </p>
    <p>
     Function or local parameters, defined per-thread.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .shared
     </span>
    </p>
   </td>
   <td>
    <p>
     Addressable memory, defined per CTA, accessible to all threads in the cluster
throughout the lifetime of the CTA that defines it.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .tex
     </span>
    </p>
   </td>
   <td>
    <p>
     Global texture memory (deprecated).
    </p>
   </td>
  </tr>
 </table>
 <table class="table-no-stripes docutils align-default" id="state-spaces-properties-state-spaces">
  <span class="caption-number">
   Table 7
  </span>
  <span class="caption-text">
   Properties of State Spaces
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#state-spaces-properties-state-spaces" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Name
    </p>
   </th>
   <th class="head">
    <p>
     Addressable
    </p>
   </th>
   <th class="head">
    <p>
     Initializable
    </p>
   </th>
   <th class="head">
    <p>
     Access
    </p>
   </th>
   <th class="head">
    <p>
     Sharing
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .reg
     </span>
    </p>
   </td>
   <td>
    <p>
     No
    </p>
   </td>
   <td>
    <p>
     No
    </p>
   </td>
   <td>
    <p>
     R/W
    </p>
   </td>
   <td>
    <p>
     per-thread
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .sreg
     </span>
    </p>
   </td>
   <td>
    <p>
     No
    </p>
   </td>
   <td>
    <p>
     No
    </p>
   </td>
   <td>
    <p>
     RO
    </p>
   </td>
   <td>
    <p>
     per-CTA
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .const
     </span>
    </p>
   </td>
   <td>
    <p>
     Yes
    </p>
   </td>
   <td>
    <p>
     Yes
     1
    </p>
   </td>
   <td>
    <p>
     RO
    </p>
   </td>
   <td>
    <p>
     per-grid
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .global
     </span>
    </p>
   </td>
   <td>
    <p>
     Yes
    </p>
   </td>
   <td>
    <p>
     Yes
     1
    </p>
   </td>
   <td>
    <p>
     R/W
    </p>
   </td>
   <td>
    <p>
     Context
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .local
     </span>
    </p>
   </td>
   <td>
    <p>
     Yes
    </p>
   </td>
   <td>
    <p>
     No
    </p>
   </td>
   <td>
    <p>
     R/W
    </p>
   </td>
   <td>
    <p>
     per-thread
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .param
     </span>
     (as input to kernel)
    </p>
   </td>
   <td>
    <p>
     Yes
     2
    </p>
   </td>
   <td>
    <p>
     No
    </p>
   </td>
   <td>
    <p>
     RO
    </p>
   </td>
   <td>
    <p>
     per-grid
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .param
     </span>
     (used in functions)
    </p>
   </td>
   <td>
    <p>
     Restricted
     3
    </p>
   </td>
   <td>
    <p>
     No
    </p>
   </td>
   <td>
    <p>
     R/W
    </p>
   </td>
   <td>
    <p>
     per-thread
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .shared
     </span>
    </p>
   </td>
   <td>
    <p>
     Yes
    </p>
   </td>
   <td>
    <p>
     No
    </p>
   </td>
   <td>
    <p>
     R/W
    </p>
   </td>
   <td>
    <p>
     per-cluster
     5
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .tex
     </span>
    </p>
   </td>
   <td>
    <p>
     No
     4
    </p>
   </td>
   <td>
    <p>
     Yes, via driver
    </p>
   </td>
   <td>
    <p>
     RO
    </p>
   </td>
   <td>
    <p>
     Context
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td colspan="5">
    <p>
     Notes:
    </p>
    <p>
     1
     Variables in
     <span class="pre">
      .const
     </span>
     and
     <span class="pre">
      .global
     </span>
     state spaces are initialized to zero by default.
    </p>
    <p>
     2
     Accessible only via the
     <span class="pre">
      ld.param{::entry}
     </span>
     instruction. Address may be taken via
     <span class="pre">
      mov
     </span>
     instruction.
    </p>
    <p>
     3
     Accessible via
     <span class="pre">
      ld.param{::func}
     </span>
     and
     <span class="pre">
      st.param{::func}
     </span>
     instructions. Device function
input and return parameters may have their address taken via
     <span class="pre">
      mov
     </span>
     ; the parameter is then located
on the stack frame and its address is in the
     <span class="pre">
      .local
     </span>
     state space.
    </p>
    <p>
     4
     Accessible only via the
     <span class="pre">
      tex
     </span>
     instruction.
    </p>
    <p>
     5
     Visible to the owning CTA and other active CTAs in the cluster.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   5.1.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#register-state-space">
   Register State Space
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#register-state-space" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Registers (
  <span class="pre">
   .reg
  </span>
  state space) are fast storage locations. The number of registers is limited, and
will vary from platform to platform. When the limit is exceeded, register variables will be spilled
to memory, causing changes in performance. For each architecture, there is a recommended maximum
number of registers to use (see the
  CUDA Programming Guide
  for details).
 </p>
 <p>
  Registers may be typed (signed integer, unsigned integer, floating point, predicate) or
untyped. Register size is restricted; aside from predicate registers which are 1-bit, scalar
registers have a width of 8-, 16-, 32-, 64-, or 128-bits, and vector registers have a width of
16-, 32-, 64-, or 128-bits. The most common use of 8-bit registers is with
  <span class="pre">
   ld
  </span>
  ,
  <span class="pre">
   st
  </span>
  , and
  <span class="pre">
   cvt
  </span>
  instructions, or as elements of vector tuples.
 </p>
 <p>
  Registers differ from the other state spaces in that they are not fully addressable, i.e., it is not
possible to refer to the address of a register. When compiling to use the Application Binary
Interface (ABI), register variables are restricted to function scope and may not be declared at
module scope. When compiling legacy PTX code (ISA versions prior to 3.0) containing module-scoped
  <span class="pre">
   .reg
  </span>
  variables, the compiler silently disables use of the ABI. Registers may have alignment
boundaries required by multi-word loads and stores.
 </p>
 <h3>
  <span class="section-number">
   5.1.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-register-state-space">
   Special Register State Space
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-register-state-space" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The special register (
  <span class="pre">
   .sreg
  </span>
  ) state space holds predefined, platform-specific registers, such as
grid, cluster, CTA, and thread parameters, clock counters, and performance monitoring registers. All
special registers are predefined.
 </p>
 <h3>
  <span class="section-number">
   5.1.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#constant-state-space">
   Constant State Space
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#constant-state-space" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The constant (
  <span class="pre">
   .const
  </span>
  ) state space is a read-only memory initialized by the host. Constant memory
is accessed with a
  <span class="pre">
   ld.const
  </span>
  instruction. Constant memory is restricted in size, currently
limited to 64 KB which can be used to hold statically-sized constant variables. There is an
additional 640 KB of constant memory, organized as ten independent 64 KB regions. The driver may
allocate and initialize constant buffers in these regions and pass pointers to the buffers as kernel
function parameters. Since the ten regions are not contiguous, the driver must ensure that constant
buffers are allocated so that each buffer fits entirely within a 64 KB region and does not span a
region boundary.
 </p>
 <p>
  Statically-sized constant variables have an optional variable initializer; constant variables with
no explicit initializer are initialized to zero by default. Constant buffers allocated by the driver
are initialized by the host, and pointers to such buffers are passed to the kernel as
parameters. See the description of kernel parameter attributes in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-function-parameter-attributes">
   Kernel Function Parameter
Attributes
  </a>
  for more details on passing pointers
to constant buffers as kernel parameters.
 </p>
 <h4>
  <span class="section-number">
   5.1.3.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#banked-constant-state-space-deprecated">
   Banked Constant State Space (deprecated)
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#banked-constant-state-space-deprecated" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  Previous versions of PTX exposed constant memory as a set of eleven 64 KB banks, with explicit bank
numbers required for variable declaration and during access.
 </p>
 <p>
  Prior to PTX ISA version 2.2, the constant memory was organized into fixed size banks. There were
eleven 64 KB banks, and banks were specified using the
  <span class="pre">
   .const[bank]
  </span>
  modifier, where
  bank
  ranged from 0 to 10. If no bank number was given, bank zero was assumed.
 </p>
 <p>
  By convention, bank zero was used for all statically-sized constant variables. The remaining banks
were used to declare
  incomplete
  constant arrays (as in C, for example), where the size is not
known at compile time. For example, the declaration
 </p>
 <pre>.extern .const[2] .b32 const_buffer[];
</pre>
 <p>
  resulted in
  <span class="pre">
   const_buffer
  </span>
  pointing to the start of constant bank two. This pointer could then be
used to access the entire 64 KB constant bank. Multiple incomplete array variables declared in the
same bank were aliased, with each pointing to the start address of the specified constant bank.
 </p>
 <p>
  To access data in contant banks 1 through 10, the bank number was required in the state space of the
load instruction. For example, an incomplete array in bank 2 was accessed as follows:
 </p>
 <pre>.extern .const[2] .b32 const_buffer[];
ld.const[2].b32  %r1, [const_buffer+4]; // load second word
</pre>
 <p>
  In PTX ISA version 2.2, we eliminated explicit banks and replaced the incomplete array
representation of driver-allocated constant buffers with kernel parameter attributes that allow
pointers to constant buffers to be passed as kernel parameters.
 </p>
 <h3>
  <span class="section-number">
   5.1.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#global-state-space">
   Global State Space
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#global-state-space" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The global (
  <span class="pre">
   .global
  </span>
  ) state space is memory that is accessible by all threads in a context. It is
the mechanism by which threads in different CTAs, clusters, and grids can communicate. Use
  <span class="pre">
   ld.global
  </span>
  ,
  <span class="pre">
   st.global
  </span>
  , and
  <span class="pre">
   atom.global
  </span>
  to access global variables.
 </p>
 <p>
  Global variables have an optional variable initializer; global variables with no explicit
initializer are initialized to zero by default.
 </p>
 <h3>
  <span class="section-number">
   5.1.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#local-state-space">
   Local State Space
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#local-state-space" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The local state space (
  <span class="pre">
   .local
  </span>
  ) is private memory for each thread to keep its own data. It is
typically standard memory with cache. The size is limited, as it must be allocated on a per-thread
basis. Use
  <span class="pre">
   ld.local
  </span>
  and
  <span class="pre">
   st.local
  </span>
  to access local variables.
 </p>
 <p>
  When compiling to use the
  Application Binary Interface (ABI)
  ,
  <span class="pre">
   .local
  </span>
  state-space variables
must be declared within function scope and are allocated on the stack. In implementations that do
not support a stack, all local memory variables are stored at fixed addresses, recursive function
calls are not supported, and
  <span class="pre">
   .local
  </span>
  variables may be declared at module scope. When compiling
legacy PTX code (ISA versions prior to 3.0) containing module-scoped
  <span class="pre">
   .local
  </span>
  variables, the
compiler silently disables use of the ABI.
 </p>
 <h3>
  <span class="section-number">
   5.1.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parameter-state-space">
   Parameter State Space
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parameter-state-space" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The parameter (
  <span class="pre">
   .param
  </span>
  ) state space is used (1) to pass input arguments from the host to the
kernel, (2a) to declare formal input and return parameters for device functions called from within
kernel execution, and (2b) to declare locally-scoped byte array variables that serve as function
call arguments, typically for passing large structures by value to a function. Kernel function
parameters differ from device function parameters in terms of access and sharing (read-only versus
read-write, per-kernel versus per-thread). Note that PTX ISA versions 1.x supports only kernel
function parameters in .param space; device function parameters were previously restricted to the
register state space. The use of parameter state space for device function parameters was introduced
in PTX ISA version 2.0 and requires target architecture
  <span class="pre">
   sm_20
  </span>
  or higher. Additional sub-qualifiers
  <span class="pre">
   ::entry
  </span>
  or
  <span class="pre">
   ::func
  </span>
  can be specified on instructions with
  <span class="pre">
   .param
  </span>
  state space to indicate
whether the address refers to kernel function parameter or device function parameter. If no
sub-qualifier is specified with the
  <span class="pre">
   .param
  </span>
  state space, then the default sub-qualifier is specific
to and dependent on the exact instruction. For example,
  <span class="pre">
   st.param
  </span>
  is equivalent to
  <span class="pre">
   st.param::func
  </span>
  whereas
  <span class="pre">
   isspacep.param
  </span>
  is equivalent to
  <span class="pre">
   isspacep.param::entry
  </span>
  . Refer to the instruction
description for more details on default sub-qualifier assumption.
 </p>
 <p class="admonition-title">
  Note
 </p>
 <p>
  The location of parameter space is implementation specific. For example, in some implementations
kernel parameters reside in global memory. No access protection is provided between parameter and
global space in this case. Though the exact location of the kernel parameter space is
implementation specific, the kernel parameter space window is always contained within the global
space window. Similarly, function parameters are mapped to parameter passing registers and/or
stack locations based on the function calling conventions of the
  Application Binary Interface
(ABI)
  . Therefore, PTX code should make no assumptions about the relative locations or ordering
of
  <span class="pre">
   .param
  </span>
  space variables.
 </p>
 <h4>
  <span class="section-number">
   5.1.6.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-function-parameters">
   Kernel Function Parameters
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-function-parameters" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  Each kernel function definition includes an optional list of parameters. These parameters are
addressable, read-only variables declared in the
  <span class="pre">
   .param
  </span>
  state space. Values passed from the host
to the kernel are accessed through these parameter variables using
  <span class="pre">
   ld.param
  </span>
  instructions. The
kernel parameter variables are shared across all CTAs from all clusters within a grid.
 </p>
 <p>
  The address of a kernel parameter may be moved into a register using the
  <span class="pre">
   mov
  </span>
  instruction. The
resulting address is in the
  <span class="pre">
   .param
  </span>
  state space and is accessed using
  <span class="pre">
   ld.param
  </span>
  instructions.
 </p>
 <p>
  Example
 </p>
 <pre>.entry foo ( .param .b32 N, .param .align 8 .b8 buffer[64] )
{
    .reg .u32 %n;
    .reg .f64 %d;

    ld.param.u32 %n, [N];
    ld.param.f64 %d, [buffer];
    ...
</pre>
 <p>
  Example
 </p>
 <pre>.entry bar ( .param .b32 len )
{
    .reg .u32 %ptr, %n;

    mov.u32      %ptr, len;
    ld.param.u32 %n, [%ptr];
    ...
</pre>
 <p>
  Kernel function parameters may represent normal data values, or they may hold addresses to objects
in constant, global, local, or shared state spaces. In the case of pointers, the compiler and
runtime system need information about which parameters are pointers, and to which state space they
point. Kernel parameter attribute directives are used to provide this information at the PTX
level. See
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-function-parameter-attributes">
   Kernel Function Parameter Attributes
  </a>
  for a description of kernel parameter attribute
directives.
 </p>
 <p class="admonition-title">
  Note
 </p>
 <p>
  The current implementation does not allow creation of generic pointers to constant variables
(
  <span class="pre">
   cvta.const
  </span>
  ) in programs that have pointers to constant buffers passed as kernel parameters.
 </p>
 <h4>
  <span class="section-number">
   5.1.6.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-function-parameter-attributes">
   Kernel Function Parameter Attributes
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-function-parameter-attributes" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  Kernel function parameters may be declared with an optional .ptr attribute to indicate that a
parameter is a pointer to memory, and also indicate the state space and alignment of the memory
being pointed to.
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-parameter-attribute-ptr">
   Kernel Parameter Attribute: .ptr
  </a>
  describes the
  <span class="pre">
   .ptr
  </span>
  kernel parameter attribute.
 </p>
 <h4>
  <span class="section-number">
   5.1.6.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-parameter-attribute-ptr">
   Kernel Parameter Attribute: .ptr
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-parameter-attribute-ptr" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  .ptr
 </p>
 <p>
  Kernel parameter alignment attribute.
 </p>
 <p>
  Syntax
 </p>
 <pre>.param .type .ptr .space .align N  varname
.param .type .ptr        .align N  varname

.space = { .const, .global, .local, .shared };
</pre>
 <p>
  Description
 </p>
 <p>
  Used to specify the state space and, optionally, the alignment of memory pointed to by a pointer
type kernel parameter. The alignment value
  N
  , if present, must be a power of two. If no state
space is specified, the pointer is assumed to be a generic address pointing to one of const, global,
local, or shared memory. If no alignment is specified, the memory pointed to is assumed to be
aligned to a 4 byte boundary.
 </p>
 <p>
  Spaces between
  <span class="pre">
   .ptr
  </span>
  ,
  <span class="pre">
   .space
  </span>
  , and
  <span class="pre">
   .align
  </span>
  may be eliminated to improve readability.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <ul class="simple">
  <li>
   <p>
    Introduced in PTX ISA version 2.2.
   </p>
  </li>
  <li>
   <p>
    Support for generic addressing of .const space added in PTX ISA version 3.1.
   </p>
  </li>
 </ul>
 <p>
  Target ISA Notes
 </p>
 <ul class="simple">
  <li>
   <p>
    Supported on all target architectures.
   </p>
  </li>
 </ul>
 <p>
  Examples
 </p>
 <pre>.entry foo ( .param .u32 param1,
             .param .u32 .ptr.global.align 16 param2,
             .param .u32 .ptr.const.align 8 param3,
             .param .u32 .ptr.align 16 param4  // generic address
                                               // pointer
) { .. }
</pre>
 <h4>
  <span class="section-number">
   5.1.6.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#device-function-parameters">
   Device Function Parameters
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#device-function-parameters" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  PTX ISA version 2.0 extended the use of parameter space to device function parameters. The most
common use is for passing objects by value that do not fit within a PTX register, such as C
structures larger than 8 bytes. In this case, a byte array in parameter space is used. Typically,
the caller will declare a locally-scoped
  <span class="pre">
   .param
  </span>
  byte array variable that represents a flattened
C structure or union. This will be passed by value to a callee, which declares a
  <span class="pre">
   .param
  </span>
  formal
parameter having the same size and alignment as the passed argument.
 </p>
 <p>
  Example
 </p>
 <pre>// pass object of type struct { double d; int y; };
.func foo ( .reg .b32 N, .param .align 8 .b8 buffer[12] )
{
    .reg .f64 %d;
    .reg .s32 %y;

    ld.param.f64 %d, [buffer];
    ld.param.s32 %y, [buffer+8];
    ...
}

// code snippet from the caller
// struct { double d; int y; } mystruct; is flattened, passed to foo
    ...
    .reg .f64 dbl;
    .reg .s32 x;
    .param .align 8 .b8 mystruct;
    ...
    st.param.f64 [mystruct+0], dbl;
    st.param.s32 [mystruct+8], x;
    call foo, (4, mystruct);
    ...
</pre>
 <p>
  See the section on function call syntax for more details.
 </p>
 <p>
  Function input parameters may be read via
  <span class="pre">
   ld.param
  </span>
  and function return parameters may be written
using
  <span class="pre">
   st.param
  </span>
  ; it is illegal to write to an input parameter or read from a return parameter.
 </p>
 <p>
  Aside from passing structures by value,
  <span class="pre">
   .param
  </span>
  space is also required whenever a formal
parameter has its address taken within the called function. In PTX, the address of a function input
parameter may be moved into a register using the
  <span class="pre">
   mov
  </span>
  instruction. Note that the parameter will
be copied to the stack if necessary, and so the address will be in the
  <span class="pre">
   .local
  </span>
  state space and is
accessed via
  <span class="pre">
   ld.local
  </span>
  and
  <span class="pre">
   st.local
  </span>
  instructions. It is not possible to use
  <span class="pre">
   mov
  </span>
  to get
the address of or a locally-scoped
  <span class="pre">
   .param
  </span>
  space variable. Starting PTX ISA version 6.0, it is
possible to use
  <span class="pre">
   mov
  </span>
  instruction to get address of return parameter of device function.
 </p>
 <p>
  Example
 </p>
 <pre>// pass array of up to eight floating-point values in buffer
.func foo ( .param .b32 N, .param .b32 buffer[32] )
{
    .reg .u32  %n, %r;
    .reg .f32  %f;
    .reg .pred %p;

    ld.param.u32 %n, [N];
    mov.u32      %r, buffer;  // forces buffer to .local state space
Loop:
    setp.eq.u32  %p, %n, 0;
@%p: bra         Done;
    ld.local.f32 %f, [%r];
    ...
    add.u32      %r, %r, 4;
    sub.u32      %n, %n, 1;
    bra          Loop;
Done:
    ...
}
</pre>
 <h3>
  <span class="section-number">
   5.1.7.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#shared-state-space">
   Shared State Space
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#shared-state-space" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The shared (
  <span class="pre">
   .shared
  </span>
  ) state space is a memory that is owned by an executing CTA and is accessible
to the threads of all the CTAs within a cluster. An address in shared memory can be read and written
by any thread in a CTA cluster.
 </p>
 <p>
  Additional sub-qualifiers
  <span class="pre">
   ::cta
  </span>
  or
  <span class="pre">
   ::cluster
  </span>
  can be specified on instructions with
  <span class="pre">
   .shared
  </span>
  state space to indicate whether the address belongs to the shared memory window of the
executing CTA or of any CTA in the cluster respectively. The addresses in the
  <span class="pre">
   .shared::cta
  </span>
  window also fall within the
  <span class="pre">
   .shared::cluster
  </span>
  window. If no sub-qualifier is specified with the
  <span class="pre">
   .shared
  </span>
  state space, then it defaults to
  <span class="pre">
   ::cta
  </span>
  . For example,
  <span class="pre">
   ld.shared
  </span>
  is equivalent to
  <span class="pre">
   ld.shared::cta
  </span>
  .
 </p>
 <p>
  Variables declared in
  <span class="pre">
   .shared
  </span>
  state space refer to the memory addresses in the current
CTA. Instruction
  <span class="pre">
   mapa
  </span>
  gives the
  <span class="pre">
   .shared::cluster
  </span>
  address of the corresponding variable in
another CTA in the cluster.
 </p>
 <p>
  Shared memory typically has some optimizations to support the sharing. One example is broadcast;
where all threads read from the same address. Another is sequential access from sequential threads.
 </p>
 <h3>
  <span class="section-number">
   5.1.8.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texture-state-space-deprecated">
   Texture State Space (deprecated)
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texture-state-space-deprecated" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The texture (
  <span class="pre">
   .tex
  </span>
  ) state space is global memory accessed via the texture instruction. It is
shared by all threads in a context. Texture memory is read-only and cached, so accesses to texture
memory are not coherent with global memory stores to the texture image.
 </p>
 <p>
  The GPU hardware has a fixed number of texture bindings that can be accessed within a single kernel
(typically 128). The .tex directive will bind the named texture memory variable to a hardware
texture identifier, where texture identifiers are allocated sequentially beginning with
zero. Multiple names may be bound to the same physical texture identifier. An error is generated if
the maximum number of physical resources is exceeded. The texture name must be of type
  <span class="pre">
   .u32
  </span>
  or
  <span class="pre">
   .u64
  </span>
  .
 </p>
 <p>
  Physical texture resources are allocated on a per-kernel granularity, and
  <span class="pre">
   .tex
  </span>
  variables are
required to be defined in the global scope.
 </p>
 <p>
  Texture memory is read-only. A textureâs base address is assumed to be aligned to a 16 byte
boundary.
 </p>
 <p>
  Example
 </p>
 <pre>.tex .u32 tex_a;         // bound to physical texture 0
.tex .u32 tex_c, tex_d;  // both bound to physical texture 1
.tex .u32 tex_d;         // bound to physical texture 2
.tex .u32 tex_f;         // bound to physical texture 3
</pre>
 <p class="admonition-title">
  Note
 </p>
 <p>
  Explicit declarations of variables in the texture state space is deprecated, and programs should
instead reference texture memory through variables of type
  <span class="pre">
   .texref
  </span>
  . The
  <span class="pre">
   .tex
  </span>
  directive is
retained for backward compatibility, and variables declared in the
  <span class="pre">
   .tex
  </span>
  state space are
equivalent to module-scoped
  <span class="pre">
   .texref
  </span>
  variables in the
  <span class="pre">
   .global
  </span>
  state space.
 </p>
 <p>
  For example, a legacy PTX definitions such as
 </p>
 <pre>.tex .u32 tex_a;
</pre>
 <p>
  is equivalent to:
 </p>
 <pre>.global .texref tex_a;
</pre>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texture-sampler-and-surface-types">
   Texture Sampler and Surface Types
  </a>
  for the
description of the
  <span class="pre">
   .texref
  </span>
  type and
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texture-instructions">
   Texture Instructions
  </a>
  for its use in texture instructions.
 </p>
 <h2>
  <span class="section-number">
   5.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#types">
   Types
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#types" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <h3>
  <span class="section-number">
   5.2.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#fundamental-types">
   Fundamental Types
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#fundamental-types" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  In PTX, the fundamental types reflect the native data types supported by the target architectures. A
fundamental type specifies both a basic type and a size. Register variables are always of a
fundamental type, and instructions operate on these types. The same type-size specifiers are used
for both variable definitions and for typing instructions, so their names are intentionally short.
 </p>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#fundamental-types-fundamental-type-specifiers">
   <span class="std std-numref">
    Table 8
   </span>
  </a>
  lists the fundamental type specifiers for
each basic type:
 </p>
 <table class="table-no-stripes docutils align-default" id="fundamental-types-fundamental-type-specifiers">
  <span class="caption-number">
   Table 8
  </span>
  <span class="caption-text">
   Fundamental Type Specifiers
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#fundamental-types-fundamental-type-specifiers" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Basic Type
    </p>
   </th>
   <th class="head">
    <p>
     Fundamental Type Specifiers
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     Signed integer
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .s8
     </span>
     ,
     <span class="pre">
      .s16
     </span>
     ,
     <span class="pre">
      .s32
     </span>
     ,
     <span class="pre">
      .s64
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     Unsigned integer
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .u8
     </span>
     ,
     <span class="pre">
      .u16
     </span>
     ,
     <span class="pre">
      .u32
     </span>
     ,
     <span class="pre">
      .u64
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     Floating-point
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .f16
     </span>
     ,
     <span class="pre">
      .f16x2
     </span>
     ,
     <span class="pre">
      .f32
     </span>
     ,
     <span class="pre">
      .f64
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     Bits (untyped)
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .b8
     </span>
     ,
     <span class="pre">
      .b16
     </span>
     ,
     <span class="pre">
      .b32
     </span>
     ,
     <span class="pre">
      .b64
     </span>
     ,
     <span class="pre">
      .b128
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     Predicate
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .pred
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Most instructions have one or more type specifiers, needed to fully specify instruction
behavior. Operand types and sizes are checked against instruction types for compatibility.
 </p>
 <p>
  Two fundamental types are compatible if they have the same basic type and are the same size. Signed
and unsigned integer types are compatible if they have the same size. The bit-size type is
compatible with any fundamental type having the same size.
 </p>
 <p>
  In principle, all variables (aside from predicates) could be declared using only bit-size types, but
typed variables enhance program readability and allow for better operand type checking.
 </p>
 <h3>
  <span class="section-number">
   5.2.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#restricted-use-of-sub-word-sizes">
   Restricted Use of Sub-Word Sizes
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#restricted-use-of-sub-word-sizes" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The
  <span class="pre">
   .u8
  </span>
  ,
  <span class="pre">
   .s8
  </span>
  , and
  <span class="pre">
   .b8
  </span>
  instruction types are restricted to
  <span class="pre">
   ld
  </span>
  ,
  <span class="pre">
   st
  </span>
  , and
  <span class="pre">
   cvt
  </span>
  instructions. The
  <span class="pre">
   .f16
  </span>
  floating-point type is allowed only in conversions to and from
  <span class="pre">
   .f32
  </span>
  ,
  <span class="pre">
   .f64
  </span>
  types, in half precision floating point instructions and texture fetch instructions. The
  <span class="pre">
   .f16x2
  </span>
  floating point type is allowed only in half precision floating point arithmetic
instructions and texture fetch instructions.
 </p>
 <p>
  For convenience,
  <span class="pre">
   ld
  </span>
  ,
  <span class="pre">
   st
  </span>
  , and
  <span class="pre">
   cvt
  </span>
  instructions permit source and destination data
operands to be wider than the instruction-type size, so that narrow values may be loaded, stored,
and converted using regular-width registers. For example, 8-bit or 16-bit values may be held
directly in 32-bit or 64-bit registers when being loaded, stored, or converted to other types and
sizes.
 </p>
 <h3>
  <span class="section-number">
   5.2.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#alternate-floating-point-data-formats">
   Alternate Floating-Point Data Formats
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#alternate-floating-point-data-formats" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The fundamental floating-point types supported in PTX have implicit bit representations that
indicate the number of bits used to store exponent and mantissa. For example, the
  <span class="pre">
   .f16
  </span>
  type
indicates 5 bits reserved for exponent and 10 bits reserved for mantissa. In addition to the
floating-point representations assumed by the fundamental types, PTX allows the following alternate
floating-point data formats:
 </p>
 <span class="pre">
  bf16
 </span>
 data format:
 <p>
  This data format is a 16-bit floating point format with 8 bits for exponent and 7 bits for
mantissa. A register variable containing
  <span class="pre">
   bf16
  </span>
  data must be declared with
  <span class="pre">
   .b16
  </span>
  type.
 </p>
 <span class="pre">
  e4m3
 </span>
 data format:
 <p>
  This data format is an 8-bit floating point format with 4 bits for exponent and 3 bits for
mantissa. The
  <span class="pre">
   e4m3
  </span>
  encoding does not support infinity and
  <span class="pre">
   NaN
  </span>
  values are limited to
  <span class="pre">
   0x7f
  </span>
  and
  <span class="pre">
   0xff
  </span>
  . A register variable containing
  <span class="pre">
   e4m3
  </span>
  value must be declared using
bit-size type.
 </p>
 <span class="pre">
  e5m2
 </span>
 data format:
 <p>
  This data format is an 8-bit floating point format with 5 bits for exponent and 2 bits for
mantissa. A register variable containing
  <span class="pre">
   e5m2
  </span>
  value must be declared using bit-size type.
 </p>
 <span class="pre">
  tf32
 </span>
 data format:
 <p>
  This data format is a special 32-bit floating point format supported by the matrix
multiply-and-accumulate instructions, with the same range as
  <span class="pre">
   .f32
  </span>
  and reduced precision (&gt;=10
bits). The internal layout of
  <span class="pre">
   tf32
  </span>
  format is implementation defined. PTX facilitates
conversion from single precision
  <span class="pre">
   .f32
  </span>
  type to
  <span class="pre">
   tf32
  </span>
  format. A register variable containing
  <span class="pre">
   tf32
  </span>
  data must be declared with
  <span class="pre">
   .b32
  </span>
  type.
 </p>
 <p>
  Alternate data formats cannot be used as fundamental types. They are supported as source or
destination formats by certain instructions.
 </p>
 <h3>
  <span class="section-number">
   5.2.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#packed-data-types">
   Packed Data Types
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#packed-data-types" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Certain PTX instructions operate on two sets of inputs in parallel, and produce two outputs. Such
instructions can use the data stored in a packed format. PTX supports packing two values of the same
scalar data type into a single, larger value. The packed value is considered as a value of a
  packed
data type
  . In this section we describe the packed data types supported in PTX.
 </p>
 <h4>
  <span class="section-number">
   5.2.4.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#packed-floating-point-data-types">
   Packed Floating Point Data Types
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#packed-floating-point-data-types" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  PTX supports the following four variants of packed floating point data types:
 </p>
 <ol class="arabic simple">
  <li>
   <p>
    <span class="pre">
     .f16x2
    </span>
    packed type containing two
    <span class="pre">
     .f16
    </span>
    floating point values.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .bf16x2
    </span>
    packed type containing two
    <span class="pre">
     .bf16
    </span>
    alternate floating point values.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .e4m3x2
    </span>
    packed type containing two
    <span class="pre">
     .e4m3
    </span>
    alternate floating point values.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .e5m2x2
    </span>
    packed type containing two
    <span class="pre">
     .e5m2
    </span>
    alternate floating point values.
   </p>
  </li>
 </ol>
 <p>
  <span class="pre">
   .f16x2
  </span>
  is supported as a fundamental type.
  <span class="pre">
   .bf16x2
  </span>
  ,
  <span class="pre">
   .e4m3x2
  </span>
  and
  <span class="pre">
   .e5m2x2
  </span>
  cannot be
used as fundamental types - they are supported as instruction types on certain instructions. A
register variable containing
  <span class="pre">
   .bf16x2
  </span>
  data must be declared with
  <span class="pre">
   .b32
  </span>
  type. A register
variable containing
  <span class="pre">
   .e4m3x2
  </span>
  or
  <span class="pre">
   .e5m2x2
  </span>
  data must be declared with
  <span class="pre">
   .b16
  </span>
  type.
 </p>
 <h4>
  <span class="section-number">
   5.2.4.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#packed-integer-data-types">
   Packed Integer Data Types
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#packed-integer-data-types" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  PTX supports two variants of packed integer data types:
  <span class="pre">
   .u16x2
  </span>
  and
  <span class="pre">
   .s16x2
  </span>
  . The packed data
type consists of two
  <span class="pre">
   .u16
  </span>
  or
  <span class="pre">
   .s16
  </span>
  values. A register variable containing
  <span class="pre">
   .u16x2
  </span>
  or
  <span class="pre">
   .s16x2
  </span>
  data must be declared with
  <span class="pre">
   .b32
  </span>
  type. Packed integer data types cannot be used as
fundamental types. They are supported as instruction types on certain instructions.
 </p>
 <h2>
  <span class="section-number">
   5.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texture-sampler-and-surface-types">
   Texture Sampler and Surface Types
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texture-sampler-and-surface-types" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  PTX includes built-in
  opaque
  types for defining texture, sampler, and surface descriptor
variables. These types have named fields similar to structures, but all information about layout,
field ordering, base address, and overall size is hidden to a PTX program, hence the term
  opaque
  . The use of these opaque types is limited to:
 </p>
 <ul class="simple">
  <li>
   <p>
    Variable definition within global (module) scope and in kernel entry parameter lists.
   </p>
  </li>
  <li>
   <p>
    Static initialization of module-scope variables using comma-delimited static assignment
expressions for the named members of the type.
   </p>
  </li>
  <li>
   <p>
    Referencing textures, samplers, or surfaces via texture and surface load/store instructions
(
    <span class="pre">
     tex
    </span>
    ,
    <span class="pre">
     suld
    </span>
    ,
    <span class="pre">
     sust
    </span>
    ,
    <span class="pre">
     sured
    </span>
    ).
   </p>
  </li>
  <li>
   <p>
    Retrieving the value of a named member via query instructions (
    <span class="pre">
     txq
    </span>
    ,
    <span class="pre">
     suq
    </span>
    ).
   </p>
  </li>
  <li>
   <p>
    Creating pointers to opaque variables using
    <span class="pre">
     mov
    </span>
    , e.g.,
    <span class="pre">
     mov.u64
    </span>
    <span class="pre">
     reg,
    </span>
    <span class="pre">
     opaque_var;
    </span>
    . The
resulting pointer may be stored to and loaded from memory, passed as a parameter to functions, and
de-referenced by texture and surface load, store, and query instructions, but the pointer cannot
otherwise be treated as an address, i.e., accessing the pointer with
    <span class="pre">
     ld
    </span>
    and
    <span class="pre">
     st
    </span>
    instructions, or performing pointer arithmetic will result in undefined results.
   </p>
  </li>
  <li>
   <p>
    Opaque variables may not appear in initializers, e.g., to initialize a pointer to an opaque
variable.
   </p>
  </li>
 </ul>
 <p class="admonition-title">
  Note
 </p>
 <p>
  Indirect access to textures and surfaces using pointers to opaque variables is supported
beginning with PTX ISA version 3.1 and requires target
  <span class="pre">
   sm_20
  </span>
  or later.
 </p>
 <p>
  Indirect access to textures is supported only in unified texture mode (see below).
 </p>
 <p>
  The three built-in types are
  <span class="pre">
   .texref
  </span>
  ,
  <span class="pre">
   .samplerref
  </span>
  , and
  <span class="pre">
   .surfref
  </span>
  . For working with
textures and samplers, PTX has two modes of operation. In the
  unified mode,
  texture and sampler
information is accessed through a single
  <span class="pre">
   .texref
  </span>
  handle. In the
  independent mode
  , texture and
sampler information each have their own handle, allowing them to be defined separately and combined
at the site of usage in the program. In independent mode, the fields of the
  <span class="pre">
   .texref
  </span>
  type that
describe sampler properties are ignored, since these properties are defined by
  <span class="pre">
   .samplerref
  </span>
  variables.
 </p>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texture-sampler-and-surface-types-opaque-type-fields-in-unified-texture-mode">
   <span class="std std-numref">
    Table 9
   </span>
  </a>
  and
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sampler-properties-opaque-type-fields-in-independent-texture-mode">
   <span class="std std-numref">
    Table 10
   </span>
  </a>
  list the named members
of each type for unified and independent texture modes. These members and their values have
precise mappings to methods and values defined in the texture
  <span class="pre">
   HW
  </span>
  class as well as
exposed values via the API.
 </p>
 <table class="table-no-stripes docutils align-default" id="texture-sampler-and-surface-types-opaque-type-fields-in-unified-texture-mode">
  <span class="caption-number">
   Table 9
  </span>
  <span class="caption-text">
   Opaque Type Fields in Unified Texture Mode
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texture-sampler-and-surface-types-opaque-type-fields-in-unified-texture-mode" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Member
    </p>
   </th>
   <th class="head">
    <p>
     .texref values
    </p>
   </th>
   <th class="head">
    <p>
     .surfref values
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      width
     </span>
    </p>
   </td>
   <td colspan="2">
    <p>
     in elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      height
     </span>
    </p>
   </td>
   <td colspan="2">
    <p>
     in elements
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      depth
     </span>
    </p>
   </td>
   <td colspan="2">
    <p>
     in elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      channel_data_type
     </span>
    </p>
   </td>
   <td colspan="2">
    <p>
     <span class="pre">
      enum
     </span>
     type corresponding to source language API
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      channel_order
     </span>
    </p>
   </td>
   <td colspan="2">
    <p>
     <span class="pre">
      enum
     </span>
     type corresponding to source language API
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      normalized_coords
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      0
     </span>
     ,
     <span class="pre">
      1
     </span>
    </p>
   </td>
   <td>
    <p>
     N/A
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      filter_mode
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      nearest
     </span>
     ,
     <span class="pre">
      linear
     </span>
    </p>
   </td>
   <td>
    <p>
     N/A
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      addr_mode_0
     </span>
     ,
     <span class="pre">
      addr_mode_1
     </span>
     ,
     <span class="pre">
      addr_mode_2
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      wrap
     </span>
     ,
     <span class="pre">
      mirror
     </span>
     ,
     <span class="pre">
      clamp_ogl
     </span>
     ,
     <span class="pre">
      clamp_to_edge
     </span>
     ,
     <span class="pre">
      clamp_to_border
     </span>
    </p>
   </td>
   <td>
    <p>
     N/A
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      array_size
     </span>
    </p>
   </td>
   <td>
    <p>
     as number of textures in a texture
array
    </p>
   </td>
   <td>
    <p>
     as number of surfaces in a surface array
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      num_mipmap_levels
     </span>
    </p>
   </td>
   <td>
    <p>
     as number of levels in a mipmapped
texture
    </p>
   </td>
   <td>
    <p>
     N/A
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      num_samples
     </span>
    </p>
   </td>
   <td>
    <p>
     as number of samples in a multi-sample
texture
    </p>
   </td>
   <td>
    <p>
     N/A
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      memory_layout
     </span>
    </p>
   </td>
   <td>
    <p>
     N/A
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      1
     </span>
     for linear memory layout;
     <span class="pre">
      0
     </span>
     otherwise
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   5.3.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texture-surface-properties">
   Texture and Surface Properties
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texture-and-surface-properties" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Fields
  <span class="pre">
   width
  </span>
  ,
  <span class="pre">
   height
  </span>
  , and
  <span class="pre">
   depth
  </span>
  specify the size of the texture or surface in number of
elements in each dimension.
 </p>
 <p>
  The
  <span class="pre">
   channel_data_type
  </span>
  and
  <span class="pre">
   channel_order
  </span>
  fields specify these properties of the texture or
surface using enumeration types corresponding to the source language API. For example, see
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#channel-data-type-and-channel-order-fields">
   Channel
Data Type and Channel Order Fields
  </a>
  for
the OpenCL enumeration types currently supported in PTX.
 </p>
 <h3>
  <span class="section-number">
   5.3.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sampler-properties">
   Sampler Properties
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sampler-properties" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The
  <span class="pre">
   normalized_coords
  </span>
  field indicates whether the texture or surface uses normalized coordinates
in the range [0.0, 1.0) instead of unnormalized coordinates in the range [0, N). If no value is
specified, the default is set by the runtime system based on the source language.
 </p>
 <p>
  The
  <span class="pre">
   filter_mode
  </span>
  field specifies how the values returned by texture reads are computed based on
the input texture coordinates.
 </p>
 <p>
  The
  <span class="pre">
   addr_mode_{0,1,2}
  </span>
  fields define the addressing mode in each dimension, which determine how
out-of-range coordinates are handled.
 </p>
 <p>
  See the
  CUDA C++ Programming Guide
  for more details of these properties.
 </p>
 <table class="table-no-stripes docutils align-default" id="sampler-properties-opaque-type-fields-in-independent-texture-mode">
  <span class="caption-number">
   Table 10
  </span>
  <span class="caption-text">
   Opaque Type Fields in Independent Texture Mode
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sampler-properties-opaque-type-fields-in-independent-texture-mode" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Member
    </p>
   </th>
   <th class="head">
    <p>
     .samplerref values
    </p>
   </th>
   <th class="head">
    <p>
     .texref values
    </p>
   </th>
   <th class="head">
    <p>
     .surfref values
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      width
     </span>
    </p>
   </td>
   <td>
    <p>
     N/A
    </p>
   </td>
   <td colspan="2">
    <p>
     in elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      height
     </span>
    </p>
   </td>
   <td>
    <p>
     N/A
    </p>
   </td>
   <td colspan="2">
    <p>
     in elements
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      depth
     </span>
    </p>
   </td>
   <td>
    <p>
     N/A
    </p>
   </td>
   <td colspan="2">
    <p>
     in elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      channel_data_type
     </span>
    </p>
   </td>
   <td>
    <p>
     N/A
    </p>
   </td>
   <td colspan="2">
    <p>
     <span class="pre">
      enum
     </span>
     type corresponding to source
language API
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      channel_order
     </span>
    </p>
   </td>
   <td>
    <p>
     N/A
    </p>
   </td>
   <td colspan="2">
    <p>
     <span class="pre">
      enum
     </span>
     type corresponding to source
language AP
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      normalized_coords
     </span>
    </p>
   </td>
   <td>
    <p>
     N/A
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      0
     </span>
     ,
     <span class="pre">
      1
     </span>
    </p>
   </td>
   <td>
    <p>
     N/A
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      force_unnormalized_coords
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      0
     </span>
     ,
     <span class="pre">
      1
     </span>
    </p>
   </td>
   <td>
    <p>
     N/A
    </p>
   </td>
   <td>
    <p>
     N/A
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      filter_mode
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      nearest
     </span>
     ,
     <span class="pre">
      linear
     </span>
    </p>
   </td>
   <td>
    <p>
     ignored
    </p>
   </td>
   <td>
    <p>
     N/A
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      addr_mode_0
     </span>
     ,
     <span class="pre">
      addr_mode_1
     </span>
     ,
     <span class="pre">
      addr_mode_2
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      wrap
     </span>
     ,
     <span class="pre">
      mirror
     </span>
     ,
     <span class="pre">
      clamp_ogl
     </span>
     ,
     <span class="pre">
      clamp_to_edge
     </span>
     ,
     <span class="pre">
      clamp_to_border
     </span>
    </p>
   </td>
   <td>
    <p>
     N/A
    </p>
   </td>
   <td>
    <p>
     N/A
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      array_size
     </span>
    </p>
   </td>
   <td>
    <p>
     N/A
    </p>
   </td>
   <td>
    <p>
     as number of textures
in a texture array
    </p>
   </td>
   <td>
    <p>
     as number of surfaces in
a surface array
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      num_mipmap_levels
     </span>
    </p>
   </td>
   <td>
    <p>
     N/A
    </p>
   </td>
   <td>
    <p>
     as number of levels
in a mipmapped
texture
    </p>
   </td>
   <td>
    <p>
     N/A
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      num_samples
     </span>
    </p>
   </td>
   <td>
    <p>
     N/A
    </p>
   </td>
   <td>
    <p>
     as number of samples
in a multi-sample
texture
    </p>
   </td>
   <td>
    <p>
     N/A
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      memory_layout
     </span>
    </p>
   </td>
   <td>
    <p>
     N/A
    </p>
   </td>
   <td>
    <p>
     N/A
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      1
     </span>
     for linear memory
layout;
     <span class="pre">
      0
     </span>
     otherwise
    </p>
   </td>
  </tr>
 </table>
 <p>
  In independent texture mode, the sampler properties are carried in an independent
  <span class="pre">
   .samplerref
  </span>
  variable, and these fields are disabled in the
  <span class="pre">
   .texref
  </span>
  variables. One additional sampler
property,
  <span class="pre">
   force_unnormalized_coords
  </span>
  , is available in independent texture mode.
 </p>
 <p>
  The
  <span class="pre">
   force_unnormalized_coords
  </span>
  field is a property of
  <span class="pre">
   .samplerref
  </span>
  variables that allows the
sampler to override the texture header
  <span class="pre">
   normalized_coords
  </span>
  property. This field is defined only in
independent texture mode. When
  <span class="pre">
   True
  </span>
  , the texture header setting is overridden and unnormalized
coordinates are used; when
  <span class="pre">
   False
  </span>
  , the texture header setting is used.
 </p>
 <p>
  The
  <span class="pre">
   force_unnormalized_coords
  </span>
  property is used in compiling OpenCL; in OpenCL, the property of
normalized coordinates is carried in sampler headers. To compile OpenCL to PTX, texture headers are
always initialized with
  <span class="pre">
   normalized_coords
  </span>
  set to True, and the OpenCL sampler-based
  <span class="pre">
   normalized_coords
  </span>
  flag maps (negated) to the PTX-level
  <span class="pre">
   force_unnormalized_coords
  </span>
  flag.
 </p>
 <p>
  Variables using these types may be declared at module scope or within kernel entry parameter
lists. At module scope, these variables must be in the
  <span class="pre">
   .global
  </span>
  state space. As kernel
parameters, these variables are declared in the
  <span class="pre">
   .param
  </span>
  state space.
 </p>
 <p>
  Example
 </p>
 <pre>.global .texref     my_texture_name;
.global .samplerref my_sampler_name;
.global .surfref    my_surface_name;
</pre>
 <p>
  When declared at module scope, the types may be initialized using a list of static expressions
assigning values to the named members.
 </p>
 <p>
  Example
 </p>
 <pre>.global .texref tex1;
.global .samplerref tsamp1 = { addr_mode_0 = clamp_to_border,
                               filter_mode = nearest
                             };
</pre>
 <h3>
  <span class="section-number">
   5.3.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#channel-data-type-and-channel-order-fields">
   Channel Data Type and Channel Order Fields
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#channel-data-type-and-channel-order-fields" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The
  <span class="pre">
   channel_data_type
  </span>
  and
  <span class="pre">
   channel_order
  </span>
  fields have enumeration types corresponding to the
source language API. Currently, OpenCL is the only source language that defines these
fields.
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#channel-data-type-and-channel-order-fields-opencl-channel-order-definition">
   <span class="std std-numref">
    Table 12
   </span>
  </a>
  and
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#channel-data-type-and-channel-order-fields-opencl-channel-data-type-definition">
   <span class="std std-numref">
    Table 11
   </span>
  </a>
  show the
enumeration values defined in OpenCL version 1.0 for channel data type and channel order.
 </p>
 <table class="table-no-stripes docutils align-default" id="channel-data-type-and-channel-order-fields-opencl-channel-data-type-definition">
  <span class="caption-number">
   Table 11
  </span>
  <span class="caption-text">
   OpenCL 1.0 Channel Data Type Definition
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#channel-data-type-and-channel-order-fields-opencl-channel-data-type-definition" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CL_SNORM_INT8
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      0x10D0
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CL_SNORM_INT16
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      0x10D1
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CL_UNORM_INT8
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      0x10D2
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CL_UNORM_INT16
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      0x10D3
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CL_UNORM_SHORT_565
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      0x10D4
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CL_UNORM_SHORT_555
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      0x10D5
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CL_UNORM_INT_101010
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      0x10D6
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CL_SIGNED_INT8
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      0x10D7
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CL_SIGNED_INT16
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      0x10D8
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CL_SIGNED_INT32
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      0x10D9
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CL_UNSIGNED_INT8
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      0x10DA
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CL_UNSIGNED_INT16
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      0x10DB
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CL_UNSIGNED_INT32
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      0x10DC
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CL_HALF_FLOAT
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      0x10DD
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CL_FLOAT
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      0x10DE
     </span>
    </p>
   </td>
  </tr>
 </table>
 <table class="table-no-stripes docutils align-default" id="channel-data-type-and-channel-order-fields-opencl-channel-order-definition">
  <span class="caption-number">
   Table 12
  </span>
  <span class="caption-text">
   OpenCL 1.0 Channel Order Definition
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#channel-data-type-and-channel-order-fields-opencl-channel-order-definition" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CL_R
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      0x10B0
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CL_A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      0x10B1
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CL_RG
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      0x10B2
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CL_RA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      0x10B3
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CL_RGB
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      0x10B4
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CL_RGBA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      0x10B5
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CL_BGRA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      0x10B6
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CL_ARGB
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      0x10B7
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CL_INTENSITY
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      0x10B8
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CL_LUMINANCE
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      0x10B9
     </span>
    </p>
   </td>
  </tr>
 </table>
 <h2>
  <span class="section-number">
   5.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#variables">
   Variables
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#variables" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  In PTX, a variable declaration describes both the variableâs type and its state space. In addition
to fundamental types, PTX supports types for simple aggregate objects such as vectors and arrays.
 </p>
 <h3>
  <span class="section-number">
   5.4.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#variable-declarations">
   Variable Declarations
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#variable-declarations" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  All storage for data is specified with variable declarations. Every variable must reside in one of
the state spaces enumerated in the previous section.
 </p>
 <p>
  A variable declaration names the space in which the variable resides, its type and size, its name,
an optional array size, an optional initializer, and an optional fixed address for the variable.
 </p>
 <p>
  Predicate variables may only be declared in the register state space.
 </p>
 <p>
  Examples
 </p>
 <pre>.global .u32 loc;
.reg    .s32 i;
.const  .f32 bias[] = {-1.0, 1.0};
.global .u8  bg[4] = {0, 0, 0, 0};
.reg    .v4 .f32 accel;
.reg    .pred p, q, r;
</pre>
 <h3>
  <span class="section-number">
   5.4.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#vectors">
   Vectors
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#vectors" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Limited-length vector types are supported. Vectors of length 2 and 4 of any non-predicate
fundamental type can be declared by prefixing the type with
  <span class="pre">
   .v2
  </span>
  or
  <span class="pre">
   .v4
  </span>
  . Vectors must be
based on a fundamental type, and they may reside in the register space. Vectors cannot exceed
128-bits in length; for example,
  <span class="pre">
   .v4
  </span>
  <span class="pre">
   .f64
  </span>
  is not allowed. Three-element vectors may be
handled by using a
  <span class="pre">
   .v4
  </span>
  vector, where the fourth element provides padding. This is a common case
for three-dimensional grids, textures, etc.
 </p>
 <p>
  Examples
 </p>
 <pre>.global .v4 .f32 V;   // a length-4 vector of floats
.shared .v2 .u16 uv;  // a length-2 vector of unsigned ints
.global .v4 .b8  v;   // a length-4 vector of bytes
</pre>
 <p>
  By default, vector variables are aligned to a multiple of their overall size (vector length times
base-type size), to enable vector load and store instructions which require addresses aligned to a
multiple of the access size.
 </p>
 <h3>
  <span class="section-number">
   5.4.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#array-declarations">
   Array Declarations
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#array-declarations" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Array declarations are provided to allow the programmer to reserve space. To declare an array, the
variable name is followed with dimensional declarations similar to fixed-size array declarations
in C. The size of each dimension is a constant expression.
 </p>
 <p>
  Examples
 </p>
 <pre>.local  .u16 kernel[19][19];
.shared .u8  mailbox[128];
</pre>
 <p>
  The size of the array specifies how many elements should be reserved. For the declaration of array
  kernel
  above, 19*19 = 361 halfwords are reserved, for a total of 722 bytes.
 </p>
 <p>
  When declared with an initializer, the first dimension of the array may be omitted. The size of the
first array dimension is determined by the number of elements in the array initializer.
 </p>
 <p>
  Examples
 </p>
 <pre>.global .u32 index[] = { 0, 1, 2, 3, 4, 5, 6, 7 };
.global .s32 offset[][2] = { {-1, 0}, {0, -1}, {1, 0}, {0, 1} };
</pre>
 <p>
  Array
  index
  has eight elements, and array
  offset
  is a 4x2 array.
 </p>
 <h3>
  <span class="section-number">
   5.4.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#initializers">
   Initializers
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#initializers" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Declared variables may specify an initial value using a syntax similar to C/C++, where the variable
name is followed by an equals sign and the initial value or values for the variable. A scalar takes
a single value, while vectors and arrays take nested lists of values inside of curly braces (the
nesting matches the dimensionality of the declaration).
 </p>
 <p>
  As in C, array initializers may be incomplete, i.e., the number of initializer elements may be less
than the extent of the corresponding array dimension, with remaining array locations initialized to
the default value for the specified array type.
 </p>
 <p>
  Examples
 </p>
 <pre>.const  .f32 vals[8] = { 0.33, 0.25, 0.125 };
.global .s32 x[3][2] = { {1,2}, {3} };
</pre>
 <p>
  is equivalent to
 </p>
 <pre>.const  .f32 vals[8] = { 0.33, 0.25, 0.125, 0.0, 0.0, 0.0, 0.0, 0.0 };
.global .s32 x[3][2] = { {1,2}, {3,0}, {0,0} };
</pre>
 <p>
  Currently, variable initialization is supported only for constant and global state spaces. Variables
in constant and global state spaces with no explicit initializer are initialized to zero by
default. Initializers are not allowed in external variable declarations.
 </p>
 <p>
  Variable names appearing in initializers represent the address of the variable; this can be used to
statically initialize a pointer to a variable. Initializers may also contain
  var+offset
  expressions, where
  offset
  is a byte offset added to the address of
  var
  . Only variables in
  <span class="pre">
   .global
  </span>
  or
  <span class="pre">
   .const
  </span>
  state spaces may be used in initializers. By default, the resulting
address is the offset in the variableâs state space (as is the case when taking the address of a
variable with a
  <span class="pre">
   mov
  </span>
  instruction). An operator,
  <span class="pre">
   generic()
  </span>
  , is provided to create a generic
address for variables used in initializers.
 </p>
 <p>
  Starting PTX ISA version 7.1, an operator
  <span class="pre">
   mask()
  </span>
  is provided, where
  <span class="pre">
   mask
  </span>
  is an integer
immediate. The only allowed expressions in the
  <span class="pre">
   mask()
  </span>
  operator are integer constant expression
and symbol expression representing address of variable. The
  <span class="pre">
   mask()
  </span>
  operator extracts
  <span class="pre">
   n
  </span>
  consecutive bits from the expression used in initializers and inserts these bits at the lowest
position of the initialized variable. The number
  <span class="pre">
   n
  </span>
  and the starting position of the bits to be
extracted is specified by the integer immediate
  <span class="pre">
   mask
  </span>
  . PTX ISA version 7.1 only supports
extracting a single byte starting at byte boundary from the address of the variable. PTX ISA version
7.3 supports Integer constant expression as an operand in the
  <span class="pre">
   mask()
  </span>
  operator.
 </p>
 <p>
  Supported values for
  <span class="pre">
   mask
  </span>
  are: 0xFF, 0xFF00, 0XFF0000, 0xFF000000, 0xFF00000000, 0xFF0000000000,
0xFF000000000000, 0xFF00000000000000.
 </p>
 <p>
  Examples
 </p>
 <pre>.const  .u32 foo = 42;
.global .u32 bar[] = { 2, 3, 5 };
.global .u32 p1 = foo;          // offset of foo in .const space
.global .u32 p2 = generic(foo); // generic address of foo

// array of generic-address pointers to elements of bar
.global .u32 parr[] = { generic(bar), generic(bar)+4,
generic(bar)+8 };

// examples using mask() operator are pruned for brevity
.global .u8 addr[] = {0xff(foo), 0xff00(foo), 0xff0000(foo), ...};

.global .u8 addr2[] = {0xff(foo+4), 0xff00(foo+4), 0xff0000(foo+4),...}

.global .u8 addr3[] = {0xff(generic(foo)), 0xff00(generic(foo)),...}

.global .u8 addr4[] = {0xff(generic(foo)+4), 0xff00(generic(foo)+4),...}

// mask() operator with integer const expression
.global .u8 addr5[] = { 0xFF(1000 + 546), 0xFF00(131187), ...};
</pre>
 <p class="admonition-title">
  Note
 </p>
 <p>
  PTX 3.1 redefines the default addressing for global variables in initializers, from generic
addresses to offsets in the global state space. Legacy PTX code is treated as having an implicit
  <span class="pre">
   generic()
  </span>
  operator for each global variable used in an initializer. PTX 3.1 code should
either include explicit
  <span class="pre">
   generic()
  </span>
  operators in initializers, use
  <span class="pre">
   cvta.global
  </span>
  to form
generic addresses at runtime, or load from the non-generic address using
  <span class="pre">
   ld.global
  </span>
  .
 </p>
 <p>
  Device function names appearing in initializers represent the address of the first instruction in
the function; this can be used to initialize a table of function pointers to be used with indirect
calls. Beginning in PTX ISA version 3.1, kernel function names can be used as initializers e.g. to
initialize a table of kernel function pointers, to be used with CUDA Dynamic Parallelism to launch
kernels from GPU. See the
  CUDA Dynamic Parallelism Programming Guide
  for details.
 </p>
 <p>
  Labels cannot be used in initializers.
 </p>
 <p>
  Variables that hold addresses of variables or functions should be of type
  <span class="pre">
   .u8
  </span>
  or
  <span class="pre">
   .u32
  </span>
  or
  <span class="pre">
   .u64
  </span>
  .
 </p>
 <p>
  Type
  <span class="pre">
   .u8
  </span>
  is allowed only if the
  <span class="pre">
   mask()
  </span>
  operator is used.
 </p>
 <p>
  Initializers are allowed for all types except
  <span class="pre">
   .f16
  </span>
  ,
  <span class="pre">
   .f16x2
  </span>
  and
  <span class="pre">
   .pred
  </span>
  .
 </p>
 <p>
  Examples
 </p>
 <pre>.global .s32 n = 10;
.global .f32 blur_kernel[][3]
               = {{.05,.1,.05},{.1,.4,.1},{.05,.1,.05}};

.global .u32 foo[] = { 2, 3, 5, 7, 9, 11 };
.global .u64 ptr = generic(foo);   // generic address of foo[0]
.global .u64 ptr = generic(foo)+8; // generic address of foo[2]
</pre>
 <h3>
  <span class="section-number">
   5.4.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#alignment">
   Alignment
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#alignment" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Byte alignment of storage for all addressable variables can be specified in the variable
declaration. Alignment is specified using an optional
  <span class="pre">
   .align
  </span>
  byte-count
  specifier immediately
following the state-space specifier. The variable will be aligned to an address which is an integer
multiple of byte-count. The alignment value byte-count must be a power of two. For arrays, alignment
specifies the address alignment for the starting address of the entire array, not for individual
elements.
 </p>
 <p>
  The default alignment for scalar and array variables is to a multiple of the base-type size. The
default alignment for vector variables is to a multiple of the overall vector size.
 </p>
 <p>
  Examples
 </p>
 <pre> // allocate array at 4-byte aligned address.  Elements are bytes.
.const .align 4 .b8 bar[8] = {0,0,0,0,2,0,0,0};
</pre>
 <p>
  Note that all PTX instructions that access memory require that the address be aligned to a multiple
of the access size. The access size of a memory instruction is the total number of bytes accessed in
memory. For example, the access size of
  <span class="pre">
   ld.v4.b32
  </span>
  is 16 bytes, while the access size of
  <span class="pre">
   atom.f16x2
  </span>
  is 4 bytes.
 </p>
 <h3>
  <span class="section-number">
   5.4.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parameterized-variable-names">
   Parameterized Variable Names
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parameterized-variable-names" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Since PTX supports virtual registers, it is quite common for a compiler frontend to generate a large
number of register names. Rather than require explicit declaration of every name, PTX supports a
syntax for creating a set of variables having a common prefix string appended with integer suffixes.
 </p>
 <p>
  For example, suppose a program uses a large number, say one hundred, of
  <span class="pre">
   .b32
  </span>
  variables, named
  <span class="pre">
   %r0
  </span>
  ,
  <span class="pre">
   %r1
  </span>
  , â¦,
  <span class="pre">
   %r99
  </span>
  . These 100 register variables can be declared as follows:
 </p>
 <pre>.reg .b32 %r&lt;100&gt;;    // declare %r0, %r1, ..., %r99
</pre>
 <p>
  This shorthand syntax may be used with any of the fundamental types and with any state space, and
may be preceded by an alignment specifier. Array variables cannot be declared this way, nor are
initializers permitted.
 </p>
 <h3>
  <span class="section-number">
   5.4.7.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#variable-attributes">
   Variable Attributes
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#variable-attributes" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Variables may be declared with an optional
  <span class="pre">
   .attribute
  </span>
  directive which allows specifying special
attributes of variables. Keyword
  <span class="pre">
   .attribute
  </span>
  is followed by attribute specification inside
parenthesis. Multiple attributes are separated by comma.
 </p>
 <p>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#variable-and-function-attribute-directive-attribute">
   Variable and Function Attribute Directive: .attribute
  </a>
  describes the
  <span class="pre">
   .attribute
  </span>
  directive.
 </p>
 <h3>
  <span class="section-number">
   5.4.8.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#variable-and-function-attribute-directive-attribute">
   Variable and Function Attribute Directive: .attribute
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#variable-and-function-attribute-directive-attribute" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  .attribute
 </p>
 <p>
  Variable and function attributes
 </p>
 <p>
  Description
 </p>
 <p>
  Used to specify special attributes of a variable or a function.
 </p>
 <p>
  The following attributes are supported.
 </p>
 <span class="pre">
  .managed
 </span>
 <p>
  <span class="pre">
   .managed
  </span>
  attribute specifies that variable will be allocated at a location in unified virtual
memory environment where host and other devices in the system can reference the variable
directly. This attribute can only be used with variables in .global state space. See the
  CUDA
UVM-Lite Programming Guide
  for details.
 </p>
 <span class="pre">
  .unified
 </span>
 <p>
  <span class="pre">
   .unified
  </span>
  attribute specifies that function has the same memory address on the host and on
other devices in the system. Integer constants
  <span class="pre">
   uuid1
  </span>
  and
  <span class="pre">
   uuid2
  </span>
  respectively specify upper
and lower 64 bits of the unique identifier associated with the function or the variable. This
attribute can only be used on device functions or on variables in the
  <span class="pre">
   .global
  </span>
  state
space. Variables with
  <span class="pre">
   .unified
  </span>
  attribute are read-only and must be loaded by specifying
  <span class="pre">
   .unified
  </span>
  qualifier on the address operand of
  <span class="pre">
   ld
  </span>
  instruction, otherwise the behavior is
undefined.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <ul class="simple">
  <li>
   <p>
    Introduced in PTX ISA version 4.0.
   </p>
  </li>
  <li>
   <p>
    Support for function attributes introduced in PTX ISA version 8.0.
   </p>
  </li>
 </ul>
 <p>
  Target ISA Notes
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     .managed
    </span>
    attribute requires
    <span class="pre">
     sm_30
    </span>
    or higher.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .unified
    </span>
    attribute requires
    <span class="pre">
     sm_90
    </span>
    or higher.
   </p>
  </li>
 </ul>
 <p>
  Examples
 </p>
 <pre>.global .attribute(.managed) .s32 g;
.global .attribute(.managed) .u64 x;

.global .attribute(.unified(19,95)) .f32 f;

.func .attribute(.unified(0xAB, 0xCD)) bar() { ... }
</pre>
 <h2>
  <span class="section-number">
   5.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensors">
   Tensors
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensors" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  A tensor is a multi-dimensional matrix structure in the memory. Tensor is defined by the following
properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    Dimensionality
   </p>
  </li>
  <li>
   <p>
    Dimension sizes across each dimension
   </p>
  </li>
  <li>
   <p>
    Individual element types
   </p>
  </li>
  <li>
   <p>
    Tensor stride across each dimension
   </p>
  </li>
 </ul>
 <p>
  PTX supports instructions which can operate on the tensor data. PTX Tensor instructions include:
 </p>
 <ul class="simple">
  <li>
   <p>
    Copying data between global and shared memories
   </p>
  </li>
  <li>
   <p>
    Reducing the destination tensor data with the source.
   </p>
  </li>
 </ul>
 <p>
  The Tensor data can be operated on by various
  <span class="pre">
   wmma.mma
  </span>
  ,
  <span class="pre">
   mma
  </span>
  and
  <span class="pre">
   wgmma.mma_async
  </span>
  instructions.
 </p>
 <p>
  PTX Tensor instructions treat the tensor data in the global memory as a multi-dimensional structure
and treat the data in the shared memory as a linear data.
 </p>
 <h3>
  <span class="section-number">
   5.5.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-dimension-size-format">
   Tensor Dimension, size and format
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-dimension-size-and-format" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Tensors can have dimensions: 1D, 2D, 3D, 4D or 5D.
 </p>
 <p>
  Each dimension has a size which represents the number of elements along the dimension. The elements
can have one the following types:
 </p>
 <ul class="simple">
  <li>
   <p>
    Bit-sized type:
    <span class="pre">
     .b32
    </span>
    ,
    <span class="pre">
     .b64
    </span>
   </p>
  </li>
  <li>
   <p>
    Integer:
    <span class="pre">
     .u8
    </span>
    ,
    <span class="pre">
     .u16
    </span>
    ,
    <span class="pre">
     .u32
    </span>
    ,
    <span class="pre">
     .s32
    </span>
    ,
    <span class="pre">
     .u64
    </span>
    ,
    <span class="pre">
     .s64
    </span>
   </p>
  </li>
  <li>
   <p>
    Floating point and alternate floating point:
    <span class="pre">
     .f16
    </span>
    ,
    <span class="pre">
     .bf16
    </span>
    ,
    <span class="pre">
     .tf32
    </span>
    ,
    <span class="pre">
     .f32
    </span>
    ,
    <span class="pre">
     .f64
    </span>
    (rounded to nearest even).
   </p>
  </li>
 </ul>
 <p>
  Tensor can have padding at the end in each of the dimensions to provide alignment for the data in
the subsequent dimensions. Tensor stride can be used to specify the amount of padding in each
dimension.
 </p>
 <h3>
  <span class="section-number">
   5.5.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-access-modes">
   Tensor Access Modes
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-access-modes" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Tensor data can be accessed in two modes:
 </p>
 <ul>
  <li>
   <p>
    Tiled mode:
   </p>
   <p>
    In tiled mode, the source multi-dimensional tensor layout is preserved at the destination.
   </p>
  </li>
  <li>
   <p>
    Im2col mode:
   </p>
   <p>
    In im2col mode, the elements in the Bounding Box of the source tensor are rearranged into columns
at the destination. Refer
    <a class="reference external" href="https://in.mathworks.com/help/images/ref/im2col.html">
     here
    </a>
    for more details.
   </p>
  </li>
 </ul>
 <h3>
  <span class="section-number">
   5.5.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-tiled-mode">
   Tiled Mode
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tiled-mode" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  This section talks about how Tensor and Tensor access work in tiled mode.
 </p>
 <h4>
  <span class="section-number">
   5.5.3.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-tiled-mode-bounding-box">
   Bounding Box
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#bounding-box" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  A tensor can be accessed in chunks known as
  Bounding Box
  . The Bounding Box has the same
dimensionality as the tensor they are accessing into. Size of each bounding Box must be a multiple
of 16 bytes. The address of the bounding Box must also be aligned to 16 bytes.
 </p>
 <p>
  Bounding Box has the following access properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    Bounding Box dimension sizes
   </p>
  </li>
  <li>
   <p>
    Out of boundary access mode
   </p>
  </li>
  <li>
   <p>
    Traversal strides
   </p>
  </li>
 </ul>
 <p>
  The tensor-coordinates, specified in the PTX tensor instructions, specify the starting offset of the
bounding box. Starting offset of the bounding box along with the rest of the bounding box
information together are used to determine the elements which are to be accessed.
 </p>
 <h4>
  <span class="section-number">
   5.5.3.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-tiled-mode-traversal-stride">
   Traversal-Stride
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#traversal-stride" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  While the Bounding Box is iterating the tensor across a dimension, the traversal stride specifies
the exact number of elements to be skipped. If no jump over is required, default value of 1 must be
specified.
 </p>
 <p>
  The traversal stride in dimension 0 can be used for the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-interleaved-layout">
   Interleave layout
  </a>
  . For non-interleaved layout, the traversal stride in
dimension 0 must always be 1.
 </p>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-tiled-mode-bb-example">
   <span class="std std-numref">
    Figure 5
   </span>
  </a>
  illustrates tensor, tensor size, tensor stride,
Bounding Box size and traversal stride.
 </p>
 <p>
  <span class="caption-number">
   Figure 5
  </span>
  <span class="caption-text">
   Tiled mode bounding box, tensor size and traversal stride
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-tiled-mode-bb-example" title="Permalink to this image">
   ï
  </a>
 </p>
 <h4>
  <span class="section-number">
   5.5.3.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-tiled-mode-oob-access">
   Out of Boundary Access
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#out-of-boundary-access" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  PTX Tensor operation can detect and handle the case when the Bounding Box crosses the tensor
boundary in any dimension. There are 2 modes:
 </p>
 <ul>
  <li>
   <p>
    Zero fill mode:
   </p>
   <p>
    Elements in the Bounding Box which fall outside of the tensor boundary are set to 0.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     OOB-NaN
    </span>
    fill mode:
   </p>
   <p>
    Elements in the Bounding Box which fall outside of the tensor boundary are set to a special NaN
called
    <span class="pre">
     OOB-NaN
    </span>
    .
   </p>
  </li>
 </ul>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-oob-access">
   <span class="std std-numref">
    Figure 6
   </span>
  </a>
  shows an example of the out of boundary access.
 </p>
 <p>
  <span class="caption-number">
   Figure 6
  </span>
  <span class="caption-text">
   Out of boundary access
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-oob-access" title="Permalink to this image">
   ï
  </a>
 </p>
 <h3>
  <span class="section-number">
   5.5.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-im2col-mode">
   Im2col mode
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#im2col-mode" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Im2col mode supports the following tensor dimensions : 3D, 4D and 5D. In this mode, the tensor data
is treated as a batch of images with the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    N : number of images in the batch
   </p>
  </li>
  <li>
   <p>
    D, H, W : size of a 3D image (depth, height and width)
   </p>
  </li>
  <li>
   <p>
    C: channels per image element
   </p>
  </li>
 </ul>
 <p>
  The above properties are associated with 3D, 4D and 5D tensors as follows:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Dimension
    </p>
   </th>
   <th class="head">
    <p>
     N/D/H/W/C applicability
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     3D
    </p>
   </td>
   <td>
    <p>
     NWC
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     4D
    </p>
   </td>
   <td>
    <p>
     NHWC
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     5D
    </p>
   </td>
   <td>
    <p>
     NDHWC
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   5.5.4.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-im2col-mode-bounding-box">
   Bounding Box
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-im2col-mode-bounding-box" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  In im2col mode, the Bounding Box is defined in DHW space. Boundaries along other dimensions are
specified by Pixels-per-Column and Channels-per-Pixel parameters as described below.
 </p>
 <p>
  The dimensionality of the Bounding Box is two less than the tensor dimensionality.
 </p>
 <p>
  The following properties describe how to access of the elements in im2col mode:
 </p>
 <ul class="simple">
  <li>
   <p>
    Bounding-Box Lower-Corner
   </p>
  </li>
  <li>
   <p>
    Bounding-Box Upper-Corner
   </p>
  </li>
  <li>
   <p>
    Pixels-per-Column
   </p>
  </li>
  <li>
   <p>
    Channels-per-Pixel
   </p>
  </li>
 </ul>
 <p>
  Bounding-box Lower-Corner
  and
  Bounding-box Upper-Corner
  specify the two opposite corners of the
Bounding Box in the DHW space.
  Bounding-box Lower-Corner
  specifies the corner with the smallest
coordinate and
  Bounding-box Upper-Corner
  specifies the corner with the largest coordinate.
 </p>
 <p>
  Bounding-box Upper-
  and
  Lower-Corners
  are 16-bit signed values whose limits varies across the
dimensions and are as shown below:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     3D
    </p>
   </th>
   <th class="head">
    <p>
     4D
    </p>
   </th>
   <th class="head">
    <p>
     5D
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     Upper- / Lower- Corner sizes
    </p>
   </td>
   <td>
    <p>
     [-2
     15
     , 2
     15
     -1]
    </p>
   </td>
   <td>
    <p>
     [-2
     7
     , 2
     7
     -1]
    </p>
   </td>
   <td>
    <p>
     [-2
     4
     , 2
     4
     -1]
    </p>
   </td>
  </tr>
 </table>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#im2col-mode-bounding-box1">
   <span class="std std-numref">
    Figure 7
   </span>
  </a>
  and
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#im2col-mode-bounding-box2">
   <span class="std std-numref">
    Figure 8
   </span>
  </a>
  show the Upper-Corners and Lower-Corners.
 </p>
 <p>
  <span class="caption-number">
   Figure 7
  </span>
  <span class="caption-text">
   im2col mode bounding box example 1
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#im2col-mode-bounding-box1" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  <span class="caption-number">
   Figure 8
  </span>
  <span class="caption-text">
   im2col mode bounding box example 2
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#im2col-mode-bounding-box2" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  The
  Bounding-box Upper-
  and
  Lower- Corners
  specify only the boundaries and not the number of
elements to be accessed.
  Pixels-per-Column
  specifies the number of elements to be accessed in the
NDHW space.
 </p>
 <p>
  Channels-per-Pixel
  specifies the number of elements to access across the C dimension.
 </p>
 <p>
  The tensor coordinates, specified in the PTX tensor instructions, behaves differently in different
dimensions:
 </p>
 <ul class="simple">
  <li>
   <p>
    Across N and C dimensions: specify the starting offsets along the dimension, similar to the tiled
mode.
   </p>
  </li>
  <li>
   <p>
    Across DHW dimensions: specify the location of the convolution filter base in the tensor
space. The filter corner location must be within the bounding box.
   </p>
  </li>
 </ul>
 <p>
  The im2col offsets, specified in the PTX tensor instructions in im2col mode, are added to the filter
base coordinates to determine the starting location in the tensor space from where the elements are
accessed.
 </p>
 <p>
  The size of the im2col offsets varies across the dimensions and their valid ranges are as shown
below:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     3D
    </p>
   </th>
   <th class="head">
    <p>
     4D
    </p>
   </th>
   <th class="head">
    <p>
     5D
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     im2col offsets range
    </p>
   </td>
   <td>
    <p>
     [0, 2
     16
     -1]
    </p>
   </td>
   <td>
    <p>
     [0, 2
     8
     -1]
    </p>
   </td>
   <td>
    <p>
     [0, 2
     5
     -1]
    </p>
   </td>
  </tr>
 </table>
 <p>
  Following are some examples of the im2col mode accesses:
 </p>
 <ul>
  <li>
   <p>
    Example 1 (
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-im2col-mode-example1">
     <span class="std std-numref">
      Figure 9
     </span>
    </a>
    ):
   </p>
   <pre><span class="n">Tensor</span><span class="n">Size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">64</span>
<span class="n">Tensor</span><span class="n">Size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">9</span>
<span class="n">Tensor</span><span class="n">Size</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="mi">14</span>
<span class="n">Tensor</span><span class="n">Size</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="mi">64</span>
<span class="n">Pixels</span><span class="o">-</span><span class="n">per</span><span class="o">-</span><span class="n">Column</span><span class="o">=</span><span class="mi">64</span>
<span class="n">channels</span><span class="o">-</span><span class="n">per</span><span class="o">-</span><span class="n">pixel</span><span class="o">=</span><span class="mi">8</span>
<span class="n">Bounding</span><span class="o">-</span><span class="n">Box</span><span class="n">Lower</span><span class="o">-</span><span class="n">Corner</span><span class="n">W</span><span class="o">=</span><span class="mi">-1</span>
<span class="n">Bounding</span><span class="o">-</span><span class="n">Box</span><span class="n">Lower</span><span class="o">-</span><span class="n">Corner</span><span class="n">H</span><span class="o">=</span><span class="mi">-1</span>
<span class="n">Bounding</span><span class="o">-</span><span class="n">Box</span><span class="n">Upper</span><span class="o">-</span><span class="n">Corner</span><span class="n">W</span><span class="o">=</span><span class="mi">-1</span>
<span class="n">Bounding</span><span class="o">-</span><span class="n">Box</span><span class="n">Upper</span><span class="o">-</span><span class="n">Corner</span><span class="n">H</span><span class="o">=</span><span class="mf">-1.</span>

<span class="n">tensor</span><span class="n">coordinates</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">im2col</span><span class="n">offsets</span><span class="o">:</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
</pre>
   <p>
    <span class="caption-number">
     Figure 9
    </span>
    <span class="caption-text">
     im2col mode example 1
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-im2col-mode-example1" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
  <li>
   <p>
    Example 2 (
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-im2col-mode-example2">
     <span class="std std-numref">
      Figure 10
     </span>
    </a>
    ):
   </p>
   <pre><span class="n">Tensor</span><span class="n">Size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">64</span>
<span class="n">Tensor</span><span class="n">Size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">9</span>
<span class="n">Tensor</span><span class="n">Size</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="mi">14</span>
<span class="n">Tensor</span><span class="n">Size</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="mi">64</span>
<span class="n">Pixels</span><span class="o">-</span><span class="n">per</span><span class="o">-</span><span class="n">Column</span><span class="o">=</span><span class="mi">64</span>
<span class="n">channels</span><span class="o">-</span><span class="n">per</span><span class="o">-</span><span class="n">pixel</span><span class="o">=</span><span class="mi">8</span>
<span class="n">Bounding</span><span class="o">-</span><span class="n">Box</span><span class="n">Lower</span><span class="o">-</span><span class="n">Corner</span><span class="n">W</span><span class="o">=</span><span class="mi">0</span>
<span class="n">Bounding</span><span class="o">-</span><span class="n">Box</span><span class="n">Lower</span><span class="o">-</span><span class="n">Corner</span><span class="n">H</span><span class="o">=</span><span class="mi">0</span>
<span class="n">Bounding</span><span class="o">-</span><span class="n">Box</span><span class="n">Upper</span><span class="o">-</span><span class="n">Corner</span><span class="n">W</span><span class="o">=</span><span class="mi">-2</span>
<span class="n">Bounding</span><span class="o">-</span><span class="n">Box</span><span class="n">Upper</span><span class="o">-</span><span class="n">Corner</span><span class="n">H</span><span class="o">=</span><span class="mi">-2</span>

<span class="n">tensor</span><span class="n">coordinates</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">im2col</span><span class="n">offsets</span><span class="o">:</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
</pre>
   <p>
    <span class="caption-number">
     Figure 10
    </span>
    <span class="caption-text">
     im2col mode example 2
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-im2col-mode-example2" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
 </ul>
 <h4>
  <span class="section-number">
   5.5.4.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-im2col-mode-traversal-stride">
   Traversal Stride
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-im2col-mode-traversal-stride" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The traversal stride, in im2col mode, does not impact the total number of elements (or pixels) being
accessed unlike the tiled mode. Pixels-per-Column determines the total number of elements being
accessed, in im2col mode.
 </p>
 <p>
  The number of elements traversed along the D, H and W dimensions is strided by the traversal stride
for that dimension.
 </p>
 <p>
  The following example with
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-im2col-mode-example3">
   <span class="std std-numref">
    Figure 11
   </span>
  </a>
  illustrates accesse with traversal-strides:
 </p>
 <pre><span class="n">Tensor</span><span class="n">Size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">64</span>
<span class="n">Tensor</span><span class="n">Size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">8</span>
<span class="n">Tensor</span><span class="n">Size</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="mi">14</span>
<span class="n">Tensor</span><span class="n">Size</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="mi">64</span>
<span class="n">Traversal</span><span class="n">Stride</span><span class="o">=</span><span class="mi">2</span>
<span class="n">Pixels</span><span class="o">-</span><span class="n">per</span><span class="o">-</span><span class="n">Column</span><span class="o">=</span><span class="mi">32</span>
<span class="n">channels</span><span class="o">-</span><span class="n">per</span><span class="o">-</span><span class="n">pixel</span><span class="o">=</span><span class="mi">16</span>
<span class="n">Bounding</span><span class="o">-</span><span class="n">Box</span><span class="n">Lower</span><span class="o">-</span><span class="n">Corner</span><span class="n">W</span><span class="o">=</span><span class="mi">-1</span>
<span class="n">Bounding</span><span class="o">-</span><span class="n">Box</span><span class="n">Lower</span><span class="o">-</span><span class="n">Corner</span><span class="n">H</span><span class="o">=</span><span class="mi">-1</span>
<span class="n">Bounding</span><span class="o">-</span><span class="n">Box</span><span class="n">Upper</span><span class="o">-</span><span class="n">Corner</span><span class="n">W</span><span class="o">=</span><span class="mi">-1</span>
<span class="n">Bounding</span><span class="o">-</span><span class="n">Box</span><span class="n">Upper</span><span class="o">-</span><span class="n">Corner</span><span class="n">H</span><span class="o">=</span><span class="mf">-1.</span>
<span class="n">Tensor</span><span class="n">coordinates</span><span class="n">in</span><span class="n">the</span><span class="n">instruction</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">Im2col</span><span class="n">offsets</span><span class="n">in</span><span class="n">the</span><span class="n">instruction</span><span class="o">:</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</pre>
 <p>
  <span class="caption-number">
   Figure 11
  </span>
  <span class="caption-text">
   im2col mode traversal stride example
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-im2col-mode-example3" title="Permalink to this image">
   ï
  </a>
 </p>
 <h4>
  <span class="section-number">
   5.5.4.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-im2col-mode-oob-access">
   Out of Boundary Access
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-im2col-mode-oob-access" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  In im2col mode, when the number of requested pixels in NDHW space specified by
  Pixels-per-Column
  exceeds the number of available pixels in the image batch then out-of-bounds access is performed.
 </p>
 <p>
  Similar to tiled mode, zero fill or
  <span class="pre">
   OOB-NaN
  </span>
  fill can be performed based on the Fill-Mode
specified.
 </p>
 <h3>
  <span class="section-number">
   5.5.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-interleaved-layout">
   Interleave layout
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#interleave-layout" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Tensor can be interleaved and the following interleave layouts are supported:
 </p>
 <ul class="simple">
  <li>
   <p>
    No interleave (NDHWC)
   </p>
  </li>
  <li>
   <p>
    8 byte interleave (NC/8DHWC8) : C8 utilizes 16 bytes in memory assuming 2B per channel.
   </p>
  </li>
  <li>
   <p>
    16 byte interleave (NC/16HWC16) : C16 utilizes 32 bytes in memory assuming 4B per channel.
   </p>
  </li>
 </ul>
 <p>
  The
  C
  information is organized in slices where sequential C elements are grouped in 16 byte or 32
byte quantities.
 </p>
 <p>
  If the total number of channels is not a multiple of the number of channels per slice, then the last
slice must be padded with zeros to make it complete 16B or 32B slice.
 </p>
 <p>
  Interleaved layouts are supported only for the dimensionalities : 3D, 4D and 5D.
 </p>
 <h3>
  <span class="section-number">
   5.5.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-swizzling-modes">
   Swizzling Modes
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#swizzling-modes" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The layout of the data in the shared memory can be different to that of global memory, for access
performance reasons. The following describes various swizzling modes:
 </p>
 <ul>
  <li>
   <p>
    No swizzle mode:
   </p>
   <p>
    There is no swizzling in this mode and the destination data layout is exactly similar to the
source data layout.
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <td>
      <p>
       0
      </p>
     </td>
     <td>
      <p>
       1
      </p>
     </td>
     <td>
      <p>
       2
      </p>
     </td>
     <td>
      <p>
       3
      </p>
     </td>
     <td>
      <p>
       4
      </p>
     </td>
     <td>
      <p>
       5
      </p>
     </td>
     <td>
      <p>
       6
      </p>
     </td>
     <td>
      <p>
       7
      </p>
     </td>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       0
      </p>
     </td>
     <td>
      <p>
       1
      </p>
     </td>
     <td>
      <p>
       2
      </p>
     </td>
     <td>
      <p>
       3
      </p>
     </td>
     <td>
      <p>
       4
      </p>
     </td>
     <td>
      <p>
       5
      </p>
     </td>
     <td>
      <p>
       6
      </p>
     </td>
     <td>
      <p>
       7
      </p>
     </td>
    </tr>
    <tr class="row-odd">
     <td colspan="8">
      <p>
       â¦ Pattern repeats â¦
      </p>
     </td>
    </tr>
   </table>
  </li>
  <li>
   <p>
    32 byte swizzle mode:
   </p>
   <p>
    The following table, where each elements (numbered cell) is 16 byte and the starting address is
256 bytes aligned, shows the pattern of the destination data layout:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <td>
      <p>
       0
      </p>
     </td>
     <td>
      <p>
       1
      </p>
     </td>
     <td>
      <p>
       2
      </p>
     </td>
     <td>
      <p>
       3
      </p>
     </td>
     <td>
      <p>
       4
      </p>
     </td>
     <td>
      <p>
       5
      </p>
     </td>
     <td>
      <p>
       6
      </p>
     </td>
     <td>
      <p>
       7
      </p>
     </td>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       1
      </p>
     </td>
     <td>
      <p>
       0
      </p>
     </td>
     <td>
      <p>
       3
      </p>
     </td>
     <td>
      <p>
       2
      </p>
     </td>
     <td>
      <p>
       5
      </p>
     </td>
     <td>
      <p>
       4
      </p>
     </td>
     <td>
      <p>
       7
      </p>
     </td>
     <td>
      <p>
       6
      </p>
     </td>
    </tr>
    <tr class="row-odd">
     <td colspan="8">
      <p>
       â¦ Pattern repeats â¦
      </p>
     </td>
    </tr>
   </table>
   <p>
    An example of the 32 byte swizzle mode for NC/(32B)HWC(32B) tensor of 1x2x10x10xC16 dimension,
with the innermost dimension holding slice of 16 channels with 2 byte/channel, is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-32b-swizzle">
     <span class="std std-numref">
      Figure 12
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 12
    </span>
    <span class="caption-text">
     32-byte swizzle mode example
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-32b-swizzle" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-32b-swizzle-frag">
     <span class="std std-numref">
      Figure 13
     </span>
    </a>
    shows the two fragments of the tensor : one for C/(32B) = 0 and another for C/(32B) = 1.
   </p>
   <p>
    <span class="caption-number">
     Figure 13
    </span>
    <span class="caption-text">
     32-byte swizzle mode fragments
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-32b-swizzle-frag" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-32b-swizzle-dst">
     <span class="std std-numref">
      Figure 14
     </span>
    </a>
    shows the destination data layout with 32 byte swizzling.
   </p>
   <p>
    <span class="caption-number">
     Figure 14
    </span>
    <span class="caption-text">
     32-byte swizzle mode destination data layout
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-32b-swizzle-dst" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
  <li>
   <p>
    64 byte swizzle mode:
   </p>
   <p>
    The following table, where each elements (numbered cell) is 16 byte and the starting address is
512 bytes aligned, shows the pattern of the destination data layout:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <td>
      <p>
       0
      </p>
     </td>
     <td>
      <p>
       1
      </p>
     </td>
     <td>
      <p>
       2
      </p>
     </td>
     <td>
      <p>
       3
      </p>
     </td>
     <td>
      <p>
       4
      </p>
     </td>
     <td>
      <p>
       5
      </p>
     </td>
     <td>
      <p>
       6
      </p>
     </td>
     <td>
      <p>
       7
      </p>
     </td>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       1
      </p>
     </td>
     <td>
      <p>
       0
      </p>
     </td>
     <td>
      <p>
       3
      </p>
     </td>
     <td>
      <p>
       2
      </p>
     </td>
     <td>
      <p>
       5
      </p>
     </td>
     <td>
      <p>
       4
      </p>
     </td>
     <td>
      <p>
       7
      </p>
     </td>
     <td>
      <p>
       6
      </p>
     </td>
    </tr>
    <tr class="row-odd">
     <td>
      <p>
       2
      </p>
     </td>
     <td>
      <p>
       3
      </p>
     </td>
     <td>
      <p>
       0
      </p>
     </td>
     <td>
      <p>
       1
      </p>
     </td>
     <td>
      <p>
       6
      </p>
     </td>
     <td>
      <p>
       7
      </p>
     </td>
     <td>
      <p>
       4
      </p>
     </td>
     <td>
      <p>
       5
      </p>
     </td>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       3
      </p>
     </td>
     <td>
      <p>
       2
      </p>
     </td>
     <td>
      <p>
       1
      </p>
     </td>
     <td>
      <p>
       0
      </p>
     </td>
     <td>
      <p>
       7
      </p>
     </td>
     <td>
      <p>
       6
      </p>
     </td>
     <td>
      <p>
       5
      </p>
     </td>
     <td>
      <p>
       4
      </p>
     </td>
    </tr>
    <tr class="row-odd">
     <td colspan="8">
      <p>
       â¦ Pattern repeats â¦
      </p>
     </td>
    </tr>
   </table>
   <p>
    An example of the 64 byte swizzle mode for NHWC tensor of 1x10x10x64 dimension, with 2 bytes /
channel and 32 channels, is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-64b-swizzle">
     <span class="std std-numref">
      Figure 15
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 15
    </span>
    <span class="caption-text">
     64-byte swizzle mode example
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-64b-swizzle" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    Each colored cell represents 8 channels.
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-64b-swizzle-src">
     <span class="std std-numref">
      Figure 16
     </span>
    </a>
    shows the source data layout.
   </p>
   <p>
    <span class="caption-number">
     Figure 16
    </span>
    <span class="caption-text">
     64-byte swizzle mode source data layout
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-64b-swizzle-src" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-64b-swizzle-dst">
     <span class="std std-numref">
      Figure 17
     </span>
    </a>
    shows the destination data layout with 64 byte swizzling.
   </p>
   <p>
    <span class="caption-number">
     Figure 17
    </span>
    <span class="caption-text">
     64-byte swizzle mode destination data layout
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-64b-swizzle-dst" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
  <li>
   <p>
    128 byte swizzle mode:
   </p>
   <p>
    The following table, where each elements (numbered cell) is 16 byte and the starting address is
1024 bytes aligned, shows the pattern of the destination data layout:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <td>
      <p>
       0
      </p>
     </td>
     <td>
      <p>
       1
      </p>
     </td>
     <td>
      <p>
       2
      </p>
     </td>
     <td>
      <p>
       3
      </p>
     </td>
     <td>
      <p>
       4
      </p>
     </td>
     <td>
      <p>
       5
      </p>
     </td>
     <td>
      <p>
       6
      </p>
     </td>
     <td>
      <p>
       7
      </p>
     </td>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       1
      </p>
     </td>
     <td>
      <p>
       0
      </p>
     </td>
     <td>
      <p>
       3
      </p>
     </td>
     <td>
      <p>
       2
      </p>
     </td>
     <td>
      <p>
       5
      </p>
     </td>
     <td>
      <p>
       4
      </p>
     </td>
     <td>
      <p>
       7
      </p>
     </td>
     <td>
      <p>
       6
      </p>
     </td>
    </tr>
    <tr class="row-odd">
     <td>
      <p>
       2
      </p>
     </td>
     <td>
      <p>
       3
      </p>
     </td>
     <td>
      <p>
       0
      </p>
     </td>
     <td>
      <p>
       1
      </p>
     </td>
     <td>
      <p>
       6
      </p>
     </td>
     <td>
      <p>
       7
      </p>
     </td>
     <td>
      <p>
       4
      </p>
     </td>
     <td>
      <p>
       5
      </p>
     </td>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       3
      </p>
     </td>
     <td>
      <p>
       2
      </p>
     </td>
     <td>
      <p>
       1
      </p>
     </td>
     <td>
      <p>
       0
      </p>
     </td>
     <td>
      <p>
       7
      </p>
     </td>
     <td>
      <p>
       6
      </p>
     </td>
     <td>
      <p>
       5
      </p>
     </td>
     <td>
      <p>
       4
      </p>
     </td>
    </tr>
    <tr class="row-odd">
     <td>
      <p>
       4
      </p>
     </td>
     <td>
      <p>
       5
      </p>
     </td>
     <td>
      <p>
       6
      </p>
     </td>
     <td>
      <p>
       7
      </p>
     </td>
     <td>
      <p>
       0
      </p>
     </td>
     <td>
      <p>
       1
      </p>
     </td>
     <td>
      <p>
       2
      </p>
     </td>
     <td>
      <p>
       3
      </p>
     </td>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       5
      </p>
     </td>
     <td>
      <p>
       4
      </p>
     </td>
     <td>
      <p>
       7
      </p>
     </td>
     <td>
      <p>
       6
      </p>
     </td>
     <td>
      <p>
       1
      </p>
     </td>
     <td>
      <p>
       0
      </p>
     </td>
     <td>
      <p>
       3
      </p>
     </td>
     <td>
      <p>
       2
      </p>
     </td>
    </tr>
    <tr class="row-odd">
     <td>
      <p>
       6
      </p>
     </td>
     <td>
      <p>
       7
      </p>
     </td>
     <td>
      <p>
       4
      </p>
     </td>
     <td>
      <p>
       5
      </p>
     </td>
     <td>
      <p>
       2
      </p>
     </td>
     <td>
      <p>
       3
      </p>
     </td>
     <td>
      <p>
       0
      </p>
     </td>
     <td>
      <p>
       1
      </p>
     </td>
    </tr>
    <tr class="row-even">
     <td colspan="8">
      <p>
       â¦ Pattern repeats â¦
      </p>
     </td>
    </tr>
   </table>
   <p>
    An example of the 128 byte swizzle mode for NHWC tensor of 1x10x10x64 dimension, with 2 bytes /
channel and 64 channels, is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-128b-swizzle">
     <span class="std std-numref">
      Figure 18
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 18
    </span>
    <span class="caption-text">
     128-byte swizzle mode example
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-128b-swizzle" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    Each colored cell represents 8 channels.
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-128b-swizzle-src">
     <span class="std std-numref">
      Figure 19
     </span>
    </a>
    shows the source data layout.
   </p>
   <p>
    <span class="caption-number">
     Figure 19
    </span>
    <span class="caption-text">
     128-byte swizzle mode source data layout
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-128b-swizzle-src" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-128b-swizzle-dst">
     <span class="std std-numref">
      Figure 20
     </span>
    </a>
    shows the destination data layout with 128 byte swizzling.
   </p>
   <p>
    <span class="caption-number">
     Figure 20
    </span>
    <span class="caption-text">
     128-byte swizzle mode destination data layout
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-128b-swizzle-dst" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
 </ul>
 <h3>
  <span class="section-number">
   5.5.7.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-tensormap">
   Tensor-map
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-map" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The tensor-map is a 128-byte opaque object either in
  <span class="pre">
   .const
  </span>
  space or
  <span class="pre">
   .param
  </span>
  (kernel function
parameter) space or
  <span class="pre">
   .global
  </span>
  space which describes the tensor properties and the access properties
of the tensor data described in previous sections.
 </p>
 <p>
  Tensor-Map can be created using CUDA APIs. Refer to
  CUDA programming guide
  for more details.
 </p>
 <h1>
  <span class="section-number">
   6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#instruction-operands">
   Instruction Operands
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#instruction-operands" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <h2>
  <span class="section-number">
   6.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#operand-type-information">
   Operand Type Information
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#operand-type-information" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  All operands in instructions have a known type from their declarations. Each operand type must be
compatible with the type determined by the instruction template and instruction type. There is no
automatic conversion between types.
 </p>
 <p>
  The bit-size type is compatible with every type having the same size. Integer types of a common size
are compatible with each other. Operands having type different from but compatible with the
instruction type are silently cast to the instruction type.
 </p>
 <h2>
  <span class="section-number">
   6.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#source-operands">
   Source Operands
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#source-operands" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  The source operands are denoted in the instruction descriptions by the names
  <span class="pre">
   a
  </span>
  ,
  <span class="pre">
   b
  </span>
  , and
  <span class="pre">
   c
  </span>
  . PTX describes a load-store machine, so operands for ALU instructions must all be in variables
declared in the
  <span class="pre">
   .reg
  </span>
  register state space. For most operations, the sizes of the operands must
be consistent.
 </p>
 <p>
  The
  <span class="pre">
   cvt
  </span>
  (convert) instruction takes a variety of operand types and sizes, as its job is to
convert from nearly any data type to any other data type (and size).
 </p>
 <p>
  The
  <span class="pre">
   ld
  </span>
  ,
  <span class="pre">
   st
  </span>
  ,
  <span class="pre">
   mov
  </span>
  , and
  <span class="pre">
   cvt
  </span>
  instructions copy data from one location to
another. Instructions
  <span class="pre">
   ld
  </span>
  and
  <span class="pre">
   st
  </span>
  move data from/to addressable state spaces to/from
registers. The
  <span class="pre">
   mov
  </span>
  instruction copies data between registers.
 </p>
 <p>
  Most instructions have an optional predicate guard that controls conditional execution, and a few
instructions have additional predicate source operands. Predicate operands are denoted by the names
  <span class="pre">
   p
  </span>
  ,
  <span class="pre">
   q
  </span>
  ,
  <span class="pre">
   r
  </span>
  ,
  <span class="pre">
   s
  </span>
  .
 </p>
 <h2>
  <span class="section-number">
   6.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#destination-operands">
   Destination Operands
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#destination-operands" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  PTX instructions that produce a single result store the result in the field denoted by
  <span class="pre">
   d
  </span>
  (for
destination) in the instruction descriptions. The result operand is a scalar or vector variable in
the register state space.
 </p>
 <h2>
  <span class="section-number">
   6.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#using-addresses-arrays-and-vectors">
   Using Addresses, Arrays, and Vectors
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#using-addresses-arrays-and-vectors" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  Using scalar variables as operands is straightforward. The interesting capabilities begin with
addresses, arrays, and vectors.
 </p>
 <h3>
  <span class="section-number">
   6.4.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#addresses-as-operands">
   Addresses as Operands
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#addresses-as-operands" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  All the memory instructions take an address operand that specifies the memory location being
accessed. This addressable operand is one of:
 </p>
 <span class="pre">
  [var]
 </span>
 <p>
  the name of an addressable variable
  <span class="pre">
   var
  </span>
  .
 </p>
 <span class="pre">
  [reg]
 </span>
 <p>
  an integer or bit-size type register
  <span class="pre">
   reg
  </span>
  containing a byte address.
 </p>
 <span class="pre">
  [reg+immOff]
 </span>
 <p>
  a sum of register
  <span class="pre">
   reg
  </span>
  containing a byte address plus a constant integer byte offset (signed, 32-bit).
 </p>
 <span class="pre">
  [var+immOff]
 </span>
 <p>
  a sum of address of addressable variable
  <span class="pre">
   var
  </span>
  containing a byte address plus a constant integer
byte offset (signed, 32-bit).
 </p>
 <span class="pre">
  [immAddr]
 </span>
 <p>
  an immediate absolute byte address (unsigned, 32-bit).
 </p>
 <span class="pre">
  var[immOff]
 </span>
 <p>
  an array element as described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#arrays-as-operands">
   Arrays as Operands
  </a>
  .
 </p>
 <p>
  The register containing an address may be declared as a bit-size type or integer type.
 </p>
 <p>
  The access size of a memory instruction is the total number of bytes accessed in memory. For
example, the access size of
  <span class="pre">
   ld.v4.b32
  </span>
  is 16 bytes, while the access size of
  <span class="pre">
   atom.f16x2
  </span>
  is 4
bytes.
 </p>
 <p>
  The address must be naturally aligned to a multiple of the access size. If an address is not
properly aligned, the resulting behavior is undefined. For example, among other things, the access
may proceed by silently masking off low-order address bits to achieve proper rounding, or the
instruction may fault.
 </p>
 <p>
  The address size may be either 32-bit or 64-bit. 128-bit adresses are not supported. Addresses are
zero-extended to the specified width as needed, and truncated if the register width exceeds the
state space address width for the target architecture.
 </p>
 <p>
  Address arithmetic is performed using integer arithmetic and logical instructions. Examples include
pointer arithmetic and pointer comparisons. All addresses and address computations are byte-based;
there is no support for C-style pointer arithmetic.
 </p>
 <p>
  The
  <span class="pre">
   mov
  </span>
  instruction can be used to move the address of a variable into a pointer. The address is
an offset in the state space in which the variable is declared. Load and store operations move data
between registers and locations in addressable state spaces. The syntax is similar to that used in
many assembly languages, where scalar variables are simply named and addresses are de-referenced by
enclosing the address expression in square brackets. Address expressions include variable names,
address registers, address register plus byte offset, and immediate address expressions which
evaluate at compile-time to a constant address.
 </p>
 <p>
  Here are a few examples:
 </p>
 <pre>.shared .u16 x;
.reg    .u16 r0;
.global .v4 .f32 V;
.reg    .v4 .f32 W;
.const  .s32 tbl[256];
.reg    .b32 p;
.reg    .s32 q;

ld.shared.u16   r0,[x];
ld.global.v4.f32 W, [V];
ld.const.s32    q, [tbl+12];
mov.u32         p, tbl;
</pre>
 <h4>
  <span class="section-number">
   6.4.1.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#generic-addressing">
   Generic Addressing
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#generic-addressing" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  If a memory instruction does not specify a state space, the operation is performed using generic
addressing. The state spaces
  <span class="pre">
   .const
  </span>
  ,
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-function-parameters">
   Kernel Function Parameters
  </a>
  (
  <span class="pre">
   .param
  </span>
  ),
  <span class="pre">
   .local
  </span>
  and
  <span class="pre">
   .shared
  </span>
  are modeled as
windows within the generic address space. Each window is defined by a window base and a window size
that is equal to the size of the corresponding state space. A generic address maps to
  <span class="pre">
   global
  </span>
  memory unless it falls within the window for
  <span class="pre">
   const
  </span>
  ,
  <span class="pre">
   local
  </span>
  , or
  <span class="pre">
   shared
  </span>
  memory. The
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-function-parameters">
   Kernel
Function Parameters
  </a>
  (
  <span class="pre">
   .param
  </span>
  ) window is contained
within the
  <span class="pre">
   .global
  </span>
  window. Within each window, a generic address maps to an address in the
underlying state space by subtracting the window base from the generic address.
 </p>
 <h3>
  <span class="section-number">
   6.4.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#arrays-as-operands">
   Arrays as Operands
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#arrays-as-operands" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Arrays of all types can be declared, and the identifier becomes an address constant in the space
where the array is declared. The size of the array is a constant in the program.
 </p>
 <p>
  Array elements can be accessed using an explicitly calculated byte address, or by indexing into the
array using square-bracket notation. The expression within square brackets is either a constant
integer, a register variable, or a simple
  register with constant offset
  expression, where the
offset is a constant expression that is either added or subtracted from a register variable. If more
complicated indexing is desired, it must be written as an address calculation prior to use. Examples
are:
 </p>
 <pre>ld.global.u32  s, a[0];
ld.global.u32  s, a[N-1];
mov.u32        s, a[1];  // move address of a[1] into s
</pre>
 <h3>
  <span class="section-number">
   6.4.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#vectors-as-operands">
   Vectors as Operands
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#vectors-as-operands" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Vector operands are supported by a limited subset of instructions, which include
  <span class="pre">
   mov
  </span>
  ,
  <span class="pre">
   ld
  </span>
  ,
  <span class="pre">
   st
  </span>
  ,
  <span class="pre">
   atom
  </span>
  ,
  <span class="pre">
   red
  </span>
  and
  <span class="pre">
   tex
  </span>
  . Vectors may also be passed as arguments to called functions.
 </p>
 <p>
  Vector elements can be extracted from the vector with the suffixes
  <span class="pre">
   .x
  </span>
  ,
  <span class="pre">
   .y
  </span>
  ,
  <span class="pre">
   .z
  </span>
  and
  <span class="pre">
   .w
  </span>
  , as well as the typical color fields
  <span class="pre">
   .r
  </span>
  ,
  <span class="pre">
   .g
  </span>
  ,
  <span class="pre">
   .b
  </span>
  and
  <span class="pre">
   .a
  </span>
  .
 </p>
 <p>
  A brace-enclosed list is used for pattern matching to pull apart vectors.
 </p>
 <pre>.reg .v4 .f32 V;
.reg .f32     a, b, c, d;

mov.v4.f32 {a,b,c,d}, V;
</pre>
 <p>
  Vector loads and stores can be used to implement wide loads and stores, which may improve memory
performance. The registers in the load/store operations can be a vector, or a brace-enclosed list of
similarly typed scalars. Here are examples:
 </p>
 <pre>ld.global.v4.f32  {a,b,c,d}, [addr+16];
ld.global.v2.u32  V2, [addr+8];
</pre>
 <p>
  Elements in a brace-enclosed vector, say {Ra, Rb, Rc, Rd}, correspond to extracted elements as follows:
 </p>
 <pre>Ra = V.x = V.r
Rb = V.y = V.g
Rc = V.z = V.b
Rd = V.w = V.a
</pre>
 <h3>
  <span class="section-number">
   6.4.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#labels-and-function-names-as-operands">
   Labels and Function Names as Operands
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#labels-and-function-names-as-operands" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Labels and function names can be used only in
  <span class="pre">
   bra
  </span>
  /
  <span class="pre">
   brx.idx
  </span>
  and
  <span class="pre">
   call
  </span>
  instructions
respectively. Function names can be used in
  <span class="pre">
   mov
  </span>
  instruction to get the address of the function
into a register, for use in an indirect call.
 </p>
 <p>
  Beginning in PTX ISA version 3.1, the
  <span class="pre">
   mov
  </span>
  instruction may be used to take the address of kernel
functions, to be passed to a system call that initiates a kernel launch from the GPU. This feature
is part of the support for CUDA Dynamic Parallelism. See the
  CUDA Dynamic Parallelism Programming
Guide
  for details.
 </p>
 <h2>
  <span class="section-number">
   6.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#type-conversion">
   Type Conversion
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#type-conversion" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  All operands to all arithmetic, logic, and data movement instruction must be of the same type and
size, except for operations where changing the size and/or type is part of the definition of the
instruction. Operands of different sizes or types must be converted prior to the operation.
 </p>
 <h3>
  <span class="section-number">
   6.5.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#scalar-conversions">
   Scalar Conversions
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#scalar-conversions" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#scalar-conversions-convert-instruction-precision-and-format">
   <span class="std std-numref">
    Table 13
   </span>
  </a>
  shows what
precision and format the cvt instruction uses given operands of differing types. For example, if a
  <span class="pre">
   cvt.s32.u16
  </span>
  instruction is given a
  <span class="pre">
   u16
  </span>
  source operand and
  <span class="pre">
   s32
  </span>
  as a destination operand,
the
  <span class="pre">
   u16
  </span>
  is zero-extended to
  <span class="pre">
   s32
  </span>
  .
 </p>
 <p>
  Conversions to floating-point that are beyond the range of floating-point numbers are represented
with the maximum floating-point value (IEEE 754 Inf for
  <span class="pre">
   f32
  </span>
  and
  <span class="pre">
   f64
  </span>
  , and ~131,000 for
  <span class="pre">
   f16
  </span>
  ).
 </p>
 <table class="table-no-stripes docutils align-default" id="scalar-conversions-convert-instruction-precision-and-format">
  <span class="caption-number">
   Table 13
  </span>
  <span class="caption-text">
   Convert Instruction Precision and Format
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#scalar-conversions-convert-instruction-precision-and-format" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head" colspan="11">
    <p>
     Destination Format
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <th class="head">
    <p>
     s8
    </p>
   </th>
   <th class="head">
    <p>
     s16
    </p>
   </th>
   <th class="head">
    <p>
     s32
    </p>
   </th>
   <th class="head">
    <p>
     s64
    </p>
   </th>
   <th class="head">
    <p>
     u8
    </p>
   </th>
   <th class="head">
    <p>
     u16
    </p>
   </th>
   <th class="head">
    <p>
     u32
    </p>
   </th>
   <th class="head">
    <p>
     u64
    </p>
   </th>
   <th class="head">
    <p>
     f16
    </p>
   </th>
   <th class="head">
    <p>
     f32
    </p>
   </th>
   <th class="head">
    <p>
     f64
    </p>
   </th>
  </tr>
  <tr class="row-odd">
   <td rowspan="11">
    <p>
     Source
Format
    </p>
   </td>
   <td>
    <p>
     s8
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     s2f
    </p>
   </td>
   <td>
    <p>
     s2f
    </p>
   </td>
   <td>
    <p>
     s2f
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     s16
    </p>
   </td>
   <td>
    <p>
     chop
     1
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     chop
     1
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     s2f
    </p>
   </td>
   <td>
    <p>
     s2f
    </p>
   </td>
   <td>
    <p>
     s2f
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     s32
    </p>
   </td>
   <td>
    <p>
     chop
     1
    </p>
   </td>
   <td>
    <p>
     chop
     1
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     chop
     1
    </p>
   </td>
   <td>
    <p>
     chop
     1
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     s2f
    </p>
   </td>
   <td>
    <p>
     s2f
    </p>
   </td>
   <td>
    <p>
     s2f
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     s64
    </p>
   </td>
   <td>
    <p>
     chop
     1
    </p>
   </td>
   <td>
    <p>
     chop
     1
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
     1
    </p>
   </td>
   <td>
    <p>
     chop
     1
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     s2f
    </p>
   </td>
   <td>
    <p>
     s2f
    </p>
   </td>
   <td>
    <p>
     s2f
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     u8
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     u2f
    </p>
   </td>
   <td>
    <p>
     u2f
    </p>
   </td>
   <td>
    <p>
     u2f
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     u16
    </p>
   </td>
   <td>
    <p>
     chop
     1
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     chop
     1
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     u2f
    </p>
   </td>
   <td>
    <p>
     u2f
    </p>
   </td>
   <td>
    <p>
     u2f
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     u32
    </p>
   </td>
   <td>
    <p>
     chop
     1
    </p>
   </td>
   <td>
    <p>
     chop
     1
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     chop
     1
    </p>
   </td>
   <td>
    <p>
     chop
     1
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     u2f
    </p>
   </td>
   <td>
    <p>
     u2f
    </p>
   </td>
   <td>
    <p>
     u2f
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     u64
    </p>
   </td>
   <td>
    <p>
     chop
     1
    </p>
   </td>
   <td>
    <p>
     chop
     1
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
     1
    </p>
   </td>
   <td>
    <p>
     chop
     1
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     u2f
    </p>
   </td>
   <td>
    <p>
     u2f
    </p>
   </td>
   <td>
    <p>
     u2f
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     f16
    </p>
   </td>
   <td>
    <p>
     f2s
    </p>
   </td>
   <td>
    <p>
     f2s
    </p>
   </td>
   <td>
    <p>
     f2s
    </p>
   </td>
   <td>
    <p>
     f2s
    </p>
   </td>
   <td>
    <p>
     f2u
    </p>
   </td>
   <td>
    <p>
     f2u
    </p>
   </td>
   <td>
    <p>
     f2u
    </p>
   </td>
   <td>
    <p>
     f2u
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     f2f
    </p>
   </td>
   <td>
    <p>
     f2f
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     f32
    </p>
   </td>
   <td>
    <p>
     f2s
    </p>
   </td>
   <td>
    <p>
     f2s
    </p>
   </td>
   <td>
    <p>
     f2s
    </p>
   </td>
   <td>
    <p>
     f2s
    </p>
   </td>
   <td>
    <p>
     f2u
    </p>
   </td>
   <td>
    <p>
     f2u
    </p>
   </td>
   <td>
    <p>
     f2u
    </p>
   </td>
   <td>
    <p>
     f2u
    </p>
   </td>
   <td>
    <p>
     f2f
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     f2f
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     f64
    </p>
   </td>
   <td>
    <p>
     f2s
    </p>
   </td>
   <td>
    <p>
     f2s
    </p>
   </td>
   <td>
    <p>
     f2s
    </p>
   </td>
   <td>
    <p>
     f2s
    </p>
   </td>
   <td>
    <p>
     f2u
    </p>
   </td>
   <td>
    <p>
     f2u
    </p>
   </td>
   <td>
    <p>
     f2u
    </p>
   </td>
   <td>
    <p>
     f2u
    </p>
   </td>
   <td>
    <p>
     f2f
    </p>
   </td>
   <td>
    <p>
     f2f
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td colspan="2">
    <p>
     Notes
    </p>
   </td>
   <td colspan="11">
    <p>
     sext = sign-extend; zext = zero-extend; chop = keep only low bits that fit;
    </p>
    <p>
     s2f = signed-to-float; f2s = float-to-signed; u2f = unsigned-to-float;
    </p>
    <p>
     f2u = float-to-unsigned; f2f = float-to-float.
    </p>
    <p>
     1
     If the destination register is wider than the destination format, the result is extended to the
destination register width after chopping. The type of extension (sign or zero) is based on the
destination format. For example, cvt.s16.u32 targeting a 32-bit register first chops to 16-bit, then
sign-extends to 32-bit.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   6.5.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#rounding-modifiers">
   Rounding Modifiers
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#rounding-modifiers" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Conversion instructions may specify a rounding modifier. In PTX, there are four integer rounding
modifiers and four floating-point rounding
modifiers.
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#rounding-modifiers-floating-point-rounding-modifiers">
   <span class="std std-numref">
    Table 14
   </span>
  </a>
  and
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#rounding-modifiers-integer-rounding-modifiers">
   <span class="std std-numref">
    Table 15
   </span>
  </a>
  summarize the rounding modifiers.
 </p>
 <table class="table-no-stripes docutils align-default" id="rounding-modifiers-floating-point-rounding-modifiers">
  <span class="caption-number">
   Table 14
  </span>
  <span class="caption-text">
   Floating-Point Rounding Modifiers
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#rounding-modifiers-floating-point-rounding-modifiers" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Modifier
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .rn
     </span>
    </p>
   </td>
   <td>
    <p>
     mantissa LSB rounds to nearest even
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .rna
     </span>
    </p>
   </td>
   <td>
    <p>
     mantissa LSB rounds to nearest, ties away from zero
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .rz
     </span>
    </p>
   </td>
   <td>
    <p>
     mantissa LSB rounds towards zero
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .rm
     </span>
    </p>
   </td>
   <td>
    <p>
     mantissa LSB rounds towards negative infinity
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .rp
     </span>
    </p>
   </td>
   <td>
    <p>
     mantissa LSB rounds towards positive infinity
    </p>
   </td>
  </tr>
 </table>
 <table class="table-no-stripes docutils align-default" id="rounding-modifiers-integer-rounding-modifiers">
  <span class="caption-number">
   Table 15
  </span>
  <span class="caption-text">
   Integer Rounding Modifiers
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#rounding-modifiers-integer-rounding-modifiers" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Modifier
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .rni
     </span>
    </p>
   </td>
   <td>
    <p>
     round to nearest integer, choosing even integer if source is equidistant between two integers.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .rzi
     </span>
    </p>
   </td>
   <td>
    <p>
     round to nearest integer in the direction of zero
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .rmi
     </span>
    </p>
   </td>
   <td>
    <p>
     round to nearest integer in direction of negative infinity
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .rpi
     </span>
    </p>
   </td>
   <td>
    <p>
     round to nearest integer in direction of positive infinity
    </p>
   </td>
  </tr>
 </table>
 <h2>
  <span class="section-number">
   6.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#operand-costs">
   Operand Costs
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#operand-costs" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  Operands from different state spaces affect the speed of an operation. Registers are fastest, while
global memory is slowest. Much of the delay to memory can be hidden in a number of ways. The first
is to have multiple threads of execution so that the hardware can issue a memory operation and then
switch to other execution. Another way to hide latency is to issue the load instructions as early as
possible, as execution is not blocked until the desired result is used in a subsequent (in time)
instruction. The register in a store operation is available much more
quickly.
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#operand-costs-cost-estimates-for-sccessing-state-spaces">
   <span class="std std-numref">
    Table 16
   </span>
  </a>
  gives estimates of the
costs of using different kinds of memory.
 </p>
 <table class="table-no-stripes docutils align-default" id="operand-costs-cost-estimates-for-sccessing-state-spaces">
  <span class="caption-number">
   Table 16
  </span>
  <span class="caption-text">
   Cost Estimates for Accessing State-Spaces
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#operand-costs-cost-estimates-for-sccessing-state-spaces" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Space
    </p>
   </th>
   <th class="head">
    <p>
     Time
    </p>
   </th>
   <th class="head">
    <p>
     Notes
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     Register
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     Shared
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     Constant
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     Amortized cost is low, first access is high
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     Local
    </p>
   </td>
   <td>
    <p>
     &gt; 100 clocks
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     Parameter
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     Immediate
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     Global
    </p>
   </td>
   <td>
    <p>
     &gt; 100 clocks
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     Texture
    </p>
   </td>
   <td>
    <p>
     &gt; 100 clocks
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     Surface
    </p>
   </td>
   <td>
    <p>
     &gt; 100 clocks
    </p>
   </td>
  </tr>
 </table>
 <h1>
  <span class="section-number">
   7.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#abstracting-abi">
   Abstracting the ABI
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#abstracting-the-abi" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <p>
  Rather than expose details of a particular calling convention, stack layout, and Application Binary
Interface (ABI), PTX provides a slightly higher-level abstraction and supports multiple ABI
implementations. In this section, we describe the features of PTX needed to achieve this hiding of
the ABI. These include syntax for function definitions, function calls, parameter passing, support
for variadic functions (
  <span class="pre">
   varargs
  </span>
  ), and memory allocated on the stack (
  <span class="pre">
   alloca
  </span>
  ).
 </p>
 <p>
  Refer to
  PTX Writers Guide to Interoperability
  for details on generating PTX compliant with
Application Binary Interface (ABI) for the CUDA
  Â®
  architecture.
 </p>
 <h2>
  <span class="section-number">
   7.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#function-declarations-and-definitions">
   Function Declarations and Definitions
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#function-declarations-and-definitions" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  In PTX, functions are declared and defined using the
  <span class="pre">
   .func
  </span>
  directive. A function
  declaration
  specifies an optional list of return parameters, the function name, and an optional list of input
parameters; together these specify the functionâs interface, or prototype. A function
  definition
  specifies both the interface and the body of the function. A function must be declared or defined
prior to being called.
 </p>
 <p>
  The simplest function has no parameters or return values, and is represented in PTX as follows:
 </p>
 <pre>.func foo
{
    ...
    ret;
}

    ...
    call foo;
    ...
</pre>
 <p>
  Here, execution of the
  <span class="pre">
   call
  </span>
  instruction transfers control to
  <span class="pre">
   foo
  </span>
  , implicitly saving the
return address. Execution of the
  <span class="pre">
   ret
  </span>
  instruction within
  <span class="pre">
   foo
  </span>
  transfers control to the
instruction following the call.
 </p>
 <p>
  Scalar and vector base-type input and return parameters may be represented simply as register
variables. At the call, arguments may be register variables or constants, and return values may be
placed directly into register variables. The arguments and return variables at the call must have
type and size that match the calleeâs corresponding formal parameters.
 </p>
 <p>
  Example
 </p>
 <pre>.func (.reg .u32 %res) inc_ptr ( .reg .u32 %ptr, .reg .u32 %inc )
{
    add.u32 %res, %ptr, %inc;
    ret;
}

    ...
    call (%r1), inc_ptr, (%r1,4);
    ...
</pre>
 <p>
  When using the ABI,
  <span class="pre">
   .reg
  </span>
  state space parameters must be at least 32-bits in size. Subword scalar
objects in the source language should be promoted to 32-bit registers in PTX, or use
  <span class="pre">
   .param
  </span>
  state space byte arrays described next.
 </p>
 <p>
  Objects such as C structures and unions are flattened into registers or byte arrays in PTX and are
represented using
  <span class="pre">
   .param
  </span>
  space memory. For example, consider the following C structure, passed
by value to a function:
 </p>
 <pre>struct {
    double dbl;
    char   c[4];
};
</pre>
 <p>
  In PTX, this structure will be flattened into a byte array. Since memory accesses are required to be
aligned to a multiple of the access size, the structure in this example will be a 12 byte array with
8 byte alignment so that accesses to the
  <span class="pre">
   .f64
  </span>
  field are aligned. The
  <span class="pre">
   .param
  </span>
  state space is
used to pass the structure by value:
 </p>
 <p>
  Example
 </p>
 <pre>.func (.reg .s32 out) bar (.reg .s32 x, .param .align 8 .b8 y[12])
{
    .reg .f64 f1;
    .reg .b32 c1, c2, c3, c4;
    ...
    ld.param.f64 f1, [y+0];
    ld.param.b8  c1, [y+8];
    ld.param.b8  c2, [y+9];
    ld.param.b8  c3, [y+10];
    ld.param.b8  c4, [y+11];
    ...
    ... // computation using x,f1,c1,c2,c3,c4;
}

{
     .param .b8 .align 8 py[12];
     ...
     st.param.b64 [py+ 0], %rd;
     st.param.b8  [py+ 8], %rc1;
     st.param.b8  [py+ 9], %rc2;
     st.param.b8  [py+10], %rc1;
     st.param.b8  [py+11], %rc2;
     // scalar args in .reg space, byte array in .param space
     call (%out), bar, (%x, py);
     ...
</pre>
 <p>
  In this example, note that
  <span class="pre">
   .param
  </span>
  space variables are used in two ways. First, a
  <span class="pre">
   .param
  </span>
  variable
  <span class="pre">
   y
  </span>
  is used in function definition bar to represent a formal parameter. Second, a
  <span class="pre">
   .param
  </span>
  variable
  <span class="pre">
   py
  </span>
  is declared in the body of the calling function and used to set up the
structure being passed to bar.
 </p>
 <p>
  The following is a conceptual way to think about the
  <span class="pre">
   .param
  </span>
  state space use in device functions.
 </p>
 <p>
  For a caller,
 </p>
 <ul class="simple">
  <li>
   <p>
    The
    <span class="pre">
     .param
    </span>
    state space is used to set values that will be passed to a called function and/or
to receive return values from a called function. Typically, a
    <span class="pre">
     .param
    </span>
    byte array is used to
collect together fields of a structure being passed by value.
   </p>
  </li>
 </ul>
 <p>
  For a callee,
 </p>
 <ul class="simple">
  <li>
   <p>
    The
    <span class="pre">
     .param
    </span>
    state space is used to receive parameter values and/or pass return values back to
the caller.
   </p>
  </li>
 </ul>
 <p>
  The following restrictions apply to parameter passing.
 </p>
 <p>
  For a caller,
 </p>
 <ul class="simple">
  <li>
   <p>
    Arguments may be
    <span class="pre">
     .param
    </span>
    variables,
    <span class="pre">
     .reg
    </span>
    variables, or constants.
   </p>
  </li>
  <li>
   <p>
    In the case of
    <span class="pre">
     .param
    </span>
    space formal parameters that are byte arrays, the argument must also be
a
    <span class="pre">
     .param
    </span>
    space byte array with matching type, size, and alignment. A
    <span class="pre">
     .param
    </span>
    argument must
be declared within the local scope of the caller.
   </p>
  </li>
  <li>
   <p>
    In the case of
    <span class="pre">
     .param
    </span>
    space formal parameters that are base-type scalar or vector variables,
the corresponding argument may be either a
    <span class="pre">
     .param
    </span>
    or
    <span class="pre">
     .reg
    </span>
    space variable with matching
type and size, or a constant that can be represented in the type of the formal parameter.
   </p>
  </li>
  <li>
   <p>
    In the case of
    <span class="pre">
     .reg
    </span>
    space formal parameters, the corresponding argument may be either a
    <span class="pre">
     .param
    </span>
    or
    <span class="pre">
     .reg
    </span>
    space variable of matching type and size, or a constant that can be
represented in the type of the formal parameter.
   </p>
  </li>
  <li>
   <p>
    In the case of
    <span class="pre">
     .reg
    </span>
    space formal parameters, the register must be at least 32-bits in size.
   </p>
  </li>
  <li>
   <p>
    All
    <span class="pre">
     st.param
    </span>
    instructions used for passing arguments to function call must immediately precede
the corresponding
    <span class="pre">
     call
    </span>
    instruction and
    <span class="pre">
     ld.param
    </span>
    instruction used for collecting return
value must immediately follow the
    <span class="pre">
     call
    </span>
    instruction without any control flow
alteration.
    <span class="pre">
     st.param
    </span>
    and
    <span class="pre">
     ld.param
    </span>
    instructions used for argument passing cannot be
predicated. This enables compiler optimization and ensures that the
    <span class="pre">
     .param
    </span>
    variable does not
consume extra space in the callerâs frame beyond that needed by the ABI. The
    <span class="pre">
     .param
    </span>
    variable
simply allows a mapping to be made at the call site between data that may be in multiple
locations (e.g., structure being manipulated by caller is located in registers and memory) to
something that can be passed as a parameter or return value to the callee.
   </p>
  </li>
 </ul>
 <p>
  For a callee,
 </p>
 <ul class="simple">
  <li>
   <p>
    Input and return parameters may be
    <span class="pre">
     .param
    </span>
    variables or
    <span class="pre">
     .reg
    </span>
    variables.
   </p>
  </li>
  <li>
   <p>
    Parameters in
    <span class="pre">
     .param
    </span>
    memory must be aligned to a multiple of 1, 2, 4, 8, or 16 bytes.
   </p>
  </li>
  <li>
   <p>
    Parameters in the
    <span class="pre">
     .reg
    </span>
    state space must be at least 32-bits in size.
   </p>
  </li>
  <li>
   <p>
    The
    <span class="pre">
     .reg
    </span>
    state space can be used to receive and return base-type scalar and vector values,
including sub-word size objects when compiling in non-ABI mode. Supporting the
    <span class="pre">
     .reg
    </span>
    state
space provides legacy support.
   </p>
  </li>
 </ul>
 <p>
  Note that the choice of
  <span class="pre">
   .reg
  </span>
  or
  <span class="pre">
   .param
  </span>
  state space for parameter passing has no impact on
whether the parameter is ultimately passed in physical registers or on the stack. The mapping of
parameters to physical registers and stack locations depends on the ABI definition and the order,
size, and alignment of parameters.
 </p>
 <h3>
  <span class="section-number">
   7.1.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-from-ptx-isa-version-1-x">
   Changes from PTX ISA Version 1.x
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-from-ptx-isa-version-1-x" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  In PTX ISA version 1.x, formal parameters were restricted to .reg state space, and there was no
support for array parameters. Objects such as C structures were flattened and passed or returned
using multiple registers. PTX ISA version 1.x supports multiple return values for this purpose.
 </p>
 <p>
  Beginning with PTX ISA version 2.0, formal parameters may be in either
  <span class="pre">
   .reg
  </span>
  or
  <span class="pre">
   .param
  </span>
  state
space, and
  <span class="pre">
   .param
  </span>
  space parameters support arrays. For targets
  <span class="pre">
   sm_20
  </span>
  or higher, PTX
restricts functions to a single return value, and a
  <span class="pre">
   .param
  </span>
  byte array should be used to return
objects that do not fit into a register. PTX continues to support multiple return registers for
  <span class="pre">
   sm_1x
  </span>
  targets.
 </p>
 <p class="admonition-title">
  Note
 </p>
 <p>
  PTX implements a stack-based ABI only for targets
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  PTX ISA versions prior to 3.0 permitted variables in
  <span class="pre">
   .reg
  </span>
  and
  <span class="pre">
   .local
  </span>
  state spaces to be
defined at module scope. When compiling to use the ABI, PTX ISA version 3.0 and later disallows
module-scoped
  <span class="pre">
   .reg
  </span>
  and
  <span class="pre">
   .local
  </span>
  variables and restricts their use to within function
scope. When compiling without use of the ABI, module-scoped
  <span class="pre">
   .reg
  </span>
  and
  <span class="pre">
   .local
  </span>
  variables are
supported as before. When compiling legacy PTX code (ISA versions prior to 3.0) containing
module-scoped
  <span class="pre">
   .reg
  </span>
  or
  <span class="pre">
   .local
  </span>
  variables, the compiler silently disables use of the ABI.
 </p>
 <h2>
  <span class="section-number">
   7.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#variadic-functions">
   Variadic Functions
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#variadic-functions" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p class="admonition-title">
  Note
 </p>
 <p>
  Support for variadic functions which was unimplemented has been removed from the spec.
 </p>
 <p>
  PTX version 6.0 supports passing unsized array parameter to a function which can be used to
implement variadic functions.
 </p>
 <p>
  Refer to
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-and-function-directives-func">
   Kernel and Function Directives: .func
  </a>
  for details
 </p>
 <h2>
  <span class="section-number">
   7.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#alloca">
   Alloca
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#alloca" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  PTX provides
  <span class="pre">
   alloca
  </span>
  instruction for allocating storage at runtime on the per-thread local memory
stack. The allocated stack memory can be accessed with
  <span class="pre">
   ld.local
  </span>
  and
  <span class="pre">
   st.local
  </span>
  instructions
using the pointer returned by
  <span class="pre">
   alloca
  </span>
  .
 </p>
 <p>
  In order to facilitate deallocation of memory allocated with
  <span class="pre">
   alloca
  </span>
  , PTX provides two additional
instructions:
  <span class="pre">
   stacksave
  </span>
  which allows reading the value of stack pointer in a local variable, and
  <span class="pre">
   stackrestore
  </span>
  which can restore the stack pointer with the saved value.
 </p>
 <p>
  <span class="pre">
   alloca
  </span>
  ,
  <span class="pre">
   stacksave
  </span>
  , and
  <span class="pre">
   stackrestore
  </span>
  instructions are described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#stack-manipulation-instructions">
   Stack Manipulation
Instructions
  </a>
  .
 </p>
 Preview Feature:
 <p>
  Stack manipulation instructions
  <span class="pre">
   alloca
  </span>
  ,
  <span class="pre">
   stacksave
  </span>
  and
  <span class="pre">
   stackrestore
  </span>
  are preview features
in PTX ISA version 7.3. All details are subject to change with no guarantees of backward
compatibility on future PTX ISA versions or SM architectures.
 </p>
 <h1>
  <span class="section-number">
   8.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory Consistency Model
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <p>
  In multi-threaded executions, the side-effects of memory operations performed by each thread become
visible to other threads in a partial and non-identical order. This means that any two operations
may appear to happen in no order, or in different orders, to different threads. The axioms
introduced by the memory consistency model specify exactly which contradictions are forbidden
between the orders observed by different threads.
 </p>
 <p>
  In the absence of any constraint, each read operation returns the value committed by some write
operation to the same memory location, including the initial write to that memory location. The
memory consistency model effectively constrains the set of such candidate writes from which a read
operation can return a value.
 </p>
 <h2>
  <span class="section-number">
   8.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#scope-and-applicability">
   Scope and applicability of the model
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#scope-and-applicability-of-the-model" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  The constraints specified under this model apply to PTX programs with any PTX ISA version number,
running on
  <span class="pre">
   sm_70
  </span>
  or later architectures.
 </p>
 <p>
  The memory consistency model does not apply to texture (including
  <span class="pre">
   ld.global.nc
  </span>
  ) and surface
accesses.
 </p>
 <h3>
  <span class="section-number">
   8.1.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#limitations-system-scope-atomicity">
   Limitations on atomicity at system scope
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#limitations-on-atomicity-at-system-scope" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  When communicating with the host CPU, certain strong operations with system scope may not be
performed atomically on some systems. For more details on atomicity guarantees to host memory, see
the
  CUDA Atomicity Requirements
  .
 </p>
 <h2>
  <span class="section-number">
   8.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-operations">
   Memory operations
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-operations" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  The fundamental storage unit in the PTX memory model is a byte, consisting of 8 bits. Each state
space available to a PTX program is a sequence of contiguous bytes in memory. Every byte in a PTX
state space has a unique address relative to all threads that have access to the same state space.
 </p>
 <p>
  Each PTX memory instruction specifies an address operand and a data type. The address operand
contains a virtual address that gets converted to a physical address during memory access. The
physical address and the size of the data type together define a physical memory location, which is
the range of bytes starting from the physical address and extending up to the size of the data type
in bytes.
 </p>
 <p>
  The memory consistency model specification uses the terms âaddressâ or âmemory addressâ to indicate
a virtual address, and the term âmemory locationâ to indicate a physical memory location.
 </p>
 <p>
  Each PTX memory instruction also specifies the operation â either a read, a write or an atomic
read-modify-write â to be performed on all the bytes in the corresponding memory location.
 </p>
 <h3>
  <span class="section-number">
   8.2.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#overlap">
   Overlap
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#overlap" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Two memory locations are said to overlap when the starting address of one location is within the
range of bytes constituting the other location. Two memory operations are said to overlap when they
specify the same virtual address and the corresponding memory locations overlap. The overlap is said
to be complete when both memory locations are identical, and it is said to be partial otherwise.
 </p>
 <h3>
  <span class="section-number">
   8.2.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#aliases">
   Aliases
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#aliases" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Two distinct virtual addresses are said to be aliases if they map to the same memory location.
 </p>
 <h3>
  <span class="section-number">
   8.2.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#multimem-addresses">
   Multimem Addresses
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#multimem-addresses" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  A multimem address is a virtual address which points to multiple distinct memory locations across
devices.
 </p>
 <p>
  Only
  multimem.
  * operations are valid on multimem addresses. That is, the behavior of accessing
a multimem address in any other memory operation is undefined.
 </p>
 <h3>
  <span class="section-number">
   8.2.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-operations-on-vector-data-types">
   Memory Operations on Vector Data Types
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-operations-on-vector-data-types" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The memory consistency model relates operations executed on memory locations with scalar data types,
which have a maximum size and alignment of 64 bits. Memory operations with a vector data type are
modelled as a set of equivalent memory operations with a scalar data type, executed in an
unspecified order on the elements in the vector.
 </p>
 <h3>
  <span class="section-number">
   8.2.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-operations-on-packed-data-types">
   Memory Operations on Packed Data Types
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-operations-on-packed-data-types" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  A packed data type consists of two values of the same scalar data type, as described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#packed-data-types">
   Packed Data
Types
  </a>
  . These values are accessed in adjacent memory locations. A
memory operation on a packed data type is modelled as a pair of equivalent memory operations on the
scalar data type, executed in an unspecified order on each element of the packed data.
 </p>
 <h3>
  <span class="section-number">
   8.2.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#initialization">
   Initialization
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#initialization" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Each byte in memory is initialized by a hypothetical write
  W0
  executed before starting any thread
in the program. If the byte is included in a program variable, and that variable has an initial
value, then
  W0
  writes the corresponding initial value for that byte; else
  W0
  is assumed to have
written an unknown but constant value to the byte.
 </p>
 <h2>
  <span class="section-number">
   8.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-state-spaces">
   State spaces
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-state-spaces" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  The relations defined in the memory consistency model are independent of state spaces. In
particular, causality order closes over all memory operations across all the state spaces. But the
side-effect of a memory operation in one state space can be observed directly only by operations
that also have access to the same state space. This further constrains the synchronizing effect of a
memory operation in addition to scope. For example, the synchronizing effect of the PTX instruction
  <span class="pre">
   ld.relaxed.shared.sys
  </span>
  is identical to that of
  <span class="pre">
   ld.relaxed.shared.cluster
  </span>
  , since no thread
outside the same cluster can execute an operation that accesses the same memory location.
 </p>
 <h2>
  <span class="section-number">
   8.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#operation-types">
   Operation types
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#operation-types" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  For simplicity, the rest of the document refers to the following operation types, instead of
mentioning specific instructions that give rise to them.
 </p>
 <table class="table-no-stripes docutils align-default" id="id83">
  <span class="caption-number">
   Table 17
  </span>
  <span class="caption-text">
   Operation Types
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#id83" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Operation Type
    </p>
   </th>
   <th class="head">
    <p>
     Instruction/Operation
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     atomic operation
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      atom
     </span>
     or
     <span class="pre">
      red
     </span>
     instruction.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     read operation
    </p>
   </td>
   <td>
    <p>
     All variants of
     <span class="pre">
      ld
     </span>
     instruction and
     <span class="pre">
      atom
     </span>
     instruction (but not
     <span class="pre">
      red
     </span>
     instruction).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     write operation
    </p>
   </td>
   <td>
    <p>
     All variants of
     <span class="pre">
      st
     </span>
     instruction, and
     atomic
     operations if they result
in a write.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     memory operation
    </p>
   </td>
   <td>
    <p>
     A
     read
     or
     write
     operation.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     volatile operation
    </p>
   </td>
   <td>
    <p>
     An instruction with
     <span class="pre">
      .volatile
     </span>
     qualifier.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     acquire operation
    </p>
   </td>
   <td>
    <p>
     A
     memory
     operation with
     <span class="pre">
      .acquire
     </span>
     or
     <span class="pre">
      .acq_rel
     </span>
     qualifier.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     release operation
    </p>
   </td>
   <td>
    <p>
     A
     memory
     operation with
     <span class="pre">
      .release
     </span>
     or
     <span class="pre">
      .acq_rel
     </span>
     qualifier.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     mmio operation
    </p>
   </td>
   <td>
    <p>
     An
     <span class="pre">
      ld
     </span>
     or
     <span class="pre">
      st
     </span>
     instruction with
     <span class="pre">
      .mmio
     </span>
     qualifier.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     memory fence operation
    </p>
   </td>
   <td>
    <p>
     A
     <span class="pre">
      membar
     </span>
     ,
     <span class="pre">
      fence.sc
     </span>
     or
     <span class="pre">
      fence.acq_rel
     </span>
     instruction.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     proxy fence operation
    </p>
   </td>
   <td>
    <p>
     A
     <span class="pre">
      fence.proxy
     </span>
     or a
     <span class="pre">
      membar.proxy
     </span>
     instruction.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     strong operation
    </p>
   </td>
   <td>
    <p>
     A
     memory fence
     operation, or a
     memory
     operation with a
     <span class="pre">
      .relaxed
     </span>
     ,
     <span class="pre">
      .acquire
     </span>
     ,
     <span class="pre">
      .release
     </span>
     ,
     <span class="pre">
      .acq_rel
     </span>
     ,
     <span class="pre">
      .volatile
     </span>
     , or
     <span class="pre">
      .mmio
     </span>
     qualifier.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     weak operation
    </p>
   </td>
   <td>
    <p>
     An
     <span class="pre">
      ld
     </span>
     or
     <span class="pre">
      st
     </span>
     instruction with a
     <span class="pre">
      .weak
     </span>
     qualifier.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     synchronizing operation
    </p>
   </td>
   <td>
    <p>
     A
     <span class="pre">
      barrier
     </span>
     instruction,
     fence
     operation,
     release
     operation or
     acquire
     operation.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   8.4.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mmio-operation">
   mmio Operation
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mmio-operation" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  An
  mmio
  operation is a memory operation with
  <span class="pre">
   .mmio
  </span>
  qualifier specified. It is usually performed
on a memory location which is mapped to the control registers of peer I/O devices. It can also be
used for communication between threads but has poor performance relative to non-
  mmio
  operations.
 </p>
 <p>
  The semantic meaning of
  mmio
  operations cannot be defined precisely as it is defined by the
underlying I/O device. For formal specification of semantics of
  mmio
  operation from Memory
Consistency Model perspective, it is equivalent to the semantics of a
  strong
  operation. But it
follows a few implementation-specific properties, if it meets the
  CUDA atomicity requirements
  at
the specified scope:
 </p>
 <ul class="simple">
  <li>
   <p>
    Writes are always performed and are never combined within the scope specified.
   </p>
  </li>
  <li>
   <p>
    Reads are always performed, and are not forwarded, prefetched, combined, or allowed to hit any
cache within the scope specified.
   </p>
   <ul>
    <li>
     <p>
      As an exception, in some implementations, the surrounding locations may also be loaded. In such
cases the amount of data loaded is implementation specific and varies between 32 and 128 bytes
in size.
     </p>
    </li>
   </ul>
  </li>
 </ul>
 <h2>
  <span class="section-number">
   8.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#scope">
   Scope
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#scope" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  Each
  strong
  operation must specify a
  scope
  , which is the set of threads that may interact
directly with that operation and establish any of the relations described in the memory consistency
model. There are four scopes:
 </p>
 <table class="table-no-stripes docutils align-default" id="id84">
  <span class="caption-number">
   Table 18
  </span>
  <span class="caption-text">
   Scopes
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#id84" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Scope
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .cta
     </span>
    </p>
   </td>
   <td>
    <p>
     The set of all threads executing in the same CTA as the current thread.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .cluster
     </span>
    </p>
   </td>
   <td>
    <p>
     The set of all threads executing in the same cluster as the current thread.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .gpu
     </span>
    </p>
   </td>
   <td>
    <p>
     The set of all threads in the current program executing on the same compute
device as the current thread. This also includes other kernel grids invoked by
the host program on the same compute device.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .sys
     </span>
    </p>
   </td>
   <td>
    <p>
     The set of all threads in the current program, including all kernel grids
invoked by the host program on all compute devices, and all threads
constituting the host program itself.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Note that the warp is not a
  scope
  ; the CTA is the smallest collection of threads that qualifies as
a
  scope
  in the memory consistency model.
 </p>
 <h2>
  <span class="section-number">
   8.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#proxies">
   Proxies
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#proxies" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  A
  memory proxy
  , or a
  proxy
  is an abstract label applied to a method of memory access. When two
memory operations use distinct methods of memory access, they are said to be different
  proxies
  .
 </p>
 <p>
  Memory operations as defined in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#operation-types">
   Operation types
  </a>
  use
  generic
  method of memory access, i.e. a
  generic proxy
  . Other operations such as textures and surfaces all
use distinct methods of memory access, also distinct from the
  generic
  method.
 </p>
 <p>
  A
  proxy fence
  is required to synchronize memory operations across different
  proxies
  . Although
virtual aliases use the
  generic
  method of memory access, since using distinct virtual addresses
behaves as if using different
  proxies
  , they require a
  proxy fence
  to establish memory ordering.
 </p>
 <h2>
  <span class="section-number">
   8.7.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#morally-strong-operations">
   Morally strong operations
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#morally-strong-operations" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  Two operations are said to be
  morally strong
  relative to each other if they satisfy all of the
following conditions:
 </p>
 <ol class="arabic simple">
  <li>
   <p>
    The operations are related in
    program order
    (i.e, they are both executed by the same thread),
or each operation is
    strong
    and specifies a
    scope
    that includes the thread executing the
other operation.
   </p>
  </li>
  <li>
   <p>
    Both operations are performed via the same
    proxy
    .
   </p>
  </li>
  <li>
   <p>
    If both are memory operations, then they overlap completely.
   </p>
  </li>
 </ol>
 <p>
  Most (but not all) of the axioms in the memory consistency model depend on relations between
  morally strong
  operations.
 </p>
 <h3>
  <span class="section-number">
   8.7.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#conflict-and-data-races">
   Conflict and Data-races
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#conflict-and-data-races" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Two
  overlapping
  memory operations are said to
  conflict
  when at least one of them is a
  write
  .
 </p>
 <p>
  Two
  conflicting
  memory operations are said to be in a
  data-race
  if they are not related in
  causality order
  and they are not
  morally strong
  .
 </p>
 <h3>
  <span class="section-number">
   8.7.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mixed-size-limitations">
   Limitations on Mixed-size Data-races
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#limitations-on-mixed-size-data-races" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  A
  data-race
  between operations that
  overlap
  completely is called a
  uniform-size data-race
  ,
while a
  data-race
  between operations that
  overlap
  partially is called a
  mixed-size data-race
  .
 </p>
 <p>
  The axioms in the memory consistency model do not apply if a PTX program contains one or more
  mixed-size data-races
  . But these axioms are sufficient to describe the behavior of a PTX program
with only
  uniform-size data-races
  .
 </p>
 <p>
  Atomicity of mixed-size RMW operations
 </p>
 <p>
  In any program with or without
  mixed-size data-races
  , the following property holds for every pair
of
  overlapping atomic
  operations A1 and A2 such that each specifies a
  scope
  that includes the
other: Either the
  read-modify-write
  operation specified by A1 is performed completely before A2 is
initiated, or vice versa. This property holds irrespective of whether the two operations A1 and A2
overlap partially or completely.
 </p>
 <h2>
  <span class="section-number">
   8.8.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#release-acquire-patterns">
   Release and Acquire Patterns
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#release-and-acquire-patterns" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  Some sequences of instructions give rise to patterns that participate in memory synchronization as
described later. The
  release
  pattern makes prior operations from the current thread
  1
  visible to some operations from other threads. The
  acquire
  pattern makes some operations from
other threads visible to later operations from the current thread.
 </p>
 <p>
  A
  release
  pattern on a location M consists of one of the following:
 </p>
 <ol class="arabic">
  <li>
   <p>
    A
    release
    operation on M
   </p>
   <p>
    E.g.:
    <span class="pre">
     st.release
    </span>
    <span class="pre">
     [M];
    </span>
    or
    <span class="pre">
     atom.acq_rel
    </span>
    <span class="pre">
     [M];
    </span>
    or
    <span class="pre">
     mbarrier.arrive.release
    </span>
    <span class="pre">
     [M];
    </span>
   </p>
  </li>
  <li>
   <p>
    Or a
    release
    operation on M followed by a
    strong
    write on M in
    program order
   </p>
   <p>
    E.g.:
    <span class="pre">
     st.release
    </span>
    <span class="pre">
     [M]
    </span>
    ;
    <span class="pre">
     st.relaxed
    </span>
    <span class="pre">
     [M];
    </span>
   </p>
  </li>
  <li>
   <p>
    Or a
    memory fence
    followed by a
    strong
    write on M in
    program order
   </p>
   <p>
    E.g.:
    <span class="pre">
     fence;
    </span>
    <span class="pre">
     st.relaxed
    </span>
    <span class="pre">
     [M];
    </span>
   </p>
  </li>
 </ol>
 <p>
  Any
  memory synchronization
  established by a
  release
  pattern only affects operations occurring in
  program order
  before the first instruction in that pattern.
 </p>
 <p>
  An
  acquire
  pattern on a location M consists of one of the following:
 </p>
 <ol class="arabic">
  <li>
   <p>
    An
    acquire
    operation on M
   </p>
   <p>
    E.g.:
    <span class="pre">
     ld.acquire
    </span>
    <span class="pre">
     [M];
    </span>
    or
    <span class="pre">
     atom.acq_rel
    </span>
    <span class="pre">
     [M];
    </span>
    or
    <span class="pre">
     mbarrier.test_wait.acquire
    </span>
    <span class="pre">
     [M];
    </span>
   </p>
  </li>
  <li>
   <p>
    Or a
    strong
    read on M followed by an
    acquire
    operation on M in
    program order
   </p>
   <p>
    E.g.:
    <span class="pre">
     ld.relaxed
    </span>
    <span class="pre">
     [M];
    </span>
    <span class="pre">
     ld.acquire
    </span>
    <span class="pre">
     [M];
    </span>
   </p>
  </li>
  <li>
   <p>
    Or a
    strong
    read on M followed by a
    memory fence
    in
    program order
   </p>
   <p>
    E.g.:
    <span class="pre">
     ld.relaxed
    </span>
    <span class="pre">
     [M];
    </span>
    <span class="pre">
     fence;
    </span>
   </p>
  </li>
 </ol>
 <p>
  Any
  memory synchronization
  established by an
  acquire
  pattern only affects operations occurring
in
  program order
  after the last instruction in that pattern.
 </p>
 <p>
  1
  For both
  release
  and
  acquire
  patterns, this effect is further extended to operations in
other threads through the transitive nature of
  causality order
  .
 </p>
 <h2>
  <span class="section-number">
   8.9.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#ordering-memory-operations">
   Ordering of memory operations
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#ordering-of-memory-operations" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  The sequence of operations performed by each thread is captured as
  program order
  while
  memory
synchronization
  across threads is captured as
  causality order
  . The visibility of the side-effects
of memory operations to other memory operations is captured as
  communication order
  . The memory
consistency model defines contradictions that are disallowed between communication order on the one
hand, and
  causality order
  and
  program order
  on the other.
 </p>
 <h3>
  <span class="section-number">
   8.9.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#program-order">
   Program Order
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#program-order" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The
  program order
  relates all operations performed by a thread to the order in which a sequential
processor will execute instructions in the corresponding PTX source. It is a transitive relation
that forms a total order over the operations performed by the thread, but does not relate operations
from different threads.
 </p>
 <h4>
  <span class="section-number">
   8.9.1.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#program-order-async-operations">
   Asynchronous Operations
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-operations" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  Some PTX instructions (all variants of
  <span class="pre">
   cp.async
  </span>
  ,
  <span class="pre">
   cp.async.bulk
  </span>
  ,
  <span class="pre">
   cp.reduce.async.bulk
  </span>
  ,
  <span class="pre">
   wgmma.mma_async
  </span>
  ) perform operations that are asynchronous to the thread that executed the
instruction. These asynchronous operations are ordered after prior instructions in the same thread
(except in the case of
  <span class="pre">
   wgmma.mma_async
  </span>
  ), but they are not part of the program order for that
thread. Instead, they provide weaker ordering guarantees as documented in the instruction
description.
 </p>
 <p>
  For example, the loads and stores performed as part of a
  <span class="pre">
   cp.async
  </span>
  are ordered with respect to
each other, but not to those of any other
  <span class="pre">
   cp.async
  </span>
  instructions initiated by the same thread,
nor any other instruction subsequently issued by the thread with the exception of
  <span class="pre">
   cp.async.commit_group
  </span>
  or
  <span class="pre">
   cp.async.mbarrier.arrive
  </span>
  . The asynchronous mbarrier
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-arrive-on">
   arrive-on
  </a>
  operation
performed by a
  <span class="pre">
   cp.async.mbarrier.arrive
  </span>
  instruction is ordered with respect to the memory
operations performed by all prior
  <span class="pre">
   cp.async
  </span>
  operations initiated by the same thread, but not to
those of any other instruction issued by the thread. The implicit mbarrier
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-complete-tx-operation">
   complete-tx
  </a>
  operation that is part of all variants of
  <span class="pre">
   cp.async.bulk
  </span>
  and
  <span class="pre">
   cp.reduce.async.bulk
  </span>
  instructions is ordered only with respect to the memory operations performed by the same
asynchronous instruction, and in particular it does not transitively establish ordering with respect
to prior instructions from the issuing thread.
 </p>
 <h3>
  <span class="section-number">
   8.9.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#observation-order">
   Observation Order
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#observation-order" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Observation order
  relates a write W to a read R through an optional sequence of atomic
read-modify-write operations.
 </p>
 <p>
  A write W precedes a read R in
  observation order
  if:
 </p>
 <ol class="arabic simple">
  <li>
   <p>
    R and W are
    morally strong
    and R reads the value written by W, or
   </p>
  </li>
  <li>
   <p>
    For some atomic operation Z, W precedes Z and Z precedes R in
    observation order
    .
   </p>
  </li>
 </ol>
 <h3>
  <span class="section-number">
   8.9.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#fence-sc-order">
   Fence-SC Order
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#fence-sc-order" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The
  Fence-SC
  order is an acyclic partial order, determined at runtime, that relates every pair of
  morally strong fence.sc
  operations.
 </p>
 <h3>
  <span class="section-number">
   8.9.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-synchronization">
   Memory synchronization
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-synchronization" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Synchronizing operations performed by different threads synchronize with each other at runtime as
described here. The effect of such synchronization is to establish
  causality order
  across threads.
 </p>
 <ol class="arabic simple">
  <li>
   <p>
    A
    fence.sc
    operation X
    synchronizes
    with a
    fence.sc
    operation Y if X precedes Y in the
    Fence-SC
    order.
   </p>
  </li>
  <li>
   <p>
    A
    bar{.cta}.sync
    or
    bar{.cta}.red
    or
    bar{.cta}.arrive
    operation
    synchronizes
    with a
    bar{.cta}.sync
    or
    bar{.cta}.red
    operation executed on the same barrier.
   </p>
  </li>
  <li>
   <p>
    A
    <span class="pre">
     barrier.cluster.arrive
    </span>
    operation synchronizes with a
    <span class="pre">
     barrier.cluster.wait
    </span>
    operation.
   </p>
  </li>
  <li>
   <p>
    A
    release
    pattern X
    synchronizes
    with an
    acquire
    pattern Y, if a
    write
    operation in X
precedes a
    read
    operation in Y in
    observation order
    , and the first operation in X and the
last operation in Y are
    morally strong
    .
   </p>
  </li>
 </ol>
 <p>
  API synchronization
 </p>
 <p>
  A
  synchronizes
  relation can also be established by certain CUDA APIs.
 </p>
 <ol class="arabic simple">
  <li>
   <p>
    Completion of a task enqueued in a CUDA stream
    synchronizes
    with the start of the following
task in the same stream, if any.
   </p>
  </li>
  <li>
   <p>
    For purposes of the above, recording or waiting on a CUDA event in a stream, or causing a
cross-stream barrier to be inserted due to
    <span class="pre">
     cudaStreamLegacy
    </span>
    , enqueues tasks in the associated
streams even if there are no direct side effects. An event record task
    synchronizes
    with
matching event wait tasks, and a barrier arrival task
    synchronizes
    with matching barrier wait
tasks.
   </p>
  </li>
  <li>
   <p>
    Start of a CUDA kernel
    synchronizes
    with start of all threads in the kernel. End of all threads
in a kernel
    synchronize
    with end of the kernel.
   </p>
  </li>
  <li>
   <p>
    Start of a CUDA graph
    synchronizes
    with start of all source nodes in the graph. Completion of
all sink nodes in a CUDA graph
    synchronizes
    with completion of the graph. Completion of a graph
node
    synchronizes
    with start of all nodes with a direct dependency.
   </p>
  </li>
  <li>
   <p>
    Start of a CUDA API call to enqueue a task
    synchronizes
    with start of the task.
   </p>
  </li>
  <li>
   <p>
    Completion of the last task queued to a stream, if any,
    synchronizes
    with return from
    <span class="pre">
     cudaStreamSynchronize
    </span>
    . Completion of the most recently queued matching event record task, if
any,
    synchronizes
    with return from
    <span class="pre">
     cudaEventSynchronize
    </span>
    . Synchronizing a CUDA device or
context behaves as if synchronizing all streams in the context, including ones that have been
destroyed.
   </p>
  </li>
  <li>
   <p>
    Returning
    <span class="pre">
     cudaSuccess
    </span>
    from an API to query a CUDA handle, such as a stream or event, behaves
the same as return from the matching synchronization API.
   </p>
  </li>
 </ol>
 <p>
  In addition to establishing a
  synchronizes
  relation, the CUDA API synchronization mechanisms above
also participate in
  proxy-preserved base causality order
  .
 </p>
 <h3>
  <span class="section-number">
   8.9.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#causality-order">
   Causality Order
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#causality-order" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Causality order
  captures how memory operations become visible across threads through synchronizing
operations. The axiom âCausalityâ uses this order to constrain the set of write operations from
which a read operation may read a value.
 </p>
 <p>
  Relations in the
  causality order
  primarily consist of relations in
  Base causality order
  1
  , which is a transitive order, determined at runtime.
 </p>
 <p>
  Base causality order
 </p>
 <p>
  An operation X precedes an operation Y in
  base causality order
  if:
 </p>
 <ol class="arabic simple">
  <li>
   <p>
    X precedes Y in
    program order
    , or
   </p>
  </li>
  <li>
   <p>
    X
    synchronizes
    with Y, or
   </p>
  </li>
  <li>
   <p>
    For some operation Z,
   </p>
   <ol class="loweralpha simple">
    <li>
     <p>
      X precedes Z in
      program order
      and Z precedes Y in
      base causality order
      , or
     </p>
    </li>
    <li>
     <p>
      X precedes Z in
      base causality order
      and Z precedes Y in
      program order
      , or
     </p>
    </li>
    <li>
     <p>
      X precedes Z in
      base causality order
      and Z precedes Y in
      base causality order
      .
     </p>
    </li>
   </ol>
  </li>
 </ol>
 <p>
  Proxy-preserved base causality order
 </p>
 <p>
  A memory operation X precedes a memory operation Y in
  proxy-preserved base causality order
  if X
precedes Y in
  base causality order
  , and:
 </p>
 <ol class="arabic simple">
  <li>
   <p>
    X and Y are performed to the same address, using the
    generic proxy
    , or
   </p>
  </li>
  <li>
   <p>
    X and Y are performed to the same address, using the same
    proxy
    , and by the same thread block,
or
   </p>
  </li>
  <li>
   <p>
    X and Y are aliases and there is an alias
    proxy fence
    along the base causality path from X
to Y.
   </p>
  </li>
 </ol>
 <p>
  Causality order
 </p>
 <p>
  Causality order
  combines
  base causality order
  with some non-transitive relations as follows:
 </p>
 <p>
  An operation X precedes an operation Y in
  causality order
  if:
 </p>
 <ol class="arabic simple">
  <li>
   <p>
    X precedes Y in
    proxy-preserved base causality order
    , or
   </p>
  </li>
  <li>
   <p>
    For some operation Z, X precedes Z in observation order, and Z precedes Y in
    proxy-preserved
base causality order
    .
   </p>
  </li>
 </ol>
 <p>
  1
  The transitivity of
  base causality order
  accounts for the âcumulativityâ of synchronizing
operations.
 </p>
 <h3>
  <span class="section-number">
   8.9.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#coherence-order">
   Coherence Order
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#coherence-order" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  There exists a partial transitive order that relates
  overlapping
  write operations, determined at
runtime, called the
  coherence order
  1
  . Two
  overlapping
  write operations are related in
  coherence order
  if they are
  morally strong
  or if they are related in
  causality order
  . Two
  overlapping
  writes are unrelated in
  coherence order
  if they are in a
  data-race
  , which gives
rise to the partial nature of
  coherence order
  .
 </p>
 <p>
  1
  Coherence order
  cannot be observed directly since it consists entirely of write
operations. It may be observed indirectly by its use in constraining the set of candidate
writes that a read operation may read from.
 </p>
 <h3>
  <span class="section-number">
   8.9.7.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#communication-order">
   Communication Order
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#communication-order" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The
  communication order
  is a non-transitive order, determined at runtime, that relates write
operations to other
  overlapping
  memory operations.
 </p>
 <ol class="arabic simple">
  <li>
   <p>
    A write W precedes an
    overlapping
    read R in
    communication order
    if R returns the value of any
byte that was written by W.
   </p>
  </li>
  <li>
   <p>
    A write W precedes a write Wâ in
    communication order
    if W precedes Wâ in
    coherence order
    .
   </p>
  </li>
  <li>
   <p>
    A read R precedes an
    overlapping
    write W in
    communication order
    if, for any byte accessed by
both R and W, R returns the value written by a write Wâ that precedes W in
    coherence order
    .
   </p>
  </li>
 </ol>
 <p>
  Communication order
  captures the visibility of memory operations â when a memory operation X1
precedes a memory operation X2 in
  communication order
  , X1 is said to be visible to X2.
 </p>
 <h2>
  <span class="section-number">
   8.10.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#axioms">
   Axioms
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#axioms" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <h3>
  <span class="section-number">
   8.10.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#coherence-axiom">
   Coherence
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#coherence" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  If a write W precedes an
  overlapping
  write Wâ in
  causality order
  , then W must precede Wâ in
  coherence order
  .
 </p>
 <h3>
  <span class="section-number">
   8.10.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#fence-sc-axiom">
   Fence-SC
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#fence-sc" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Fence-SC
  order cannot contradict
  causality order
  . For a pair of
  morally strong
  fence.sc
  operations F1 and F2, if F1 precedes F2 in
  causality order
  , then F1 must precede F2 in
  Fence-SC
  order.
 </p>
 <h3>
  <span class="section-number">
   8.10.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#atomicity-axiom">
   Atomicity
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#atomicity" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Single-Copy Atomicity
 </p>
 <p>
  Conflicting
  morally strong
  operations are performed with
  single-copy atomicity
  . When a read R
and a write W are
  morally strong
  , then the following two communications cannot both exist in the
same execution, for the set of bytes accessed by both R and W:
 </p>
 <ol class="arabic simple">
  <li>
   <p>
    R reads any byte from W.
   </p>
  </li>
  <li>
   <p>
    R reads any byte from any write Wâ which precedes W in
    coherence order
    .
   </p>
  </li>
 </ol>
 <p>
  Atomicity of read-modify-write (RMW) operations
 </p>
 <p>
  When an
  atomic
  operation A and a write W
  overlap
  and are
  morally strong
  , then the following
two communications cannot both exist in the same execution, for the set of bytes accessed by both A
and W:
 </p>
 <ol class="arabic simple">
  <li>
   <p>
    A reads any byte from a write Wâ that precedes W in
    coherence order
    .
   </p>
  </li>
  <li>
   <p>
    A follows W in
    coherence order
    .
   </p>
  </li>
 </ol>
 <p>
  Litmus Test 1:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td colspan="2">
    <pre><span class="p">.</span><span class="n">global</span><span class="p">.</span><span class="n">u32</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</pre>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     T1
    </p>
   </td>
   <td>
    <p>
     T2
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <pre><span class="nl">A1</span><span class="p">:</span><span class="n">atom</span><span class="p">.</span><span class="n">sys</span><span class="p">.</span><span class="n">inc</span><span class="p">.</span><span class="n">u32</span><span class="o">%</span><span class="n">r0</span><span class="p">,</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
</pre>
   </td>
   <td>
    <pre><span class="nl">A2</span><span class="p">:</span><span class="n">atom</span><span class="p">.</span><span class="n">sys</span><span class="p">.</span><span class="n">inc</span><span class="p">.</span><span class="n">u32</span><span class="o">%</span><span class="n">r0</span><span class="p">,</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
</pre>
   </td>
  </tr>
  <tr class="row-even">
   <td colspan="2">
    <pre><span class="n">FINAL</span><span class="n">STATE</span><span class="o">:</span><span class="n">x</span><span class="o">==</span><span class="mi">2</span>
</pre>
   </td>
  </tr>
 </table>
 <p>
  Atomicity is guaranteed when the operations are
  morally strong
  .
 </p>
 <p>
  Litmus Test 2:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td colspan="2">
    <pre><span class="p">.</span><span class="n">global</span><span class="p">.</span><span class="n">u32</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</pre>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     T1
    </p>
   </td>
   <td>
    <p>
     T2 (In a different CTA)
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <pre><span class="nl">A1</span><span class="p">:</span><span class="n">atom</span><span class="p">.</span><span class="n">cta</span><span class="p">.</span><span class="n">inc</span><span class="p">.</span><span class="n">u32</span><span class="o">%</span><span class="n">r0</span><span class="p">,</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
</pre>
   </td>
   <td>
    <pre><span class="nl">A2</span><span class="p">:</span><span class="n">atom</span><span class="p">.</span><span class="n">gpu</span><span class="p">.</span><span class="n">inc</span><span class="p">.</span><span class="n">u32</span><span class="o">%</span><span class="n">r0</span><span class="p">,</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
</pre>
   </td>
  </tr>
  <tr class="row-even">
   <td colspan="2">
    <pre><span class="n">FINAL</span><span class="n">STATE</span><span class="o">:</span><span class="n">x</span><span class="o">==</span><span class="mi">1</span><span class="n">OR</span><span class="n">x</span><span class="o">==</span><span class="mi">2</span>
</pre>
   </td>
  </tr>
 </table>
 <p>
  Atomicity is not guaranteed if the operations are not
  morally strong
  .
 </p>
 <h3>
  <span class="section-number">
   8.10.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#no-thin-air-axiom">
   No Thin Air
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#no-thin-air" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Values may not appear âout of thin airâ: an execution cannot speculatively produce a value in such a
way that the speculation becomes self-satisfying through chains of instruction dependencies and
inter-thread communication. This matches both programmer intuition and hardware reality, but is
necessary to state explicitly when performing formal analysis.
 </p>
 <p>
  Litmus Test: Load Buffering
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td colspan="2">
    <pre><span class="p">.</span><span class="n">global</span><span class="p">.</span><span class="n">u32</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="p">.</span><span class="n">global</span><span class="p">.</span><span class="n">u32</span><span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</pre>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     T1
    </p>
   </td>
   <td>
    <p>
     T2
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <pre><span class="nl">A1</span><span class="p">:</span><span class="n">ld</span><span class="p">.</span><span class="n">global</span><span class="p">.</span><span class="n">u32</span><span class="o">%</span><span class="n">r0</span><span class="p">,</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
<span class="nl">B1</span><span class="p">:</span><span class="n">st</span><span class="p">.</span><span class="n">global</span><span class="p">.</span><span class="n">u32</span><span class="p">[</span><span class="n">y</span><span class="p">],</span><span class="o">%</span><span class="n">r0</span><span class="p">;</span>
</pre>
   </td>
   <td>
    <pre><span class="nl">A2</span><span class="p">:</span><span class="n">ld</span><span class="p">.</span><span class="n">global</span><span class="p">.</span><span class="n">u32</span><span class="o">%</span><span class="n">r1</span><span class="p">,</span><span class="p">[</span><span class="n">y</span><span class="p">];</span>
<span class="nl">B2</span><span class="p">:</span><span class="n">st</span><span class="p">.</span><span class="n">global</span><span class="p">.</span><span class="n">u32</span><span class="p">[</span><span class="n">x</span><span class="p">],</span><span class="o">%</span><span class="n">r1</span><span class="p">;</span>
</pre>
   </td>
  </tr>
  <tr class="row-even">
   <td colspan="2">
    <pre><span class="n">FINAL</span><span class="n">STATE</span><span class="o">:</span><span class="n">x</span><span class="o">==</span><span class="mi">0</span><span class="n">AND</span><span class="n">y</span><span class="o">==</span><span class="mi">0</span>
</pre>
   </td>
  </tr>
 </table>
 <p>
  The litmus test known as âLBâ (Load Buffering) checks such forbidden values that may arise out of
thin air. Two threads T1 and T2 each read from a first variable and copy the observed result into a
second variable, with the first and second variable exchanged between the threads. If each variable
is initially zero, the final result shall also be zero. If A1 reads from B2 and A2 reads from B1,
then values passing through the memory operations in this example form a cycle:
A1-&gt;B1-&gt;A2-&gt;B2-&gt;A1. Only the values x == 0 and y == 0 are allowed to satisfy this cycle. If any of
the memory operations in this example were to speculatively associate a different value with the
corresponding memory location, then such a speculation would become self-fulfilling, and hence
forbidden.
 </p>
 <h3>
  <span class="section-number">
   8.10.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sc-per-loc-axiom">
   Sequential Consistency Per Location
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sequential-consistency-per-location" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Within any set of
  overlapping
  memory operations that are pairwise
  morally strong
  ,
  communication
order
  cannot contradict
  program order
  , i.e., a concatenation of
  program order
  between
  overlapping
  operations and
  morally strong
  relations in
  communication order
  cannot result in a
cycle. This ensures that each program slice of
  overlapping
  pairwise morally
  strong operations
  is
strictly
  sequentially-consistent
  .
 </p>
 <p>
  Litmus Test: CoRR
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td colspan="2">
    <pre><span class="p">.</span><span class="n">global</span><span class="p">.</span><span class="n">u32</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</pre>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     T1
    </p>
   </td>
   <td>
    <p>
     T2
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <pre><span class="nl">W1</span><span class="p">:</span><span class="n">st</span><span class="p">.</span><span class="n">global</span><span class="p">.</span><span class="n">relaxed</span><span class="p">.</span><span class="n">sys</span><span class="p">.</span><span class="n">u32</span><span class="p">[</span><span class="n">x</span><span class="p">],</span><span class="mi">1</span><span class="p">;</span>
</pre>
   </td>
   <td>
    <pre><span class="nl">R1</span><span class="p">:</span><span class="n">ld</span><span class="p">.</span><span class="n">global</span><span class="p">.</span><span class="n">relaxed</span><span class="p">.</span><span class="n">sys</span><span class="p">.</span><span class="n">u32</span><span class="o">%</span><span class="n">r0</span><span class="p">,</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
<span class="nl">R2</span><span class="p">:</span><span class="n">ld</span><span class="p">.</span><span class="n">global</span><span class="p">.</span><span class="n">relaxed</span><span class="p">.</span><span class="n">sys</span><span class="p">.</span><span class="n">u32</span><span class="o">%</span><span class="n">r1</span><span class="p">,</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
</pre>
   </td>
  </tr>
  <tr class="row-even">
   <td colspan="2">
    <pre><span class="n">IF</span><span class="o">%</span><span class="n">r0</span><span class="o">==</span><span class="mi">1</span><span class="n">THEN</span><span class="o">%</span><span class="n">r1</span><span class="o">==</span><span class="mi">1</span>
</pre>
   </td>
  </tr>
 </table>
 <p>
  The litmus test âCoRRâ (Coherent Read-Read), demonstrates one consequence of this guarantee. A
thread T1 executes a write W1 on a location x, and a thread T2 executes two (or an infinite sequence
of) reads R1 and R2 on the same location x. No other writes are executed on x, except the one
modelling the initial value. The operations W1, R1 and R2 are pairwise
  morally strong
  . If R1 reads
from W1, then the subsequent read R2 must also observe the same value. If R2 observed the initial
value of x instead, then this would form a sequence of
  morally-strong
  relations R2-&gt;W1-&gt;R1 in
  communication order
  that contradicts the
  program order
  R1-&gt;R2 in thread T2. Hence R2 cannot read
the initial value of x in such an execution.
 </p>
 <h3>
  <span class="section-number">
   8.10.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#causality-axiom">
   Causality
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#causality" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Relations in
  communication order
  cannot contradict
  causality order
  . This constrains the set of
candidate write operations that a read operation may read from:
 </p>
 <ol class="arabic simple">
  <li>
   <p>
    If a read R precedes an
    overlapping
    write W in
    causality order
    , then R cannot read from W.
   </p>
  </li>
  <li>
   <p>
    If a write W precedes an
    overlapping
    read R in
    causality order
    , then for any byte accessed by
both R and W, R cannot read from any write Wâ that precedes W in
    coherence order
    .
   </p>
  </li>
 </ol>
 <p>
  Litmus Test: Message Passing
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td colspan="2">
    <pre><span class="p">.</span><span class="n">global</span><span class="p">.</span><span class="n">u32</span><span class="n">data</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="p">.</span><span class="n">global</span><span class="p">.</span><span class="n">u32</span><span class="n">flag</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</pre>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     T1
    </p>
   </td>
   <td>
    <p>
     T2
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <pre><span class="nl">W1</span><span class="p">:</span><span class="n">st</span><span class="p">.</span><span class="n">global</span><span class="p">.</span><span class="n">u32</span><span class="p">[</span><span class="n">data</span><span class="p">],</span><span class="mi">1</span><span class="p">;</span>
<span class="nl">F1</span><span class="p">:</span><span class="n">fence</span><span class="p">.</span><span class="n">sys</span><span class="p">;</span>
<span class="nl">W2</span><span class="p">:</span><span class="n">st</span><span class="p">.</span><span class="n">global</span><span class="p">.</span><span class="n">relaxed</span><span class="p">.</span><span class="n">sys</span><span class="p">.</span><span class="n">u32</span><span class="p">[</span><span class="n">flag</span><span class="p">],</span><span class="mi">1</span><span class="p">;</span>
</pre>
   </td>
   <td>
    <pre><span class="nl">R1</span><span class="p">:</span><span class="n">ld</span><span class="p">.</span><span class="n">global</span><span class="p">.</span><span class="n">relaxed</span><span class="p">.</span><span class="n">sys</span><span class="p">.</span><span class="n">u32</span><span class="o">%</span><span class="n">r0</span><span class="p">,</span><span class="p">[</span><span class="n">flag</span><span class="p">];</span>
<span class="nl">F2</span><span class="p">:</span><span class="n">fence</span><span class="p">.</span><span class="n">sys</span><span class="p">;</span>
<span class="nl">R2</span><span class="p">:</span><span class="n">ld</span><span class="p">.</span><span class="n">global</span><span class="p">.</span><span class="n">u32</span><span class="o">%</span><span class="n">r1</span><span class="p">,</span><span class="p">[</span><span class="n">data</span><span class="p">];</span>
</pre>
   </td>
  </tr>
  <tr class="row-even">
   <td colspan="2">
    <pre><span class="n">IF</span><span class="o">%</span><span class="n">r0</span><span class="o">==</span><span class="mi">1</span><span class="n">THEN</span><span class="o">%</span><span class="n">r1</span><span class="o">==</span><span class="mi">1</span>
</pre>
   </td>
  </tr>
 </table>
 <p>
  The litmus test known as âMPâ (Message Passing) represents the essence of typical synchronization
algorithms. A vast majority of useful programs can be reduced to sequenced applications of this
pattern.
 </p>
 <p>
  Thread T1 first writes to a data variable and then to a flag variable while a second thread T2 first
reads from the flag variable and then from the data variable. The operations on the flag are
  morally strong
  and the memory operations in each thread are separated by a
  fence
  , and these
  fences
  are
  morally strong
  .
 </p>
 <p>
  If R1 observes W2, then the release pattern âF1; W2â
  synchronizes
  with the
  acquire pattern
  âR1;
F2â. This establishes the
  causality order
  W1 -&gt; F1 -&gt; W2 -&gt; R1 -&gt; F2 -&gt; R2. Then axiom
  causality
  guarantees that R2 cannot read from any write that precedes W1 in
  coherence order
  . In the absence
of any other writes in this example, R2 must read from W1.
 </p>
 <p>
  Litmus Test: CoWR
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <pre><span class="c1">// These addresses are aliases</span>
<span class="p">.</span><span class="n">global</span><span class="p">.</span><span class="n">u32</span><span class="n">data_alias_1</span><span class="p">;</span>
<span class="p">.</span><span class="n">global</span><span class="p">.</span><span class="n">u32</span><span class="n">data_alias_2</span><span class="p">;</span>
</pre>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     T1
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <pre><span class="nl">W1</span><span class="p">:</span><span class="n">st</span><span class="p">.</span><span class="n">global</span><span class="p">.</span><span class="n">u32</span><span class="p">[</span><span class="n">data_alias_1</span><span class="p">],</span><span class="mi">1</span><span class="p">;</span>
<span class="nl">F1</span><span class="p">:</span><span class="n">fence</span><span class="p">.</span><span class="n">proxy</span><span class="p">.</span><span class="n">alias</span><span class="p">;</span>
<span class="nl">R1</span><span class="p">:</span><span class="n">ld</span><span class="p">.</span><span class="n">global</span><span class="p">.</span><span class="n">u32</span><span class="o">%</span><span class="n">r1</span><span class="p">,</span><span class="p">[</span><span class="n">data_alias_2</span><span class="p">];</span>
</pre>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <pre><span class="o">%</span><span class="n">r1</span><span class="o">==</span><span class="mi">1</span>
</pre>
   </td>
  </tr>
 </table>
 <p>
  Virtual aliases require an alias
  proxy fence
  along the synchronization path.
 </p>
 <p>
  Litmus Test: Store Buffering
 </p>
 <p>
  The litmus test known as âSBâ (Store Buffering) demonstrates the
  sequential consistency
  enforced
by the
  <span class="pre">
   fence.sc
  </span>
  . A thread T1 writes to a first variable, and then reads the value of a second
variable, while a second thread T2 writes to the second variable and then reads the value of the
first variable. The memory operations in each thread are separated by
  <span class="pre">
   fence.
  </span>
  sc instructions,
and these
  fences
  are
  morally strong
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td colspan="2">
    <pre><span class="p">.</span><span class="n">global</span><span class="p">.</span><span class="n">u32</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="p">.</span><span class="n">global</span><span class="p">.</span><span class="n">u32</span><span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</pre>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     T1
    </p>
   </td>
   <td>
    <p>
     T2
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <pre><span class="nl">W1</span><span class="p">:</span><span class="n">st</span><span class="p">.</span><span class="n">global</span><span class="p">.</span><span class="n">u32</span><span class="p">[</span><span class="n">x</span><span class="p">],</span><span class="mi">1</span><span class="p">;</span>
<span class="nl">F1</span><span class="p">:</span><span class="n">fence</span><span class="p">.</span><span class="n">sc</span><span class="p">.</span><span class="n">sys</span><span class="p">;</span>
<span class="nl">R1</span><span class="p">:</span><span class="n">ld</span><span class="p">.</span><span class="n">global</span><span class="p">.</span><span class="n">u32</span><span class="o">%</span><span class="n">r0</span><span class="p">,</span><span class="p">[</span><span class="n">y</span><span class="p">];</span>
</pre>
   </td>
   <td>
    <pre><span class="nl">W2</span><span class="p">:</span><span class="n">st</span><span class="p">.</span><span class="n">global</span><span class="p">.</span><span class="n">u32</span><span class="p">[</span><span class="n">y</span><span class="p">],</span><span class="mi">1</span><span class="p">;</span>
<span class="nl">F2</span><span class="p">:</span><span class="n">fence</span><span class="p">.</span><span class="n">sc</span><span class="p">.</span><span class="n">sys</span><span class="p">;</span>
<span class="nl">R2</span><span class="p">:</span><span class="n">ld</span><span class="p">.</span><span class="n">global</span><span class="p">.</span><span class="n">u32</span><span class="o">%</span><span class="n">r1</span><span class="p">,</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
</pre>
   </td>
  </tr>
  <tr class="row-even">
   <td colspan="2">
    <pre><span class="o">%</span><span class="n">r0</span><span class="o">==</span><span class="mi">1</span><span class="n">OR</span><span class="o">%</span><span class="n">r1</span><span class="o">==</span><span class="mi">1</span>
</pre>
   </td>
  </tr>
 </table>
 <p>
  In any execution, either F1 precedes F2 in
  Fence-SC
  order, or vice versa. If F1 precedes F2 in
  Fence-SC
  order, then F1
  synchronizes
  with F2. This establishes the
  causality order
  in W1 -&gt; F1
-&gt; F2 -&gt; R2. Axiom
  causality
  ensures that R2 cannot read from any write that precedes W1 in
  coherence order
  . In the absence of any other write to that variable, R2 must read from
W1. Similarly, in the case where F2 precedes F1 in
  Fence-SC
  order, R1 must read from W2. If each
  <span class="pre">
   fence.sc
  </span>
  in this example were replaced by a
  <span class="pre">
   fence.acq_rel
  </span>
  instruction, then this outcome is
not guaranteed. There may be an execution where the write from each thread remains unobserved from
the other thread, i.e., an execution is possible, where both R1 and R2 return the initial value â0â
for variables y and x respectively.
 </p>
 <h1>
  <span class="section-number">
   9.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#instruction-set">
   Instruction Set
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#instruction-set" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <h2>
  <span class="section-number">
   9.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#format-and-semantics-of-instruction-descriptions">
   Format and Semantics of Instruction Descriptions
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#format-and-semantics-of-instruction-descriptions" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  This section describes each PTX instruction. In addition to the name and the format of the
instruction, the semantics are described, followed by some examples that attempt to show several
possible instantiations of the instruction.
 </p>
 <h2>
  <span class="section-number">
   9.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#ptx-instructions">
   PTX Instructions
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#ptx-instructions" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  PTX instructions generally have from zero to four operands, plus an optional guard predicate
appearing after an
  <span class="pre">
   @
  </span>
  symbol to the left of the
  <span class="pre">
   opcode
  </span>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     @p
    </span>
    Â Â
    <span class="pre">
     opcode;
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     @p
    </span>
    Â Â
    <span class="pre">
     opcode
    </span>
    <span class="pre">
     a;
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     @p
    </span>
    Â Â
    <span class="pre">
     opcode
    </span>
    <span class="pre">
     d,
    </span>
    <span class="pre">
     a;
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     @p
    </span>
    Â Â
    <span class="pre">
     opcode
    </span>
    <span class="pre">
     d,
    </span>
    <span class="pre">
     a,
    </span>
    <span class="pre">
     b;
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     @p
    </span>
    Â Â
    <span class="pre">
     opcode
    </span>
    <span class="pre">
     d,
    </span>
    <span class="pre">
     a,
    </span>
    <span class="pre">
     b,
    </span>
    <span class="pre">
     c;
    </span>
   </p>
  </li>
 </ul>
 <p>
  For instructions that create a result value, the
  <span class="pre">
   d
  </span>
  operand is the destination operand, while
  <span class="pre">
   a
  </span>
  ,
  <span class="pre">
   b
  </span>
  , and
  <span class="pre">
   c
  </span>
  are source operands.
 </p>
 <p>
  The
  <span class="pre">
   setp
  </span>
  instruction writes two destination registers. We use a
  <span class="pre">
   |
  </span>
  symbol to separate
multiple destination registers.
 </p>
 <pre>setp.lt.s32  p|q, a, b;  // p = (a &lt; b); q = !(a &lt; b);
</pre>
 <p>
  For some instructions the destination operand is optional. A
  bit bucket
  operand denoted with an
underscore (
  <span class="pre">
   _
  </span>
  ) may be used in place of a destination register.
 </p>
 <h2>
  <span class="section-number">
   9.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#predicated-execution">
   Predicated Execution
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#predicated-execution" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  In PTX, predicate registers are virtual and have
  <span class="pre">
   .pred
  </span>
  as the type specifier. So, predicate
registers can be declared as
 </p>
 <pre>.reg .pred p, q, r;
</pre>
 <p>
  All instructions have an optional
  guard predicate
  which controls conditional execution of the
instruction. The syntax to specify conditional execution is to prefix an instruction with
  <span class="pre">
   @{!}p
  </span>
  ,
where
  <span class="pre">
   p
  </span>
  is a predicate variable, optionally negated. Instructions without a guard predicate are
executed unconditionally.
 </p>
 <p>
  Predicates are most commonly set as the result of a comparison performed by the
  <span class="pre">
   setp
  </span>
  instruction.
 </p>
 <p>
  As an example, consider the high-level code
 </p>
 <pre>if (i &lt; n)
    j = j + 1;
</pre>
 <p>
  This can be written in PTX as
 </p>
 <pre>      setp.lt.s32  p, i, n;    // p = (i &lt; n)
@p    add.s32      j, j, 1;    // if i &lt; n, add 1 to j
</pre>
 <p>
  To get a conditional branch or conditional function call, use a predicate to control the execution
of the branch or call instructions. To implement the above example as a true conditional branch, the
following PTX instruction sequence might be used:
 </p>
 <pre>      setp.lt.s32  p, i, n;    // compare i to n
@!p   bra  L1;                 // if False, branch over
      add.s32      j, j, 1;
L1:     ...
</pre>
 <h3>
  <span class="section-number">
   9.3.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#comparisons">
   Comparisons
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#comparisons" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <h4>
  <span class="section-number">
   9.3.1.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-and-bit-size-comparisons">
   Integer and Bit-Size Comparisons
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-and-bit-size-comparisons" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The signed integer comparisons are the traditional
  <span class="pre">
   eq
  </span>
  (equal),
  <span class="pre">
   ne
  </span>
  (not-equal),
  <span class="pre">
   lt
  </span>
  (less-than),
  <span class="pre">
   le
  </span>
  (less-than-or-equal),
  <span class="pre">
   gt
  </span>
  (greater-than), and
  <span class="pre">
   ge
  </span>
  (greater-than-or-equal). The unsigned comparisons are
  <span class="pre">
   eq
  </span>
  ,
  <span class="pre">
   ne
  </span>
  ,
  <span class="pre">
   lo
  </span>
  (lower),
  <span class="pre">
   ls
  </span>
  (lower-or-same),
  <span class="pre">
   hi
  </span>
  (higher), and
  <span class="pre">
   hs
  </span>
  (higher-or-same). The bit-size comparisons are
  <span class="pre">
   eq
  </span>
  and
  <span class="pre">
   ne
  </span>
  ; ordering comparisons are not defined for bit-size types.
 </p>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-and-bit-size-comparisons-operators-for-signed-integer-unsigned-integer-and-bit-size-types">
   <span class="std std-numref">
    Table 19
   </span>
  </a>
  shows the operators for signed integer, unsigned integer, and bit-size types.
 </p>
 <table class="table-no-stripes docutils align-default" id="integer-and-bit-size-comparisons-operators-for-signed-integer-unsigned-integer-and-bit-size-types">
  <span class="caption-number">
   Table 19
  </span>
  <span class="caption-text">
   Operators for Signed Integer, Unsigned Integer, and Bit-Size Types
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-and-bit-size-comparisons-operators-for-signed-integer-unsigned-integer-and-bit-size-types" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
   <th class="head">
    <p>
     Signed Operator
    </p>
   </th>
   <th class="head">
    <p>
     Unsigned Operator
    </p>
   </th>
   <th class="head">
    <p>
     Bit-Size Operator
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      a
     </span>
     <span class="pre">
      ==
     </span>
     <span class="pre">
      b
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      eq
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      eq
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      eq
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      a
     </span>
     <span class="pre">
      !=
     </span>
     <span class="pre">
      b
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ne
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ne
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ne
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      a
     </span>
     <span class="pre">
      &lt;
     </span>
     <span class="pre">
      b
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      lt
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      lo
     </span>
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      a
     </span>
     <span class="pre">
      &lt;=
     </span>
     <span class="pre">
      b
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      le
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ls
     </span>
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      a
     </span>
     <span class="pre">
      &gt;
     </span>
     <span class="pre">
      b
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      gt
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      hi
     </span>
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      a
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      b
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ge
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      hs
     </span>
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   9.3.1.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-comparisons">
   Floating Point Comparisons
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-comparisons" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The ordered floating-point comparisons are
  <span class="pre">
   eq
  </span>
  ,
  <span class="pre">
   ne
  </span>
  ,
  <span class="pre">
   lt
  </span>
  ,
  <span class="pre">
   le
  </span>
  ,
  <span class="pre">
   gt
  </span>
  , and
  <span class="pre">
   ge
  </span>
  . If
either operand is
  <span class="pre">
   NaN
  </span>
  , the result is
  <span class="pre">
   False
  </span>
  .
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-comparisons-floating-point-operators">
   <span class="std std-numref">
    Table 20
   </span>
  </a>
  lists the floating-point
comparison operators.
 </p>
 <table class="table-no-stripes docutils align-default" id="floating-point-comparisons-floating-point-operators">
  <span class="caption-number">
   Table 20
  </span>
  <span class="caption-text">
   Floating-Point Comparison Operators
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-comparisons-floating-point-operators" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
   <th class="head">
    <p>
     Floating-Point Operator
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      a
     </span>
     <span class="pre">
      ==
     </span>
     <span class="pre">
      b
     </span>
     <span class="pre">
      &amp;&amp;
     </span>
     <span class="pre">
      !isNaN(a)
     </span>
     <span class="pre">
      &amp;&amp;
     </span>
     <span class="pre">
      !isNaN(b)
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      eq
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      a
     </span>
     <span class="pre">
      !=
     </span>
     <span class="pre">
      b
     </span>
     <span class="pre">
      &amp;&amp;
     </span>
     <span class="pre">
      !isNaN(a)
     </span>
     <span class="pre">
      &amp;&amp;
     </span>
     <span class="pre">
      !isNaN(b)
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ne
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      a
     </span>
     <span class="pre">
      &lt;
     </span>
     <span class="pre">
      b
     </span>
     <span class="pre">
      &amp;&amp;
     </span>
     <span class="pre">
      !isNaN(a)
     </span>
     <span class="pre">
      &amp;&amp;
     </span>
     <span class="pre">
      !isNaN(b)
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      lt
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      a
     </span>
     <span class="pre">
      &lt;=
     </span>
     <span class="pre">
      b
     </span>
     <span class="pre">
      &amp;&amp;
     </span>
     <span class="pre">
      !isNaN(a)
     </span>
     <span class="pre">
      &amp;&amp;
     </span>
     <span class="pre">
      !isNaN(b)
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      le
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      a
     </span>
     <span class="pre">
      &gt;
     </span>
     <span class="pre">
      b
     </span>
     <span class="pre">
      &amp;&amp;
     </span>
     <span class="pre">
      !isNaN(a)
     </span>
     <span class="pre">
      &amp;&amp;
     </span>
     <span class="pre">
      !isNaN(b)
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      gt
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      a
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      b
     </span>
     <span class="pre">
      &amp;&amp;
     </span>
     <span class="pre">
      !isNaN(a)
     </span>
     <span class="pre">
      &amp;&amp;
     </span>
     <span class="pre">
      !isNaN(b)
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ge
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  To aid comparison operations in the presence of
  <span class="pre">
   NaN
  </span>
  values, unordered floating-point comparisons
are provided:
  <span class="pre">
   equ
  </span>
  ,
  <span class="pre">
   neu
  </span>
  ,
  <span class="pre">
   ltu
  </span>
  ,
  <span class="pre">
   leu
  </span>
  ,
  <span class="pre">
   gtu
  </span>
  , and
  <span class="pre">
   geu
  </span>
  . If both operands are numeric
values (not
  <span class="pre">
   NaN
  </span>
  ), then the comparison has the same result as its ordered counterpart. If either
operand is
  <span class="pre">
   NaN
  </span>
  , then the result of the comparison is
  <span class="pre">
   True
  </span>
  .
 </p>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-comparisons-floating-point-operators-nan">
   <span class="std std-numref">
    Table 21
   </span>
  </a>
  lists the floating-point
comparison operators accepting
  <span class="pre">
   NaN
  </span>
  values.
 </p>
 <table class="table-no-stripes docutils align-default" id="floating-point-comparisons-floating-point-operators-nan">
  <span class="caption-number">
   Table 21
  </span>
  <span class="caption-text">
   Floating-Point Comparison Operators Accepting NaN
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-comparisons-floating-point-operators-nan" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
   <th class="head">
    <p>
     Floating-Point Operator
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      a
     </span>
     <span class="pre">
      ==
     </span>
     <span class="pre">
      b
     </span>
     <span class="pre">
      ||
     </span>
     <span class="pre">
      isNaN(a)
     </span>
     <span class="pre">
      ||
     </span>
     <span class="pre">
      isNaN(b)
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      equ
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      a
     </span>
     <span class="pre">
      !=
     </span>
     <span class="pre">
      b
     </span>
     <span class="pre">
      ||
     </span>
     <span class="pre">
      isNaN(a)
     </span>
     <span class="pre">
      ||
     </span>
     <span class="pre">
      isNaN(b)
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      neu
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      a
     </span>
     <span class="pre">
      &lt;
     </span>
     <span class="pre">
      b
     </span>
     <span class="pre">
      ||
     </span>
     <span class="pre">
      isNaN(a)
     </span>
     <span class="pre">
      ||
     </span>
     <span class="pre">
      isNaN(b)
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      ltu
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      a
     </span>
     <span class="pre">
      &lt;=
     </span>
     <span class="pre">
      b
     </span>
     <span class="pre">
      ||
     </span>
     <span class="pre">
      isNaN(a)
     </span>
     <span class="pre">
      ||
     </span>
     <span class="pre">
      isNaN(b)
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      leu
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      a
     </span>
     <span class="pre">
      &gt;
     </span>
     <span class="pre">
      b
     </span>
     <span class="pre">
      ||
     </span>
     <span class="pre">
      isNaN(a)
     </span>
     <span class="pre">
      ||
     </span>
     <span class="pre">
      isNaN(b)
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      gtu
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      a
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      b
     </span>
     <span class="pre">
      ||
     </span>
     <span class="pre">
      isNaN(a)
     </span>
     <span class="pre">
      ||
     </span>
     <span class="pre">
      isNaN(b)
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      geu
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  To test for
  <span class="pre">
   NaN
  </span>
  values, two operators
  <span class="pre">
   num
  </span>
  (
  <span class="pre">
   numeric
  </span>
  ) and
  <span class="pre">
   nan
  </span>
  (
  <span class="pre">
   isNaN
  </span>
  ) are
provided.
  <span class="pre">
   num
  </span>
  returns
  <span class="pre">
   True
  </span>
  if both operands are numeric values (not
  <span class="pre">
   NaN
  </span>
  ), and
  <span class="pre">
   nan
  </span>
  returns
  <span class="pre">
   True
  </span>
  if either operand is
  <span class="pre">
   NaN
  </span>
  .
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-comparisons-floating-point-operators-testing-nan">
   <span class="std std-numref">
    Table 22
   </span>
  </a>
  lists the
floating-point comparison operators testing for
  <span class="pre">
   NaN
  </span>
  values.
 </p>
 <table class="table-no-stripes docutils align-default" id="floating-point-comparisons-floating-point-operators-testing-nan">
  <span class="caption-number">
   Table 22
  </span>
  <span class="caption-text">
   Floating-Point Comparison Operators Testing for NaN
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-comparisons-floating-point-operators-testing-nan" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
   <th class="head">
    <p>
     Floating-Point Operator
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      !isNaN(a)
     </span>
     <span class="pre">
      &amp;&amp;
     </span>
     <span class="pre">
      !isNaN(b)
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      num
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      isNaN(a)
     </span>
     <span class="pre">
      ||
     </span>
     <span class="pre">
      isNaN(b)
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      nan
     </span>
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   9.3.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#manipulating-predicates">
   Manipulating Predicates
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#manipulating-predicates" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Predicate values may be computed and manipulated using the following instructions:
  <span class="pre">
   and
  </span>
  ,
  <span class="pre">
   or
  </span>
  ,
  <span class="pre">
   xor
  </span>
  ,
  <span class="pre">
   not
  </span>
  , and
  <span class="pre">
   mov
  </span>
  .
 </p>
 <p>
  There is no direct conversion between predicates and integer values, and no direct way to load or
store predicate register values. However,
  <span class="pre">
   setp
  </span>
  can be used to generate a predicate from an
integer, and the predicate-based select (
  <span class="pre">
   selp
  </span>
  ) instruction can be used to generate an integer
value based on the value of a predicate; for example:
 </p>
 <pre>selp.u32 %r1,1,0,%p;    // convert predicate to 32-bit value
</pre>
 <h2>
  <span class="section-number">
   9.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#type-information-for-instructions-and-operands">
   Type Information for Instructions and Operands
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#type-information-for-instructions-and-operands" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  Typed instructions must have a type-size modifier. For example, the
  <span class="pre">
   add
  </span>
  instruction requires
type and size information to properly perform the addition operation (signed, unsigned, float,
different sizes), and this information must be specified as a suffix to the opcode.
 </p>
 <p>
  Example
 </p>
 <pre>.reg .u16 d, a, b;

add.u16 d, a, b;    // perform a 16-bit unsigned add
</pre>
 <p>
  Some instructions require multiple type-size modifiers, most notably the data conversion instruction
  <span class="pre">
   cvt
  </span>
  . It requires separate type-size modifiers for the result and source, and these are placed in
the same order as the operands. For example:
 </p>
 <pre>.reg .u16 a;
.reg .f32 d;

cvt.f32.u16 d, a;   // convert 16-bit unsigned to 32-bit float
</pre>
 <p>
  In general, an operandâs type must agree with the corresponding instruction-type modifier. The rules
for operand and instruction type conformance are as follows:
 </p>
 <ul class="simple">
  <li>
   <p>
    Bit-size types agree with any type of the same size.
   </p>
  </li>
  <li>
   <p>
    Signed and unsigned integer types agree provided they have the same size, and integer operands are
silently cast to the instruction type if needed. For example, an unsigned integer operand used in
a signed integer instruction will be treated as a signed integer by the instruction.
   </p>
  </li>
  <li>
   <p>
    Floating-point types agree only if they have the same size; i.e., they must match exactly.
   </p>
  </li>
 </ul>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#type-information-for-instructions-and-operands-type-checking-rules">
   <span class="std std-numref">
    Table 23
   </span>
  </a>
  summarizes these type
checking rules.
 </p>
 <table class="table-no-stripes docutils align-default" id="type-information-for-instructions-and-operands-type-checking-rules">
  <span class="caption-number">
   Table 23
  </span>
  <span class="caption-text">
   Type Checking Rules
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#type-information-for-instructions-and-operands-type-checking-rules" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head" colspan="4">
    <p>
     Operand Type
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     .bX
    </p>
   </td>
   <td>
    <p>
     .sX
    </p>
   </td>
   <td>
    <p>
     .uX
    </p>
   </td>
   <td>
    <p>
     .fX
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td rowspan="4">
    <p>
     Instruction Type
    </p>
   </td>
   <td>
    <p>
     .bX
    </p>
   </td>
   <td>
    <p>
     okay
    </p>
   </td>
   <td>
    <p>
     okay
    </p>
   </td>
   <td>
    <p>
     okay
    </p>
   </td>
   <td>
    <p>
     okay
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     .sX
    </p>
   </td>
   <td>
    <p>
     okay
    </p>
   </td>
   <td>
    <p>
     okay
    </p>
   </td>
   <td>
    <p>
     okay
    </p>
   </td>
   <td>
    <p>
     invalid
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     .uX
    </p>
   </td>
   <td>
    <p>
     okay
    </p>
   </td>
   <td>
    <p>
     okay
    </p>
   </td>
   <td>
    <p>
     okay
    </p>
   </td>
   <td>
    <p>
     invalid
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     .fX
    </p>
   </td>
   <td>
    <p>
     okay
    </p>
   </td>
   <td>
    <p>
     invalid
    </p>
   </td>
   <td>
    <p>
     invalid
    </p>
   </td>
   <td>
    <p>
     okay
    </p>
   </td>
  </tr>
 </table>
 <p class="admonition-title">
  Note
 </p>
 <p>
  Some operands have their type and size defined independently from the instruction type-size. For
example, the shift amount operand for left and right shift instructions always has type
  <span class="pre">
   .u32
  </span>
  ,
while the remaining operands have their type and size determined by the instruction type.
 </p>
 <p>
  Example
 </p>
 <pre>// 64-bit arithmetic right shift; shift amount 'b' is .u32
    shr.s64 d,a,b;
</pre>
 <h3>
  <span class="section-number">
   9.4.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#operand-size-exceeding-instruction-type-size">
   Operand Size Exceeding Instruction-Type Size
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#operand-size-exceeding-instruction-type-size" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  For convenience,
  <span class="pre">
   ld
  </span>
  ,
  <span class="pre">
   st
  </span>
  , and
  <span class="pre">
   cvt
  </span>
  instructions permit source and destination data
operands to be wider than the instruction-type size, so that narrow values may be loaded, stored,
and converted using regular-width registers. For example, 8-bit or 16-bit values may be held
directly in 32-bit or 64-bit registers when being loaded, stored, or converted to other types and
sizes. The operand type checking rules are relaxed for bit-size and integer (signed and unsigned)
instruction types; floating-point instruction types still require that the operand type-size matches
exactly, unless the operand is of bit-size type.
 </p>
 <p>
  When a source operand has a size that exceeds the instruction-type size, the source data is
truncated (chopped) to the appropriate number of bits specified by the instruction type-size.
 </p>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#operand-size-exceeding-instruction-type-size-relaxed-type-checking-rules-source-operands">
   <span class="std std-numref">
    Table 24
   </span>
  </a>
  summarizes the relaxed type-checking rules for source operands. Note that some combinations may
still be invalid for a particular instruction; for example, the
  <span class="pre">
   cvt
  </span>
  instruction does not support
  <span class="pre">
   .bX
  </span>
  instruction types, so those rows are invalid for
  <span class="pre">
   cvt
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default" id="operand-size-exceeding-instruction-type-size-relaxed-type-checking-rules-source-operands">
  <span class="caption-number">
   Table 24
  </span>
  <span class="caption-text">
   Relaxed Type-checking Rules for Source Operands
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#operand-size-exceeding-instruction-type-size-relaxed-type-checking-rules-source-operands" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head" colspan="16">
    <p>
     Source Operand Type
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <th class="head">
    <p>
     b8
    </p>
   </th>
   <th class="head">
    <p>
     b16
    </p>
   </th>
   <th class="head">
    <p>
     b32
    </p>
   </th>
   <th class="head">
    <p>
     b64
    </p>
   </th>
   <th class="head">
    <p>
     b128
    </p>
   </th>
   <th class="head">
    <p>
     s8
    </p>
   </th>
   <th class="head">
    <p>
     s16
    </p>
   </th>
   <th class="head">
    <p>
     s32
    </p>
   </th>
   <th class="head">
    <p>
     s64
    </p>
   </th>
   <th class="head">
    <p>
     u8
    </p>
   </th>
   <th class="head">
    <p>
     u16
    </p>
   </th>
   <th class="head">
    <p>
     u32
    </p>
   </th>
   <th class="head">
    <p>
     u64
    </p>
   </th>
   <th class="head">
    <p>
     f16
    </p>
   </th>
   <th class="head">
    <p>
     f32
    </p>
   </th>
   <th class="head">
    <p>
     f64
    </p>
   </th>
  </tr>
  <tr class="row-odd">
   <td rowspan="16">
    <p>
     Instruction Type
    </p>
   </td>
   <td>
    <p>
     b8
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     b16
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     b32
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     b64
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     b128
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     s8
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     s16
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     s32
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     s64
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     u8
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     u16
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     u32
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     u64
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     f16
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     f32
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     f64
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     chop
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td colspan="2">
    <p>
     Notes
    </p>
   </td>
   <td colspan="16">
    <p>
     chop = keep only low bits that fit; âââ = allowed, but no conversion needed;
    </p>
    <p>
     inv = invalid, parse error.
    </p>
    <ol class="arabic simple">
     <li>
      <p>
       Source register size must be of equal or greater size than the instruction-type size.
      </p>
     </li>
     <li>
      <p>
       Bit-size source registers may be used with any appropriately-sized instruction type. The data are
truncated (âchoppedâ) to the instruction-type size and interpreted according to the instruction
type.
      </p>
     </li>
     <li>
      <p>
       Integer source registers may be used with any appropriately-sized bit-size or integer instruction
type. The data are truncated to the instruction-type size and interpreted according to the
instruction type.
      </p>
     </li>
     <li>
      <p>
       Floating-point source registers can only be used with bit-size or floating-point instruction types.
When used with a narrower bit-size instruction type, the data are truncated. When used with a
floating-point instruction type, the size must match exactly.
      </p>
     </li>
    </ol>
   </td>
  </tr>
 </table>
 <p>
  When a destination operand has a size that exceeds the instruction-type size, the destination data
is zero- or sign-extended to the size of the destination register. If the corresponding instruction
type is signed integer, the data is sign-extended; otherwise, the data is zero-extended.
 </p>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#operand-size-exceeding-instruction-type-size-relaxed-type-checking-rules-destination-operands">
   <span class="std std-numref">
    Table 25
   </span>
  </a>
  summarizes the relaxed type-checking rules for destination operands.
 </p>
 <table class="table-no-stripes docutils align-default" id="operand-size-exceeding-instruction-type-size-relaxed-type-checking-rules-destination-operands">
  <span class="caption-number">
   Table 25
  </span>
  <span class="caption-text">
   Relaxed Type-checking Rules for Destination Operands
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#operand-size-exceeding-instruction-type-size-relaxed-type-checking-rules-destination-operands" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head" colspan="16">
    <p>
     Destination Operand Type
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <th class="head">
    <p>
     b8
    </p>
   </th>
   <th class="head">
    <p>
     b16
    </p>
   </th>
   <th class="head">
    <p>
     b32
    </p>
   </th>
   <th class="head">
    <p>
     b64
    </p>
   </th>
   <th class="head">
    <p>
     b128
    </p>
   </th>
   <th class="head">
    <p>
     s8
    </p>
   </th>
   <th class="head">
    <p>
     s16
    </p>
   </th>
   <th class="head">
    <p>
     s32
    </p>
   </th>
   <th class="head">
    <p>
     s64
    </p>
   </th>
   <th class="head">
    <p>
     u8
    </p>
   </th>
   <th class="head">
    <p>
     u16
    </p>
   </th>
   <th class="head">
    <p>
     u32
    </p>
   </th>
   <th class="head">
    <p>
     u64
    </p>
   </th>
   <th class="head">
    <p>
     f16
    </p>
   </th>
   <th class="head">
    <p>
     f32
    </p>
   </th>
   <th class="head">
    <p>
     f64
    </p>
   </th>
  </tr>
  <tr class="row-odd">
   <td rowspan="16">
    <p>
     Instruction Type
    </p>
   </td>
   <td>
    <p>
     b8
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     b16
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     b32
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     b64
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     b128
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     s8
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     s16
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     s32
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     s64
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     sext
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     u8
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     u16
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     u32
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     u64
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     f16
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     f32
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     f64
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     zext
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     inv
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td colspan="2">
    <p>
     Notes
    </p>
   </td>
   <td colspan="16">
    <p>
     sext = sign-extend; zext = zero-extend; âââ = allowed, but no conversion needed;
    </p>
    <p>
     inv = invalid, parse error.
    </p>
    <ol class="arabic simple">
     <li>
      <p>
       Destination register size must be of equal or greater size than the instruction-type size.
      </p>
     </li>
     <li>
      <p>
       Bit-size destination registers may be used with any appropriately-sized instruction type. The data
are sign-extended to the destination register width for signed integer instruction types, and are
zero-extended to the destination register width otherwise.
      </p>
     </li>
     <li>
      <p>
       Integer destination registers may be used with any appropriately-sized bit-size or integer
instruction type. The data are sign-extended to the destination register width for signed integer
instruction types, and are zero-extended to the destination register width for bit-size an d
unsigned integer instruction types.
      </p>
     </li>
     <li>
      <p>
       Floating-point destination registers can only be used with bit-size or floating-point instruction
types. When used with a narrower bit-size instruction type, the data are zero-extended. When used
with a floating-point instruction type, the size must match exactly.
      </p>
     </li>
    </ol>
   </td>
  </tr>
 </table>
 <h2>
  <span class="section-number">
   9.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#divergence-of-threads-in-control-constructs">
   Divergence of Threads in Control Constructs
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#divergence-of-threads-in-control-constructs" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  Threads in a CTA execute together, at least in appearance, until they come to a conditional control
construct such as a conditional branch, conditional function call, or conditional return. If threads
execute down different control flow paths, the threads are called
  divergent
  . If all of the threads
act in unison and follow a single control flow path, the threads are called
  uniform
  . Both
situations occur often in programs.
 </p>
 <p>
  A CTA with divergent threads may have lower performance than a CTA with uniformly executing threads,
so it is important to have divergent threads re-converge as soon as possible. All control constructs
are assumed to be divergent points unless the control-flow instruction is marked as uniform, using
the
  <span class="pre">
   .uni
  </span>
  suffix. For divergent control flow, the optimizing code generator automatically
determines points of re-convergence. Therefore, a compiler or code author targeting PTX can ignore
the issue of divergent threads, but has the opportunity to improve performance by marking branch
points as uniform when the compiler or author can guarantee that the branch point is non-divergent.
 </p>
 <h2>
  <span class="section-number">
   9.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#semantics">
   Semantics
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#semantics" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  The goal of the semantic description of an instruction is to describe the results in all cases in as
simple language as possible. The semantics are described using C, until C is not expressive enough.
 </p>
 <h3>
  <span class="section-number">
   9.6.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#machine-specific-semantics-of-16-bit-code">
   Machine-Specific Semantics of 16-bit Code
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#machine-specific-semantics-of-16-bit-code" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  A PTX program may execute on a GPU with either a 16-bit or a 32-bit data path. When executing on a
32-bit data path, 16-bit registers in PTX are mapped to 32-bit physical registers, and 16-bit
computations are
  promoted
  to 32-bit computations. This can lead to computational differences
between code run on a 16-bit machine versus the same code run on a 32-bit machine, since the
promoted computation may have bits in the high-order half-word of registers that are not present in
16-bit physical registers. These extra precision bits can become visible at the application level,
for example, by a right-shift instruction.
 </p>
 <p>
  At the PTX language level, one solution would be to define semantics for 16-bit code that is
consistent with execution on a 16-bit data path. This approach introduces a performance penalty for
16-bit code executing on a 32-bit data path, since the translated code would require many additional
masking instructions to suppress extra precision bits in the high-order half-word of 32-bit
registers.
 </p>
 <p>
  Rather than introduce a performance penalty for 16-bit code running on 32-bit GPUs, the semantics of
16-bit instructions in PTX is machine-specific. A compiler or programmer may chose to enforce
portable, machine-independent 16-bit semantics by adding explicit conversions to 16-bit values at
appropriate points in the program to guarantee portability of the code. However, for many
performance-critical applications, this is not desirable, and for many applications the difference
in execution is preferable to limiting performance.
 </p>
 <h2>
  <span class="section-number">
   9.7.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#instructions">
   Instructions
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#instructions" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  All PTX instructions may be predicated. In the following descriptions, the optional guard predicate
is omitted from the syntax.
 </p>
 <h3>
  <span class="section-number">
   9.7.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions">
   Integer Arithmetic Instructions
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Integer arithmetic instructions operate on the integer types in register and constant immediate
forms. The integer arithmetic instructions are:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     add
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     sub
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     mul
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     mad
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     mul24
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     mad24
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     sad
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     div
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     rem
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     abs
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     neg
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     min
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     max
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     popc
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     clz
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     bfind
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     fns
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     brev
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     bfe
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     bfi
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     bmsk
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     szext
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     dp4a
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     dp2a
    </span>
   </p>
  </li>
 </ul>
 <h4>
  <span class="section-number">
   9.7.1.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-add">
   Integer Arithmetic Instructions: add
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-add" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  add
 </p>
 <p>
  Add two values.
 </p>
 <p>
  Syntax
 </p>
 <pre>add.type       d, a, b;
add{.sat}.s32  d, a, b;     // .sat applies only to .s32

.type = { .u16, .u32, .u64,
          .s16, .s32, .s64,
          .u16x2, .s16x2 };
</pre>
 <p>
  Description
 </p>
 <p>
  Performs addition and writes the resulting value into a destination register.
 </p>
 <p>
  For
  <span class="pre">
   .u16x2
  </span>
  ,
  <span class="pre">
   .s16x2
  </span>
  instruction types, forms input vectors by half word values from source
operands. Half-word operands are then added in parallel to produce
  <span class="pre">
   .u16x2
  </span>
  ,
  <span class="pre">
   .s16x2
  </span>
  result in
destination.
 </p>
 <p>
  Operands
  <span class="pre">
   d
  </span>
  ,
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  have type
  <span class="pre">
   .type
  </span>
  . For instruction types
  <span class="pre">
   .u16x2
  </span>
  ,
  <span class="pre">
   .s16x2
  </span>
  ,
operands
  <span class="pre">
   d
  </span>
  ,
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  have type
  <span class="pre">
   .b32
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>if (type == u16x2 || type == s16x2) {
    iA[0] = a[0:15];
    iA[1] = a[16:31];
    iB[0] = b[0:15];
    iB[1] = b[16:31];
    for (i = 0; i &lt; 2; i++) {
         d[i] = iA[i] + iB[i];
    }
} else {
    d = a + b;
}
</pre>
 <p>
  Notes
 </p>
 <p>
  Saturation modifier:
 </p>
 .sat
 <p>
  limits result to
  <span class="pre">
   MININT..MAXINT
  </span>
  (no overflow) for the size of the operation. Applies only to
  <span class="pre">
   .s32
  </span>
  type.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  <span class="pre">
   add.u16x2
  </span>
  and
  <span class="pre">
   add.s16x2
  </span>
  introduced in PTX ISA version 8.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  <span class="pre">
   add.u16x2
  </span>
  and
  <span class="pre">
   add.s16x2
  </span>
  require
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>@p  add.u32     x,y,z;
    add.sat.s32 c,c,1;
    add.u16x2   u,v,w;
</pre>
 <h4>
  <span class="section-number">
   9.7.1.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-sub">
   Integer Arithmetic Instructions: sub
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-sub" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  sub
 </p>
 <p>
  Subtract one value from another.
 </p>
 <p>
  Syntax
 </p>
 <pre>sub.type       d, a, b;
sub{.sat}.s32  d, a, b;     // .sat applies only to .s32

.type = { .u16, .u32, .u64,
          .s16, .s32, .s64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Performs subtraction and writes the resulting value into a destination register.
 </p>
 <p>
  Semantics
 </p>
 <pre>d = a - b;
</pre>
 <p>
  Notes
 </p>
 <p>
  Saturation modifier:
 </p>
 <span class="pre">
  .sat
 </span>
 <p>
  limits result to
  <span class="pre">
   MININT..MAXINT
  </span>
  (no overflow) for the size of the operation. Applies only to
  <span class="pre">
   .s32
  </span>
  type.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>sub.s32 c,a,b;
</pre>
 <h4>
  <span class="section-number">
   9.7.1.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-mul">
   Integer Arithmetic Instructions: mul
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-mul" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  mul
 </p>
 <p>
  Multiply two values.
 </p>
 <p>
  Syntax
 </p>
 <pre>mul.mode.type  d, a, b;

.mode = { .hi, .lo, .wide };
.type = { .u16, .u32, .u64,
          .s16, .s32, .s64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Compute the product of two values.
 </p>
 <p>
  Semantics
 </p>
 <pre>t = a * b;
n = bitwidth of type;
d = t;            // for .wide
d = t&lt;2n-1..n&gt;;   // for .hi variant
d = t&lt;n-1..0&gt;;    // for .lo variant
</pre>
 <p>
  Notes
 </p>
 <p>
  The type of the operation represents the types of the
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  operands. If
  <span class="pre">
   .hi
  </span>
  or
  <span class="pre">
   .lo
  </span>
  is specified, then
  <span class="pre">
   d
  </span>
  is the same size as
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  , and either the upper or lower
half of the result is written to the destination register. If
  <span class="pre">
   .wide
  </span>
  is specified, then
  <span class="pre">
   d
  </span>
  is
twice as wide as
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  to receive the full result of the multiplication.
 </p>
 <p>
  The
  <span class="pre">
   .wide
  </span>
  suffix is supported only for 16- and 32-bit integer types.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>mul.wide.s16 fa,fxs,fys;   // 16*16 bits yields 32 bits
mul.lo.s16 fa,fxs,fys;     // 16*16 bits, save only the low 16 bits
mul.wide.s32 z,x,y;        // 32*32 bits, creates 64 bit result
</pre>
 <h4>
  <span class="section-number">
   9.7.1.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-mad">
   Integer Arithmetic Instructions: mad
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-mad" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  mad
 </p>
 <p>
  Multiply two values, optionally extract the high or low half of the intermediate result, and add a third value.
 </p>
 <p>
  Syntax
 </p>
 <pre>mad.mode.type  d, a, b, c;
mad.hi.sat.s32 d, a, b, c;

.mode = { .hi, .lo, .wide };
.type = { .u16, .u32, .u64,
          .s16, .s32, .s64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Multiplies two values, optionally extracts the high or low half of the intermediate result, and adds
a third value. Writes the result into a destination register.
 </p>
 <p>
  Semantics
 </p>
 <pre>t = a * b;
n = bitwidth of type;
d = t + c;           // for .wide
d = t&lt;2n-1..n&gt; + c;  // for .hi variant
d = t&lt;n-1..0&gt; + c;   // for .lo variant
</pre>
 <p>
  Notes
 </p>
 <p>
  The type of the operation represents the types of the
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  operands. If .hi or .lo is
specified, then
  <span class="pre">
   d
  </span>
  and
  <span class="pre">
   c
  </span>
  are the same size as
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  , and either the upper or lower
half of the result is written to the destination register. If
  <span class="pre">
   .wide
  </span>
  is specified, then
  <span class="pre">
   d
  </span>
  and
  <span class="pre">
   c
  </span>
  are twice as wide as
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  to receive the result of the multiplication.
 </p>
 <p>
  The
  <span class="pre">
   .wide
  </span>
  suffix is supported only for 16-bit and 32-bit integer types.
 </p>
 <p>
  Saturation modifier:
 </p>
 <span class="pre">
  .sat
 </span>
 <p>
  limits result to
  <span class="pre">
   MININT..MAXINT
  </span>
  (no overflow) for the size of the operation.
 </p>
 <p>
  Applies only to
  <span class="pre">
   .s32
  </span>
  type in
  <span class="pre">
   .hi
  </span>
  mode.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>@p  mad.lo.s32 d,a,b,c;
    mad.lo.s32 r,p,q,r;
</pre>
 <h4>
  <span class="section-number">
   9.7.1.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-mul24">
   Integer Arithmetic Instructions: mul24
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-mul24" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  mul24
 </p>
 <p>
  Multiply two 24-bit integer values.
 </p>
 <p>
  Syntax
 </p>
 <pre>mul24.mode.type  d, a, b;

.mode = { .hi, .lo };
.type = { .u32, .s32 };
</pre>
 <p>
  Description
 </p>
 <p>
  Compute the product of two 24-bit integer values held in 32-bit source registers, and return either
the high or low 32-bits of the 48-bit result.
 </p>
 <p>
  Semantics
 </p>
 <pre>t = a * b;
d = t&lt;47..16&gt;;    // for .hi variant
d = t&lt;31..0&gt;;     // for .lo variant
</pre>
 <p>
  Notes
 </p>
 <p>
  Integer multiplication yields a result that is twice the size of the input operands, i.e., 48-bits.
 </p>
 <p>
  <span class="pre">
   mul24.hi
  </span>
  performs a 24x24-bit multiply and returns the high 32 bits of the 48-bit result.
 </p>
 <p>
  <span class="pre">
   mul24.lo
  </span>
  performs a 24x24-bit multiply and returns the low 32 bits of the 48-bit result.
 </p>
 <p>
  All operands are of the same type and size.
 </p>
 <p>
  <span class="pre">
   mul24.hi
  </span>
  may be less efficient on machines without hardware support for 24-bit multiply.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>mul24.lo.s32 d,a,b;   // low 32-bits of 24x24-bit signed multiply.
</pre>
 <h4>
  <span class="section-number">
   9.7.1.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-mad24">
   Integer Arithmetic Instructions: mad24
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-mad24" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  mad24
 </p>
 <p>
  Multiply two 24-bit integer values and add a third value.
 </p>
 <p>
  Syntax
 </p>
 <pre>mad24.mode.type  d, a, b, c;
mad24.hi.sat.s32 d, a, b, c;

.mode = { .hi, .lo };
.type = { .u32, .s32 };
</pre>
 <p>
  Description
 </p>
 <p>
  Compute the product of two 24-bit integer values held in 32-bit source registers, and add a third,
32-bit value to either the high or low 32-bits of the 48-bit result. Return either the high or low
32-bits of the 48-bit result.
 </p>
 <p>
  Semantics
 </p>
 <pre>t = a * b;
d = t&lt;47..16&gt; + c;   // for .hi variant
d = t&lt;31..0&gt; + c;    // for .lo variant
</pre>
 <p>
  Notes
 </p>
 <p>
  Integer multiplication yields a result that is twice the size of the input operands, i.e., 48-bits.
 </p>
 <p>
  <span class="pre">
   mad24.hi
  </span>
  performs a 24x24-bit multiply and adds the high 32 bits of the 48-bit result to a third
value.
 </p>
 <p>
  <span class="pre">
   mad24.lo
  </span>
  performs a 24x24-bit multiply and adds the low 32 bits of the 48-bit result to a third
value.
 </p>
 <p>
  All operands are of the same type and size.
 </p>
 <p>
  Saturation modifier:
 </p>
 <span class="pre">
  .sat
 </span>
 <p>
  limits result of 32-bit signed addition to
  <span class="pre">
   MININT..MAXINT
  </span>
  (no overflow). Applies only to
  <span class="pre">
   .s32
  </span>
  type in .hi mode.
 </p>
 <p>
  <span class="pre">
   mad24.hi
  </span>
  may be less efficient on machines without hardware support for 24-bit multiply.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>mad24.lo.s32 d,a,b,c;   // low 32-bits of 24x24-bit signed multiply.
</pre>
 <h4>
  <span class="section-number">
   9.7.1.7.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-sad">
   Integer Arithmetic Instructions: sad
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-sad" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  sad
 </p>
 <p>
  Sum of absolute differences.
 </p>
 <p>
  Syntax
 </p>
 <pre>sad.type  d, a, b, c;

.type = { .u16, .u32, .u64,
          .s16, .s32, .s64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Adds the absolute value of
  <span class="pre">
   a-b
  </span>
  to
  <span class="pre">
   c
  </span>
  and writes the resulting value into
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>d = c + ((a&lt;b) ? b-a : a-b);
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>sad.s32  d,a,b,c;
sad.u32  d,a,b,d;  // running sum
</pre>
 <h4>
  <span class="section-number">
   9.7.1.8.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-div">
   Integer Arithmetic Instructions: div
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-div" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  div
 </p>
 <p>
  Divide one value by another.
 </p>
 <p>
  Syntax
 </p>
 <pre>div.type  d, a, b;

.type = { .u16, .u32, .u64,
          .s16, .s32, .s64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Divides
  <span class="pre">
   a
  </span>
  by
  <span class="pre">
   b
  </span>
  , stores result in
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>d = a / b;
</pre>
 <p>
  Notes
 </p>
 <p>
  Division by zero yields an unspecified, machine-specific value.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>div.s32  b,n,i;
</pre>
 <h4>
  <span class="section-number">
   9.7.1.9.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-rem">
   Integer Arithmetic Instructions: rem
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-rem" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  rem
 </p>
 <p>
  The remainder of integer division.
 </p>
 <p>
  Syntax
 </p>
 <pre>rem.type  d, a, b;

.type = { .u16, .u32, .u64,
          .s16, .s32, .s64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Divides
  <span class="pre">
   a
  </span>
  by
  <span class="pre">
   b
  </span>
  , store the remainder in
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>d = a % b;
</pre>
 <p>
  Notes
 </p>
 <p>
  The behavior for negative numbers is machine-dependent and depends on whether divide rounds towards
zero or negative infinity.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>rem.s32  x,x,8;    // x = x%8;
</pre>
 <h4>
  <span class="section-number">
   9.7.1.10.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-abs">
   Integer Arithmetic Instructions: abs
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-abs" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  abs
 </p>
 <p>
  Absolute value.
 </p>
 <p>
  Syntax
 </p>
 <pre>abs.type  d, a;

.type = { .s16, .s32, .s64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Take the absolute value of
  <span class="pre">
   a
  </span>
  and store it in
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>d = |a|;
</pre>
 <p>
  Notes
 </p>
 <p>
  Only for signed integers.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>abs.s32  r0,a;
</pre>
 <h4>
  <span class="section-number">
   9.7.1.11.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-neg">
   Integer Arithmetic Instructions: neg
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-neg" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  neg
 </p>
 <p>
  Arithmetic negate.
 </p>
 <p>
  Syntax
 </p>
 <pre>neg.type  d, a;

.type = { .s16, .s32, .s64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Negate the sign of
  a
  and store the result in
  d
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>d = -a;
</pre>
 <p>
  Notes
 </p>
 <p>
  Only for signed integers.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>neg.s32  r0,a;
</pre>
 <h4>
  <span class="section-number">
   9.7.1.12.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-min">
   Integer Arithmetic Instructions: min
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-min" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  min
 </p>
 <p>
  Find the minimum of two values.
 </p>
 <p>
  Syntax
 </p>
 <pre>min.atype         d, a, b;
min{.relu}.btype  d, a, b;

.atype = { .u16, .u32, .u64,
           .u16x2, .s16, .s64 };
.btype = { .s16x2, .s32 };
</pre>
 <p>
  Description
 </p>
 <p>
  Store the minimum of
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  in
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  For
  <span class="pre">
   .u16x2
  </span>
  ,
  <span class="pre">
   .s16x2
  </span>
  instruction types, forms input vectors by half word values from source
operands. Half-word operands are then processed in parallel to produce
  <span class="pre">
   .u16x2
  </span>
  ,
  <span class="pre">
   .s16x2
  </span>
  result
in destination.
 </p>
 <p>
  Operands
  <span class="pre">
   d
  </span>
  ,
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  have the same type as the instruction type. For instruction types
  <span class="pre">
   .u16x2
  </span>
  ,
  <span class="pre">
   .s16x2
  </span>
  , operands
  <span class="pre">
   d
  </span>
  ,
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  have type
  <span class="pre">
   .b32
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>if (type == u16x2 || type == s16x2) {
    iA[0] = a[0:15];
    iA[1] = a[16:31];
    iB[0] = b[0:15];
    iB[1] = b[16:31];
    for (i = 0; i &lt; 2; i++) {
         d[i] = (iA[i] &lt; iB[i]) ? iA[i] : iB[i];
    }
} else {
    d = (a &lt; b) ? a : b; // Integer (signed and unsigned)
}
</pre>
 <p>
  Notes
 </p>
 <p>
  Signed and unsigned differ.
 </p>
 Saturation modifier:
 <p>
  <span class="pre">
   min.relu.{s16x2,
  </span>
  <span class="pre">
   s32}
  </span>
  clamps the result to 0 if negative.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  <span class="pre">
   min.u16x2
  </span>
  ,
  <span class="pre">
   min{.relu}.s16x2
  </span>
  and
  <span class="pre">
   min.relu.s32
  </span>
  introduced in PTX ISA version 8.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  <span class="pre">
   min.u16x2
  </span>
  ,
  <span class="pre">
   min{.relu}.s16x2
  </span>
  and
  <span class="pre">
   min.relu.s32
  </span>
  require
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>    min.s32  r0,a,b;
@p  min.u16  h,i,j;
    min.s16x2.relu u,v,w;
</pre>
 <h4>
  <span class="section-number">
   9.7.1.13.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-max">
   Integer Arithmetic Instructions: max
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-max" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  max
 </p>
 <p>
  Find the maximum of two values.
 </p>
 <p>
  Syntax
 </p>
 <pre>max.atype         d, a, b;
max{.relu}.btype  d, a, b;

.atype = { .u16, .u32, .u64,
           .u16x2, .s16, .s64 };
.btype = { .s16x2, .s32 };
</pre>
 <p>
  Description
 </p>
 <p>
  Store the maximum of
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  in
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  For
  <span class="pre">
   .u16x2
  </span>
  ,
  <span class="pre">
   .s16x2
  </span>
  instruction types, forms input vectors by half word values from source
operands. Half-word operands are then processed in parallel to produce
  <span class="pre">
   .u16x2
  </span>
  ,
  <span class="pre">
   .s16x2
  </span>
  result
in destination.
 </p>
 <p>
  Operands
  <span class="pre">
   d
  </span>
  ,
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  have the same type as the instruction type. For instruction types
  <span class="pre">
   .u16x2
  </span>
  ,
  <span class="pre">
   .s16x2
  </span>
  , operands
  <span class="pre">
   d
  </span>
  ,
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  have type
  <span class="pre">
   .b32
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>if (type == u16x2 || type == s16x2) {
    iA[0] = a[0:15];
    iA[1] = a[16:31];
    iB[0] = b[0:15];
    iB[1] = b[16:31];
    for (i = 0; i &lt; 2; i++) {
         d[i] = (iA[i] &gt; iB[i]) ? iA[i] : iB[i];
    }
} else {
    d = (a &gt; b) ? a : b; // Integer (signed and unsigned)
}
</pre>
 <p>
  Notes
 </p>
 <p>
  Signed and unsigned differ.
 </p>
 Saturation modifier:
 <p>
  <span class="pre">
   max.relu.{s16x2,
  </span>
  <span class="pre">
   s32}
  </span>
  clamps the result to 0 if negative.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  <span class="pre">
   max.u16x2
  </span>
  ,
  <span class="pre">
   max{.relu}.s16x2
  </span>
  and
  <span class="pre">
   max.relu.s32
  </span>
  introduced in PTX ISA version 8.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  <span class="pre">
   max.u16x2
  </span>
  ,
  <span class="pre">
   max{.relu}.s16x2
  </span>
  and
  <span class="pre">
   max.relu.s32
  </span>
  require
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>max.u32  d,a,b;
max.s32  q,q,0;
max.relu.s16x2 t,t,u;
</pre>
 <h4>
  <span class="section-number">
   9.7.1.14.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-popc">
   Integer Arithmetic Instructions: popc
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-popc" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  popc
 </p>
 <p>
  Population count.
 </p>
 <p>
  Syntax
 </p>
 <pre>popc.type  d, a;

.type = { .b32, .b64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Count the number of one bits in
  <span class="pre">
   a
  </span>
  and place the resulting
  population count
  in 32-bit
destination register
  <span class="pre">
   d
  </span>
  . Operand
  <span class="pre">
   a
  </span>
  has the instruction type and destination
  <span class="pre">
   d
  </span>
  has type
  <span class="pre">
   .u32
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>.u32  d = 0;
while (a != 0) {
   if (a &amp; 0x1)  d++;
   a = a &gt;&gt; 1;
}
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   popc
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>popc.b32  d, a;
popc.b64  cnt, X;  // cnt is .u32
</pre>
 <h4>
  <span class="section-number">
   9.7.1.15.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-clz">
   Integer Arithmetic Instructions: clz
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-clz" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  clz
 </p>
 <p>
  Count leading zeros.
 </p>
 <p>
  Syntax
 </p>
 <pre>clz.type  d, a;

.type = { .b32, .b64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Count the number of leading zeros in
  <span class="pre">
   a
  </span>
  starting with the most-significant bit and place the
result in 32-bit destination register
  <span class="pre">
   d
  </span>
  .Â Operand
  <span class="pre">
   a
  </span>
  has the instruction type, and destination
  <span class="pre">
   d
  </span>
  has type
  <span class="pre">
   .u32
  </span>
  . For
  <span class="pre">
   .b32
  </span>
  type, the number of leading zeros is between 0 and 32,
inclusively. For
  <span class="pre">
   .b64
  </span>
  type, the number of leading zeros is between 0 and 64, inclusively.
 </p>
 <p>
  Semantics
 </p>
 <pre>.u32  d = 0;
if (.type == .b32)   { max = 32; mask = 0x80000000; }
else                 { max = 64; mask = 0x8000000000000000; }

while (d &lt; max &amp;&amp; (a&amp;mask == 0) ) {
    d++;
    a = a &lt;&lt; 1;
}
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   clz
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>clz.b32  d, a;
clz.b64  cnt, X;  // cnt is .u32
</pre>
 <h4>
  <span class="section-number">
   9.7.1.16.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-bfind">
   Integer Arithmetic Instructions: bfind
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-bfind" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  bfind
 </p>
 <p>
  Find most significant non-sign bit.
 </p>
 <p>
  Syntax
 </p>
 <pre>bfind.type           d, a;
bfind.shiftamt.type  d, a;

.type = { .u32, .u64,
          .s32, .s64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Find the bit position of the most significant non-sign bit in
  <span class="pre">
   a
  </span>
  and place the result in
  <span class="pre">
   d
  </span>
  . Operand
  <span class="pre">
   a
  </span>
  has the instruction type, and destination
  <span class="pre">
   d
  </span>
  has type
  <span class="pre">
   .u32
  </span>
  . For unsigned
integers,
  <span class="pre">
   bfind
  </span>
  returns the bit position of the most significant
  <span class="pre">
   1
  </span>
  . For signed integers,
  <span class="pre">
   bfind
  </span>
  returns the bit position of the most significant
  <span class="pre">
   0
  </span>
  for negative inputs and the most
significant
  <span class="pre">
   1
  </span>
  for non-negative inputs.
 </p>
 <p>
  If
  <span class="pre">
   .shiftamt
  </span>
  is specified,
  <span class="pre">
   bfind
  </span>
  returns the shift amount needed to left-shift the found bit
into the most-significant bit position.
 </p>
 <p>
  <span class="pre">
   bfind
  </span>
  returns
  <span class="pre">
   0xffffffff
  </span>
  if no non-sign bit is found.
 </p>
 <p>
  Semantics
 </p>
 <pre>msb = (.type==.u32 || .type==.s32) ? 31 : 63;
// negate negative signed inputs
if ( (.type==.s32 || .type==.s64) &amp;&amp; (a &amp; (1&lt;&lt;msb)) ) {
    a = ~a;
}
.u32  d = 0xffffffff;
for (.s32 i=msb; i&gt;=0; i--) {
    if (a &amp; (1&lt;&lt;i))  { d = i; break; }
}
if (.shiftamt &amp;&amp; d != 0xffffffff)  { d = msb - d; }
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   bfind
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>bfind.u32  d, a;
bfind.shiftamt.s64  cnt, X;  // cnt is .u32
</pre>
 <h4>
  <span class="section-number">
   9.7.1.17.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-fns">
   Integer Arithmetic Instructions: fns
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-fns" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  fns
 </p>
 <p>
  Find the n-th set bit
 </p>
 <p>
  Syntax
 </p>
 <pre>fns.b32 d, mask, base, offset;
</pre>
 <p>
  Description
 </p>
 <p>
  Given a 32-bit value
  <span class="pre">
   mask
  </span>
  and an integer value
  <span class="pre">
   base
  </span>
  (between 0 and 31), find the n-th (given
by offset) set bit in
  <span class="pre">
   mask
  </span>
  from the
  <span class="pre">
   base
  </span>
  bit, and store the bit position in
  <span class="pre">
   d
  </span>
  . If not
found, store 0xffffffff in
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  Operand
  <span class="pre">
   mask
  </span>
  has a 32-bit type. Operand
  <span class="pre">
   base
  </span>
  has
  <span class="pre">
   .b32
  </span>
  ,
  <span class="pre">
   .u32
  </span>
  or
  <span class="pre">
   .s32
  </span>
  type. Operand offset has
  <span class="pre">
   .s32
  </span>
  type. Destination
  <span class="pre">
   d
  </span>
  has type
  <span class="pre">
   .b32.
  </span>
 </p>
 <p>
  Operand
  <span class="pre">
   base
  </span>
  must be &lt;= 31, otherwise behavior is undefined.
 </p>
 <p>
  Semantics
 </p>
 <pre>d = 0xffffffff;
if (offset == 0) {
    if (mask[base] == 1) {
        d = base;
    }
} else {
    pos = base;
    count = |offset| - 1;
    inc = (offset &gt; 0) ? 1 : -1;

    while ((pos &gt;= 0) &amp;&amp; (pos &lt; 32)) {
        if (mask[pos] == 1) {
            if (count == 0) {
              d = pos;
              break;
           } else {
               count = count â 1;
           }
        }
        pos = pos + inc;
    }
}
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 6.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   fns
  </span>
  requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>fns.b32 d, 0xaaaaaaaa, 3, 1;   // d = 3
fns.b32 d, 0xaaaaaaaa, 3, -1;  // d = 3
fns.b32 d, 0xaaaaaaaa, 2, 1;   // d = 3
fns.b32 d, 0xaaaaaaaa, 2, -1;  // d = 1
</pre>
 <h4>
  <span class="section-number">
   9.7.1.18.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-brev">
   Integer Arithmetic Instructions: brev
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-brev" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  brev
 </p>
 <p>
  Bit reverse.
 </p>
 <p>
  Syntax
 </p>
 <pre>brev.type  d, a;

.type = { .b32, .b64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Perform bitwise reversal of input.
 </p>
 <p>
  Semantics
 </p>
 <pre>msb = (.type==.b32) ? 31 : 63;

for (i=0; i&lt;=msb; i++) {
    d[i] = a[msb-i];
}
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   brev
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>brev.b32  d, a;
</pre>
 <h4>
  <span class="section-number">
   9.7.1.19.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-bfe">
   Integer Arithmetic Instructions: bfe
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-bfe" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  bfe
 </p>
 <p>
  Bit Field Extract.
 </p>
 <p>
  Syntax
 </p>
 <pre>bfe.type  d, a, b, c;

.type = { .u32, .u64,
          .s32, .s64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Extract bit field from
  <span class="pre">
   a
  </span>
  and place the zero or sign-extended result in
  <span class="pre">
   d
  </span>
  . Source
  <span class="pre">
   b
  </span>
  gives
the bit field starting bit position, and source
  <span class="pre">
   c
  </span>
  gives the bit field length in bits.
 </p>
 <p>
  Operands
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   d
  </span>
  have the same type as the instruction type. Operands
  <span class="pre">
   b
  </span>
  and
  <span class="pre">
   c
  </span>
  are
type
  <span class="pre">
   .u32
  </span>
  , but are restricted to the 8-bit value range
  <span class="pre">
   0..255
  </span>
  .
 </p>
 <p>
  The sign bit of the extracted field is defined as:
 </p>
 <span class="pre">
  .u32
 </span>
 ,
 <span class="pre">
  .u64
 </span>
 :
 <p>
  zero
 </p>
 <span class="pre">
  .s32
 </span>
 ,
 <span class="pre">
  .s64
 </span>
 :
 <p>
  <span class="pre">
   msb
  </span>
  of input a if the extracted field extends beyond the
  <span class="pre">
   msb
  </span>
  of a
  <span class="pre">
   msb
  </span>
  of extracted
field, otherwise
 </p>
 <p>
  If the bit field length is zero, the result is zero.
 </p>
 <p>
  The destination
  <span class="pre">
   d
  </span>
  is padded with the sign bit of the extracted field. If the start position is
beyond the
  <span class="pre">
   msb
  </span>
  of the input, the destination
  <span class="pre">
   d
  </span>
  is filled with the replicated sign bit of the
extracted field.
 </p>
 <p>
  Semantics
 </p>
 <pre>msb = (.type==.u32 || .type==.s32) ? 31 : 63;
pos = b &amp; 0xff;  // pos restricted to 0..255 range
len = c &amp; 0xff;  // len restricted to 0..255 range

if (.type==.u32 || .type==.u64 || len==0)
    sbit = 0;
else
    sbit = a[min(pos+len-1,msb)];

d = 0;
for (i=0; i&lt;=msb; i++) {
    d[i] = (i&lt;len &amp;&amp; pos+i&lt;=msb) ? a[pos+i] : sbit;
}
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   bfe
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>bfe.b32  d,a,start,len;
</pre>
 <h4>
  <span class="section-number">
   9.7.1.20.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-bfi">
   Integer Arithmetic Instructions: bfi
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-bfi" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  bfi
 </p>
 <p>
  Bit Field Insert.
 </p>
 <p>
  Syntax
 </p>
 <pre>bfi.type  f, a, b, c, d;

.type = { .b32, .b64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Align and insert a bit field from
  <span class="pre">
   a
  </span>
  into
  <span class="pre">
   b
  </span>
  , and place the result in
  <span class="pre">
   f
  </span>
  . Source
  <span class="pre">
   c
  </span>
  gives the starting bit position for the insertion, and source
  <span class="pre">
   d
  </span>
  gives the bit field length in
bits.
 </p>
 <p>
  Operands
  <span class="pre">
   a
  </span>
  ,
  <span class="pre">
   b
  </span>
  , and
  <span class="pre">
   f
  </span>
  have the same type as the instruction type. Operands
  <span class="pre">
   c
  </span>
  and
  <span class="pre">
   d
  </span>
  are type
  <span class="pre">
   .u32
  </span>
  , but are restricted to the 8-bit value range
  <span class="pre">
   0..255
  </span>
  .
 </p>
 <p>
  If the bit field length is zero, the result is
  <span class="pre">
   b
  </span>
  .
 </p>
 <p>
  If the start position is beyond the msb of the input, the result is
  <span class="pre">
   b
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>msb = (.type==.b32) ? 31 : 63;
pos = c &amp; 0xff;  // pos restricted to 0..255 range
len = d &amp; 0xff;  // len restricted to 0..255 range

f = b;
for (i=0; i&lt;len &amp;&amp; pos+i&lt;=msb; i++) {
    f[pos+i] = a[i];
}
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   bfi
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>bfi.b32  d,a,b,start,len;
</pre>
 <h4>
  <span class="section-number">
   9.7.1.21.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-szext">
   Integer Arithmetic Instructions: szext
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-szext" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  szext
 </p>
 <p>
  Sign-extend or Zero-extend.
 </p>
 <p>
  Syntax
 </p>
 <pre>szext.mode.type  d, a, b;

.mode = { .clamp, .wrap };
.type = { .u32, .s32 };
</pre>
 <p>
  Description
 </p>
 <p>
  Sign-extends or zero-extends an N-bit value from operand
  <span class="pre">
   a
  </span>
  where N is specified in operand
  <span class="pre">
   b
  </span>
  . The resulting value is stored in the destination operand
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  For the
  <span class="pre">
   .s32
  </span>
  instruction type, the value in
  <span class="pre">
   a
  </span>
  is treated as an N-bit signed value and the
most significant bit of this N-bit value is replicated up to bit 31. For the
  <span class="pre">
   .u32
  </span>
  instruction
type, the value in
  <span class="pre">
   a
  </span>
  is treated as an N-bit unsigned number and is zero-extended to 32
bits. Operand
  <span class="pre">
   b
  </span>
  is an unsigned 32-bit value.
 </p>
 <p>
  If the value of N is 0, then the result of
  <span class="pre">
   szext
  </span>
  is 0. If the value of N is 32 or higher, then
the result of
  <span class="pre">
   szext
  </span>
  depends upon the value of the
  <span class="pre">
   .mode
  </span>
  qualifier as follows:
 </p>
 <ul class="simple">
  <li>
   <p>
    If
    <span class="pre">
     .mode
    </span>
    is
    <span class="pre">
     .clamp
    </span>
    , then the result is the same as the source operand
    <span class="pre">
     a
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    If
    <span class="pre">
     .mode
    </span>
    is
    <span class="pre">
     .wrap
    </span>
    , then the result is computed using the wrapped value of N.
   </p>
  </li>
 </ul>
 <p>
  Semantics
 </p>
 <pre>b1        = b &amp; 0x1f;
too_large = (b &gt;= 32 &amp;&amp; .mode == .clamp) ? true : false;
mask      = too_large ? 0 : (~0) &lt;&lt; b1;
sign_pos  = (b1 - 1) &amp; 0x1f;

if (b1 == 0 || too_large || .type != .s32) {
    sign_bit = false;
} else {
    sign_bit = (a &gt;&gt; sign_pos) &amp; 1;
}
d = (a &amp; ~mask) | (sign_bit ? mask | 0);
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.6.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   szext
  </span>
  requires
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>szext.clamp.s32 rd, ra, rb;
szext.wrap.u32  rd, 0xffffffff, 0; // Result is 0.
</pre>
 <h4>
  <span class="section-number">
   9.7.1.22.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-bmsk">
   Integer Arithmetic Instructions: bmsk
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-bmsk" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  bmsk
 </p>
 <p>
  Bit Field Mask.
 </p>
 <p>
  Syntax
 </p>
 <pre>bmsk.mode.b32  d, a, b;

.mode = { .clamp, .wrap };
</pre>
 <p>
  Description
 </p>
 <p>
  Generates a 32-bit mask starting from the bit position specified in operand
  <span class="pre">
   a
  </span>
  , and of the width
specified in operand
  <span class="pre">
   b
  </span>
  . The generated bitmask is stored in the destination operand
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  The resulting bitmask is 0 in the following cases:
 </p>
 <ul class="simple">
  <li>
   <p>
    When the value of
    <span class="pre">
     a
    </span>
    is 32 or higher and
    <span class="pre">
     .mode
    </span>
    is
    <span class="pre">
     .clamp
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    When either the specified value of
    <span class="pre">
     b
    </span>
    or the wrapped value of
    <span class="pre">
     b
    </span>
    (when
    <span class="pre">
     .mode
    </span>
    is
specified as
    <span class="pre">
     .wrap
    </span>
    ) is 0.
   </p>
  </li>
 </ul>
 <p>
  Semantics
 </p>
 <pre>a1    = a &amp; 0x1f;
mask0 = (~0) &lt;&lt; a1;
b1    = b &amp; 0x1f;
sum   = a1 + b1;
mask1 = (~0) &lt;&lt; sum;

sum-overflow          = sum &gt;= 32 ? true : false;
bit-position-overflow = false;
bit-width-overflow    = false;

if (.mode == .clamp) {
    if (a &gt;= 32) {
        bit-position-overflow = true;
        mask0 = 0;
    }
    if (b &gt;= 32) {
        bit-width-overflow = true;
    }
}

if (sum-overflow || bit-position-overflow || bit-width-overflow) {
    mask1 = 0;
} else if (b1 == 0) {
    mask1 = ~0;
}
d = mask0 &amp; ~mask1;
</pre>
 <p>
  Notes
 </p>
 <p>
  The bitmask width specified by operand
  <span class="pre">
   b
  </span>
  is limited to range
  <span class="pre">
   0..32
  </span>
  in
  <span class="pre">
   .clamp
  </span>
  mode and to
range
  <span class="pre">
   0..31
  </span>
  in
  <span class="pre">
   .wrap
  </span>
  mode.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.6.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   bmsk
  </span>
  requires
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>bmsk.clamp.b32  rd, ra, rb;
bmsk.wrap.b32   rd, 1, 2; // Creates a bitmask of 0x00000006.
</pre>
 <h4>
  <span class="section-number">
   9.7.1.23.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-dp4a">
   Integer Arithmetic Instructions: dp4a
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-dp4a" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  dp4a
 </p>
 <p>
  Four-way byte dot product-accumulate.
 </p>
 <p>
  Syntax
 </p>
 <pre>dp4a.atype.btype  d, a, b, c;

.atype = .btype = { .u32, .s32 };
</pre>
 <p>
  Description
 </p>
 <p>
  Four-way byte dot product which is accumulated in 32-bit result.
 </p>
 <p>
  Operand
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  are 32-bit inputs which hold 4 byte inputs in packed form for dot product.
 </p>
 <p>
  Operand
  <span class="pre">
   c
  </span>
  has type
  <span class="pre">
   .u32
  </span>
  if both
  <span class="pre">
   .atype
  </span>
  and
  <span class="pre">
   .btype
  </span>
  are
  <span class="pre">
   .u32
  </span>
  else operand
  <span class="pre">
   c
  </span>
  has type
  <span class="pre">
   .s32
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>d = c;

// Extract 4 bytes from a 32bit input and sign or zero extend
// based on input type.
Va = extractAndSignOrZeroExt_4(a, .atype);
Vb = extractAndSignOrZeroExt_4(b, .btype);

for (i = 0; i &lt; 4; ++i) {
    d += Va[i] * Vb[i];
}
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 5.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_61
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>dp4a.u32.u32           d0, a0, b0, c0;
dp4a.u32.s32           d1, a1, b1, c1;
</pre>
 <h4>
  <span class="section-number">
   9.7.1.24.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-dp2a">
   Integer Arithmetic Instructions: dp2a
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-dp2a" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  dp2a
 </p>
 <p>
  Two-way dot product-accumulate.
 </p>
 <p>
  Syntax
 </p>
 <pre>dp2a.mode.atype.btype  d, a, b, c;

.atype = .btype = { .u32, .s32 };
.mode = { .lo, .hi };
</pre>
 <p>
  Description
 </p>
 <p>
  Two-way 16-bit to 8-bit dot product which is accumulated in 32-bit result.
 </p>
 <p>
  Operand
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  are 32-bit inputs. Operand
  <span class="pre">
   a
  </span>
  holds two 16-bits inputs in packed form and
operand
  <span class="pre">
   b
  </span>
  holds 4 byte inputs in packed form for dot product.
 </p>
 <p>
  Depending on the
  <span class="pre">
   .mode
  </span>
  specified, either lower half or upper half of operand
  <span class="pre">
   b
  </span>
  will be used
for dot product.
 </p>
 <p>
  Operand
  <span class="pre">
   c
  </span>
  has type
  <span class="pre">
   .u32
  </span>
  if both
  <span class="pre">
   .atype
  </span>
  and
  <span class="pre">
   .btype
  </span>
  are
  <span class="pre">
   .u32
  </span>
  else operand
  <span class="pre">
   c
  </span>
  has type
  <span class="pre">
   .s32
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>d = c;
// Extract two 16-bit values from a 32-bit input and sign or zero extend
// based on input type.
Va = extractAndSignOrZeroExt_2(a, .atype);

// Extract four 8-bit values from a 32-bit input and sign or zer extend
// based on input type.
Vb = extractAndSignOrZeroExt_4(b, .btype);

b_select = (.mode == .lo) ? 0 : 2;

for (i = 0; i &lt; 2; ++i) {
    d += Va[i] * Vb[b_select + i];
}
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 5.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_61
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>dp2a.lo.u32.u32           d0, a0, b0, c0;
dp2a.hi.u32.s32           d1, a1, b1, c1;
</pre>
 <h3>
  <span class="section-number">
   9.7.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#extended-precision-integer-arithmetic-instructions">
   Extended-Precision Integer Arithmetic Instructions
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#extended-precision-integer-arithmetic-instructions" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Instructions
  <span class="pre">
   add.cc
  </span>
  ,
  <span class="pre">
   addc
  </span>
  ,
  <span class="pre">
   sub.cc
  </span>
  ,
  <span class="pre">
   subc
  </span>
  ,
  <span class="pre">
   mad.cc
  </span>
  and
  <span class="pre">
   madc
  </span>
  reference an
implicitly specified condition code register (
  <span class="pre">
   CC
  </span>
  ) having a single carry flag bit (
  <span class="pre">
   CC.CF
  </span>
  )
holding carry-in/carry-out or borrow-in/borrow-out. These instructions support extended-precision
integer addition, subtraction, and multiplication. No other instructions access the condition code,
and there is no support for setting, clearing, or testing the condition code. The condition code
register is not preserved across calls and is mainly intended for use in straight-line code
sequences for computing extended-precision integer addition, subtraction, and multiplication.
 </p>
 <p>
  The extended-precision arithmetic instructions are:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     add.cc
    </span>
    ,
    <span class="pre">
     addc
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     sub.cc
    </span>
    ,
    <span class="pre">
     subc
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     mad.cc
    </span>
    ,
    <span class="pre">
     madc
    </span>
   </p>
  </li>
 </ul>
 <h4>
  <span class="section-number">
   9.7.2.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#extended-precision-arithmetic-instructions-add-cc">
   Extended-Precision Arithmetic Instructions: add.cc
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#extended-precision-arithmetic-instructions-add-cc" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  add.cc
 </p>
 <p>
  Add two values with carry-out.
 </p>
 <p>
  Syntax
 </p>
 <pre>add.cc.type  d, a, b;

.type = { .u32, .s32, .u64, .s64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Performs integer addition and writes the carry-out value into the condition code register.
 </p>
 <p>
  Semantics
 </p>
 <pre>d = a + b;
</pre>
 <p>
  carry-out written to
  <span class="pre">
   CC.CF
  </span>
 </p>
 <p>
  Notes
 </p>
 <p>
  No integer rounding modifiers.
 </p>
 <p>
  No saturation.
 </p>
 <p>
  Behavior is the same for unsigned and signed integers.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  32-bit
  <span class="pre">
   add.cc
  </span>
  introduced in PTX ISA version 1.2.
 </p>
 <p>
  64-bit
  <span class="pre">
   add.cc
  </span>
  introduced in PTX ISA version 4.3.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  32-bit
  <span class="pre">
   add.cc
  </span>
  is supported on all target architectures.
 </p>
 <p>
  64-bit
  <span class="pre">
   add.cc
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>@p  add.cc.u32   x1,y1,z1;   // extended-precision addition of
@p  addc.cc.u32  x2,y2,z2;   // two 128-bit values
@p  addc.cc.u32  x3,y3,z3;
@p  addc.u32     x4,y4,z4;
</pre>
 <h4>
  <span class="section-number">
   9.7.2.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#extended-precision-arithmetic-instructions-addc">
   Extended-Precision Arithmetic Instructions: addc
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#extended-precision-arithmetic-instructions-addc" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  addc
 </p>
 <p>
  Add two values with carry-in and optional carry-out.
 </p>
 <p>
  Syntax
 </p>
 <pre>addc{.cc}.type  d, a, b;

.type = { .u32, .s32, .u64, .s64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Performs integer addition with carry-in and optionally writes the carry-out value into the condition
code register.
 </p>
 <p>
  Semantics
 </p>
 <pre>d = a + b + CC.CF;
</pre>
 <p>
  if
  <span class="pre">
   .cc
  </span>
  specified, carry-out written to
  <span class="pre">
   CC.CF
  </span>
 </p>
 <p>
  Notes
 </p>
 <p>
  No integer rounding modifiers.
 </p>
 <p>
  No saturation.
 </p>
 <p>
  Behavior is the same for unsigned and signed integers.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  32-bit
  <span class="pre">
   addc
  </span>
  introduced in PTX ISA version 1.2.
 </p>
 <p>
  64-bit
  <span class="pre">
   addc
  </span>
  introduced in PTX ISA version 4.3.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  32-bit
  <span class="pre">
   addc
  </span>
  is supported on all target architectures.
 </p>
 <p>
  64-bit
  <span class="pre">
   addc
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>@p  add.cc.u32   x1,y1,z1;   // extended-precision addition of
@p  addc.cc.u32  x2,y2,z2;   // two 128-bit values
@p  addc.cc.u32  x3,y3,z3;
@p  addc.u32     x4,y4,z4;
</pre>
 <h4>
  <span class="section-number">
   9.7.2.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#extended-precision-arithmetic-instructions-sub-cc">
   Extended-Precision Arithmetic Instructions: sub.cc
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#extended-precision-arithmetic-instructions-sub-cc" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  sub.cc
 </p>
 <p>
  Subtract one value from another, with borrow-out.
 </p>
 <p>
  Syntax
 </p>
 <pre>sub.cc.type  d, a, b;

.type = { .u32, .s32, .u64, .s64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Performs integer subtraction and writes the borrow-out value into the condition code register.
 </p>
 <p>
  Semantics
 </p>
 <pre>d = a - b;
</pre>
 <p>
  borrow-out written to
  <span class="pre">
   CC.CF
  </span>
 </p>
 <p>
  Notes
 </p>
 <p>
  No integer rounding modifiers.
 </p>
 <p>
  No saturation.
 </p>
 <p>
  Behavior is the same for unsigned and signed integers.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  32-bit
  <span class="pre">
   sub.cc
  </span>
  introduced in PTX ISA version 1.2.
 </p>
 <p>
  64-bit
  <span class="pre">
   sub.cc
  </span>
  introduced in PTX ISA version 4.3.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  32-bit
  <span class="pre">
   sub.cc
  </span>
  is supported on all target architectures.
 </p>
 <p>
  64-bit
  <span class="pre">
   sub.cc
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>@p  sub.cc.u32   x1,y1,z1;   // extended-precision subtraction
@p  subc.cc.u32  x2,y2,z2;   // of two 128-bit values
@p  subc.cc.u32  x3,y3,z3;
@p  subc.u32     x4,y4,z4;
</pre>
 <h4>
  <span class="section-number">
   9.7.2.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#extended-precision-arithmetic-instructions-subc">
   Extended-Precision Arithmetic Instructions: subc
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#extended-precision-arithmetic-instructions-subc" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  subc
 </p>
 <p>
  Subtract one value from another, with borrow-in and optional borrow-out.
 </p>
 <p>
  Syntax
 </p>
 <pre>subc{.cc}.type  d, a, b;

.type = { .u32, .s32, .u64, .s64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Performs integer subtraction with borrow-in and optionally writes the borrow-out value into the
condition code register.
 </p>
 <p>
  Semantics
 </p>
 <pre>d = a  - (b + CC.CF);
</pre>
 <p>
  if
  <span class="pre">
   .cc
  </span>
  specified, borrow-out written to
  <span class="pre">
   CC.CF
  </span>
 </p>
 <p>
  Notes
 </p>
 <p>
  No integer rounding modifiers.
 </p>
 <p>
  No saturation.
 </p>
 <p>
  Behavior is the same for unsigned and signed integers.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  32-bit
  <span class="pre">
   subc
  </span>
  introduced in PTX ISA version 1.2.
 </p>
 <p>
  64-bit
  <span class="pre">
   subc
  </span>
  introduced in PTX ISA version 4.3.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  32-bit
  <span class="pre">
   subc
  </span>
  is supported on all target architectures.
 </p>
 <p>
  64-bit
  <span class="pre">
   subc
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>@p  sub.cc.u32   x1,y1,z1;   // extended-precision subtraction
@p  subc.cc.u32  x2,y2,z2;   // of two 128-bit values
@p  subc.cc.u32  x3,y3,z3;
@p  subc.u32     x4,y4,z4;
</pre>
 <h4>
  <span class="section-number">
   9.7.2.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#extended-precision-arithmetic-instructions-mad-cc">
   Extended-Precision Arithmetic Instructions: mad.cc
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#extended-precision-arithmetic-instructions-mad-cc" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  mad.cc
 </p>
 <p>
  Multiply two values, extract high or low half of result, and add a third value with carry-out.
 </p>
 <p>
  Syntax
 </p>
 <pre>mad{.hi,.lo}.cc.type  d, a, b, c;

.type = { .u32, .s32, .u64, .s64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Multiplies two values, extracts either the high or low part of the result, and adds a third
value. Writes the result to the destination register and the carry-out from the addition into the
condition code register.
 </p>
 <p>
  Semantics
 </p>
 <pre>t = a * b;
d = t&lt;63..32&gt; + c;    // for .hi variant
d = t&lt;31..0&gt; + c;     // for .lo variant
</pre>
 <p>
  carry-out from addition is written to
  <span class="pre">
   CC.CF
  </span>
 </p>
 <p>
  Notes
 </p>
 <p>
  Generally used in combination with
  <span class="pre">
   madc
  </span>
  and
  <span class="pre">
   addc
  </span>
  to implement extended-precision multi-word
multiplication. See
  <span class="pre">
   madc
  </span>
  for an example.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  32-bit
  <span class="pre">
   mad.cc
  </span>
  introduced in PTX ISA version 3.0.
 </p>
 <p>
  64-bit
  <span class="pre">
   mad.cc
  </span>
  introduced in PTX ISA version 4.3.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires target
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>@p  mad.lo.cc.u32 d,a,b,c;
    mad.lo.cc.u32 r,p,q,r;
</pre>
 <h4>
  <span class="section-number">
   9.7.2.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#extended-precision-arithmetic-instructions-madc">
   Extended-Precision Arithmetic Instructions: madc
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#extended-precision-arithmetic-instructions-madc" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  madc
 </p>
 <p>
  Multiply two values, extract high or low half of result, and add a third value with carry-in and
optional carry-out.
 </p>
 <p>
  Syntax
 </p>
 <pre>madc{.hi,.lo}{.cc}.type  d, a, b, c;

.type = { .u32, .s32, .u64, .s64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Multiplies two values, extracts either the high or low part of the result, and adds a third value
along with carry-in. Writes the result to the destination register and optionally writes the
carry-out from the addition into the condition code register.
 </p>
 <p>
  Semantics
 </p>
 <pre>t = a * b;
d = t&lt;63..32&gt; + c + CC.CF;     // for .hi variant
d = t&lt;31..0&gt; + c + CC.CF;      // for .lo variant
</pre>
 <p>
  if
  <span class="pre">
   .cc
  </span>
  specified, carry-out from addition is written to
  <span class="pre">
   CC.CF
  </span>
 </p>
 <p>
  Notes
 </p>
 <p>
  Generally used in combination with
  <span class="pre">
   mad.cc
  </span>
  and
  <span class="pre">
   addc
  </span>
  to implement extended-precision
multi-word multiplication. See example below.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  32-bit
  <span class="pre">
   madc
  </span>
  introduced in PTX ISA version 3.0.
 </p>
 <p>
  64-bit
  <span class="pre">
   madc
  </span>
  introduced in PTX ISA version 4.3.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires target
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>// extended-precision multiply:  [r3,r2,r1,r0] = [r5,r4] * [r7,r6]
mul.lo.u32     r0,r4,r6;      // r0=(r4*r6).[31:0], no carry-out
mul.hi.u32     r1,r4,r6;      // r1=(r4*r6).[63:32], no carry-out
mad.lo.cc.u32  r1,r5,r6,r1;   // r1+=(r5*r6).[31:0], may carry-out
madc.hi.u32    r2,r5,r6,0;    // r2 =(r5*r6).[63:32]+carry-in,
                              // no carry-out
mad.lo.cc.u32   r1,r4,r7,r1;  // r1+=(r4*r7).[31:0], may carry-out
madc.hi.cc.u32  r2,r4,r7,r2;  // r2+=(r4*r7).[63:32]+carry-in,
                              // may carry-out
addc.u32        r3,0,0;       // r3 = carry-in, no carry-out
mad.lo.cc.u32   r2,r5,r7,r2;  // r2+=(r5*r7).[31:0], may carry-out
madc.hi.u32     r3,r5,r7,r3;  // r3+=(r5*r7).[63:32]+carry-in
</pre>
 <h3>
  <span class="section-number">
   9.7.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions">
   Floating-Point Instructions
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Floating-point instructions operate on
  <span class="pre">
   .f32
  </span>
  and
  <span class="pre">
   .f64
  </span>
  register operands and constant
immediate values. The floating-point instructions are:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     testp
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     copysign
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     add
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     sub
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     mul
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     fma
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     mad
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     div
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     abs
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     neg
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     min
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     max
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     rcp
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     sqrt
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     rsqrt
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     sin
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     cos
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     lg2
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     ex2
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     tanh
    </span>
   </p>
  </li>
 </ul>
 <p>
  Instructions that support rounding modifiers are IEEE-754 compliant. Double-precision instructions
support subnormal inputs and results. Single-precision instructions support subnormal inputs and
results by default for
  <span class="pre">
   sm_20
  </span>
  and subsequent targets, and flush subnormal inputs and results to
sign-preserving zero for
  <span class="pre">
   sm_1x
  </span>
  targets. The optional
  <span class="pre">
   .ftz
  </span>
  modifier on single-precision
instructions provides backward compatibility with
  <span class="pre">
   sm_1x
  </span>
  targets by flushing subnormal inputs and
results to sign-preserving zero regardless of the target architecture.
 </p>
 <p>
  Single-precision
  <span class="pre">
   add
  </span>
  ,
  <span class="pre">
   sub
  </span>
  ,
  <span class="pre">
   mul
  </span>
  , and
  <span class="pre">
   mad
  </span>
  support saturation of results to the range
[0.0, 1.0], with
  <span class="pre">
   NaN
  </span>
  s being flushed to positive zero.
  <span class="pre">
   NaN
  </span>
  payloads are supported for
double-precision instructions (except for
  <span class="pre">
   rcp.approx.ftz.f64
  </span>
  and
  <span class="pre">
   rsqrt.approx.ftz.f64
  </span>
  , which
maps input
  <span class="pre">
   NaN
  </span>
  s to a canonical
  <span class="pre">
   NaN
  </span>
  ). Single-precision instructions return an unspecified
  <span class="pre">
   NaN
  </span>
  . Note that future implementations may support
  <span class="pre">
   NaN
  </span>
  payloads for single-precision
instructions, so PTX programs should not rely on the specific single-precision
  <span class="pre">
   NaN
  </span>
  s being
generated.
 </p>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-summary-of-floating-point-instructions">
   <span class="std std-numref">
    Table 26
   </span>
  </a>
  summarizes
floating-point instructions in PTX.
 </p>
 <table class="table-no-stripes docutils align-default" id="floating-point-instructions-summary-of-floating-point-instructions">
  <span class="caption-number">
   Table 26
  </span>
  <span class="caption-text">
   Summary of Floating-Point Instructions
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-summary-of-floating-point-instructions" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Instruction
    </p>
   </th>
   <th class="head">
    <p>
     .rn
    </p>
   </th>
   <th class="head">
    <p>
     .rz
    </p>
   </th>
   <th class="head">
    <p>
     .rm
    </p>
   </th>
   <th class="head">
    <p>
     .rp
    </p>
   </th>
   <th class="head">
    <p>
     .ftz
    </p>
   </th>
   <th class="head">
    <p>
     .sat
    </p>
   </th>
   <th class="head">
    <p>
     Notes
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      {add,sub,mul}.rnd.f32
     </span>
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     If no rounding modifier is specified,
default is
     <span class="pre">
      .rn
     </span>
     and instructions may
be folded into a multiply-add.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      {add,sub,mul}.rnd.f64
     </span>
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     If no rounding modifier is specified,
default is
     <span class="pre">
      .rn
     </span>
     and instructions may
be folded into a multiply-add.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      mad.f32
     </span>
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .target
     </span>
     <span class="pre">
      sm_1x
     </span>
    </p>
    <p>
     No rounding modifier.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      {mad,fma}.rnd.f32
     </span>
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .target
     </span>
     <span class="pre">
      sm_20
     </span>
     or higher
    </p>
    <p>
     <span class="pre">
      mad.f32
     </span>
     and
     <span class="pre">
      fma.f32
     </span>
     are the same.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      {mad,fma}.rnd.f64
     </span>
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      mad.f64
     </span>
     and
     <span class="pre">
      fma.f64
     </span>
     are the same.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      div.full.f32
     </span>
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     No rounding modifier.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      {div,rcp,sqrt}.approx.f32
     </span>
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      rcp.approx.ftz.f64
     </span>
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .target
     </span>
     <span class="pre">
      sm_20
     </span>
     or higher
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      {div,rcp,sqrt}.rnd.f32
     </span>
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .target
     </span>
     <span class="pre">
      sm_20
     </span>
     or higher
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      {div,rcp,sqrt}.rnd.f64
     </span>
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .target
     </span>
     <span class="pre">
      sm_20
     </span>
     or higher
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      {abs,neg,min,max}.f32
     </span>
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      {abs,neg,min,max}.f64
     </span>
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      rsqrt.approx.f32
     </span>
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      rsqrt.approx.f64
     </span>
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      rsqrt.approx.ftz.f64
     </span>
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .target
     </span>
     <span class="pre">
      sm_20
     </span>
     or higher
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      {sin,cos,lg2,ex2}.approx.f32
     </span>
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      tanh.approx.f32
     </span>
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     n/a
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .target
     </span>
     <span class="pre">
      sm_75
     </span>
     or higher
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   9.7.3.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-testp">
   Floating Point Instructions: testp
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-testp" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  testp
 </p>
 <p>
  Test floating-point property.
 </p>
 <p>
  Syntax
 </p>
 <pre>testp.op.type  p, a;  // result is .pred

.op   = { .finite, .infinite,
          .number, .notanumber,
          .normal, .subnormal };
.type = { .f32, .f64 };
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   testp
  </span>
  tests common properties of floating-point numbers and returns a predicate value of
  <span class="pre">
   1
  </span>
  if
  <span class="pre">
   True
  </span>
  and
  <span class="pre">
   0
  </span>
  if
  <span class="pre">
   False
  </span>
  .
 </p>
 <span class="pre">
  testp.finite
 </span>
 <p>
  <span class="pre">
   True
  </span>
  if the input is not infinite or
  <span class="pre">
   NaN
  </span>
 </p>
 <span class="pre">
  testp.infinite
 </span>
 <p>
  <span class="pre">
   True
  </span>
  if the input is positive or negative infinity
 </p>
 <span class="pre">
  testp.number
 </span>
 <p>
  <span class="pre">
   True
  </span>
  if the input is not
  <span class="pre">
   NaN
  </span>
 </p>
 <span class="pre">
  testp.notanumber
 </span>
 <p>
  <span class="pre">
   True
  </span>
  if the input is
  <span class="pre">
   NaN
  </span>
 </p>
 <span class="pre">
  testp.normal
 </span>
 <p>
  <span class="pre">
   True
  </span>
  if the input is a normal number (not
  <span class="pre">
   NaN
  </span>
  , not infinity)
 </p>
 <span class="pre">
  testp.subnormal
 </span>
 <p>
  <span class="pre">
   True
  </span>
  if the input is a subnormal number (not
  <span class="pre">
   NaN
  </span>
  , not infinity)
 </p>
 <p>
  As a special case, positive and negative zero are considered normal numbers.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>testp.notanumber.f32  isnan, f0;
testp.infinite.f64    p, X;
</pre>
 <h4>
  <span class="section-number">
   9.7.3.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-copysign">
   Floating Point Instructions: copysign
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-copysign" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  copysign
 </p>
 <p>
  Copy sign of one input to another.
 </p>
 <p>
  Syntax
 </p>
 <pre>copysign.type  d, a, b;

.type = { .f32, .f64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Copy sign bit of
  <span class="pre">
   a
  </span>
  into value of
  <span class="pre">
   b
  </span>
  , and return the result as
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>copysign.f32  x, y, z;
copysign.f64  A, B, C;
</pre>
 <h4>
  <span class="section-number">
   9.7.3.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-add">
   Floating Point Instructions: add
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-add" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  add
 </p>
 <p>
  Add two values.
 </p>
 <p>
  Syntax
 </p>
 <pre>add{.rnd}{.ftz}{.sat}.f32  d, a, b;
add{.rnd}.f64              d, a, b;

.rnd = { .rn, .rz, .rm, .rp };
</pre>
 <p>
  Description
 </p>
 <p>
  Performs addition and writes the resulting value into a destination register.
 </p>
 <p>
  Semantics
 </p>
 <pre>d = a + b;
</pre>
 <p>
  Notes
 </p>
 <p>
  Rounding modifiers:
 </p>
 <span class="pre">
  .rn
 </span>
 <p>
  mantissa LSB rounds to nearest even
 </p>
 <span class="pre">
  .rz
 </span>
 <p>
  mantissa LSB rounds towards zero
 </p>
 <span class="pre">
  .rm
 </span>
 <p>
  mantissa LSB rounds towards negative infinity
 </p>
 <span class="pre">
  .rp
 </span>
 <p>
  mantissa LSB rounds towards positive infinity
 </p>
 <p>
  The default value of rounding modifier is
  <span class="pre">
   .rn
  </span>
  . Note that an
  <span class="pre">
   add
  </span>
  instruction with an explicit
rounding modifier is treated conservatively by the code optimizer. An
  <span class="pre">
   add
  </span>
  instruction with no
rounding modifier defaults to round-to-nearest-even and may be optimized aggressively by the code
optimizer. In particular,
  <span class="pre">
   mul
  </span>
  /
  <span class="pre">
   add
  </span>
  sequences with no rounding modifiers may be optimized to
use fused-multiply-add instructions on the target device.
 </p>
 <p>
  Subnormal numbers:
 </p>
 <span class="pre">
  sm_20+
 </span>
 <p>
  By default, subnormal numbers are supported.
 </p>
 <p>
  <span class="pre">
   add.ftz.f32
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <span class="pre">
  sm_1x
 </span>
 <p>
  <span class="pre">
   add.f64
  </span>
  supports subnormal numbers.
 </p>
 <p>
  <span class="pre">
   add.f32
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <p>
  Saturation modifier:
 </p>
 <p>
  <span class="pre">
   add.sat.f32
  </span>
  clamps the result to [0.0, 1.0].
  <span class="pre">
   NaN
  </span>
  results are flushed to
  <span class="pre">
   +0.0f
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   add.f32
  </span>
  supported on all target architectures.
 </p>
 <p>
  <span class="pre">
   add.f64
  </span>
  requires
  <span class="pre">
   sm_13
  </span>
  or higher.
 </p>
 <p>
  Rounding modifiers have the following target requirements:
 </p>
 <span class="pre">
  .rn
 </span>
 ,
 <span class="pre">
  .rz
 </span>
 <p>
  available for all targets
 </p>
 <span class="pre">
  .rm
 </span>
 ,
 <span class="pre">
  .rp
 </span>
 <p>
  for
  <span class="pre">
   add.f64
  </span>
  , requires
  <span class="pre">
   sm_13
  </span>
  or higher.
 </p>
 <p>
  for
  <span class="pre">
   add.f32
  </span>
  , requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>@p  add.rz.ftz.f32  f1,f2,f3;
</pre>
 <h4>
  <span class="section-number">
   9.7.3.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-sub">
   Floating Point Instructions: sub
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-sub" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  sub
 </p>
 <p>
  Subtract one value from another.
 </p>
 <p>
  Syntax
 </p>
 <pre>sub{.rnd}{.ftz}{.sat}.f32  d, a, b;
sub{.rnd}.f64              d, a, b;

.rnd = { .rn, .rz, .rm, .rp };
</pre>
 <p>
  Description
 </p>
 <p>
  Performs subtraction and writes the resulting value into a destination register.
 </p>
 <p>
  Semantics
 </p>
 <pre>d = a - b;
</pre>
 <p>
  Notes
 </p>
 <p>
  Rounding modifiers:
 </p>
 <span class="pre">
  .rn
 </span>
 <p>
  mantissa LSB rounds to nearest even
 </p>
 <span class="pre">
  .rz
 </span>
 <p>
  mantissa LSB rounds towards zero
 </p>
 <span class="pre">
  .rm
 </span>
 <p>
  mantissa LSB rounds towards negative infinity
 </p>
 <span class="pre">
  .rp
 </span>
 <p>
  mantissa LSB rounds towards positive infinity
 </p>
 <p>
  The default value of rounding modifier is
  <span class="pre">
   .rn
  </span>
  . Note that a
  <span class="pre">
   sub
  </span>
  instruction with an explicit
rounding modifier is treated conservatively by the code optimizer. A
  <span class="pre">
   sub
  </span>
  instruction with no
rounding modifier defaults to round-to-nearest-even and may be optimized aggressively by the code
optimizer. In particular,
  <span class="pre">
   mul
  </span>
  /
  <span class="pre">
   sub
  </span>
  sequences with no rounding modifiers may be optimized to
use fused-multiply-add instructions on the target device.
 </p>
 <p>
  Subnormal numbers:
 </p>
 <span class="pre">
  sm_20+
 </span>
 <p>
  By default, subnormal numbers are supported.
 </p>
 <p>
  <span class="pre">
   sub.ftz.f32
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <span class="pre">
  sm_1x
 </span>
 <p>
  <span class="pre">
   sub.f64
  </span>
  supports subnormal numbers.
 </p>
 <p>
  <span class="pre">
   sub.f32
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <p>
  Saturation modifier:
 </p>
 <p>
  <span class="pre">
   sub.sat.f32
  </span>
  clamps the result to [0.0, 1.0]. NaN results are flushed to
  <span class="pre">
   +0.0f
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   sub.f32
  </span>
  supported on all target architectures.
 </p>
 <p>
  <span class="pre">
   sub.f64
  </span>
  requires
  <span class="pre">
   sm_13
  </span>
  or higher.
 </p>
 <p>
  Rounding modifiers have the following target requirements:
 </p>
 <span class="pre">
  .rn
 </span>
 ,
 <span class="pre">
  .rz
 </span>
 <p>
  available for all targets
 </p>
 <span class="pre">
  .rm
 </span>
 ,
 <span class="pre">
  .rp
 </span>
 <p>
  for
  <span class="pre">
   sub.f64
  </span>
  , requires
  <span class="pre">
   sm_13
  </span>
  or higher.
 </p>
 <p>
  for
  <span class="pre">
   sub.f32
  </span>
  , requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>sub.f32 c,a,b;
sub.rn.ftz.f32  f1,f2,f3;
</pre>
 <h4>
  <span class="section-number">
   9.7.3.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-mul">
   Floating Point Instructions: mul
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-mul" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  mul
 </p>
 <p>
  Multiply two values.
 </p>
 <p>
  Syntax
 </p>
 <pre>mul{.rnd}{.ftz}{.sat}.f32  d, a, b;
mul{.rnd}.f64              d, a, b;

.rnd = { .rn, .rz, .rm, .rp };
</pre>
 <p>
  Description
 </p>
 <p>
  Compute the product of two values.
 </p>
 <p>
  Semantics
 </p>
 <pre>d = a * b;
</pre>
 <p>
  Notes
 </p>
 <p>
  For floating-point multiplication, all operands must be the same size.
 </p>
 <p>
  Rounding modifiers:
 </p>
 <span class="pre">
  .rn
 </span>
 <p>
  mantissa LSB rounds to nearest even
 </p>
 <span class="pre">
  .rz
 </span>
 <p>
  mantissa LSB rounds towards zero
 </p>
 <span class="pre">
  .rm
 </span>
 <p>
  mantissa LSB rounds towards negative infinity
 </p>
 <span class="pre">
  .rp
 </span>
 <p>
  mantissa LSB rounds towards positive infinity
 </p>
 <p>
  The default value of rounding modifier is
  <span class="pre">
   .rn
  </span>
  . Note that a
  <span class="pre">
   mul
  </span>
  instruction with an explicit
rounding modifier is treated conservatively by the code optimizer. A
  <span class="pre">
   mul
  </span>
  instruction with no
rounding modifier defaults to round-to-nearest-even and may be optimized aggressively by the code
optimizer. In particular,
  <span class="pre">
   mul/add
  </span>
  and
  <span class="pre">
   mul/sub
  </span>
  sequences with no rounding modifiers may be
optimized to use fused-multiply-add instructions on the target device.
 </p>
 <p>
  Subnormal numbers:
 </p>
 <span class="pre">
  sm_20+
 </span>
 <p>
  By default, subnormal numbers are supported.
 </p>
 <p>
  <span class="pre">
   mul.ftz.f32
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <span class="pre">
  sm_1x
 </span>
 <p>
  <span class="pre">
   mul.f64
  </span>
  supports subnormal numbers.
 </p>
 <p>
  <span class="pre">
   mul.f32
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <p>
  Saturation modifier:
 </p>
 <p>
  <span class="pre">
   mul.sat.f32
  </span>
  clamps the result to [0.0, 1.0].
  <span class="pre">
   NaN
  </span>
  results are flushed to
  <span class="pre">
   +0.0f
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   mul.f32
  </span>
  supported on all target architectures.
 </p>
 <p>
  <span class="pre">
   mul.f64
  </span>
  requires
  <span class="pre">
   sm_13
  </span>
  or higher.
 </p>
 <p>
  Rounding modifiers have the following target requirements:
 </p>
 <span class="pre">
  .rn
 </span>
 ,
 <span class="pre">
  .rz
 </span>
 <p>
  available for all targets
 </p>
 <span class="pre">
  .rm
 </span>
 ,
 <span class="pre">
  .rp
 </span>
 <p>
  for
  <span class="pre">
   mul.f64
  </span>
  , requires
  <span class="pre">
   sm_13
  </span>
  or higher.
 </p>
 <p>
  for
  <span class="pre">
   mul.f32
  </span>
  , requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>mul.ftz.f32 circumf,radius,pi  // a single-precision multiply
</pre>
 <h4>
  <span class="section-number">
   9.7.3.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-fma">
   Floating Point Instructions: fma
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-fma" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  fma
 </p>
 <p>
  Fused multiply-add.
 </p>
 <p>
  Syntax
 </p>
 <pre>fma.rnd{.ftz}{.sat}.f32  d, a, b, c;
fma.rnd.f64              d, a, b, c;

.rnd = { .rn, .rz, .rm, .rp };
</pre>
 <p>
  Description
 </p>
 <p>
  Performs a fused multiply-add with no loss of precision in the intermediate product and addition.
 </p>
 <p>
  Semantics
 </p>
 <pre>d = a*b + c;
</pre>
 <p>
  Notes
 </p>
 <p>
  <span class="pre">
   fma.f32
  </span>
  computes the product of
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  to infinite precision and then adds
  <span class="pre">
   c
  </span>
  to
this product, again in infinite precision. The resulting value is then rounded to single precision
using the rounding mode specified by
  <span class="pre">
   .rnd
  </span>
  .
 </p>
 <p>
  <span class="pre">
   fma.f64
  </span>
  computes the product of
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  to infinite precision and then adds
  <span class="pre">
   c
  </span>
  to
this product, again in infinite precision. The resulting value is then rounded to double precision
using the rounding mode specified by
  <span class="pre">
   .rnd
  </span>
  .
 </p>
 <p>
  <span class="pre">
   fma.f64
  </span>
  is the same as
  <span class="pre">
   mad.f64
  </span>
  .
 </p>
 <p>
  Rounding modifiers (no default):
 </p>
 <span class="pre">
  .rn
 </span>
 <p>
  mantissa LSB rounds to nearest even
 </p>
 <span class="pre">
  .rz
 </span>
 <p>
  mantissa LSB rounds towards zero
 </p>
 <span class="pre">
  .rm
 </span>
 <p>
  mantissa LSB rounds towards negative infinity
 </p>
 <span class="pre">
  .rp
 </span>
 <p>
  mantissa LSB rounds towards positive infinity
 </p>
 <p>
  Subnormal numbers:
 </p>
 <span class="pre">
  sm_20+
 </span>
 <p>
  By default, subnormal numbers are supported.
 </p>
 <p>
  <span class="pre">
   fma.ftz.f32
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <span class="pre">
  sm_1x
 </span>
 <p>
  <span class="pre">
   fma.f64
  </span>
  supports subnormal numbers.
 </p>
 <p>
  <span class="pre">
   fma.f32
  </span>
  is unimplemented for
  <span class="pre">
   sm_1x
  </span>
  targets.
 </p>
 <p>
  Saturation:
 </p>
 <p>
  <span class="pre">
   fma.sat.f32
  </span>
  clamps the result to [0.0, 1.0].
  <span class="pre">
   NaN
  </span>
  results are flushed to
  <span class="pre">
   +0.0f
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  <span class="pre">
   fma.f64
  </span>
  introduced in PTX ISA version 1.4.
 </p>
 <p>
  <span class="pre">
   fma.f32
  </span>
  introduced in PTX ISA version 2.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   fma.f32
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   fma.f64
  </span>
  requires
  <span class="pre">
   sm_13
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>    fma.rn.ftz.f32  w,x,y,z;
@p  fma.rn.f64      d,a,b,c;
</pre>
 <h4>
  <span class="section-number">
   9.7.3.7.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-mad">
   Floating Point Instructions: mad
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-mad" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  mad
 </p>
 <p>
  Multiply two values and add a third value.
 </p>
 <p>
  Syntax
 </p>
 <pre>mad{.ftz}{.sat}.f32      d, a, b, c;    // .target sm_1x
mad.rnd{.ftz}{.sat}.f32  d, a, b, c;    // .target sm_20
mad.rnd.f64              d, a, b, c;    // .target sm_13 and higher

.rnd = { .rn, .rz, .rm, .rp };
</pre>
 <p>
  Description
 </p>
 <p>
  Multiplies two values and adds a third, and then writes the resulting value into a destination
register.
 </p>
 <p>
  Semantics
 </p>
 <pre>d = a*b + c;
</pre>
 <p>
  Notes
 </p>
 <p>
  For
  <span class="pre">
   .target
  </span>
  <span class="pre">
   sm_20
  </span>
  and higher:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     mad.f32
    </span>
    computes the product of
    <span class="pre">
     a
    </span>
    and
    <span class="pre">
     b
    </span>
    to infinite precision and then adds
    <span class="pre">
     c
    </span>
    to
this product, again in infinite precision. The resulting value is then rounded to single precision
using the rounding mode specified by
    <span class="pre">
     .rnd
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     mad.f64
    </span>
    computes the product of
    <span class="pre">
     a
    </span>
    and
    <span class="pre">
     b
    </span>
    to infinite precision and then adds
    <span class="pre">
     c
    </span>
    to
this product, again in infinite precision. The resulting value is then rounded to double precision
using the rounding mode specified by
    <span class="pre">
     .rnd
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     mad.{f32,f64}
    </span>
    is the same as
    <span class="pre">
     fma.{f32,f64}
    </span>
    .
   </p>
  </li>
 </ul>
 <p>
  For
  <span class="pre">
   .target
  </span>
  <span class="pre">
   sm_1x
  </span>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     mad.f32
    </span>
    computes the product of
    <span class="pre">
     a
    </span>
    and
    <span class="pre">
     b
    </span>
    at double precision, and then the mantissa is
truncated to 23 bits, but the exponent is preserved. Note that this is different from computing
the product with
    <span class="pre">
     mul
    </span>
    , where the mantissa can be rounded and the exponent will be clamped. The
exception for
    <span class="pre">
     mad.f32
    </span>
    is when
    <span class="pre">
     c
    </span>
    <span class="pre">
     =
    </span>
    <span class="pre">
     +/-0.0
    </span>
    ,
    <span class="pre">
     mad.f32
    </span>
    is identical to the result computed
using separate mul and add instructions. When JIT-compiled for SM 2.0 devices,
    <span class="pre">
     mad.f32
    </span>
    is
implemented as a fused multiply-add (i.e.,
    <span class="pre">
     fma.rn.ftz.f32
    </span>
    ). In this case,
    <span class="pre">
     mad.f32
    </span>
    can
produce slightly different numeric results and backward compatibility is not guaranteed in this
case.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     mad.f64
    </span>
    computes the product of
    <span class="pre">
     a
    </span>
    and
    <span class="pre">
     b
    </span>
    to infinite precision and then adds
    <span class="pre">
     c
    </span>
    to
this product, again in infinite precision. The resulting value is then rounded to double precision
using the rounding mode specified by
    <span class="pre">
     .rnd
    </span>
    . Unlike
    <span class="pre">
     mad.f32
    </span>
    , the treatment of subnormal
inputs and output follows IEEE 754 standard.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     mad.f64
    </span>
    is the same as
    <span class="pre">
     fma.f64
    </span>
    .
   </p>
  </li>
 </ul>
 <p>
  Rounding modifiers (no default):
 </p>
 <span class="pre">
  .rn
 </span>
 <p>
  mantissa LSB rounds to nearest even
 </p>
 <span class="pre">
  .rz
 </span>
 <p>
  mantissa LSB rounds towards zero
 </p>
 <span class="pre">
  .rm
 </span>
 <p>
  mantissa LSB rounds towards negative infinity
 </p>
 <span class="pre">
  .rp
 </span>
 <p>
  mantissa LSB rounds towards positive infinity
 </p>
 <p>
  Subnormal numbers:
 </p>
 <span class="pre">
  sm_20+
 </span>
 <p>
  By default, subnormal numbers are supported.
 </p>
 <p>
  <span class="pre">
   mad.ftz.f32
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <span class="pre">
  sm_1x
 </span>
 <p>
  <span class="pre">
   mad.f64
  </span>
  supports subnormal numbers.
 </p>
 <p>
  <span class="pre">
   mad.f32
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <p>
  Saturation modifier:
 </p>
 <p>
  <span class="pre">
   mad.sat.f32
  </span>
  clamps the result to [0.0, 1.0].
  <span class="pre">
   NaN
  </span>
  results are flushed to
  <span class="pre">
   +0.0f
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  In PTX ISA versions 1.4 and later, a rounding modifier is required for
  <span class="pre">
   mad.f64
  </span>
  .
 </p>
 <p>
  Legacy
  <span class="pre">
   mad.f64
  </span>
  instructions having no rounding modifier will map to
  <span class="pre">
   mad.rn.f64
  </span>
  .
 </p>
 <p>
  In PTX ISA versions 2.0 and later, a rounding modifier is required for
  <span class="pre">
   mad.f32
  </span>
  for
  <span class="pre">
   sm_20
  </span>
  and higher targets.
 </p>
 <p>
  Errata
 </p>
 <p>
  <span class="pre">
   mad.f32
  </span>
  requires a rounding modifier for
  <span class="pre">
   sm_20
  </span>
  and higher targets. However for PTX ISA
version 3.0 and earlier, ptxas does not enforce this requirement and
  <span class="pre">
   mad.f32
  </span>
  silently defaults
to
  <span class="pre">
   mad.rn.f32
  </span>
  . For PTX ISA version 3.1, ptxas generates a warning and defaults to
  <span class="pre">
   mad.rn.f32
  </span>
  , and in subsequent releases ptxas will enforce the requirement for PTX ISA version
3.2 and later.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   mad.f32
  </span>
  supported on all target architectures.
 </p>
 <p>
  <span class="pre">
   mad.f64
  </span>
  requires
  <span class="pre">
   sm_13
  </span>
  or higher.
 </p>
 <p>
  Rounding modifiers have the following target requirements:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     .rn
    </span>
    ,
    <span class="pre">
     .rz
    </span>
    ,
    <span class="pre">
     .rm
    </span>
    ,
    <span class="pre">
     .rp
    </span>
    for
    <span class="pre">
     mad.f64
    </span>
    , requires
    <span class="pre">
     sm_13
    </span>
    or higher.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .rn
    </span>
    ,
    <span class="pre">
     .rz
    </span>
    ,
    <span class="pre">
     .rm
    </span>
    ,
    <span class="pre">
     .rp
    </span>
    for
    <span class="pre">
     mad.f32
    </span>
    , requires
    <span class="pre">
     sm_20
    </span>
    or higher.
   </p>
  </li>
 </ul>
 <p>
  Examples
 </p>
 <pre>@p  mad.f32  d,a,b,c;
</pre>
 <h4>
  <span class="section-number">
   9.7.3.8.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-div">
   Floating Point Instructions: div
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-div" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  div
 </p>
 <p>
  Divide one value by another.
 </p>
 <p>
  Syntax
 </p>
 <pre>div.approx{.ftz}.f32  d, a, b;  // fast, approximate divide
div.full{.ftz}.f32    d, a, b;  // full-range approximate divide
div.rnd{.ftz}.f32     d, a, b;  // IEEE 754 compliant rounding
div.rnd.f64           d, a, b;  // IEEE 754 compliant rounding

.rnd = { .rn, .rz, .rm, .rp };
</pre>
 <p>
  Description
 </p>
 <p>
  Divides
  <span class="pre">
   a
  </span>
  by
  <span class="pre">
   b
  </span>
  , stores result in
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>d = a / b;
</pre>
 <p>
  Notes
 </p>
 <p>
  Fast, approximate single-precision divides:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     div.approx.f32
    </span>
    implements a fast approximation to divide, computed as
    <span class="pre">
     d
    </span>
    <span class="pre">
     =
    </span>
    <span class="pre">
     a
    </span>
    <span class="pre">
     *
    </span>
    <span class="pre">
     (1/b)
    </span>
    . For
    <span class="pre">
     |b|
    </span>
    in [2
    -126
    , 2
    126
    ], the maximum
    <span class="pre">
     ulp
    </span>
    error is 2. For 2
    126
    &lt;
    <span class="pre">
     |b|
    </span>
    &lt; 2
    128
    , if
    <span class="pre">
     a
    </span>
    is infinity,
    <span class="pre">
     div.approx.f32
    </span>
    returns
    <span class="pre">
     NaN
    </span>
    , otherwise it
returns 0.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     div.full.f32
    </span>
    implements a relatively fast, full-range approximation that scales operands to
achieve better accuracy, but is not fully IEEE 754 compliant and does not support rounding
modifiers. The maximum
    <span class="pre">
     ulp
    </span>
    error is 2 across the full range of inputs.
   </p>
  </li>
  <li>
   <p>
    Subnormal inputs and results are flushed to sign-preserving zero. Fast, approximate division by
zero creates a value of infinity (with same sign as
    <span class="pre">
     a
    </span>
    ).
   </p>
  </li>
 </ul>
 <p>
  Divide with IEEE 754 compliant rounding:
 </p>
 <p>
  Rounding modifiers (no default):
 </p>
 <span class="pre">
  .rn
 </span>
 <p>
  mantissa LSB rounds to nearest even
 </p>
 <span class="pre">
  .rz
 </span>
 <p>
  mantissa LSB rounds towards zero
 </p>
 <span class="pre">
  .rm
 </span>
 <p>
  mantissa LSB rounds towards negative infinity
 </p>
 <span class="pre">
  .rp
 </span>
 <p>
  mantissa LSB rounds towards positive infinity
 </p>
 <p>
  Subnormal numbers:
 </p>
 <span class="pre">
  sm_20+
 </span>
 <p>
  By default, subnormal numbers are supported.
 </p>
 <p>
  <span class="pre">
   div.ftz.f32
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <span class="pre">
  sm_1x
 </span>
 <p>
  <span class="pre">
   div.f64
  </span>
  supports subnormal numbers.
 </p>
 <p>
  <span class="pre">
   div.f32
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  <span class="pre">
   div.f32
  </span>
  and
  <span class="pre">
   div.f64
  </span>
  introduced in PTX ISA version 1.0.
 </p>
 <p>
  Explicit modifiers
  <span class="pre">
   .approx
  </span>
  ,
  <span class="pre">
   .full
  </span>
  ,
  <span class="pre">
   .ftz
  </span>
  , and rounding introduced in PTX ISA version 1.4.
 </p>
 <p>
  For PTX ISA version 1.4 and later, one of
  <span class="pre">
   .approx
  </span>
  ,
  <span class="pre">
   .full
  </span>
  , or
  <span class="pre">
   .rnd
  </span>
  is required.
 </p>
 <p>
  For PTX ISA versions 1.0 through 1.3,
  <span class="pre">
   div.f32
  </span>
  defaults to
  <span class="pre">
   div.approx.ftz.f32
  </span>
  , and
  <span class="pre">
   div.f64
  </span>
  defaults to
  <span class="pre">
   div.rn.f64
  </span>
  .
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   div.approx.f32
  </span>
  and
  <span class="pre">
   div.full.f32
  </span>
  supported on all target architectures.
 </p>
 <p>
  <span class="pre">
   div.rnd.f32
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   div.rn.f64
  </span>
  requires
  <span class="pre">
   sm_13
  </span>
  or higher, or
  <span class="pre">
   .target
  </span>
  <span class="pre">
   map_f64_to_f32
  </span>
  .
 </p>
 <p>
  <span class="pre">
   div.{rz,rm,rp}.f64
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>div.approx.ftz.f32  diam,circum,3.14159;
div.full.ftz.f32    x, y, z;
div.rn.f64          xd, yd, zd;
</pre>
 <h4>
  <span class="section-number">
   9.7.3.9.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-abs">
   Floating Point Instructions: abs
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-abs" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  abs
 </p>
 <p>
  Absolute value.
 </p>
 <p>
  Syntax
 </p>
 <pre>abs{.ftz}.f32  d, a;
abs.f64        d, a;
</pre>
 <p>
  Description
 </p>
 <p>
  Take the absolute value of
  <span class="pre">
   a
  </span>
  and store the result in
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>d = |a|;
</pre>
 <p>
  Notes
 </p>
 <p>
  Subnormal numbers:
 </p>
 <span class="pre">
  sm_20+
 </span>
 <p>
  By default, subnormal numbers are supported.
 </p>
 <p>
  <span class="pre">
   abs.ftz.f32
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <span class="pre">
  sm_1x
 </span>
 <p>
  <span class="pre">
   abs.f64
  </span>
  supports subnormal numbers.
 </p>
 <p>
  <span class="pre">
   abs.f32
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <p>
  For
  <span class="pre">
   abs.f32
  </span>
  ,
  <span class="pre">
   NaN
  </span>
  input yields unspecified
  <span class="pre">
   NaN
  </span>
  . For
  <span class="pre">
   abs.f64
  </span>
  ,
  <span class="pre">
   NaN
  </span>
  input is passed
through unchanged. Future implementations may comply with the IEEE 754 standard by preserving
payload and modifying only the sign bit.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   abs.f32
  </span>
  supported on all target architectures.
 </p>
 <p>
  <span class="pre">
   abs.f64
  </span>
  requires
  <span class="pre">
   sm_13
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>abs.ftz.f32  x,f0;
</pre>
 <h4>
  <span class="section-number">
   9.7.3.10.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-neg">
   Floating Point Instructions: neg
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-neg" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  neg
 </p>
 <p>
  Arithmetic negate.
 </p>
 <p>
  Syntax
 </p>
 <pre>neg{.ftz}.f32  d, a;
neg.f64        d, a;
</pre>
 <p>
  Description
 </p>
 <p>
  Negate the sign of
  <span class="pre">
   a
  </span>
  and store the result in
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>d = -a;
</pre>
 <p>
  Notes
 </p>
 <p>
  Subnormal numbers:
 </p>
 <span class="pre">
  sm_20+
 </span>
 <p>
  By default, subnormal numbers are supported.
 </p>
 <p>
  <span class="pre">
   neg.ftz.f32
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <span class="pre">
  sm_1x
 </span>
 <p>
  <span class="pre">
   neg.f64
  </span>
  supports subnormal numbers.
 </p>
 <p>
  <span class="pre">
   neg.f32
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <p>
  <span class="pre">
   NaN
  </span>
  inputs yield an unspecified
  <span class="pre">
   NaN
  </span>
  . Future implementations may comply with the IEEE 754
standard by preserving payload and modifying only the sign bit.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   neg.f32
  </span>
  supported on all target architectures.
 </p>
 <p>
  <span class="pre">
   neg.f64
  </span>
  requires
  <span class="pre">
   sm_13
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>neg.ftz.f32  x,f0;
</pre>
 <h4>
  <span class="section-number">
   9.7.3.11.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-min">
   Floating Point Instructions: min
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-min" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  min
 </p>
 <p>
  Find the minimum of two values.
 </p>
 <p>
  Syntax
 </p>
 <pre>min{.ftz}{.NaN}{.xorsign.abs}.f32  d, a, b;
min.f64                            d, a, b;
</pre>
 <p>
  Description
 </p>
 <p>
  Store the minimum of
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  in
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  If
  <span class="pre">
   .NaN
  </span>
  modifier is specified, then the result is canonical
  <span class="pre">
   NaN
  </span>
  if either of the inputs is
  <span class="pre">
   NaN
  </span>
  .
 </p>
 <p>
  If
  <span class="pre">
   .abs
  </span>
  modifier is specified, the magnitude of destination operand
  <span class="pre">
   d
  </span>
  is the minimum of
absolute values of both the input arguments.
 </p>
 <p>
  If
  <span class="pre">
   .xorsign
  </span>
  modifier is specified, the sign bit of destination
  <span class="pre">
   d
  </span>
  is equal to the XOR of the
sign bits of both the inputs.
 </p>
 <p>
  Modifiers
  <span class="pre">
   .abs
  </span>
  and
  <span class="pre">
   .xorsign
  </span>
  must be specified together and
  <span class="pre">
   .xorsign
  </span>
  considers the sign
bit of both inputs before applying
  <span class="pre">
   .abs
  </span>
  operation.
 </p>
 <p>
  If the result of
  <span class="pre">
   min
  </span>
  is
  <span class="pre">
   NaN
  </span>
  then the
  <span class="pre">
   .xorsign
  </span>
  and
  <span class="pre">
   .abs
  </span>
  modifiers will be ignored.
 </p>
 <p>
  Semantics
 </p>
 <pre>if (.xorsign) {
    xorsign = getSignBit(a) ^ getSignBit(b);
    if (.abs) {
        a = |a|;
        b = |b|;
   }
}
if (isNaN(a) &amp;&amp; isNaN(b))                 d = NaN;
else if (.NaN &amp;&amp; (isNaN(a) || isNaN(b)))  d = NaN;
else if (isNaN(a))                        d = b;
else if (isNaN(b))                        d = a;
else                                      d = (a &lt; b) ? a : b;
if (.xorsign &amp;&amp; !isNaN(d)) {
    setSignBit(d, xorsign);
}
</pre>
 <p>
  Notes
 </p>
 <p>
  Subnormal numbers:
 </p>
 <span class="pre">
  sm_20+
 </span>
 <p>
  By default, subnormal numbers are supported.
 </p>
 <p>
  <span class="pre">
   min.ftz.f32
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <span class="pre">
  sm_1x
 </span>
 <p>
  <span class="pre">
   min.f64
  </span>
  supports subnormal numbers.
 </p>
 <p>
  <span class="pre">
   min.f32
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <p>
  If values of both inputs are 0.0, then +0.0 &gt; -0.0.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  <span class="pre">
   min.NaN
  </span>
  introduced in PTX ISA version 7.0.
 </p>
 <p>
  <span class="pre">
   min.xorsign.abs
  </span>
  introduced in PTX ISA version 7.2.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   min.f32
  </span>
  supported on all target architectures.
 </p>
 <p>
  <span class="pre">
   min.f64
  </span>
  requires
  <span class="pre">
   sm_13
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   min.NaN
  </span>
  requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   min.xorsign.abs
  </span>
  requires
  <span class="pre">
   sm_86
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>@p  min.ftz.f32  z,z,x;
    min.f64      a,b,c;
    // fp32 min with .NaN
    min.NaN.f32  f0,f1,f2;
    // fp32 min with .xorsign.abs
    min.xorsign.abs.f32 Rd, Ra, Rb;
</pre>
 <h4>
  <span class="section-number">
   9.7.3.12.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-max">
   Floating Point Instructions: max
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-max" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  max
 </p>
 <p>
  Find the maximum of two values.
 </p>
 <p>
  Syntax
 </p>
 <pre>max{.ftz}{.NaN}{.xorsign.abs}.f32  d, a, b;
max.f64                            d, a, b;
</pre>
 <p>
  Description
 </p>
 <p>
  Store the maximum of
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  in
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  If
  <span class="pre">
   .NaN
  </span>
  modifier is specified, the result is canonical
  <span class="pre">
   NaN
  </span>
  if either of the inputs is
  <span class="pre">
   NaN
  </span>
  .
 </p>
 <p>
  If
  <span class="pre">
   .abs
  </span>
  modifier is specified, the magnitude of destination operand
  <span class="pre">
   d
  </span>
  is the maximum of
absolute values of both the input arguments.
 </p>
 <p>
  If
  <span class="pre">
   .xorsign
  </span>
  modifier is specified, the sign bit of destination
  <span class="pre">
   d
  </span>
  is equal to the XOR of the
sign bits of both the inputs.
 </p>
 <p>
  Modifiers
  <span class="pre">
   .abs
  </span>
  and
  <span class="pre">
   .xorsign
  </span>
  must be specified together and
  <span class="pre">
   .xorsign
  </span>
  considers the sign
bit of both inputs before applying
  <span class="pre">
   .abs
  </span>
  operation.
 </p>
 <p>
  If the result of
  <span class="pre">
   max
  </span>
  is
  <span class="pre">
   NaN
  </span>
  then the
  <span class="pre">
   .xorsign
  </span>
  and
  <span class="pre">
   .abs
  </span>
  modifiers will be ignored.
 </p>
 <p>
  Semantics
 </p>
 <pre>if (.xorsign) {
    xorsign = getSignBit(a) ^ getSignBit(b);
    if (.abs) {
        a = |a|;
        b = |b|;
    }
}
if (isNaN(a) &amp;&amp; isNaN(b))                 d = NaN;
else if (.NaN &amp;&amp; (isNaN(a) || isNaN(b)))  d = NaN;
else if (isNaN(a))                        d = b;
else if (isNaN(b))                        d = a;
else                                      d = (a &gt; b) ? a : b;
if (.xorsign &amp;&amp; !isNaN(d)) {
    setSignBit(d, xorsign);
}
</pre>
 <p>
  Notes
 </p>
 <p>
  Subnormal numbers:
 </p>
 <span class="pre">
  sm_20+
 </span>
 <p>
  By default, subnormal numbers are supported.
 </p>
 <p>
  <span class="pre">
   max.ftz.f32
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <span class="pre">
  sm_1x
 </span>
 <p>
  <span class="pre">
   max.f64
  </span>
  supports subnormal numbers.
 </p>
 <p>
  <span class="pre">
   max.f32
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <p>
  If values of both inputs are 0.0, then +0.0 &gt; -0.0.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  <span class="pre">
   max.NaN
  </span>
  introduced in PTX ISA version 7.0.
 </p>
 <p>
  <span class="pre">
   max.xorsign.abs
  </span>
  introduced in PTX ISA version 7.2.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   max.f32
  </span>
  supported on all target architectures.
 </p>
 <p>
  <span class="pre">
   max.f64
  </span>
  requires
  <span class="pre">
   sm_13
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   max.NaN
  </span>
  requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   max.xorsign.abs
  </span>
  requires
  <span class="pre">
   sm_86
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>max.ftz.f32  f0,f1,f2;
max.f64      a,b,c;
// fp32 max with .NaN
max.NaN.f32  f0,f1,f2;
// fp32 max with .xorsign.abs
max.xorsign.abs.f32 Rd, Ra, Rb;
</pre>
 <h4>
  <span class="section-number">
   9.7.3.13.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-rcp">
   Floating Point Instructions: rcp
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-rcp" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  rcp
 </p>
 <p>
  Take the reciprocal of a value.
 </p>
 <p>
  Syntax
 </p>
 <pre>rcp.approx{.ftz}.f32  d, a;  // fast, approximate reciprocal
rcp.rnd{.ftz}.f32     d, a;  // IEEE 754 compliant rounding
rcp.rnd.f64           d, a;  // IEEE 754 compliant rounding

.rnd = { .rn, .rz, .rm, .rp };
</pre>
 <p>
  Description
 </p>
 <p>
  Compute
  <span class="pre">
   1/a
  </span>
  , store result in
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>d = 1 / a;
</pre>
 <p>
  Notes
 </p>
 <p>
  Fast, approximate single-precision reciprocal:
 </p>
 <p>
  <span class="pre">
   rcp.approx.f32
  </span>
  implements a fast approximation to reciprocal. The maximum absolute error is 2
  -23.0
  over the range 1.0-2.0.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Input
    </p>
   </th>
   <th class="head">
    <p>
     Result
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     -Inf
    </p>
   </td>
   <td>
    <p>
     -0.0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     -subnormal
    </p>
   </td>
   <td>
    <p>
     -Inf
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     -0.0
    </p>
   </td>
   <td>
    <p>
     -Inf
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     +0.0
    </p>
   </td>
   <td>
    <p>
     +Inf
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     +subnormal
    </p>
   </td>
   <td>
    <p>
     +Inf
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     +Inf
    </p>
   </td>
   <td>
    <p>
     +0.0
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     NaN
    </p>
   </td>
   <td>
    <p>
     NaN
    </p>
   </td>
  </tr>
 </table>
 <p>
  Reciprocal with IEEE 754 compliant rounding:
 </p>
 <p>
  Rounding modifiers (no default):
 </p>
 <span class="pre">
  .rn
 </span>
 <p>
  mantissa LSB rounds to nearest even
 </p>
 <span class="pre">
  .rz
 </span>
 <p>
  mantissa LSB rounds towards zero
 </p>
 <span class="pre">
  .rm
 </span>
 <p>
  mantissa LSB rounds towards negative infinity
 </p>
 <span class="pre">
  .rp
 </span>
 <p>
  mantissa LSB rounds towards positive infinity
 </p>
 <p>
  Subnormal numbers:
 </p>
 <span class="pre">
  sm_20+
 </span>
 <p>
  By default, subnormal numbers are supported.
 </p>
 <p>
  <span class="pre">
   rcp.ftz.f32
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <span class="pre">
  sm_1x
 </span>
 <p>
  <span class="pre">
   rcp.f64
  </span>
  supports subnormal numbers.
 </p>
 <p>
  <span class="pre">
   rcp.f32
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  <span class="pre">
   rcp.f32
  </span>
  and
  <span class="pre">
   rcp.f64
  </span>
  introduced in PTX ISA version 1.0.
  <span class="pre">
   rcp.rn.f64
  </span>
  and explicit modifiers
  <span class="pre">
   .approx
  </span>
  and
  <span class="pre">
   .ftz
  </span>
  were introduced in PTX ISA version 1.4. General rounding modifiers were
added in PTX ISA version 2.0.
 </p>
 <p>
  For PTX ISA version 1.4 and later, one of
  <span class="pre">
   .approx
  </span>
  or
  <span class="pre">
   .rnd
  </span>
  is required.
 </p>
 <p>
  For PTX ISA versions 1.0 through 1.3,
  <span class="pre">
   rcp.f32
  </span>
  defaults to
  <span class="pre">
   rcp.approx.ftz.f32
  </span>
  , and
  <span class="pre">
   rcp.f64
  </span>
  defaults to
  <span class="pre">
   rcp.rn.f64
  </span>
  .
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   rcp.approx.f32
  </span>
  supported on all target architectures.
 </p>
 <p>
  <span class="pre">
   rcp.rnd.f32
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   rcp.rn.f64
  </span>
  requires
  <span class="pre">
   sm_13
  </span>
  or higher, or
  <span class="pre">
   .target
  </span>
  <span class="pre">
   map_f64_to_f32.
  </span>
 </p>
 <p>
  <span class="pre">
   rcp.{rz,rm,rp}.f64
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>rcp.approx.ftz.f32  ri,r;
rcp.rn.ftz.f32      xi,x;
rcp.rn.f64          xi,x;
</pre>
 <h4>
  <span class="section-number">
   9.7.3.14.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-rcp-approx-ftz-f64">
   Floating Point Instructions: rcp.approx.ftz.f64
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-rcp-approx-ftz-f64" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  rcp.approx.ftz.f64
 </p>
 <p>
  Compute a fast, gross approximation to the reciprocal of a value.
 </p>
 <p>
  Syntax
 </p>
 <pre>rcp.approx.ftz.f64  d, a;
</pre>
 <p>
  Description
 </p>
 <p>
  Compute a fast, gross approximation to the reciprocal as follows:
 </p>
 <ol class="arabic simple">
  <li>
   <p>
    extract the most-significant 32 bits of
    <span class="pre">
     .f64
    </span>
    operand
    <span class="pre">
     a
    </span>
    in 1.11.20 IEEE floating-point
format (i.e., ignore the least-significant 32 bits of
    <span class="pre">
     a
    </span>
    ),
   </p>
  </li>
  <li>
   <p>
    compute an approximate
    <span class="pre">
     .f64
    </span>
    reciprocal of this value using the most-significant 20 bits of
the mantissa of operand
    <span class="pre">
     a
    </span>
    ,
   </p>
  </li>
  <li>
   <p>
    place the resulting 32-bits in 1.11.20 IEEE floating-point format in the most-significant 32-bits
of destination
    <span class="pre">
     d
    </span>
    ,and
   </p>
  </li>
  <li>
   <p>
    zero the least significant 32 mantissa bits of
    <span class="pre">
     .f64
    </span>
    destination
    <span class="pre">
     d
    </span>
    .
   </p>
  </li>
 </ol>
 <p>
  Semantics
 </p>
 <pre>tmp = a[63:32]; // upper word of a, 1.11.20 format
d[63:32] = 1.0 / tmp;
d[31:0] = 0x00000000;
</pre>
 <p>
  Notes
 </p>
 <p>
  <span class="pre">
   rcp.approx.ftz.f64
  </span>
  implements a fast, gross approximation to reciprocal.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Input a[63:32]
    </p>
   </th>
   <th class="head">
    <p>
     Result d[63:32]
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     -Inf
    </p>
   </td>
   <td>
    <p>
     -0.0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     -subnormal
    </p>
   </td>
   <td>
    <p>
     -Inf
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     -0.0
    </p>
   </td>
   <td>
    <p>
     -Inf
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     +0.0
    </p>
   </td>
   <td>
    <p>
     +Inf
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     +subnormal
    </p>
   </td>
   <td>
    <p>
     +Inf
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     +Inf
    </p>
   </td>
   <td>
    <p>
     +0.0
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     NaN
    </p>
   </td>
   <td>
    <p>
     NaN
    </p>
   </td>
  </tr>
 </table>
 <p>
  Input
  <span class="pre">
   NaN
  </span>
  s map to a canonical
  <span class="pre">
   NaN
  </span>
  with encoding
  <span class="pre">
   0x7fffffff00000000
  </span>
  .
 </p>
 <p>
  Subnormal inputs and results are flushed to sign-preserving zero.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  <span class="pre">
   rcp.approx.ftz.f64
  </span>
  introduced in PTX ISA version 2.1.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   rcp.approx.ftz.f64
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>rcp.ftz.f64  xi,x;
</pre>
 <h4>
  <span class="section-number">
   9.7.3.15.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-sqrt">
   Floating Point Instructions: sqrt
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-sqrt" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  sqrt
 </p>
 <p>
  Take the square root of a value.
 </p>
 <p>
  Syntax
 </p>
 <pre>sqrt.approx{.ftz}.f32  d, a; // fast, approximate square root
sqrt.rnd{.ftz}.f32     d, a; // IEEE 754 compliant rounding
sqrt.rnd.f64           d, a; // IEEE 754 compliant rounding

.rnd = { .rn, .rz, .rm, .rp };
</pre>
 <p>
  Description
 </p>
 <p>
  Compute sqrt(
  <span class="pre">
   a
  </span>
  ) and store the result in
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>d = sqrt(a);
</pre>
 <p>
  Notes
 </p>
 <p>
  <span class="pre">
   sqrt.approx.f32
  </span>
  implements a fast approximation to square root.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Input
    </p>
   </th>
   <th class="head">
    <p>
     Result
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     -Inf
    </p>
   </td>
   <td>
    <p>
     NaN
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     -normal
    </p>
   </td>
   <td>
    <p>
     NaN
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     -subnormal
    </p>
   </td>
   <td>
    <p>
     -0.0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     -0.0
    </p>
   </td>
   <td>
    <p>
     -0.0
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     +0.0
    </p>
   </td>
   <td>
    <p>
     +0.0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     +subnormal
    </p>
   </td>
   <td>
    <p>
     +0.0
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     +Inf
    </p>
   </td>
   <td>
    <p>
     +Inf
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     NaN
    </p>
   </td>
   <td>
    <p>
     NaN
    </p>
   </td>
  </tr>
 </table>
 <p>
  Square root with IEEE 754 compliant rounding:
 </p>
 <p>
  Rounding modifiers (no default):
 </p>
 <span class="pre">
  .rn
 </span>
 <p>
  mantissa LSB rounds to nearest even
 </p>
 <span class="pre">
  .rz
 </span>
 <p>
  mantissa LSB rounds towards zero
 </p>
 <span class="pre">
  .rm
 </span>
 <p>
  mantissa LSB rounds towards negative infinity
 </p>
 <span class="pre">
  .rp
 </span>
 <p>
  mantissa LSB rounds towards positive infinity
 </p>
 <p>
  Subnormal numbers:
 </p>
 <span class="pre">
  sm_20+
 </span>
 <p>
  By default, subnormal numbers are supported.
 </p>
 <p>
  <span class="pre">
   sqrt.ftz.f32
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <span class="pre">
  sm_1x
 </span>
 <p>
  <span class="pre">
   sqrt.f64
  </span>
  supports subnormal numbers.
 </p>
 <p>
  <span class="pre">
   sqrt.f32
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  <span class="pre">
   sqrt.f32
  </span>
  and
  <span class="pre">
   sqrt.f64
  </span>
  introduced in PTX ISA version 1.0.
  <span class="pre">
   sqrt.rn.f64
  </span>
  and explicit
modifiers
  <span class="pre">
   .approx
  </span>
  and
  <span class="pre">
   .ftz
  </span>
  were introduced in PTX ISA version 1.4. General rounding
modifiers were added in PTX ISA version 2.0.
 </p>
 <p>
  For PTX ISA version 1.4 and later, one of
  <span class="pre">
   .approx
  </span>
  or
  <span class="pre">
   .rnd
  </span>
  is required.
 </p>
 <p>
  For PTX ISA versions 1.0 through 1.3,
  <span class="pre">
   sqrt.f32
  </span>
  defaults to
  <span class="pre">
   sqrt.approx.ftz.f32
  </span>
  , and
  <span class="pre">
   sqrt.f64
  </span>
  defaults to
  <span class="pre">
   sqrt.rn.f64
  </span>
  .
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   sqrt.approx.f32
  </span>
  supported on all target architectures.
 </p>
 <p>
  <span class="pre">
   sqrt.rnd.f32
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   sqrt.rn.f64
  </span>
  requires
  <span class="pre">
   sm_13
  </span>
  or higher, or
  <span class="pre">
   .target
  </span>
  <span class="pre">
   map_f64_to_f32
  </span>
  .
 </p>
 <p>
  <span class="pre">
   sqrt.{rz,rm,rp}.f64
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>sqrt.approx.ftz.f32  r,x;
sqrt.rn.ftz.f32      r,x;
sqrt.rn.f64          r,x;
</pre>
 <h4>
  <span class="section-number">
   9.7.3.16.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-rsqrt">
   Floating Point Instructions: rsqrt
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-rsqrt" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  rsqrt
 </p>
 <p>
  Take the reciprocal of the square root of a value.
 </p>
 <p>
  Syntax
 </p>
 <pre>rsqrt.approx{.ftz}.f32  d, a;
rsqrt.approx.f64        d, a;
</pre>
 <p>
  Description
 </p>
 <p>
  Compute
  <span class="pre">
   1/sqrt(a)
  </span>
  and store the result in
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>d = 1/sqrt(a);
</pre>
 <p>
  Notes
 </p>
 <p>
  <span class="pre">
   rsqrt.approx
  </span>
  implements an approximation to the reciprocal square root.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Input
    </p>
   </th>
   <th class="head">
    <p>
     Result
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     -Inf
    </p>
   </td>
   <td>
    <p>
     NaN
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     -normal
    </p>
   </td>
   <td>
    <p>
     NaN
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     -subnormal
    </p>
   </td>
   <td>
    <p>
     -Inf
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     -0.0
    </p>
   </td>
   <td>
    <p>
     -Inf
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     +0.0
    </p>
   </td>
   <td>
    <p>
     +Inf
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     +subnormal
    </p>
   </td>
   <td>
    <p>
     +Inf
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     +Inf
    </p>
   </td>
   <td>
    <p>
     +0.0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     NaN
    </p>
   </td>
   <td>
    <p>
     NaN
    </p>
   </td>
  </tr>
 </table>
 <p>
  The maximum absolute error for
  <span class="pre">
   rsqrt.f32
  </span>
  is 2
  -22.4
  over the range 1.0-4.0.
 </p>
 <p>
  Subnormal numbers:
 </p>
 <span class="pre">
  sm_20+
 </span>
 <p>
  By default, subnormal numbers are supported.
 </p>
 <p>
  <span class="pre">
   rsqrt.ftz.f32
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <span class="pre">
  sm_1x
 </span>
 <p>
  <span class="pre">
   rsqrt.f64
  </span>
  supports subnormal numbers.
 </p>
 <p>
  <span class="pre">
   rsqrt.f32
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <p>
  Note that
  <span class="pre">
   rsqrt.approx.f64
  </span>
  is emulated in software and are relatively slow.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  <span class="pre">
   rsqrt.f32
  </span>
  and
  <span class="pre">
   rsqrt.f64
  </span>
  were introduced in PTX ISA version 1.0. Explicit modifiers
  <span class="pre">
   .approx
  </span>
  and
  <span class="pre">
   .ftz
  </span>
  were introduced in PTX ISA version 1.4.
 </p>
 <p>
  For PTX ISA version 1.4 and later, the
  <span class="pre">
   .approx
  </span>
  modifier is required.
 </p>
 <p>
  For PTX ISA versions 1.0 through 1.3,
  <span class="pre">
   rsqrt.f32
  </span>
  defaults to
  <span class="pre">
   rsqrt.approx.ftz.f32
  </span>
  , and
  <span class="pre">
   rsqrt.f64
  </span>
  defaults to
  <span class="pre">
   rsqrt.approx.f64
  </span>
  .
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   rsqrt.f32
  </span>
  supported on all target architectures.
 </p>
 <p>
  <span class="pre">
   rsqrt.f64
  </span>
  requires
  <span class="pre">
   sm_13
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>rsqrt.approx.ftz.f32  isr, x;
rsqrt.approx.f64      ISR, X;
</pre>
 <h4>
  <span class="section-number">
   9.7.3.17.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-rsqrt-approx-ftz-f64">
   Floating Point Instructions: rsqrt.approx.ftz.f64
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-rsqrt-approx-ftz-f64" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  rsqrt.approx.ftz.f64
 </p>
 <p>
  Compute an approximation of the square root reciprocal of a value.
 </p>
 <p>
  Syntax
 </p>
 <pre>rsqrt.approx.ftz.f64 d, a;
</pre>
 <p>
  Description
 </p>
 <p>
  Compute a double-precision (
  <span class="pre">
   .f64
  </span>
  ) approximation of the square root reciprocal of a value. The
least significant 32 bits of the double-precision (
  <span class="pre">
   .f64
  </span>
  ) destination
  <span class="pre">
   d
  </span>
  are all zeros.
 </p>
 <p>
  Semantics
 </p>
 <pre>tmp = a[63:32]; // upper word of a, 1.11.20 format
d[63:32] = 1.0 / sqrt(tmp);
d[31:0] = 0x00000000;
</pre>
 <p>
  Notes
 </p>
 <p>
  <span class="pre">
   rsqrt.approx.ftz.f64
  </span>
  implements a fast approximation of the square root reciprocal of a value.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Input
    </p>
   </th>
   <th class="head">
    <p>
     Result
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     -Inf
    </p>
   </td>
   <td>
    <p>
     NaN
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     -subnormal
    </p>
   </td>
   <td>
    <p>
     -Inf
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     -0.0
    </p>
   </td>
   <td>
    <p>
     -Inf
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     +0.0
    </p>
   </td>
   <td>
    <p>
     +Inf
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     +subnormal
    </p>
   </td>
   <td>
    <p>
     +Inf
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     +Inf
    </p>
   </td>
   <td>
    <p>
     +0.0
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     NaN
    </p>
   </td>
   <td>
    <p>
     NaN
    </p>
   </td>
  </tr>
 </table>
 <p>
  Input
  <span class="pre">
   NaN
  </span>
  s map to a canonical
  <span class="pre">
   NaN
  </span>
  with encoding
  <span class="pre">
   0x7fffffff00000000
  </span>
  .
 </p>
 <p>
  Subnormal inputs and results are flushed to sign-preserving zero.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  <span class="pre">
   rsqrt.approx.ftz.f64
  </span>
  introduced in PTX ISA version 4.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   rsqrt.approx.ftz.f64
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>rsqrt.approx.ftz.f64 xi,x;
</pre>
 <h4>
  <span class="section-number">
   9.7.3.18.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-sin">
   Floating Point Instructions: sin
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-sin" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  sin
 </p>
 <p>
  Find the sine of a value.
 </p>
 <p>
  Syntax
 </p>
 <pre>sin.approx{.ftz}.f32  d, a;
</pre>
 <p>
  Description
 </p>
 <p>
  Find the sine of the angle
  <span class="pre">
   a
  </span>
  (in radians).
 </p>
 <p>
  Semantics
 </p>
 <pre>d = sin(a);
</pre>
 <p>
  Notes
 </p>
 <p>
  <span class="pre">
   sin.approx.f32
  </span>
  implements a fast approximation to sine.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Input
    </p>
   </th>
   <th class="head">
    <p>
     Result
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     -Inf
    </p>
   </td>
   <td>
    <p>
     NaN
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     -subnormal
    </p>
   </td>
   <td>
    <p>
     -0.0
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     -0.0
    </p>
   </td>
   <td>
    <p>
     -0.0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     +0.0
    </p>
   </td>
   <td>
    <p>
     +0.0
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     +subnormal
    </p>
   </td>
   <td>
    <p>
     +0.0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     +Inf
    </p>
   </td>
   <td>
    <p>
     NaN
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     NaN
    </p>
   </td>
   <td>
    <p>
     NaN
    </p>
   </td>
  </tr>
 </table>
 <p>
  The maximum absolute error is 2
  -20.9
  in quadrant 00.
 </p>
 <p>
  Subnormal numbers:
 </p>
 <span class="pre">
  sm_20+
 </span>
 <p>
  By default, subnormal numbers are supported.
 </p>
 <p>
  <span class="pre">
   sin.ftz.f32
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <span class="pre">
  sm_1x
 </span>
 <p>
  Subnormal inputs and results to sign-preserving zero.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  <span class="pre">
   sin.f32
  </span>
  introduced in PTX ISA version 1.0. Explicit modifiers
  <span class="pre">
   .approx
  </span>
  and
  <span class="pre">
   .ftz
  </span>
  introduced in PTX ISA version 1.4.
 </p>
 <p>
  For PTX ISA version 1.4 and later, the .approx modifier is required.
 </p>
 <p>
  For PTX ISA versions 1.0 through 1.3,
  <span class="pre">
   sin.f32
  </span>
  defaults to
  <span class="pre">
   sin.approx.ftz.f32
  </span>
  .
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>sin.approx.ftz.f32  sa, a;
</pre>
 <h4>
  <span class="section-number">
   9.7.3.19.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-cos">
   Floating Point Instructions: cos
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-cos" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  cos
 </p>
 <p>
  Find the cosine of a value.
 </p>
 <p>
  Syntax
 </p>
 <pre>cos.approx{.ftz}.f32  d, a;
</pre>
 <p>
  Description
 </p>
 <p>
  Find the cosine of the angle
  <span class="pre">
   a
  </span>
  (in radians).
 </p>
 <p>
  Semantics
 </p>
 <pre>d = cos(a);
</pre>
 <p>
  Notes
 </p>
 <p>
  <span class="pre">
   cos.approx.f32
  </span>
  implements a fast approximation to cosine.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Input
    </p>
   </th>
   <th class="head">
    <p>
     Result
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     -Inf
    </p>
   </td>
   <td>
    <p>
     NaN
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     -subnormal
    </p>
   </td>
   <td>
    <p>
     +1.0
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     -0.0
    </p>
   </td>
   <td>
    <p>
     +1.0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     +0.0
    </p>
   </td>
   <td>
    <p>
     +1.0
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     +subnormal
    </p>
   </td>
   <td>
    <p>
     +1.0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     +Inf
    </p>
   </td>
   <td>
    <p>
     NaN
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     NaN
    </p>
   </td>
   <td>
    <p>
     NaN
    </p>
   </td>
  </tr>
 </table>
 <p>
  The maximum absolute error is 2
  -20.9
  in quadrant 00.
 </p>
 <p>
  Subnormal numbers:
 </p>
 <span class="pre">
  sm_20+
 </span>
 <p>
  By default, subnormal numbers are supported.
 </p>
 <p>
  <span class="pre">
   cos.ftz.f32
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <span class="pre">
  sm_1x
 </span>
 <p>
  Subnormal inputs and results to sign-preserving zero.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  <span class="pre">
   cos.f32
  </span>
  introduced in PTX ISA version 1.0. Explicit modifiers
  <span class="pre">
   .approx
  </span>
  and
  <span class="pre">
   .ftz
  </span>
  introduced in PTX ISA version 1.4.
 </p>
 <p>
  For PTX ISA version 1.4 and later, the
  <span class="pre">
   .approx
  </span>
  modifier is required.
 </p>
 <p>
  For PTX ISA versions 1.0 through 1.3,
  <span class="pre">
   cos.f32
  </span>
  defaults to
  <span class="pre">
   cos.approx.ftz.f32
  </span>
  .
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>cos.approx.ftz.f32  ca, a;
</pre>
 <h4>
  <span class="section-number">
   9.7.3.20.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-lg2">
   Floating Point Instructions: lg2
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-lg2" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  lg2
 </p>
 <p>
  Find the base-2 logarithm of a value.
 </p>
 <p>
  Syntax
 </p>
 <pre>lg2.approx{.ftz}.f32  d, a;
</pre>
 <p>
  Description
 </p>
 <p>
  Determine the log
  2
  of
  <span class="pre">
   a
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>d = log(a) / log(2);
</pre>
 <p>
  Notes
 </p>
 <p>
  <span class="pre">
   lg2.approx.f32
  </span>
  implements a fast approximation to log
  2
  (a).
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Input
    </p>
   </th>
   <th class="head">
    <p>
     Result
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     -Inf
    </p>
   </td>
   <td>
    <p>
     NaN
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     -subnormal
    </p>
   </td>
   <td>
    <p>
     -Inf
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     -0.0
    </p>
   </td>
   <td>
    <p>
     -Inf
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     +0.0
    </p>
   </td>
   <td>
    <p>
     -Inf
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     +subnormal
    </p>
   </td>
   <td>
    <p>
     -Inf
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     +Inf
    </p>
   </td>
   <td>
    <p>
     +Inf
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     NaN
    </p>
   </td>
   <td>
    <p>
     NaN
    </p>
   </td>
  </tr>
 </table>
 <p>
  The maximum absolute error is 2
  -22.6
  for mantissa.
 </p>
 <p>
  Subnormal numbers:
 </p>
 <span class="pre">
  sm_20+
 </span>
 <p>
  By default, subnormal numbers are supported.
 </p>
 <p>
  <span class="pre">
   lg2.ftz.f32
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <span class="pre">
  sm_1x
 </span>
 <p>
  Subnormal inputs and results to sign-preserving zero.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  <span class="pre">
   lg2.f32
  </span>
  introduced in PTX ISA version 1.0. Explicit modifiers
  <span class="pre">
   .approx
  </span>
  and
  <span class="pre">
   .ftz
  </span>
  introduced in PTX ISA version 1.4.
 </p>
 <p>
  For PTX ISA version 1.4 and later, the
  <span class="pre">
   .approx
  </span>
  modifier is required.
 </p>
 <p>
  For PTX ISA versions 1.0 through 1.3,
  <span class="pre">
   lg2.f32
  </span>
  defaults to
  <span class="pre">
   lg2.approx.ftz.f32
  </span>
  .
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>lg2.approx.ftz.f32  la, a;
</pre>
 <h4>
  <span class="section-number">
   9.7.3.21.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-ex2">
   Floating Point Instructions: ex2
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-ex2" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  ex2
 </p>
 <p>
  Find the base-2 exponential of a value.
 </p>
 <p>
  Syntax
 </p>
 <pre>ex2.approx{.ftz}.f32  d, a;
</pre>
 <p>
  Description
 </p>
 <p>
  Raise 2 to the power
  <span class="pre">
   a
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>d = 2 ^ a;
</pre>
 <p>
  Notes
 </p>
 <p>
  <span class="pre">
   ex2.approx.f32
  </span>
  implements a fast approximation to 2
  a
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Input
    </p>
   </th>
   <th class="head">
    <p>
     Result
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     -Inf
    </p>
   </td>
   <td>
    <p>
     +0.0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     -subnormal
    </p>
   </td>
   <td>
    <p>
     +1.0
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     -0.0
    </p>
   </td>
   <td>
    <p>
     +1.0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     +0.0
    </p>
   </td>
   <td>
    <p>
     +1.0
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     +subnormal
    </p>
   </td>
   <td>
    <p>
     +1.0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     +Inf
    </p>
   </td>
   <td>
    <p>
     +Inf
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     NaN
    </p>
   </td>
   <td>
    <p>
     NaN
    </p>
   </td>
  </tr>
 </table>
 <p>
  The maximum absolute error is 2
  -22.5
  for fraction in the primary range.
 </p>
 <p>
  Subnormal numbers:
 </p>
 <span class="pre">
  sm_20+
 </span>
 <p>
  By default, subnormal numbers are supported.
 </p>
 <p>
  <span class="pre">
   ex2.ftz.f32
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <span class="pre">
  sm_1x
 </span>
 <p>
  Subnormal inputs and results to sign-preserving zero.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  <span class="pre">
   ex2.f32
  </span>
  introduced in PTX ISA version 1.0. Explicit modifiers
  <span class="pre">
   .approx
  </span>
  and
  <span class="pre">
   .ftz
  </span>
  introduced in PTX ISA version 1.4.
 </p>
 <p>
  For PTX ISA version 1.4 and later, the
  <span class="pre">
   .approx
  </span>
  modifier is required.
 </p>
 <p>
  For PTX ISA versions 1.0 through 1.3,
  <span class="pre">
   ex2.f32
  </span>
  defaults to
  <span class="pre">
   ex2.approx.ftz.f32
  </span>
  .
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>ex2.approx.ftz.f32  xa, a;
</pre>
 <h4>
  <span class="section-number">
   9.7.3.22.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-tanh">
   Floating Point Instructions: tanh
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-tanh" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  tanh
 </p>
 <p>
  Find the hyperbolic tangent of a value (in radians)
 </p>
 <p>
  Syntax
 </p>
 <pre>tanh.approx.f32 d, a;
</pre>
 <p>
  Description
 </p>
 <p>
  Take hyperbolic tangent value of
  <span class="pre">
   a
  </span>
  .
 </p>
 <p>
  The operands
  <span class="pre">
   d
  </span>
  and
  <span class="pre">
   a
  </span>
  are of type
  <span class="pre">
   .f32
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>d = tanh(a);
</pre>
 <p>
  Notes
 </p>
 <p>
  <span class="pre">
   tanh.approx.f32
  </span>
  implements a fast approximation to FP32 hyperbolic-tangent.
 </p>
 <p>
  Results of
  <span class="pre">
   tanh
  </span>
  for various corner-case inputs are as follows:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Input
    </p>
   </th>
   <th class="head">
    <p>
     Result
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     -Inf
    </p>
   </td>
   <td>
    <p>
     -1.0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     -subnormal
    </p>
   </td>
   <td>
    <p>
     Same as input
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     -0.0
    </p>
   </td>
   <td>
    <p>
     -0.0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     +0.0
    </p>
   </td>
   <td>
    <p>
     +0.0
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     +subnormal
    </p>
   </td>
   <td>
    <p>
     Same as input
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     +Inf
    </p>
   </td>
   <td>
    <p>
     1.0
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     NaN
    </p>
   </td>
   <td>
    <p>
     NaN
    </p>
   </td>
  </tr>
 </table>
 <p>
  The subnormal numbers are supported.
 </p>
 <p class="admonition-title">
  Note
 </p>
 <p>
  The subnormal inputs gets passed through to the output since the value of
  <span class="pre">
   tanh(x)
  </span>
  for small
values of
  <span class="pre">
   x
  </span>
  is approximately the same as
  <span class="pre">
   x
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_75
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>tanh.approx.f32 sa, a;
</pre>
 <h3>
  <span class="section-number">
   9.7.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions">
   Half Precision Floating-Point Instructions
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  Half precision floating-point instructions operate on
  <span class="pre">
   .f16
  </span>
  and
  <span class="pre">
   .f16x2
  </span>
  register operands. The
half precision floating-point instructions are:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     add
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     sub
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     mul
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     fma
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     neg
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     abs
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     min
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     max
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     tanh
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     ex2
    </span>
   </p>
  </li>
 </ul>
 <p>
  Half-precision
  <span class="pre">
   add
  </span>
  ,
  <span class="pre">
   sub
  </span>
  ,
  <span class="pre">
   mul
  </span>
  , and
  <span class="pre">
   fma
  </span>
  support saturation of results to the range
[0.0, 1.0], with
  <span class="pre">
   NaN
  </span>
  s being flushed to positive zero. Half-precision instructions return an
unspecified
  <span class="pre">
   NaN
  </span>
  .
 </p>
 <h4>
  <span class="section-number">
   9.7.4.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-add">
   Half Precision Floating Point Instructions: add
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-add" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  add
 </p>
 <p>
  Add two values.
 </p>
 <p>
  Syntax
 </p>
 <pre>add{.rnd}{.ftz}{.sat}.f16   d, a, b;
add{.rnd}{.ftz}{.sat}.f16x2 d, a, b;

add{.rnd}.bf16   d, a, b;
add{.rnd}.bf16x2 d, a, b;

.rnd = { .rn };
</pre>
 <p>
  Description
 </p>
 <p>
  Performs addition and writes the resulting value into a destination register.
 </p>
 <p>
  For
  <span class="pre">
   .f16x2
  </span>
  and
  <span class="pre">
   .bf16x2
  </span>
  instruction type, forms input vectors by half word values from source
operands. Half-word operands are then added in parallel to produce
  <span class="pre">
   .f16x2
  </span>
  or
  <span class="pre">
   .bf16x2
  </span>
  result
in destination.
 </p>
 <p>
  For
  <span class="pre">
   .f16
  </span>
  instruction type, operands
  <span class="pre">
   d
  </span>
  ,
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  have
  <span class="pre">
   .f16
  </span>
  or
  <span class="pre">
   .b16
  </span>
  type. For
  <span class="pre">
   .f16x2
  </span>
  instruction type, operands
  <span class="pre">
   d
  </span>
  ,
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  have
  <span class="pre">
   .b32
  </span>
  type. For
  <span class="pre">
   .bf16
  </span>
  instruction type, operands
  <span class="pre">
   d
  </span>
  ,
  <span class="pre">
   a
  </span>
  ,
  <span class="pre">
   b
  </span>
  have
  <span class="pre">
   .b16
  </span>
  type. For
  <span class="pre">
   .bf16x2
  </span>
  instruction type,
operands
  <span class="pre">
   d
  </span>
  ,
  <span class="pre">
   a
  </span>
  ,
  <span class="pre">
   b
  </span>
  have
  <span class="pre">
   .b32
  </span>
  type.
 </p>
 <p>
  Semantics
 </p>
 <pre>if (type == f16 || type == bf16) {
    d = a + b;
} else if (type == f16x2 || type == bf16x2) {
    fA[0] = a[0:15];
    fA[1] = a[16:31];
    fB[0] = b[0:15];
    fB[1] = b[16:31];
    for (i = 0; i &lt; 2; i++) {
         d[i] = fA[i] + fB[i];
    }
}
</pre>
 <p>
  Notes
 </p>
 <p>
  Rounding modifiers:
 </p>
 <span class="pre">
  .rn
 </span>
 <p>
  mantissa LSB rounds to nearest even
 </p>
 <p>
  The default value of rounding modifier is
  <span class="pre">
   .rn
  </span>
  . Note that an
  <span class="pre">
   add
  </span>
  instruction with an explicit
rounding modifier is treated conservatively by the code optimizer. An
  <span class="pre">
   add
  </span>
  instruction with no
rounding modifier defaults to round-to-nearest-even and may be optimized aggressively by the code
optimizer. In particular,
  <span class="pre">
   mul
  </span>
  /
  <span class="pre">
   add
  </span>
  sequences with no rounding modifiers may be optimized to
use fused-multiply-add instructions on the target device.
 </p>
 Subnormal numbers:
 <p>
  By default, subnormal numbers are supported.
  <span class="pre">
   add.ftz.{f16,
  </span>
  <span class="pre">
   f16x2}
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 Saturation modifier:
 <p>
  <span class="pre">
   add.sat.{f16,
  </span>
  <span class="pre">
   f16x2}
  </span>
  clamps the result to [0.0, 1.0].
  <span class="pre">
   NaN
  </span>
  results are flushed to
  <span class="pre">
   +0.0f
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 4.2.
 </p>
 <p>
  <span class="pre">
   add{.rnd}.bf16
  </span>
  and
  <span class="pre">
   add{.rnd}.bf16x2
  </span>
  introduced in PTX ISA version 7.8.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_53
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   add{.rnd}.bf16
  </span>
  and
  <span class="pre">
   add{.rnd}.bf16x2
  </span>
  requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>// scalar f16 additions
add.f16        d0, a0, b0;
add.rn.f16     d1, a1, b1;
add.bf16       bd0, ba0, bb0;
add.rn.bf16    bd1, ba1, bb1;

// SIMD f16 addition
cvt.rn.f16.f32 h0, f0;
cvt.rn.f16.f32 h1, f1;
cvt.rn.f16.f32 h2, f2;
cvt.rn.f16.f32 h3, f3;
mov.b32  p1, {h0, h1};   // pack two f16 to 32bit f16x2
mov.b32  p2, {h2, h3};   // pack two f16 to 32bit f16x2
add.f16x2  p3, p1, p2;   // SIMD f16x2 addition

// SIMD bf16 addition
cvt.rn.bf16x2.f32 p4, f4, f5; // Convert two f32 into packed bf16x2
cvt.rn.bf16x2.f32 p5, f6, f7; // Convert two f32 into packed bf16x2
add.bf16x2  p6, p4, p5;       // SIMD bf16x2 addition

// SIMD fp16 addition
ld.global.b32   f0, [addr];     // load 32 bit which hold packed f16x2
ld.global.b32   f1, [addr + 4]; // load 32 bit which hold packed f16x2
add.f16x2       f2, f0, f1;     // SIMD f16x2 addition

ld.global.b32   f3, [addr + 8];  // load 32 bit which hold packed bf16x2
ld.global.b32   f4, [addr + 12]; // load 32 bit which hold packed bf16x2
add.bf16x2      f5, f3, f4;      // SIMD bf16x2 addition
</pre>
 <h4>
  <span class="section-number">
   9.7.4.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-sub">
   Half Precision Floating Point Instructions: sub
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-sub" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  sub
 </p>
 <p>
  Subtract two values.
 </p>
 <p>
  Syntax
 </p>
 <pre>sub{.rnd}{.ftz}{.sat}.f16   d, a, b;
sub{.rnd}{.ftz}{.sat}.f16x2 d, a, b;

sub{.rnd}.bf16   d, a, b;
sub{.rnd}.bf16x2 d, a, b;

.rnd = { .rn };
</pre>
 <p>
  Description
 </p>
 <p>
  Performs subtraction and writes the resulting value into a destination register.
 </p>
 <p>
  For
  <span class="pre">
   .f16x2
  </span>
  and
  <span class="pre">
   .bf16x2
  </span>
  instruction type, forms input vectors by half word values from source
operands. Half-word operands are then subtracted in parallel to produce
  <span class="pre">
   .f16x2
  </span>
  or
  <span class="pre">
   .bf16x2
  </span>
  result in destination.
 </p>
 <p>
  For
  <span class="pre">
   .f16
  </span>
  instruction type, operands
  <span class="pre">
   d
  </span>
  ,
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  have
  <span class="pre">
   .f16
  </span>
  or
  <span class="pre">
   .b16
  </span>
  type. For
  <span class="pre">
   .f16x2
  </span>
  instruction type, operands
  <span class="pre">
   d
  </span>
  ,
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  have
  <span class="pre">
   .b32
  </span>
  type. For
  <span class="pre">
   .bf16
  </span>
  instruction type, operands
  <span class="pre">
   d
  </span>
  ,
  <span class="pre">
   a
  </span>
  ,
  <span class="pre">
   b
  </span>
  have
  <span class="pre">
   .b16
  </span>
  type. For
  <span class="pre">
   .bf16x2
  </span>
  instruction type,
operands
  <span class="pre">
   d
  </span>
  ,
  <span class="pre">
   a
  </span>
  ,
  <span class="pre">
   b
  </span>
  have
  <span class="pre">
   .b32
  </span>
  type.
 </p>
 <p>
  Semantics
 </p>
 <pre>if (type == f16 || type == bf16) {
    d = a - b;
} else if (type == f16x2 || type == bf16x2) {
    fA[0] = a[0:15];
    fA[1] = a[16:31];
    fB[0] = b[0:15];
    fB[1] = b[16:31];
    for (i = 0; i &lt; 2; i++) {
         d[i] = fA[i] - fB[i];
    }
}
</pre>
 <p>
  Notes
 </p>
 <p>
  Rounding modifiers:
 </p>
 <span class="pre">
  .rn
 </span>
 <p>
  mantissa LSB rounds to nearest even
 </p>
 <p>
  The default value of rounding modifier is
  <span class="pre">
   .rn
  </span>
  . Note that a
  <span class="pre">
   sub
  </span>
  instruction with an explicit
rounding modifier is treated conservatively by the code optimizer. A
  <span class="pre">
   sub
  </span>
  instruction with no
rounding modifier defaults to round-to-nearest-even and may be optimized aggressively by the code
optimizer. In particular,
  <span class="pre">
   mul
  </span>
  /
  <span class="pre">
   sub
  </span>
  sequences with no rounding modifiers may be optimized to
use fused-multiply-add instructions on the target device.
 </p>
 Subnormal numbers:
 <p>
  By default, subnormal numbers are supported.
  <span class="pre">
   sub.ftz.{f16,
  </span>
  <span class="pre">
   f16x2}
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 Saturation modifier:
 <p>
  <span class="pre">
   sub.sat.{f16,
  </span>
  <span class="pre">
   f16x2}
  </span>
  clamps the result to [0.0, 1.0].
  <span class="pre">
   NaN
  </span>
  results are flushed to
  <span class="pre">
   +0.0f
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 4.2.
 </p>
 <p>
  <span class="pre">
   sub{.rnd}.bf16
  </span>
  and
  <span class="pre">
   sub{.rnd}.bf16x2
  </span>
  introduced in PTX ISA version 7.8.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_53
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   sub{.rnd}.bf16
  </span>
  and
  <span class="pre">
   sub{.rnd}.bf16x2
  </span>
  requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>// scalar f16 subtractions
sub.f16        d0, a0, b0;
sub.rn.f16     d1, a1, b1;
sub.bf16       bd0, ba0, bb0;
sub.rn.bf16    bd1, ba1, bb1;

// SIMD f16 subtraction
cvt.rn.f16.f32 h0, f0;
cvt.rn.f16.f32 h1, f1;
cvt.rn.f16.f32 h2, f2;
cvt.rn.f16.f32 h3, f3;
mov.b32  p1, {h0, h1};   // pack two f16 to 32bit f16x2
mov.b32  p2, {h2, h3};   // pack two f16 to 32bit f16x2
sub.f16x2  p3, p1, p2;   // SIMD f16x2 subtraction

// SIMD bf16 subtraction
cvt.rn.bf16x2.f32 p4, f4, f5; // Convert two f32 into packed bf16x2
cvt.rn.bf16x2.f32 p5, f6, f7; // Convert two f32 into packed bf16x2
sub.bf16x2  p6, p4, p5;       // SIMD bf16x2 subtraction

// SIMD fp16 subtraction
ld.global.b32   f0, [addr];     // load 32 bit which hold packed f16x2
ld.global.b32   f1, [addr + 4]; // load 32 bit which hold packed f16x2
sub.f16x2       f2, f0, f1;     // SIMD f16x2 subtraction

// SIMD bf16 subtraction
ld.global.b32   f3, [addr + 8];  // load 32 bit which hold packed bf16x2
ld.global.b32   f4, [addr + 12]; // load 32 bit which hold packed bf16x2
sub.bf16x2      f5, f3, f4;      // SIMD bf16x2 subtraction
</pre>
 <h4>
  <span class="section-number">
   9.7.4.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-mul">
   Half Precision Floating Point Instructions: mul
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-mul" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  mul
 </p>
 <p>
  Multiply two values.
 </p>
 <p>
  Syntax
 </p>
 <pre>mul{.rnd}{.ftz}{.sat}.f16   d, a, b;
mul{.rnd}{.ftz}{.sat}.f16x2 d, a, b;

mul{.rnd}.bf16   d, a, b;
mul{.rnd}.bf16x2 d, a, b;

.rnd = { .rn };
</pre>
 <p>
  Description
 </p>
 <p>
  Performs multiplication and writes the resulting value into a destination register.
 </p>
 <p>
  For
  <span class="pre">
   .f16x2
  </span>
  and
  <span class="pre">
   .bf16x2
  </span>
  instruction type, forms input vectors by half word values from source
operands. Half-word operands are then multiplied in parallel to produce
  <span class="pre">
   .f16x2
  </span>
  or
  <span class="pre">
   .bf16x2
  </span>
  result in destination.
 </p>
 <p>
  For
  <span class="pre">
   .f16
  </span>
  instruction type, operands
  <span class="pre">
   d
  </span>
  ,
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  have
  <span class="pre">
   .f16
  </span>
  or
  <span class="pre">
   .b16
  </span>
  type. For
  <span class="pre">
   .f16x2
  </span>
  instruction type, operands
  <span class="pre">
   d
  </span>
  ,
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  have
  <span class="pre">
   .b32
  </span>
  type. For
  <span class="pre">
   .bf16
  </span>
  instruction type, operands
  <span class="pre">
   d
  </span>
  ,
  <span class="pre">
   a
  </span>
  ,
  <span class="pre">
   b
  </span>
  have
  <span class="pre">
   .b16
  </span>
  type. For
  <span class="pre">
   .bf16x2
  </span>
  instruction type,
operands
  <span class="pre">
   d
  </span>
  ,
  <span class="pre">
   a
  </span>
  ,
  <span class="pre">
   b
  </span>
  have
  <span class="pre">
   .b32
  </span>
  type.
 </p>
 <p>
  Semantics
 </p>
 <pre>if (type == f16 || type == bf16) {
    d = a * b;
} else if (type == f16x2 || type == bf16x2) {
    fA[0] = a[0:15];
    fA[1] = a[16:31];
    fB[0] = b[0:15];
    fB[1] = b[16:31];
    for (i = 0; i &lt; 2; i++) {
         d[i] = fA[i] * fB[i];
    }
}
</pre>
 <p>
  Notes
 </p>
 <p>
  Rounding modifiers:
 </p>
 <span class="pre">
  .rn
 </span>
 <p>
  mantissa LSB rounds to nearest even
 </p>
 <p>
  The default value of rounding modifier is
  <span class="pre">
   .rn
  </span>
  . Note that a
  <span class="pre">
   mul
  </span>
  instruction with an explicit
rounding modifier is treated conservatively by the code optimizer. A
  <span class="pre">
   mul
  </span>
  instruction with no
rounding modifier defaults to round-to-nearest-even and may be optimized aggressively by the code
optimizer. In particular,
  <span class="pre">
   mul
  </span>
  /
  <span class="pre">
   add
  </span>
  and
  <span class="pre">
   mul/sub
  </span>
  sequences with no rounding modifiers may
be optimized to use fused-multiply-add instructions on the target device.
 </p>
 Subnormal numbers:
 <p>
  By default, subnormal numbers are supported.
  <span class="pre">
   mul.ftz.{f16,
  </span>
  <span class="pre">
   f16x2}
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 Saturation modifier:
 <p>
  <span class="pre">
   mul.sat.{f16,
  </span>
  <span class="pre">
   f16x2}
  </span>
  clamps the result to [0.0, 1.0].
  <span class="pre">
   NaN
  </span>
  results are flushed to
  <span class="pre">
   +0.0f
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 4.2.
 </p>
 <p>
  <span class="pre">
   mul{.rnd}.bf16
  </span>
  and
  <span class="pre">
   mul{.rnd}.bf16x2
  </span>
  introduced in PTX ISA version 7.8.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_53
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   mul{.rnd}.bf16
  </span>
  and
  <span class="pre">
   mul{.rnd}.bf16x2
  </span>
  requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>// scalar f16 multiplications
mul.f16        d0, a0, b0;
mul.rn.f16     d1, a1, b1;
mul.bf16       bd0, ba0, bb0;
mul.rn.bf16    bd1, ba1, bb1;

// SIMD f16 multiplication
cvt.rn.f16.f32 h0, f0;
cvt.rn.f16.f32 h1, f1;
cvt.rn.f16.f32 h2, f2;
cvt.rn.f16.f32 h3, f3;
mov.b32  p1, {h0, h1};   // pack two f16 to 32bit f16x2
mov.b32  p2, {h2, h3};   // pack two f16 to 32bit f16x2
mul.f16x2  p3, p1, p2;   // SIMD f16x2 multiplication

// SIMD bf16 multiplication
cvt.rn.bf16x2.f32 p4, f4, f5; // Convert two f32 into packed bf16x2
cvt.rn.bf16x2.f32 p5, f6, f7; // Convert two f32 into packed bf16x2
mul.bf16x2  p6, p4, p5;       // SIMD bf16x2 multiplication

// SIMD fp16 multiplication
ld.global.b32   f0, [addr];     // load 32 bit which hold packed f16x2
ld.global.b32   f1, [addr + 4]; // load 32 bit which hold packed f16x2
mul.f16x2       f2, f0, f1;     // SIMD f16x2 multiplication

// SIMD bf16 multiplication
ld.global.b32   f3, [addr + 8];  // load 32 bit which hold packed bf16x2
ld.global.b32   f4, [addr + 12]; // load 32 bit which hold packed bf16x2
mul.bf16x2      f5, f3, f4;      // SIMD bf16x2 multiplication
</pre>
 <h4>
  <span class="section-number">
   9.7.4.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-fma">
   Half Precision Floating Point Instructions: fma
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-fma" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  fma
 </p>
 <p>
  Fused multiply-add
 </p>
 <p>
  Syntax
 </p>
 <pre>fma.rnd{.ftz}{.sat}.f16     d, a, b, c;
fma.rnd{.ftz}{.sat}.f16x2   d, a, b, c;
fma.rnd{.ftz}.relu.f16      d, a, b, c;
fma.rnd{.ftz}.relu.f16x2    d, a, b, c;
fma.rnd{.relu}.bf16         d, a, b, c;
fma.rnd{.relu}.bf16x2       d, a, b, c;
fma.rnd.oob.{relu}.type     d, a, b, c;

.rnd = { .rn };
</pre>
 <p>
  Description
 </p>
 <p>
  Performs a fused multiply-add with no loss of precision in the intermediate product and addition.
 </p>
 <p>
  For
  <span class="pre">
   .f16x2
  </span>
  and
  <span class="pre">
   .bf16x2
  </span>
  instruction type, forms input vectors by half word values from source
operands. Half-word operands are then operated in parallel to produce
  <span class="pre">
   .f16x2
  </span>
  or
  <span class="pre">
   .bf16x2
  </span>
  result in destination.
 </p>
 <p>
  For
  <span class="pre">
   .f16
  </span>
  instruction type, operands
  <span class="pre">
   d
  </span>
  ,
  <span class="pre">
   a
  </span>
  ,
  <span class="pre">
   b
  </span>
  and
  <span class="pre">
   c
  </span>
  have
  <span class="pre">
   .f16
  </span>
  or
  <span class="pre">
   .b16
  </span>
  type. For
  <span class="pre">
   .f16x2
  </span>
  instruction type, operands
  <span class="pre">
   d
  </span>
  ,
  <span class="pre">
   a
  </span>
  ,
  <span class="pre">
   b
  </span>
  and
  <span class="pre">
   c
  </span>
  have
  <span class="pre">
   .b32
  </span>
  type. For
  <span class="pre">
   .bf16
  </span>
  instruction type, operands
  <span class="pre">
   d
  </span>
  ,
  <span class="pre">
   a
  </span>
  ,
  <span class="pre">
   b
  </span>
  and
  <span class="pre">
   c
  </span>
  have
  <span class="pre">
   .b16
  </span>
  type. For
  <span class="pre">
   .bf16x2
  </span>
  instruction type, operands
  <span class="pre">
   d
  </span>
  ,
  <span class="pre">
   a
  </span>
  ,
  <span class="pre">
   b
  </span>
  and
  <span class="pre">
   c
  </span>
  have
  <span class="pre">
   .b32
  </span>
  type.
 </p>
 <p>
  Semantics
 </p>
 <pre>if (type == f16 || type == bf16) {
    d = a * b + c;
} else if (type == f16x2 || type == bf16x2) {
    fA[0] = a[0:15];
    fA[1] = a[16:31];
    fB[0] = b[0:15];
    fB[1] = b[16:31];
    fC[0] = c[0:15];
    fC[1] = c[16:31];
    for (i = 0; i &lt; 2; i++) {
         d[i] = fA[i] * fB[i] + fC[i];
    }
}
</pre>
 <p>
  Notes
 </p>
 <p>
  Rounding modifiers (default is
  <span class="pre">
   .rn
  </span>
  ):
 </p>
 <span class="pre">
  .rn
 </span>
 <p>
  mantissa LSB rounds to nearest even
 </p>
 Subnormal numbers:
 <p>
  By default, subnormal numbers are supported.
  <span class="pre">
   fma.ftz.{f16,
  </span>
  <span class="pre">
   f16x2}
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 Saturation modifier:
 <p>
  <span class="pre">
   fma.sat.{f16,
  </span>
  <span class="pre">
   f16x2}
  </span>
  clamps the result to [0.0, 1.0].
  <span class="pre">
   NaN
  </span>
  results are flushed to
  <span class="pre">
   +0.0f
  </span>
  .
  <span class="pre">
   fma.relu.{f16,
  </span>
  <span class="pre">
   f16x2,
  </span>
  <span class="pre">
   bf16,
  </span>
  <span class="pre">
   bf16x2}
  </span>
  clamps the result to 0 if negative.
  <span class="pre">
   NaN
  </span>
  result is
converted to canonical
  <span class="pre">
   NaN
  </span>
  .
 </p>
 Out Of Bounds modifier:
 <p>
  <span class="pre">
   fma.oob.{f16,
  </span>
  <span class="pre">
   f16x2,
  </span>
  <span class="pre">
   bf16,
  </span>
  <span class="pre">
   bf16x2}
  </span>
  clamps the result to 0 if either of the operands
is
  <span class="pre">
   OOB
  </span>
  <span class="pre">
   NaN
  </span>
  (defined under
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensors">
   Tensors
  </a>
  ) value. The test for the special
  <span class="pre">
   NaN
  </span>
  value
and resultant forcing of the result to +0.0 is performed independently for each of the
two SIMD operations.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 4.2.
 </p>
 <p>
  <span class="pre">
   fma.relu.{f16,
  </span>
  <span class="pre">
   f16x2}
  </span>
  and
  <span class="pre">
   fma{.relu}.{bf16,
  </span>
  <span class="pre">
   bf16x2}
  </span>
  introduced in PTX ISA version 7.0.
 </p>
 <p>
  Support for modifier
  <span class="pre">
   .oob
  </span>
  introduced in PTX ISA version 8.1.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_53
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   fma.relu.{f16,
  </span>
  <span class="pre">
   f16x2}
  </span>
  and
  <span class="pre">
   fma{.relu}.{bf16,
  </span>
  <span class="pre">
   bf16x2}
  </span>
  require
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   fma{.oob}.{f16,
  </span>
  <span class="pre">
   f16x2,
  </span>
  <span class="pre">
   bf16,
  </span>
  <span class="pre">
   bf16x2}
  </span>
  requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>// scalar f16 fused multiply-add
fma.rn.f16         d0, a0, b0, c0;
fma.rn.f16         d1, a1, b1, c1;
fma.rn.relu.f16    d1, a1, b1, c1;
fma.rn.oob.f16      d1, a1, b1, c1;
fma.rn.oob.relu.f16 d1, a1, b1, c1;

// scalar bf16 fused multiply-add
fma.rn.bf16        d1, a1, b1, c1;
fma.rn.relu.bf16   d1, a1, b1, c1;
fma.rn.oob.bf16       d1, a1, b1, c1;
fma.rn.oob.relu.bf16  d1, a1, b1, c1;

// SIMD f16 fused multiply-add
cvt.rn.f16.f32 h0, f0;
cvt.rn.f16.f32 h1, f1;
cvt.rn.f16.f32 h2, f2;
cvt.rn.f16.f32 h3, f3;
mov.b32  p1, {h0, h1}; // pack two f16 to 32bit f16x2
mov.b32  p2, {h2, h3}; // pack two f16 to 32bit f16x2
fma.rn.f16x2  p3, p1, p2, p2;   // SIMD f16x2 fused multiply-add
fma.rn.relu.f16x2  p3, p1, p2, p2; // SIMD f16x2 fused multiply-add with relu saturation mode
fma.rn.oob.f16x2  p3, p1, p2, p2; // SIMD f16x2 fused multiply-add with oob modifier
fma.rn.oob.relu.f16x2 p3, p1, p2, p2; // SIMD f16x2 fused multiply-add with oob modifier and relu saturation mode

// SIMD fp16 fused multiply-add
ld.global.b32   f0, [addr];     // load 32 bit which hold packed f16x2
ld.global.b32   f1, [addr + 4]; // load 32 bit which hold packed f16x2
fma.rn.f16x2    f2, f0, f1, f1; // SIMD f16x2 fused multiply-add

// SIMD bf16 fused multiply-add
fma.rn.bf16x2       f2, f0, f1, f1; // SIMD bf16x2 fused multiply-add
fma.rn.relu.bf16x2  f2, f0, f1, f1; // SIMD bf16x2 fused multiply-add with relu saturation mode
fma.rn.oob.bf16x2  f2, f0, f1, f1; // SIMD bf16x2 fused multiply-add with oob modifier
fma.rn.oob.relu.bf16x2  f2, f0, f1, f1; // SIMD bf16x2 fused multiply-add with oob modifier and relu saturation mode
</pre>
 <h4>
  <span class="section-number">
   9.7.4.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-neg">
   Half Precision Floating Point Instructions: neg
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-neg" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  neg
 </p>
 <p>
  Arithmetic negate.
 </p>
 <p>
  Syntax
 </p>
 <pre>neg{.ftz}.f16    d, a;
neg{.ftz}.f16x2  d, a;
neg.bf16         d, a;
neg.bf16x2       d, a;
</pre>
 <p>
  Description
 </p>
 <p>
  Negate the sign of
  <span class="pre">
   a
  </span>
  and store the result in
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  For
  <span class="pre">
   .f16x2
  </span>
  and
  <span class="pre">
   .bf16x2
  </span>
  instruction type, forms input vector by extracting half word values
from the source operand. Half-word operands are then negated in parallel to produce
  <span class="pre">
   .f16x2
  </span>
  or
  <span class="pre">
   .bf16x2
  </span>
  result in destination.
 </p>
 <p>
  For
  <span class="pre">
   .f16
  </span>
  instruction type, operands
  <span class="pre">
   d
  </span>
  and
  <span class="pre">
   a
  </span>
  have
  <span class="pre">
   .f16
  </span>
  or
  <span class="pre">
   .b16
  </span>
  type. For
  <span class="pre">
   .f16x2
  </span>
  instruction type, operands
  <span class="pre">
   d
  </span>
  and
  <span class="pre">
   a
  </span>
  have
  <span class="pre">
   .b32
  </span>
  type. For
  <span class="pre">
   .bf16
  </span>
  instruction
type, operands
  <span class="pre">
   d
  </span>
  and
  <span class="pre">
   a
  </span>
  have
  <span class="pre">
   .b16
  </span>
  type. For
  <span class="pre">
   .bf16x2
  </span>
  instruction type, operands
  <span class="pre">
   d
  </span>
  and
  <span class="pre">
   a
  </span>
  have
  <span class="pre">
   .b32
  </span>
  type.
 </p>
 <p>
  Semantics
 </p>
 <pre>if (type == f16 || type == bf16) {
    d = -a;
} else if (type == f16x2 || type == bf16x2) {
    fA[0] = a[0:15];
    fA[1] = a[16:31];
    for (i = 0; i &lt; 2; i++) {
         d[i] = -fA[i];
    }
}
</pre>
 <p>
  Notes
 </p>
 Subnormal numbers:
 <p>
  By default, subnormal numbers are supported.
  <span class="pre">
   neg.ftz.{f16,
  </span>
  <span class="pre">
   f16x2}
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <p>
  <span class="pre">
   NaN
  </span>
  inputs yield an unspecified
  <span class="pre">
   NaN
  </span>
  . Future implementations may comply with the IEEE 754
standard by preserving payload and modifying only the sign bit.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 6.0.
 </p>
 <p>
  <span class="pre">
   neg.bf16
  </span>
  and
  <span class="pre">
   neg.bf16x2
  </span>
  introduced in PTX ISA 7.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_53
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   neg.bf16
  </span>
  and
  <span class="pre">
   neg.bf16x2
  </span>
  requires architecture
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>neg.ftz.f16  x,f0;
neg.bf16     x,b0;
neg.bf16x2   x1,b1;
</pre>
 <h4>
  <span class="section-number">
   9.7.4.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-abs">
   Half Precision Floating Point Instructions: abs
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-abs" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  abs
 </p>
 <p>
  Absolute value
 </p>
 <p>
  Syntax
 </p>
 <pre>abs{.ftz}.f16    d, a;
abs{.ftz}.f16x2  d, a;
abs.bf16         d, a;
abs.bf16x2       d, a;
</pre>
 <p>
  Description
 </p>
 <p>
  Take absolute value of
  <span class="pre">
   a
  </span>
  and store the result in
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  For
  <span class="pre">
   .f16x2
  </span>
  and
  <span class="pre">
   .bf16x2
  </span>
  instruction type, forms input vector by extracting half word values
from the source operand. Absolute values of half-word operands are then computed in parallel to
produce
  <span class="pre">
   .f16x2
  </span>
  or
  <span class="pre">
   .bf16x2
  </span>
  result in destination.
 </p>
 <p>
  For
  <span class="pre">
   .f16
  </span>
  instruction type, operands
  <span class="pre">
   d
  </span>
  and
  <span class="pre">
   a
  </span>
  have
  <span class="pre">
   .f16
  </span>
  or
  <span class="pre">
   .b16
  </span>
  type. For
  <span class="pre">
   .f16x2
  </span>
  instruction type, operands
  <span class="pre">
   d
  </span>
  and
  <span class="pre">
   a
  </span>
  have
  <span class="pre">
   .f16x2
  </span>
  or
  <span class="pre">
   .b32
  </span>
  type. For
  <span class="pre">
   .bf16
  </span>
  instruction type, operands
  <span class="pre">
   d
  </span>
  and
  <span class="pre">
   a
  </span>
  have
  <span class="pre">
   .b16
  </span>
  type. For
  <span class="pre">
   .bf16x2
  </span>
  instruction
type, operands
  <span class="pre">
   d
  </span>
  and
  <span class="pre">
   a
  </span>
  have
  <span class="pre">
   .b32
  </span>
  type.
 </p>
 <p>
  Semantics
 </p>
 <pre>if (type == f16 || type == bf16) {
    d = |a|;
} else if (type == f16x2 || type == bf16x2) {
    fA[0] = a[0:15];
    fA[1] = a[16:31];
    for (i = 0; i &lt; 2; i++) {
         d[i] = |fA[i]|;
    }
}
</pre>
 <p>
  Notes
 </p>
 Subnormal numbers:
 <p>
  By default, subnormal numbers are supported.
  <span class="pre">
   abs.ftz.{f16,
  </span>
  <span class="pre">
   f16x2}
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <p>
  <span class="pre">
   NaN
  </span>
  inputs yield an unspecified
  <span class="pre">
   NaN
  </span>
  . Future implementations may comply with the IEEE 754
standard by preserving payload and modifying only the sign bit.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 6.5.
 </p>
 <p>
  <span class="pre">
   abs.bf16
  </span>
  and
  <span class="pre">
   abs.bf16x2
  </span>
  introduced in PTX ISA 7.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_53
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   abs.bf16
  </span>
  and
  <span class="pre">
   abs.bf16x2
  </span>
  requires architecture
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>abs.ftz.f16  x,f0;
abs.bf16     x,b0;
abs.bf16x2   x1,b1;
</pre>
 <h4>
  <span class="section-number">
   9.7.4.7.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-min">
   Half Precision Floating Point Instructions: min
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-min" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  min
 </p>
 <p>
  Find the minimum of two values.
 </p>
 <p>
  Syntax
 </p>
 <pre>min{.ftz}{.NaN}{.xorsign.abs}.f16      d, a, b;
min{.ftz}{.NaN}{.xorsign.abs}.f16x2    d, a, b;
min{.NaN}{.xorsign.abs}.bf16           d, a, b;
min{.NaN}{.xorsign.abs}.bf16x2         d, a, b;
</pre>
 <p>
  Description
 </p>
 <p>
  Store the minimum of
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  in
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  For
  <span class="pre">
   .f16x2
  </span>
  and
  <span class="pre">
   .bf16x2
  </span>
  instruction types, input vectors are formed with half-word values
from source operands. Half-word operands are then processed in parallel to store
  <span class="pre">
   .f16x2
  </span>
  or
  <span class="pre">
   .bf16x2
  </span>
  result in destination.
 </p>
 <p>
  For
  <span class="pre">
   .f16
  </span>
  instruction type, operands
  <span class="pre">
   d
  </span>
  and
  <span class="pre">
   a
  </span>
  have
  <span class="pre">
   .f16
  </span>
  or
  <span class="pre">
   .b16
  </span>
  type. For
  <span class="pre">
   .f16x2
  </span>
  instruction type, operands
  <span class="pre">
   d
  </span>
  and
  <span class="pre">
   a
  </span>
  have
  <span class="pre">
   .f16x2
  </span>
  or
  <span class="pre">
   .b32
  </span>
  type. For
  <span class="pre">
   .bf16
  </span>
  instruction type, operands
  <span class="pre">
   d
  </span>
  and
  <span class="pre">
   a
  </span>
  have
  <span class="pre">
   .b16
  </span>
  type. For
  <span class="pre">
   .bf16x2
  </span>
  instruction
type, operands
  <span class="pre">
   d
  </span>
  and
  <span class="pre">
   a
  </span>
  have
  <span class="pre">
   .b32
  </span>
  type.
 </p>
 <p>
  If
  <span class="pre">
   .NaN
  </span>
  modifier is specified, then the result is canonical
  <span class="pre">
   NaN
  </span>
  if either of the inputs is
  <span class="pre">
   NaN
  </span>
  .
 </p>
 <p>
  If
  <span class="pre">
   .abs
  </span>
  modifier is specified, the magnitude of destination operand
  <span class="pre">
   d
  </span>
  is the minimum of
absolute values of both the input arguments.
 </p>
 <p>
  If
  <span class="pre">
   .xorsign
  </span>
  modifier is specified, the sign bit of destination
  <span class="pre">
   d
  </span>
  is equal to the XOR of the
sign bits of both the inputs.
 </p>
 <p>
  Modifiers
  <span class="pre">
   .abs
  </span>
  and
  <span class="pre">
   .xorsign
  </span>
  must be specified together and
  <span class="pre">
   .xorsign
  </span>
  considers the sign
bit of both inputs before applying
  <span class="pre">
   .abs
  </span>
  operation.
 </p>
 <p>
  If the result of
  <span class="pre">
   min
  </span>
  is
  <span class="pre">
   NaN
  </span>
  then the
  <span class="pre">
   .xorsign
  </span>
  and
  <span class="pre">
   .abs
  </span>
  modifiers will be ignored.
 </p>
 <p>
  Semantics
 </p>
 <pre>if (type == f16 || type == bf16) {
    if (.xorsign) {
        xorsign = getSignBit(a) ^ getSignBit(b);
        if (.abs) {
            a = |a|;
            b = |b|;
        }
    }
    if (isNaN(a) &amp;&amp; isNaN(b))              d = NaN;
    if (.NaN &amp;&amp; (isNaN(a) || isNaN(b)))    d = NaN;
    else if (isNaN(a))                     d = b;
    else if (isNaN(b))                     d = a;
    else                                   d = (a &lt; b) ? a : b;
    if (.xorsign &amp;&amp; !isNaN(d)) {
         setSignBit(d, xorsign);
    }
} else if (type == f16x2 || type == bf16x2) {
    fA[0] = a[0:15];
    fA[1] = a[16:31];
    fB[0] = b[0:15];
    fB[1] = b[16:31];
    for (i = 0; i &lt; 2; i++) {
        if (.xorsign) {
            xorsign = getSignBit(fA[i]) ^ getSignBit(fB[i]);
            if (.abs) {
               fA[i] = |fA[i]|;
               fB[i] = |fB[i]|;
           }
        }
        if (isNaN(fA[i]) &amp;&amp; isNaN(fB[i]))              d[i] = NaN;
        if (.NaN &amp;&amp; (isNaN(fA[i]) || isNaN(fB[i])))    d[i] = NaN;
        else if (isNaN(fA[i]))                         d[i] = fB[i];
        else if (isNaN(fB[i]))                         d[i] = fA[i];
        else                                           d[i] = (fA[i] &lt; fB[i]) ? fA[i] : fB[i];
        if (.xorsign &amp;&amp; !isNaN(d[i])) {
            setSignBit(d[i], xorsign);
        }
    }
}
</pre>
 <p>
  Notes
 </p>
 Subnormal numbers:
 <p>
  By default, subnormal numbers are supported.
  <span class="pre">
   min.ftz.{f16,
  </span>
  <span class="pre">
   f16x2}
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <p>
  If values of both inputs are 0.0, then +0.0 &gt; -0.0.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.0.
 </p>
 <p>
  <span class="pre">
   min.xorsign
  </span>
  introduced in PTX ISA version 7.2.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   min.xorsign.abs
  </span>
  support requires
  <span class="pre">
   sm_86
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>min.ftz.f16       h0,h1,h2;
min.f16x2         b0,b1,b2;
// SIMD fp16 min with .NaN
min.NaN.f16x2     b0,b1,b2;
min.bf16          h0, h1, h2;
// SIMD bf16 min with NaN
min.NaN.bf16x2    b0, b1, b2;
// scalar bf16 min with xorsign.abs
min.xorsign.abs.bf16 Rd, Ra, Rb
</pre>
 <h4>
  <span class="section-number">
   9.7.4.8.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-max">
   Half Precision Floating Point Instructions: max
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-max" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  max
 </p>
 <p>
  Find the maximum of two values.
 </p>
 <p>
  Syntax
 </p>
 <pre>max{.ftz}{.NaN}{.xorsign.abs}.f16      d, a, b;
max{.ftz}{.NaN}{.xorsign.abs}.f16x2    d, a, b;
max{.NaN}{.xorsign.abs}.bf16           d, a, b;
max{.NaN}{.xorsign.abs}.bf16x2         d, a, b;
</pre>
 <p>
  Description
 </p>
 <p>
  Store the maximum of
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  in
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  For
  <span class="pre">
   .f16x2
  </span>
  and
  <span class="pre">
   .bf16x2
  </span>
  instruction types, input vectors are formed with half-word values
from source operands. Half-word operands are then processed in parallel to store
  <span class="pre">
   .f16x2
  </span>
  or
  <span class="pre">
   .bf16x2
  </span>
  result in destination.
 </p>
 <p>
  For
  <span class="pre">
   .f16
  </span>
  instruction type, operands
  <span class="pre">
   d
  </span>
  and
  <span class="pre">
   a
  </span>
  have
  <span class="pre">
   .f16
  </span>
  or
  <span class="pre">
   .b16
  </span>
  type. For
  <span class="pre">
   .f16x2
  </span>
  instruction type, operands
  <span class="pre">
   d
  </span>
  and
  <span class="pre">
   a
  </span>
  have
  <span class="pre">
   .f16x2
  </span>
  or
  <span class="pre">
   .b32
  </span>
  type. For
  <span class="pre">
   .bf16
  </span>
  instruction type, operands
  <span class="pre">
   d
  </span>
  and
  <span class="pre">
   a
  </span>
  have
  <span class="pre">
   .b16
  </span>
  type. For
  <span class="pre">
   .bf16x2
  </span>
  instruction
type, operands
  <span class="pre">
   d
  </span>
  and
  <span class="pre">
   a
  </span>
  have
  <span class="pre">
   .b32
  </span>
  type.
 </p>
 <p>
  If
  <span class="pre">
   .NaN
  </span>
  modifier is specified, the result is canonical
  <span class="pre">
   NaN
  </span>
  if either of the inputs is
  <span class="pre">
   NaN
  </span>
  .
 </p>
 <p>
  If
  <span class="pre">
   .abs
  </span>
  modifier is specified, the magnitude of destination operand
  <span class="pre">
   d
  </span>
  is the maximum of
absolute values of both the input arguments.
 </p>
 <p>
  If
  <span class="pre">
   .xorsign
  </span>
  modifier is specified, the sign bit of destination
  <span class="pre">
   d
  </span>
  is equal to the XOR of the
sign bits of both the inputs.
 </p>
 <p>
  Modifiers
  <span class="pre">
   .abs
  </span>
  and
  <span class="pre">
   .xorsign
  </span>
  must be specified together and
  <span class="pre">
   .xorsign
  </span>
  considers the sign
bit of both inputs before applying
  <span class="pre">
   .abs
  </span>
  operation.
 </p>
 <p>
  If the result of
  <span class="pre">
   max
  </span>
  is
  <span class="pre">
   NaN
  </span>
  then the
  <span class="pre">
   .xorsign
  </span>
  and
  <span class="pre">
   .abs
  </span>
  modifiers will be ignored.
 </p>
 <p>
  Semantics
 </p>
 <pre>if (type == f16 || type == bf16) {
    if (.xorsign) {
        xorsign = getSignBit(a) ^ getSignBit(b);
        if (.abs) {
            a = |a|;
            b = |b|;
        }
    }
    if (isNaN(a) &amp;&amp; isNaN(b))              d = NaN;
    if (.NaN &amp;&amp; (isNaN(a) || isNaN(b)))    d = NaN;
    else if (isNaN(a))                     d = b;
    else if (isNaN(b))                     d = a;
    else                                   d = (a &gt; b) ? a : b;
    if (.xorsign &amp;&amp; !isNaN(d)) {
         setSignBit(d, xorsign);
    }
} else if (type == f16x2 || type == bf16x2) {
    fA[0] = a[0:15];
    fA[1] = a[16:31];
    fB[0] = b[0:15];
    fB[1] = b[16:31];
    for (i = 0; i &lt; 2; i++) {
        if (.xorsign) {
            xorsign = getSignBit(fA[i]) ^ getSignBit(fB[i]);
            if (.abs) {
                fA[i] = |fA[i]|;
                fB[i] = |fB[i]|;
            }
        }
        if (isNaN(fA[i]) &amp;&amp; isNaN(fB[i]))              d[i] = NaN;
        if (.NaN &amp;&amp; (isNaN(fA[i]) || isNaN(fB[i])))    d[i] = NaN;
        else if (isNaN(fA[i]))                         d[i] = fB[i];
        else if (isNaN(fB[i]))                         d[i] = fA[i];
        else                                           d[i] = (fA[i] &gt; fB[i]) ? fA[i] : fB[i];
        if (.xorsign &amp;&amp; !isNaN(fA[i])) {
            setSignBit(d[i], xorsign);
        }
    }
}
</pre>
 <p>
  Notes
 </p>
 Subnormal numbers:
 <p>
  By default, subnormal numbers are supported.
  <span class="pre">
   max.ftz.{f16,
  </span>
  <span class="pre">
   f16x2}
  </span>
  flushes subnormal inputs and results to sign-preserving zero.
 </p>
 <p>
  If values of both inputs are 0.0, then +0.0 &gt; -0.0.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.0.
 </p>
 <p>
  <span class="pre">
   max.xorsign.abs
  </span>
  introduced in PTX ISA version 7.2.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   max.xorsign.abs
  </span>
  support requires
  <span class="pre">
   sm_86
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>max.ftz.f16       h0,h1,h2;
max.f16x2         b0,b1,b2;
// SIMD fp16 max with NaN
max.NaN.f16x2     b0,b1,b2;
// scalar f16 max with xorsign.abs
max.xorsign.abs.f16 Rd, Ra, Rb;
max.bf16          h0, h1, h2;
// scalar bf16 max and NaN
max.NaN.bf16x2    b0, b1, b2;
// SIMD bf16 max with xorsign.abs
max.xorsign.abs.bf16x2 Rd, Ra, Rb;
</pre>
 <h4>
  <span class="section-number">
   9.7.4.9.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-tanh">
   Half Precision Floating Point Instructions: tanh
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-tanh" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  tanh
 </p>
 <p>
  Find the hyperbolic tangent of a value (in radians)
 </p>
 <p>
  Syntax
 </p>
 <pre>tanh.approx.type d, a;

.type = {.f16, .f16x2, .bf16, .bf16x2}
</pre>
 <p>
  Description
 </p>
 <p>
  Take hyperbolic tangent value of
  <span class="pre">
   a
  </span>
  .
 </p>
 <p>
  The type of operands
  <span class="pre">
   d
  </span>
  and
  <span class="pre">
   a
  </span>
  are as specified by
  <span class="pre">
   .type
  </span>
  .
 </p>
 <p>
  For
  <span class="pre">
   .f16x2
  </span>
  or
  <span class="pre">
   .bf16x2
  </span>
  instruction type, each of the half-word operands are operated in
parallel and the results are packed appropriately into a
  <span class="pre">
   .f16x2
  </span>
  or
  <span class="pre">
   .bf16x2
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>if (.type == .f16 || .type == .bf16) {
  d = tanh(a)
} else if (.type == .f16x2 || .type == .bf16x2) {
  fA[0] = a[0:15];
  fA[1] = a[16:31];
  d[0] = tanh(fA[0])
  d[1] = tanh(fA[1])
}
</pre>
 <p>
  Notes
 </p>
 <p>
  <span class="pre">
   tanh.approx.{f16,
  </span>
  <span class="pre">
   f16x2,
  </span>
  <span class="pre">
   bf16,
  </span>
  <span class="pre">
   bf16x2}
  </span>
  implements an approximate hyperbolic tangent in the
target format.
 </p>
 <p>
  Results of
  <span class="pre">
   tanh
  </span>
  for various corner-case inputs are as follows:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Input
    </p>
   </th>
   <th class="head">
    <p>
     Result
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     -Inf
    </p>
   </td>
   <td>
    <p>
     -1.0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     -0.0
    </p>
   </td>
   <td>
    <p>
     -0.0
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     +0.0
    </p>
   </td>
   <td>
    <p>
     +0.0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     +Inf
    </p>
   </td>
   <td>
    <p>
     1.0
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     NaN
    </p>
   </td>
   <td>
    <p>
     NaN
    </p>
   </td>
  </tr>
 </table>
 <p>
  The maximum absolute error for
  <span class="pre">
   .f16
  </span>
  type is 2-10.987. The maximum absolute error for
  <span class="pre">
   .bf16
  </span>
  type is 2-8.
 </p>
 <p>
  The subnormal numbers are supported.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.0.
 </p>
 <p>
  <span class="pre">
   tanh.approx.{bf16/bf16x2}
  </span>
  introduced in PTX ISA version 7.8.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_75
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   tanh.approx.{bf16/bf16x2}
  </span>
  requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>tanh.approx.f16    h1, h0;
tanh.approx.f16x2  hd1, hd0;
tanh.approx.bf16   b1, b0;
tanh.approx.bf16x2 hb1, hb0;
</pre>
 <h4>
  <span class="section-number">
   9.7.4.10.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-ex2">
   Half Precision Floating Point Instructions: ex2
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-floating-point-instructions-ex2" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  ex2
 </p>
 <p>
  Find the base-2 exponent of input.
 </p>
 <p>
  Syntax
 </p>
 <pre>ex2.approx.atype     d, a;
ex2.approx.ftz.btype d, a;

.atype = { .f16,  .f16x2}
.btype = { .bf16, .bf16x2}
</pre>
 <p>
  Description
 </p>
 <p>
  Raise 2 to the power
  <span class="pre">
   a
  </span>
  .
 </p>
 <p>
  The type of operands
  <span class="pre">
   d
  </span>
  and
  <span class="pre">
   a
  </span>
  are as specified by
  <span class="pre">
   .type
  </span>
  .
 </p>
 <p>
  For
  <span class="pre">
   .f16x2
  </span>
  or
  <span class="pre">
   .bf16x2
  </span>
  instruction type, each of the half-word operands are operated in
parallel and the results are packed appropriately into a
  <span class="pre">
   .f16x2
  </span>
  or
  <span class="pre">
   .bf16x2
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>if (.type == .f16 || .type == .bf16) {
  d = 2 ^ a
} else if (.type == .f16x2 || .type == .bf16x2) {
  fA[0] = a[0:15];
  fA[1] = a[16:31];
  d[0] = 2 ^ fA[0]
  d[1] = 2 ^ fA[1]
}
</pre>
 <p>
  Notes
 </p>
 <p>
  <span class="pre">
   ex2.approx.{f16,
  </span>
  <span class="pre">
   f16x2,
  </span>
  <span class="pre">
   bf16,
  </span>
  <span class="pre">
   bf16x2}
  </span>
  implement a fast approximation to 2
  a
  .
 </p>
 <p>
  For the
  <span class="pre">
   .f16
  </span>
  type, subnormal inputs are supported.
  <span class="pre">
   ex2.approx.ftz.bf16
  </span>
  flushes subnormal
inputs and results to sign-preserving zero.
 </p>
 <p>
  Results of
  <span class="pre">
   ex2.approx.ftz.bf16
  </span>
  for various corner-case inputs are as follows:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Input
    </p>
   </th>
   <th class="head">
    <p>
     Result
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     -Inf
    </p>
   </td>
   <td>
    <p>
     +0.0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     -subnormal
    </p>
   </td>
   <td>
    <p>
     +1.0
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     -0.0
    </p>
   </td>
   <td>
    <p>
     +1.0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     +0.0
    </p>
   </td>
   <td>
    <p>
     +1.0
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     +subnormal
    </p>
   </td>
   <td>
    <p>
     +1.0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     +Inf
    </p>
   </td>
   <td>
    <p>
     +Inf
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     NaN
    </p>
   </td>
   <td>
    <p>
     NaN
    </p>
   </td>
  </tr>
 </table>
 <p>
  Results of
  <span class="pre">
   ex2.approx.f16
  </span>
  for various corner-case inputs are as follows:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Input
    </p>
   </th>
   <th class="head">
    <p>
     Result
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     -Inf
    </p>
   </td>
   <td>
    <p>
     +0.0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     -0.0
    </p>
   </td>
   <td>
    <p>
     +1.0
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     +0.0
    </p>
   </td>
   <td>
    <p>
     +1.0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     +Inf
    </p>
   </td>
   <td>
    <p>
     +Inf
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     NaN
    </p>
   </td>
   <td>
    <p>
     NaN
    </p>
   </td>
  </tr>
 </table>
 <p>
  The maximum relative error for
  <span class="pre">
   .f16
  </span>
  type is 2-9.9. The maximum relative error for
  <span class="pre">
   .bf16
  </span>
  type
is 2-7.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.0.
 </p>
 <p>
  <span class="pre">
   ex2.approx.ftz.{bf16/bf16x2}
  </span>
  introduced in PTX ISA version 7.8.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_75
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   ex2.approx.ftz.{bf16/bf16x2}
  </span>
  requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>ex2.approx.f16         h1, h0;
ex2.approx.f16x2       hd1, hd0;
ex2.approx.ftz.bf16    b1, b2;
ex2.approx.ftz.bf16x2  hb1, hb2;
</pre>
 <h3>
  <span class="section-number">
   9.7.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#comparison-and-selection-instructions">
   Comparison and Selection Instructions
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#comparison-and-selection-instructions" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The comparison select instructions are:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     set
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     setp
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     selp
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     slct
    </span>
   </p>
  </li>
 </ul>
 <p>
  As with single-precision floating-point instructions, the
  <span class="pre">
   set
  </span>
  ,
  <span class="pre">
   setp
  </span>
  , and
  <span class="pre">
   slct
  </span>
  instructions support subnormal numbers for
  <span class="pre">
   sm_20
  </span>
  and higher targets and flush single-precision
subnormal inputs to sign-preserving zero for
  <span class="pre">
   sm_1x
  </span>
  targets. The optional
  <span class="pre">
   .ftz
  </span>
  modifier
provides backward compatibility with
  <span class="pre">
   sm_1x
  </span>
  targets by flushing subnormal inputs and results to
sign-preserving zero regardless of the target architecture.
 </p>
 <h4>
  <span class="section-number">
   9.7.5.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#comparison-and-selection-instructions-set">
   Comparison and Selection Instructions: set
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#comparison-and-selection-instructions-set" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  set
 </p>
 <p>
  Compare two numeric values with a relational operator, and optionally combine this result with a
predicate value by applying a Boolean operator.
 </p>
 <p>
  Syntax
 </p>
 <pre>set.CmpOp{.ftz}.dtype.stype         d, a, b;
set.CmpOp.BoolOp{.ftz}.dtype.stype  d, a, b, {!}c;

.CmpOp  = { eq, ne, lt, le, gt, ge, lo, ls, hi, hs,
            equ, neu, ltu, leu, gtu, geu, num, nan };
.BoolOp = { and, or, xor };
.dtype  = { .u32, .s32, .f32 };
.stype  = { .b16, .b32, .b64,
            .u16, .u32, .u64,
            .s16, .s32, .s64,
                  .f32, .f64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Compares two numeric values and optionally combines the result with another predicate value by
applying a Boolean operator. If this result is
  <span class="pre">
   True
  </span>
  ,
  <span class="pre">
   1.0f
  </span>
  is written for floating-point
destination types, and
  <span class="pre">
   0xffffffff
  </span>
  is written for integer destination types. Otherwise,
  <span class="pre">
   0x00000000
  </span>
  is written.
 </p>
 <p>
  Operand
  <span class="pre">
   d
  </span>
  has type
  <span class="pre">
   .dtype
  </span>
  ; operands
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  have type
  <span class="pre">
   .stype
  </span>
  ; operand
  <span class="pre">
   c
  </span>
  has
type
  <span class="pre">
   .pred
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>t = (a CmpOp b) ? 1 : 0;
if (isFloat(dtype))
    d = BoolOp(t, c) ? 1.0f : 0x00000000;
else
    d = BoolOp(t, c) ? 0xffffffff : 0x00000000;
</pre>
 <p>
  Integer Notes
 </p>
 <p>
  The signed and unsigned comparison operators are
  <span class="pre">
   eq
  </span>
  ,
  <span class="pre">
   ne
  </span>
  ,
  <span class="pre">
   lt
  </span>
  ,
  <span class="pre">
   le
  </span>
  ,
  <span class="pre">
   gt
  </span>
  ,
  <span class="pre">
   ge
  </span>
  .
 </p>
 <p>
  For unsigned values, the comparison operators
  <span class="pre">
   lo
  </span>
  ,
  <span class="pre">
   ls
  </span>
  ,
  <span class="pre">
   hi
  </span>
  , and
  <span class="pre">
   hs
  </span>
  for lower,
lower-or-same, higher, and higher-or-same may be used instead of
  <span class="pre">
   lt
  </span>
  ,
  <span class="pre">
   le
  </span>
  ,
  <span class="pre">
   gt
  </span>
  ,
  <span class="pre">
   ge
  </span>
  ,
respectively.
 </p>
 <p>
  The untyped, bit-size comparisons are
  <span class="pre">
   eq
  </span>
  and
  <span class="pre">
   ne
  </span>
  .
 </p>
 <p>
  Floating Point Notes
 </p>
 <p>
  The ordered comparisons are
  <span class="pre">
   eq
  </span>
  ,
  <span class="pre">
   ne
  </span>
  ,
  <span class="pre">
   lt
  </span>
  ,
  <span class="pre">
   le
  </span>
  ,
  <span class="pre">
   gt
  </span>
  ,
  <span class="pre">
   ge
  </span>
  . If either operand is
  <span class="pre">
   NaN
  </span>
  , the result is
  <span class="pre">
   False
  </span>
  .
 </p>
 <p>
  To aid comparison operations in the presence of
  <span class="pre">
   NaN
  </span>
  values, unordered versions are included:
  <span class="pre">
   equ
  </span>
  ,
  <span class="pre">
   neu
  </span>
  ,
  <span class="pre">
   ltu
  </span>
  ,
  <span class="pre">
   leu
  </span>
  ,
  <span class="pre">
   gtu
  </span>
  ,
  <span class="pre">
   geu
  </span>
  . If both operands are numeric values (not
  <span class="pre">
   NaN
  </span>
  ), then these comparisons have the same result as their ordered counterparts. If either
operand is
  <span class="pre">
   NaN
  </span>
  , then the result of these comparisons is
  <span class="pre">
   True
  </span>
  .
 </p>
 <p>
  <span class="pre">
   num
  </span>
  returns
  <span class="pre">
   True
  </span>
  if both operands are numeric values (not
  <span class="pre">
   NaN
  </span>
  ), and
  <span class="pre">
   nan
  </span>
  returns
  <span class="pre">
   True
  </span>
  if either operand is
  <span class="pre">
   NaN
  </span>
  .
 </p>
 <p>
  Subnormal numbers:
 </p>
 <span class="pre">
  sm_20+
 </span>
 <p>
  By default, subnormal numbers are supported.
 </p>
 <p>
  <span class="pre">
   set.ftz.dtype.f32
  </span>
  flushes subnormal inputs to sign-preserving zero.
 </p>
 <span class="pre">
  sm_1x
 </span>
 <p>
  <span class="pre">
   set.dtype.f64
  </span>
  supports subnormal numbers.
 </p>
 <p>
  <span class="pre">
   set.dtype.f32
  </span>
  flushes subnormal inputs to sign-preserving zero.
 </p>
 <p>
  Modifier
  <span class="pre">
   .ftz
  </span>
  applies only to
  <span class="pre">
   .f32
  </span>
  comparisons.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   set
  </span>
  with
  <span class="pre">
   .f64
  </span>
  source type requires
  <span class="pre">
   sm_13
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>@p  set.lt.and.f32.s32  d,a,b,r;
    set.eq.u32.u32      d,i,n;
</pre>
 <h4>
  <span class="section-number">
   9.7.5.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#comparison-and-selection-instructions-setp">
   Comparison and Selection Instructions: setp
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#comparison-and-selection-instructions-setp" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  setp
 </p>
 <p>
  CompareÂ two numeric values with a relational operator, and (optionally) combine this result with a
predicate value by applying a Boolean operator.
 </p>
 <p>
  Syntax
 </p>
 <pre>setp.CmpOp{.ftz}.type         p[|q], a, b;
setp.CmpOp.BoolOp{.ftz}.type  p[|q], a, b, {!}c;

.CmpOp  = { eq, ne, lt, le, gt, ge, lo, ls, hi, hs,
            equ, neu, ltu, leu, gtu, geu, num, nan };
.BoolOp = { and, or, xor };
.type   = { .b16, .b32, .b64,
            .u16, .u32, .u64,
            .s16, .s32, .s64,
                  .f32, .f64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Compares two values and combines the result with another predicate value by applying a Boolean
operator. This result is written to the first destination operand. A related value computed using
the complement of the compare result is written to the second destination operand.
 </p>
 <p>
  Applies to all numeric types. Operands
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  have type
  <span class="pre">
   .type
  </span>
  ; operands
  <span class="pre">
   p
  </span>
  ,
  <span class="pre">
   q
  </span>
  ,
and
  <span class="pre">
   c
  </span>
  have type
  <span class="pre">
   .pred
  </span>
  . The sink symbol â_â may be used in place of any one of the
destination operands.
 </p>
 <p>
  Semantics
 </p>
 <pre>t = (a CmpOp b) ? 1 : 0;
p = BoolOp(t, c);
q = BoolOp(!t, c);
</pre>
 <p>
  Integer Notes
 </p>
 <p>
  The signed and unsigned comparison operators are
  <span class="pre">
   eq
  </span>
  ,
  <span class="pre">
   ne
  </span>
  ,
  <span class="pre">
   lt
  </span>
  ,
  <span class="pre">
   le
  </span>
  ,
  <span class="pre">
   gt
  </span>
  ,
  <span class="pre">
   ge
  </span>
  .
 </p>
 <p>
  For unsigned values, the comparison operators
  <span class="pre">
   lo
  </span>
  ,
  <span class="pre">
   ls
  </span>
  ,
  <span class="pre">
   hi
  </span>
  , and
  <span class="pre">
   hs
  </span>
  for lower,
lower-or-same, higher, and higher-or-same may be used instead of
  <span class="pre">
   lt
  </span>
  ,
  <span class="pre">
   le
  </span>
  ,
  <span class="pre">
   gt
  </span>
  ,
  <span class="pre">
   ge
  </span>
  ,
respectively.
 </p>
 <p>
  The untyped, bit-size comparisons are
  <span class="pre">
   eq
  </span>
  and
  <span class="pre">
   ne
  </span>
  .
 </p>
 <p>
  Floating Point Notes
 </p>
 <p>
  The ordered comparisons are
  <span class="pre">
   eq
  </span>
  ,
  <span class="pre">
   ne
  </span>
  ,
  <span class="pre">
   lt
  </span>
  ,
  <span class="pre">
   le
  </span>
  ,
  <span class="pre">
   gt
  </span>
  ,
  <span class="pre">
   ge
  </span>
  . If either operand is
  <span class="pre">
   NaN
  </span>
  , the result is
  <span class="pre">
   False
  </span>
  .
 </p>
 <p>
  To aid comparison operations in the presence of
  <span class="pre">
   NaN
  </span>
  values, unordered versions are included:
  <span class="pre">
   equ
  </span>
  ,
  <span class="pre">
   neu
  </span>
  ,
  <span class="pre">
   ltu
  </span>
  ,
  <span class="pre">
   leu
  </span>
  ,
  <span class="pre">
   gtu
  </span>
  ,
  <span class="pre">
   geu
  </span>
  . If both operands are numeric values (not
  <span class="pre">
   NaN
  </span>
  ), then these comparisons have the same result as their ordered counterparts. If either
operand is
  <span class="pre">
   NaN
  </span>
  , then the result of these comparisons is
  <span class="pre">
   True
  </span>
  .
 </p>
 <p>
  <span class="pre">
   num
  </span>
  returns
  <span class="pre">
   True
  </span>
  if both operands are numeric values (not
  <span class="pre">
   NaN
  </span>
  ), and
  <span class="pre">
   nan
  </span>
  returns
  <span class="pre">
   True
  </span>
  if either operand is
  <span class="pre">
   NaN
  </span>
  .
 </p>
 <p>
  Subnormal numbers:
 </p>
 <span class="pre">
  sm_20+
 </span>
 <p>
  By default, subnormal numbers are supported.
 </p>
 <p>
  <span class="pre">
   setp.ftz.dtype.f32
  </span>
  flushes subnormal inputs to sign-preserving zero.
 </p>
 <span class="pre">
  sm_1x
 </span>
 <p>
  <span class="pre">
   setp.dtype.f64
  </span>
  supports subnormal numbers.
 </p>
 <p>
  <span class="pre">
   setp.dtype.f32
  </span>
  flushes subnormal inputs to sign-preserving zero.
 </p>
 <p>
  Modifier
  <span class="pre">
   .ftz
  </span>
  applies only to
  <span class="pre">
   .f32
  </span>
  comparisons.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   setp
  </span>
  with
  <span class="pre">
   .f64
  </span>
  source type requires
  <span class="pre">
   sm_13
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>    setp.lt.and.s32  p|q,a,b,r;
@q  setp.eq.u32      p,i,n;
</pre>
 <h4>
  <span class="section-number">
   9.7.5.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#comparison-and-selection-instructions-selp">
   Comparison and Selection Instructions: selp
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#comparison-and-selection-instructions-selp" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  selp
 </p>
 <p>
  Select between source operands, based on the value of the predicate source operand.
 </p>
 <p>
  Syntax
 </p>
 <pre>selp.type d, a, b, c;

.type = { .b16, .b32, .b64,
          .u16, .u32, .u64,
          .s16, .s32, .s64,
                .f32, .f64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Conditional selection. If
  <span class="pre">
   c
  </span>
  is
  <span class="pre">
   True
  </span>
  ,
  <span class="pre">
   a
  </span>
  is stored in
  <span class="pre">
   d
  </span>
  ,
  <span class="pre">
   b
  </span>
  otherwise. Operands
  <span class="pre">
   d
  </span>
  ,
  <span class="pre">
   a
  </span>
  , and
  <span class="pre">
   b
  </span>
  must be of the same type. Operand
  <span class="pre">
   c
  </span>
  is a predicate.
 </p>
 <p>
  Semantics
 </p>
 <pre>d = (c == 1) ? a : b;
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   selp.f64
  </span>
  requires
  <span class="pre">
   sm_13
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>    selp.s32  r0,r,g,p;
@q  selp.f32  f0,t,x,xp;
</pre>
 <h4>
  <span class="section-number">
   9.7.5.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#comparison-and-selection-instructions-slct">
   Comparison and Selection Instructions: slct
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#comparison-and-selection-instructions-slct" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  slct
 </p>
 <p>
  Select one source operand, based on the sign of the third operand.
 </p>
 <p>
  Syntax
 </p>
 <pre>slct.dtype.s32        d, a, b, c;
slct{.ftz}.dtype.f32  d, a, b, c;

.dtype = { .b16, .b32, .b64,
           .u16, .u32, .u64,
           .s16, .s32, .s64,
                 .f32, .f64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Conditional selection. If
  <span class="pre">
   c
  </span>
  â¥ 0,
  <span class="pre">
   a
  </span>
  is stored in
  <span class="pre">
   d
  </span>
  , otherwise
  <span class="pre">
   b
  </span>
  is stored in
  <span class="pre">
   d
  </span>
  . Operands
  <span class="pre">
   d
  </span>
  ,
  <span class="pre">
   a
  </span>
  , and
  <span class="pre">
   b
  </span>
  are treated as a bitsize type of the same width as the first
instruction type; operand
  <span class="pre">
   c
  </span>
  must match the second instruction type (
  <span class="pre">
   .s32
  </span>
  or
  <span class="pre">
   .f32
  </span>
  ). The
selected input is copied to the output without modification.
 </p>
 <p>
  Semantics
 </p>
 <pre>d = (c &gt;= 0) ? a : b;
</pre>
 <p>
  Floating Point Notes
 </p>
 <p>
  For
  <span class="pre">
   .f32
  </span>
  comparisons, negative zero equals zero.
 </p>
 <p>
  Subnormal numbers:
 </p>
 <span class="pre">
  sm_20+
 </span>
 <p>
  By default, subnormal numbers are supported.
 </p>
 <p>
  <span class="pre">
   slct.ftz.dtype.f32
  </span>
  flushes subnormal values of operand
  <span class="pre">
   c
  </span>
  to sign-preserving zero, and
operand
  <span class="pre">
   a
  </span>
  is selected.
 </p>
 <span class="pre">
  sm_1x
 </span>
 <p>
  <span class="pre">
   slct.dtype.f32
  </span>
  flushes subnormal values of operand
  <span class="pre">
   c
  </span>
  to sign-preserving zero, and operand
  <span class="pre">
   a
  </span>
  is selected.
 </p>
 <p>
  Modifier
  <span class="pre">
   .ftz
  </span>
  applies only to
  <span class="pre">
   .f32
  </span>
  comparisons.
 </p>
 <p>
  If operand
  <span class="pre">
   c
  </span>
  is
  <span class="pre">
   NaN
  </span>
  , the comparison is unordered and operand
  <span class="pre">
   b
  </span>
  is selected.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   slct.f64
  </span>
  requires
  <span class="pre">
   sm_13
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>slct.u32.s32  x, y, z, val;
slct.ftz.u64.f32  A, B, C, fval;
</pre>
 <h3>
  <span class="section-number">
   9.7.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#comparison--instructions">
   Half Precision Comparison Instructions
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-comparison-instructions" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The comparison instructions are:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     set
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     setp
    </span>
   </p>
  </li>
 </ul>
 <h4>
  <span class="section-number">
   9.7.6.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-comparison-instructions-set">
   Half Precision Comparison Instructions: set
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-comparison-instructions-set" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  set
 </p>
 <p>
  Compare two numeric values with a relational operator, and optionally combine this result with a
predicate value by applying a Boolean operator.
 </p>
 <p>
  Syntax
 </p>
 <pre>set.CmpOp{.ftz}.f16.stype            d, a, b;
set.CmpOp.BoolOp{.ftz}.f16.stype     d, a, b, {!}c;

set.CmpOp.bf16.stype                 d, a, b;
set.CmpOp.BoolOp.bf16.stype          d, a, b, {!}c;

set.CmpOp{.ftz}.dtype.f16            d, a, b;
set.CmpOp.BoolOp{.ftz}.dtype.f16     d, a, b, {!}c;
.dtype  = { .u16, .s16, .u32, .s32}

set.CmpOp.dtype.bf16                 d, a, b;
set.CmpOp.BoolOp.dtype.bf16          d, a, b, {!}c;
.dtype  = { .u16, .s16, .u32, .s32}

set.CmpOp{.ftz}.dtype.f16x2          d, a, b;
set.CmpOp.BoolOp{.ftz}.dtype.f16x2   d, a, b, {!}c;
.dtype  = { .f16x2, .u32, .s32}

set.CmpOp.dtype.bf16x2               d, a, b;
set.CmpOp.BoolOp.dtype.bf16x2        d, a, b, {!}c;
.dtype  = { .bf16x2, .u32, .s32}

.CmpOp  = { eq, ne, lt, le, gt, ge,
            equ, neu, ltu, leu, gtu, geu, num, nan };
.BoolOp = { and, or, xor };
.stype  = { .b16, .b32, .b64,
            .u16, .u32, .u64,
            .s16, .s32, .s64,
            .f16, .f32, .f64};
</pre>
 <p>
  Description
 </p>
 <p>
  Compares two numeric values and optionally combines the result with another predicate value by
applying a Boolean operator.
 </p>
 <p>
  Result of this computation is written in destination register in the following way:
 </p>
 <ul class="simple">
  <li>
   <p>
    If result is
    <span class="pre">
     True
    </span>
    ,
   </p>
   <ul>
    <li>
     <p>
      <span class="pre">
       0xffffffff
      </span>
      is written for destination types
      <span class="pre">
       .u32
      </span>
      /
      <span class="pre">
       .s32
      </span>
      .
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       0xffff
      </span>
      is written for destination types
      <span class="pre">
       .u16
      </span>
      /
      <span class="pre">
       .s16
      </span>
      .
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       1.0
      </span>
      in target precision floating point format is written for destination type
      <span class="pre">
       .f16
      </span>
      ,
      <span class="pre">
       .bf16
      </span>
      .
     </p>
    </li>
   </ul>
  </li>
  <li>
   <p>
    If result is
    <span class="pre">
     False
    </span>
    ,
   </p>
   <ul>
    <li>
     <p>
      <span class="pre">
       0x0
      </span>
      is written for all integer destination types.
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       0.0
      </span>
      in target precision floating point format is written for destination type
      <span class="pre">
       .f16
      </span>
      ,
      <span class="pre">
       .bf16
      </span>
      .
     </p>
    </li>
   </ul>
  </li>
 </ul>
 <p>
  If the source type is
  <span class="pre">
   .f16x2
  </span>
  or
  <span class="pre">
   .bf16x2
  </span>
  then result of individual operations are packed in
the 32-bit destination operand.
 </p>
 <p>
  Operand
  <span class="pre">
   c
  </span>
  has type
  <span class="pre">
   .pred
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>if (stype == .f16x2 || stype == .bf16x2) {
    fA[0] = a[0:15];
    fA[1] = a[16:31];
    fB[0] = b[0:15];
    fB[1] = b[16:31];
    t[0]   = (fA[0] CmpOp fB[0]) ? 1 : 0;
    t[1]   = (fA[1] CmpOp fB[1]) ? 1 : 0;
    if (dtype == .f16x2 || stype == .bf16x2) {
        for (i = 0; i &lt; 2; i++) {
            d[i] = BoolOp(t[i], c) ? 1.0 : 0.0;
        }
    } else {
        for (i = 0; i &lt; 2; i++) {
            d[i] = BoolOp(t[i], c) ? 0xffff : 0;
        }
    }
} else if (dtype == .f16 || stype == .bf16) {
    t = (a CmpOp b) ? 1 : 0;
    d = BoolOp(t, c) ? 1.0 : 0.0;
} else  { // Integer destination type
    trueVal = (isU16(dtype) || isS16(dtype)) ?  0xffff : 0xffffffff;
    t = (a CmpOp b) ? 1 : 0;
    d = BoolOp(t, c) ? trueVal : 0;
}
</pre>
 <p>
  Floating Point Notes
 </p>
 <p>
  The ordered comparisons are
  <span class="pre">
   eq
  </span>
  ,
  <span class="pre">
   ne
  </span>
  ,
  <span class="pre">
   lt
  </span>
  ,
  <span class="pre">
   le
  </span>
  ,
  <span class="pre">
   gt
  </span>
  ,
  <span class="pre">
   ge
  </span>
  . If either operand is
  <span class="pre">
   NaN
  </span>
  , the result is
  <span class="pre">
   False
  </span>
  .
 </p>
 <p>
  To aid comparison operations in the presence of
  <span class="pre">
   NaN
  </span>
  values, unordered versions are included:
  <span class="pre">
   equ
  </span>
  ,
  <span class="pre">
   neu
  </span>
  ,
  <span class="pre">
   ltu
  </span>
  ,
  <span class="pre">
   leu
  </span>
  ,
  <span class="pre">
   gtu
  </span>
  ,
  <span class="pre">
   geu
  </span>
  . If both operands are numeric values (not
  <span class="pre">
   NaN
  </span>
  ), then these comparisons have the same result as their ordered counterparts. If either
operand is
  <span class="pre">
   NaN
  </span>
  , then the result of these comparisons is
  <span class="pre">
   True
  </span>
  .
 </p>
 <p>
  <span class="pre">
   num
  </span>
  returns
  <span class="pre">
   True
  </span>
  if both operands are numeric values (not
  <span class="pre">
   NaN
  </span>
  ), and
  <span class="pre">
   nan
  </span>
  returns
  <span class="pre">
   True
  </span>
  if either operand is
  <span class="pre">
   NaN
  </span>
  .
 </p>
 Subnormal numbers:
 <p>
  By default, subnormal numbers are supported.
 </p>
 <p>
  When
  <span class="pre">
   .ftz
  </span>
  modifier is specified then subnormal inputs and results are flushed to sign
preserving zero.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 4.2.
 </p>
 <p>
  <span class="pre">
   set.{u16,
  </span>
  <span class="pre">
   u32,
  </span>
  <span class="pre">
   s16,
  </span>
  <span class="pre">
   s32}.f16
  </span>
  and
  <span class="pre">
   set.{u32,
  </span>
  <span class="pre">
   s32}.f16x2
  </span>
  are introduced in PTX ISA version 6.5.
 </p>
 <p>
  <span class="pre">
   set.{u16,
  </span>
  <span class="pre">
   u32,
  </span>
  <span class="pre">
   s16,
  </span>
  <span class="pre">
   s32}.bf16
  </span>
  ,
  <span class="pre">
   set.{u32,
  </span>
  <span class="pre">
   s32,
  </span>
  <span class="pre">
   bf16x2}.bf16x2
  </span>
  ,
  <span class="pre">
   set.bf16.{s16,u16,f16,b16,s32,u32,f32,b32,s64,u64,f64,b64}
  </span>
  are introduced in PTX ISA version
7.8.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_53
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   set.{u16,
  </span>
  <span class="pre">
   u32,
  </span>
  <span class="pre">
   s16,
  </span>
  <span class="pre">
   s32}.bf16
  </span>
  ,
  <span class="pre">
   set.{u32,
  </span>
  <span class="pre">
   s32,
  </span>
  <span class="pre">
   bf16x2}.bf16x2
  </span>
  ,
  <span class="pre">
   set.bf16.{s16,u16,f16,b16,s32,u32,f32,b32,s64,u64,f64,b64}
  </span>
  require
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>set.lt.and.f16.f16  d,a,b,r;
set.eq.f16x2.f16x2  d,i,n;
set.eq.u32.f16x2    d,i,n;
set.lt.and.u16.f16  d,a,b,r;
set.ltu.or.bf16.f16    d,u,v,s;
set.equ.bf16x2.bf16x2  d,j,m;
set.geu.s32.bf16x2     d,j,m;
set.num.xor.s32.bf16   d,u,v,s;
</pre>
 <h4>
  <span class="section-number">
   9.7.6.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-comparison-instructions-setp">
   Half Precision Comparison Instructions: setp
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#half-precision-comparison-instructions-setp" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  setp
 </p>
 <p>
  Compare two numeric values with a relational operator, and optionally combine this result with a
predicate value by applying a Boolean operator.
 </p>
 <p>
  Syntax
 </p>
 <pre>setp.CmpOp{.ftz}.f16           p, a, b;
setp.CmpOp.BoolOp{.ftz}.f16    p, a, b, {!}c;

setp.CmpOp{.ftz}.f16x2         p|q, a, b;
setp.CmpOp.BoolOp{.ftz}.f16x2  p|q, a, b, {!}c;

setp.CmpOp.bf16                p, a, b;
setp.CmpOp.BoolOp.bf16         p, a, b, {!}c;

setp.CmpOp.bf16x2              p|q, a, b;
setp.CmpOp.BoolOp.bf16x2       p|q, a, b, {!}c;

.CmpOp  = { eq, ne, lt, le, gt, ge,
            equ, neu, ltu, leu, gtu, geu, num, nan };
.BoolOp = { and, or, xor };
</pre>
 <p>
  Description
 </p>
 <p>
  Compares two values and combines the result with another predicate value by applying a Boolean
operator. This result is written to the destination operand.
 </p>
 <p>
  Operand
  <span class="pre">
   c
  </span>
  ,
  <span class="pre">
   p
  </span>
  and
  <span class="pre">
   q
  </span>
  has type
  <span class="pre">
   .pred
  </span>
  .
 </p>
 <p>
  For instruction type
  <span class="pre">
   .f16
  </span>
  , operands
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  have type
  <span class="pre">
   .b16
  </span>
  or
  <span class="pre">
   .f16
  </span>
  .
 </p>
 <p>
  For instruction type
  <span class="pre">
   .f16x2
  </span>
  , operands
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  have type
  <span class="pre">
   .b32
  </span>
  .
 </p>
 <p>
  For instruction type
  <span class="pre">
   .bf16
  </span>
  , operands
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  have type
  <span class="pre">
   .b16
  </span>
  .
 </p>
 <p>
  For instruction type
  <span class="pre">
   .bf16x2
  </span>
  , operands
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  have type
  <span class="pre">
   .b32
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>if (type == .f16 || type == .bf16) {
     t = (a CmpOp b) ? 1 : 0;
     p = BoolOp(t, c);
} else if (type == .f16x2 || type == .bf16x2) {
    fA[0] = a[0:15];
    fA[1] = a[16:31];
    fB[0] = b[0:15];
    fB[1] = b[16:31];
    t[0] = (fA[0] CmpOp fB[0]) ? 1 : 0;
    t[1] = (fA[1] CmpOp fB[1]) ? 1 : 0;
    p = BoolOp(t[0], c);
    q = BoolOp(t[1], c);
}
</pre>
 <p>
  Floating Point Notes
 </p>
 <p>
  The ordered comparisons are
  <span class="pre">
   eq
  </span>
  ,
  <span class="pre">
   ne
  </span>
  ,
  <span class="pre">
   lt
  </span>
  ,
  <span class="pre">
   le
  </span>
  ,
  <span class="pre">
   gt
  </span>
  ,
  <span class="pre">
   ge
  </span>
  . If either operand is
  <span class="pre">
   NaN
  </span>
  , the result is
  <span class="pre">
   False
  </span>
  .
 </p>
 <p>
  To aid comparison operations in the presence of
  <span class="pre">
   NaN
  </span>
  values, unordered versions are included:
  <span class="pre">
   equ
  </span>
  ,
  <span class="pre">
   neu
  </span>
  ,
  <span class="pre">
   ltu
  </span>
  ,
  <span class="pre">
   leu
  </span>
  ,
  <span class="pre">
   gtu
  </span>
  ,
  <span class="pre">
   geu
  </span>
  . If both operands are numeric values (not
  <span class="pre">
   NaN
  </span>
  ), then these comparisons have the same result as their ordered counterparts. If either
operand is
  <span class="pre">
   NaN
  </span>
  , then the result of these comparisons is
  <span class="pre">
   True
  </span>
  .
 </p>
 <p>
  <span class="pre">
   num
  </span>
  returns
  <span class="pre">
   True
  </span>
  if both operands are numeric values (not
  <span class="pre">
   NaN
  </span>
  ), and
  <span class="pre">
   nan
  </span>
  returns
  <span class="pre">
   True
  </span>
  if either operand is
  <span class="pre">
   NaN
  </span>
  .
 </p>
 Subnormal numbers:
 <p>
  By default, subnormal numbers are supported.
 </p>
 <p>
  <span class="pre">
   setp.ftz.{f16,f16x2}
  </span>
  flushes subnormal inputs to sign-preserving zero.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 4.2.
 </p>
 <p>
  <span class="pre">
   setp.{bf16/bf16x2}
  </span>
  introduced in PTX ISA version 7.8.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_53
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   setp.{bf16/bf16x2}
  </span>
  requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>setp.lt.and.f16x2  p|q,a,b,r;
@q  setp.eq.f16    p,i,n;

setp.gt.or.bf16x2  u|v,c,d,s;
@q  setp.eq.bf16   u,j,m;
</pre>
 <h3>
  <span class="section-number">
   9.7.7.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions">
   Logic and Shift Instructions
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The logic and shift instructions are fundamentally untyped, performing bit-wise operations on
operands of any type, provided the operands are of the same size. This permits bit-wise operations
on floating point values without having to define a union to access the bits. Instructions
  <span class="pre">
   and
  </span>
  ,
  <span class="pre">
   or
  </span>
  ,
  <span class="pre">
   xor
  </span>
  , and
  <span class="pre">
   not
  </span>
  also operate on predicates.
 </p>
 <p>
  The logical shift instructions are:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     and
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     or
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     xor
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     not
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     cnot
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     lop3
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     shf
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     shl
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     shr
    </span>
   </p>
  </li>
 </ul>
 <h4>
  <span class="section-number">
   9.7.7.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions-and">
   Logic and Shift Instructions: and
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions-and" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  and
 </p>
 <p>
  Bitwise AND.
 </p>
 <p>
  Syntax
 </p>
 <pre>and.type d, a, b;

.type = { .pred, .b16, .b32, .b64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Compute the bit-wise and operation for the bits in
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>d = a &amp; b;
</pre>
 <p>
  Notes
 </p>
 <p>
  The size of the operands must match, but not necessarily the type.
 </p>
 <p>
  Allowed types include predicate registers.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>and.b32  x,q,r;
and.b32  sign,fpvalue,0x80000000;
</pre>
 <h4>
  <span class="section-number">
   9.7.7.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions-or">
   Logic and Shift Instructions: or
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions-or" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  or
 </p>
 <p>
  Biwise OR.
 </p>
 <p>
  Syntax
 </p>
 <pre>or.type d, a, b;

.type = { .pred, .b16, .b32, .b64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Compute the bit-wise or operation for the bits in
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>d = a | b;
</pre>
 <p>
  Notes
 </p>
 <p>
  The size of the operands must match, but not necessarily the type.
 </p>
 <p>
  Allowed types include predicate registers.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>or.b32  mask mask,0x00010001
or.pred  p,q,r;
</pre>
 <h4>
  <span class="section-number">
   9.7.7.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions-xor">
   Logic and Shift Instructions: xor
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions-xor" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  xor
 </p>
 <p>
  Bitwise exclusive-OR (inequality).
 </p>
 <p>
  Syntax
 </p>
 <pre>xor.type d, a, b;

.type = { .pred, .b16, .b32, .b64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Compute the bit-wise exclusive-or operation for the bits in
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>d = a ^ b;
</pre>
 <p>
  Notes
 </p>
 <p>
  The size of the operands must match, but not necessarily the type.
 </p>
 <p>
  Allowed types include predicate registers.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>xor.b32  d,q,r;
xor.b16  d,x,0x0001;
</pre>
 <h4>
  <span class="section-number">
   9.7.7.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions-not">
   Logic and Shift Instructions: not
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions-not" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  not
 </p>
 <p>
  Bitwise negation; oneâs complement.
 </p>
 <p>
  Syntax
 </p>
 <pre>not.type d, a;

.type = { .pred, .b16, .b32, .b64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Invert the bits in
  <span class="pre">
   a
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>d = ~a;
</pre>
 <p>
  Notes
 </p>
 <p>
  The size of the operands must match, but not necessarily the type.
 </p>
 <p>
  Allowed types include predicates.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>not.b32  mask,mask;
not.pred  p,q;
</pre>
 <h4>
  <span class="section-number">
   9.7.7.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions-cnot">
   Logic and Shift Instructions: cnot
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions-cnot" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  cnot
 </p>
 <p>
  C/C++ style logical negation.
 </p>
 <p>
  Syntax
 </p>
 <pre>cnot.type d, a;

.type = { .b16, .b32, .b64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Compute the logical negation using C/C++ semantics.
 </p>
 <p>
  Semantics
 </p>
 <pre>d = (a==0) ? 1 : 0;
</pre>
 <p>
  Notes
 </p>
 <p>
  The size of the operands must match, but not necessarily the type.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>cnot.b32 d,a;
</pre>
 <h4>
  <span class="section-number">
   9.7.7.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions-lop3">
   Logic and Shift Instructions: lop3
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions-lop3" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  lop3
 </p>
 <p>
  Arbitrary logical operation on 3 inputs.
 </p>
 <p>
  Syntax
 </p>
 <pre>lop3.b32 d, a, b, c, immLut;
lop3.BoolOp.b32 d|p, a, b, c, immLut, q;

.BoolOp   = { .or , .and };
</pre>
 <p>
  Description
 </p>
 <p>
  Compute bitwise logical operation on inputs
  <span class="pre">
   a
  </span>
  ,
  <span class="pre">
   b
  </span>
  ,
  <span class="pre">
   c
  </span>
  and store the result in destination
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  Optionally,
  <span class="pre">
   .BoolOp
  </span>
  can be specified to compute the predicate result
  <span class="pre">
   p
  </span>
  by performing a
Boolean operation on the destination operand
  <span class="pre">
   d
  </span>
  with the predicate
  <span class="pre">
   q
  </span>
  in the following manner:
 </p>
 <pre>p = (d != 0) BoolOp q;
</pre>
 <p>
  The sink symbol â_â may be used in place of the destination operand
  <span class="pre">
   d
  </span>
  when
  <span class="pre">
   .BoolOp
  </span>
  qualifier
is specified.
 </p>
 <p>
  The logical operation is defined by a look-up table which, for 3 inputs, can be represented as an
8-bit value specified by operand
  <span class="pre">
   immLut
  </span>
  as described below.
  <span class="pre">
   immLut
  </span>
  is an integer constant
that can take values from 0 to 255, thereby allowing up to 256 distinct logical operations on inputs
  <span class="pre">
   a
  </span>
  ,
  <span class="pre">
   b
  </span>
  ,
  <span class="pre">
   c
  </span>
  .
 </p>
 <p>
  For a logical operation
  <span class="pre">
   F(a,
  </span>
  <span class="pre">
   b,
  </span>
  <span class="pre">
   c)
  </span>
  the value of
  <span class="pre">
   immLut
  </span>
  can be computed by applying the same
operation to three predefined constant values as follows:
 </p>
 <pre>ta = 0xF0;
tb = 0xCC;
tc = 0xAA;

immLut = F(ta, tb, tc);
</pre>
 <p>
  Examples:
 </p>
 <pre>If F = (a &amp; b &amp; c);
immLut = 0xF0 &amp; 0xCC &amp; 0xAA = 0x80

If F = (a | b | c);
immLut = 0xF0 | 0xCC | 0xAA = 0xFE

If F = (a &amp; b &amp; ~c);
immLut = 0xF0 &amp; 0xCC &amp; (~0xAA) = 0x40

If F = ((a &amp; b | c) ^ a);
immLut = (0xF0 &amp; 0xCC | 0xAA) ^ 0xF0 = 0x1A
</pre>
 <p>
  The following table illustrates computation of
  <span class="pre">
   immLut
  </span>
  for various logical operations:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     ta
    </p>
   </th>
   <th class="head">
    <p>
     tb
    </p>
   </th>
   <th class="head">
    <p>
     tc
    </p>
   </th>
   <th class="head">
    <p>
     Oper 0 (False)
    </p>
   </th>
   <th class="head">
    <p>
     Oper 1 (ta &amp; tb &amp; tc)
    </p>
   </th>
   <th class="head">
    <p>
     Oper 2 (ta &amp; tb &amp; ~tc)
    </p>
   </th>
   <th class="head">
    <p>
     â¦
    </p>
   </th>
   <th class="head">
    <p>
     Oper 254 (ta | tb | tc)
    </p>
   </th>
   <th class="head">
    <p>
     Oper 255 (True)
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td rowspan="8">
    <p>
     â¦
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td colspan="3">
    <p>
     immLut
    </p>
   </td>
   <td>
    <p>
     0x0
    </p>
   </td>
   <td>
    <p>
     0x80
    </p>
   </td>
   <td>
    <p>
     0x40
    </p>
   </td>
   <td>
    <p>
     â¦
    </p>
   </td>
   <td>
    <p>
     0xFE
    </p>
   </td>
   <td>
    <p>
     0xFF
    </p>
   </td>
  </tr>
 </table>
 <p>
  Semantics
 </p>
 <pre>F = GetFunctionFromTable(immLut); // returns the function corresponding to immLut value
d = F(a, b, c);
if (BoolOp specified) {
    p = (d != 0) BoolOp q;
}
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 4.3.
 </p>
 <p>
  Support for
  <span class="pre">
   .BoolOp
  </span>
  qualifier introduced in PTX ISA version 8.2.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_50
  </span>
  or higher.
 </p>
 <p>
  Qualifier
  <span class="pre">
   .BoolOp
  </span>
  requires
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>lop3.b32       d, a, b, c, 0x40;
lop3.or.b32  d|p, a, b, c, 0x3f, q;
lop3.and.b32 _|p, a, b, c, 0x3f, q;
</pre>
 <h4>
  <span class="section-number">
   9.7.7.7.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions-shf">
   Logic and Shift Instructions: shf
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions-shf" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  shf
 </p>
 <p>
  Funnel shift.
 </p>
 <p>
  Syntax
 </p>
 <pre>shf.l.mode.b32  d, a, b, c;  // left shift
shf.r.mode.b32  d, a, b, c;  // right shift

.mode = { .clamp, .wrap };
</pre>
 <p>
  Description
 </p>
 <p>
  Shift the 64-bit value formed by concatenating operands
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  left or right by the amount
specified by the unsigned 32-bit value in
  <span class="pre">
   c
  </span>
  . Operand
  <span class="pre">
   b
  </span>
  holds bits
  <span class="pre">
   63:32
  </span>
  and operand a
holds bits
  <span class="pre">
   31:0
  </span>
  of the 64-bit source value. The source is shifted left or right by the clamped
or wrapped value in
  <span class="pre">
   c
  </span>
  . For
  <span class="pre">
   shf.l
  </span>
  , the most-significant 32-bits of the result are written
into
  <span class="pre">
   d
  </span>
  ; for
  <span class="pre">
   shf.r
  </span>
  , the least-significant 32-bits of the result are written into
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>u32  n = (.mode == .clamp) ? min(c, 32) : c &amp; 0x1f;
switch (shf.dir) {  // shift concatenation of [b, a]
    case shf.l:     // extract 32 msbs
           u32  d = (b &lt;&lt; n)      | (a &gt;&gt; (32-n));
    case shf.r:     // extract 32 lsbs
           u32  d = (b &lt;&lt; (32-n)) | (a &gt;&gt; n);
}
</pre>
 <p>
  Notes
 </p>
 <p>
  Use funnel shift for multi-word shift operations and for rotate operations. The shift amount is
limited to the range
  <span class="pre">
   0..32
  </span>
  in clamp mode and
  <span class="pre">
   0..31
  </span>
  in wrap mode, so shifting multi-word
values by distances greater than 32 requires first moving 32-bit words, then using
  <span class="pre">
   shf
  </span>
  to shift
the remaining
  <span class="pre">
   0..31
  </span>
  distance.
 </p>
 <p>
  To shift data sizes greater than 64 bits to the right, use repeated
  <span class="pre">
   shf.r
  </span>
  instructions applied
to adjacent words, operating from least-significant word towards most-significant word. At each
step, a single word of the shifted result is computed. The most-significant word of the result is
computed using a
  <span class="pre">
   shr.{u32,s32}
  </span>
  instruction, which zero or sign fills based on the instruction
type.
 </p>
 <p>
  To shift data sizes greater than 64 bits to the left, use repeated
  <span class="pre">
   shf.l
  </span>
  instructions applied to
adjacent words, operating from most-significant word towards least-significant word. At each step, a
single word of the shifted result is computed. The least-significant word of the result is computed
using a
  <span class="pre">
   shl
  </span>
  instruction.
 </p>
 <p>
  Use funnel shift to perform 32-bit left or right rotate by supplying the same value for source
arguments
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 3.1.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_32
  </span>
  or higher.
 </p>
 <p>
  Example
 </p>
 <pre>shf.l.clamp.b32  r3,r1,r0,16;

// 128-bit left shift; n &lt; 32
// [r7,r6,r5,r4] = [r3,r2,r1,r0] &lt;&lt; n
shf.l.clamp.b32  r7,r2,r3,n;
shf.l.clamp.b32  r6,r1,r2,n;
shf.l.clamp.b32  r5,r0,r1,n;
shl.b32          r4,r0,n;

// 128-bit right shift, arithmetic; n &lt; 32
// [r7,r6,r5,r4] = [r3,r2,r1,r0] &gt;&gt; n
shf.r.clamp.b32  r4,r0,r1,n;
shf.r.clamp.b32  r5,r1,r2,n;
shf.r.clamp.b32  r6,r2,r3,n;
shr.s32          r7,r3,n;     // result is sign-extended

shf.r.clamp.b32  r1,r0,r0,n;  // rotate right by n; n &lt; 32
shf.l.clamp.b32  r1,r0,r0,n;  // rotate left by n; n &lt; 32

// extract 32-bits from [r1,r0] starting at position n &lt; 32
shf.r.clamp.b32  r0,r0,r1,n;
</pre>
 <h4>
  <span class="section-number">
   9.7.7.8.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions-shl">
   Logic and Shift Instructions: shl
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions-shl" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  shl
 </p>
 <p>
  Shift bits left, zero-fill on right.
 </p>
 <p>
  Syntax
 </p>
 <pre>shl.type d, a, b;

.type = { .b16, .b32, .b64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Shift
  <span class="pre">
   a
  </span>
  left by the amount specified by unsigned 32-bit value in
  <span class="pre">
   b
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>d = a &lt;&lt; b;
</pre>
 <p>
  Notes
 </p>
 <p>
  Shift amounts greater than the register width
  N
  are clamped to
  N
  .
 </p>
 <p>
  The sizes of the destination and first source operand must match, but not necessarily the type. The
  <span class="pre">
   b
  </span>
  operand must be a 32-bit value, regardless of the instruction type.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Example
 </p>
 <pre>shl.b32  q,a,2;
</pre>
 <h4>
  <span class="section-number">
   9.7.7.9.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions-shr">
   Logic and Shift Instructions: shr
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions-shr" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  shr
 </p>
 <p>
  Shift bits right, sign or zero-fill on left.
 </p>
 <p>
  Syntax
 </p>
 <pre>shr.type d, a, b;

.type = { .b16, .b32, .b64,
          .u16, .u32, .u64,
          .s16, .s32, .s64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Shift
  <span class="pre">
   a
  </span>
  right by the amount specified by unsigned 32-bit value in
  <span class="pre">
   b
  </span>
  . Signed shifts fill with
the sign bit, unsigned and untyped shifts fill with
  <span class="pre">
   0
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>d = a &gt;&gt; b;
</pre>
 <p>
  Notes
 </p>
 <p>
  Shift amounts greater than the register width
  N
  are clamped to
  N
  .
 </p>
 <p>
  The sizes of the destination and first source operand must match, but not necessarily the type. The
  <span class="pre">
   b
  </span>
  operand must be a 32-bit value, regardless of the instruction type.
 </p>
 <p>
  Bit-size types are included for symmetry with
  <span class="pre">
   shl
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Example
 </p>
 <pre>shr.u16  c,a,2;
shr.s32  i,i,1;
shr.b16  k,i,j;
</pre>
 <h3>
  <span class="section-number">
   9.7.8.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions">
   Data Movement and Conversion Instructions
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  These instructions copy data from place to place, and from state space to state space, possibly
converting it from one format to another.
  <span class="pre">
   mov
  </span>
  ,
  <span class="pre">
   ld
  </span>
  ,
  <span class="pre">
   ldu
  </span>
  , and
  <span class="pre">
   st
  </span>
  operate on both
scalar and vector types. The
  <span class="pre">
   isspacep
  </span>
  instruction is provided to query whether a generic address
falls within a particular state space window. The
  <span class="pre">
   cvta
  </span>
  instruction converts addresses between
  <span class="pre">
   generic
  </span>
  and
  <span class="pre">
   const
  </span>
  ,
  <span class="pre">
   global
  </span>
  ,
  <span class="pre">
   local
  </span>
  , or
  <span class="pre">
   shared
  </span>
  state spaces.
 </p>
 <p>
  Instructions
  <span class="pre">
   ld
  </span>
  ,
  <span class="pre">
   st
  </span>
  ,
  <span class="pre">
   suld
  </span>
  , and
  <span class="pre">
   sust
  </span>
  support optional cache operations.
 </p>
 <p>
  The Data Movement and Conversion Instructions are:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     mov
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     shfl.sync
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     prmt
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     ld
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     ldu
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     st
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     st.async
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     multimem.ld_reduce
    </span>
    ,
    <span class="pre">
     multimem.st
    </span>
    ,
    <span class="pre">
     multimem.red
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     prefetch
    </span>
    ,
    <span class="pre">
     prefetchu
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     isspacep
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     cvta
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     cvt
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     cvt.pack
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     cp.async
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     cp.async.commit_group
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     cp.async.wait_group
    </span>
    ,
    <span class="pre">
     cp.async.wait_all
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     cp.async.bulk
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     cp.reduce.async.bulk
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     cp.async.bulk.prefetch
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     cp.async.bulk.tensor
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     cp.reduce.async.bulk.tensor
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     cp.async.bulk.prefetch.tensor
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     cp.async.bulk.commit_group
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     cp.async.bulk.wait_group
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     tensormap.replace
    </span>
   </p>
  </li>
 </ul>
 <h4>
  <span class="section-number">
   9.7.8.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#cache-operators">
   Cache Operators
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#cache-operators" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  PTX ISA version 2.0 introduced optional cache operators on load and store instructions. The cache
operators require a target architecture of
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Cache operators on load or store instructions are treated as performance hints only. The use of a
cache operator on an
  <span class="pre">
   ld
  </span>
  or
  <span class="pre">
   st
  </span>
  instruction does not change the memory consistency behavior of
the program.
 </p>
 <p>
  For
  <span class="pre">
   sm_20
  </span>
  and higher, the cache operators have the following definitions and behavior.
 </p>
 <table class="table-no-stripes docutils align-default" id="id85">
  <span class="caption-number">
   Table 27
  </span>
  <span class="caption-text">
   Cache Operators for Memory Load Instructions
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#id85" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Operator
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .ca
     </span>
    </p>
   </td>
   <td>
    <p>
     Cache at all levels, likely to be accessed again.
    </p>
    <p>
     The default load instruction cache operation is ld.ca, which allocates cache lines in all
levels (L1 and L2) with normal eviction policy. Global data is coherent at the L2 level, but
multiple L1 caches are not coherent for global data. If one thread stores to global memory
via one L1 cache, and a second thread loads that address via a second L1 cache with
     <span class="pre">
      ld.ca
     </span>
     ,
the second thread may get stale L1 cache data, rather than the data stored by the first thread.
The driver must invalidate global L1 cache lines between dependent grids of parallel threads.
Stores by the first grid program are then correctly fetched by the second grid program issuing
default
     <span class="pre">
      ld.ca
     </span>
     loads cached in L1.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .cg
     </span>
    </p>
   </td>
   <td>
    <p>
     Cache at global level (cache in L2 and below, not L1).
    </p>
    <p>
     Use
     <span class="pre">
      ld.cg
     </span>
     to cache loads only globally, bypassing the L1 cache, and cache only in the L2
cache.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .cs
     </span>
    </p>
   </td>
   <td>
    <p>
     Cache streaming, likely to be accessed once.
    </p>
    <p>
     The
     <span class="pre">
      ld.cs
     </span>
     load cached streaming operation allocates global lines with evict-first policy in
L1 and L2 to limit cache pollution by temporary streaming data that may be accessed once or
twice. When
     <span class="pre">
      ld.cs
     </span>
     is applied to a Local window address, it performs the
     <span class="pre">
      ld.lu
     </span>
     operation.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .lu
     </span>
    </p>
   </td>
   <td>
    <p>
     Last use.
    </p>
    <p>
     The compiler/programmer may use
     <span class="pre">
      ld.lu
     </span>
     when restoring spilled registers and popping function
stack frames to avoid needless write-backs of lines that will not be used again. The
     <span class="pre">
      ld.lu
     </span>
     instruction performs a load cached streaming operation (
     <span class="pre">
      ld.cs
     </span>
     ) on global addresses.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .cv
     </span>
    </p>
   </td>
   <td>
    <p>
     Donât cache and fetch again (consider cached system memory lines stale, fetch again).
    </p>
    <p>
     The ld.cv load operation applied to a global System Memory address invalidates (discards) a
matching L2 line and re-fetches the line on each new load.
    </p>
   </td>
  </tr>
 </table>
 <table class="table-no-stripes docutils align-default" id="id86">
  <span class="caption-number">
   Table 28
  </span>
  <span class="caption-text">
   Cache Operators for Memory Store Instructions
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#id86" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Operator
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .wb
     </span>
    </p>
   </td>
   <td>
    <p>
     Cache write-back all coherent levels.
    </p>
    <p>
     The default store instruction cache operation is
     <span class="pre">
      st.wb
     </span>
     , which writes back cache lines of
coherent cache levels with normal eviction policy.
    </p>
    <p>
     If one thread stores to global memory, bypassing its L1 cache, and a second thread in a
different SM later loads from that address via a different L1 cache with
     <span class="pre">
      ld.ca
     </span>
     , the second
thread may get a hit on stale L1 cache data, rather than get the data from L2 or memory stored
by the first thread.
    </p>
    <p>
     The driver must invalidate global L1 cache lines between dependent grids of thread arrays.
Stores by the first grid program are then correctly missed in L1 and fetched by the second grid
program issuing default
     <span class="pre">
      ld.ca
     </span>
     loads.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .cg
     </span>
    </p>
   </td>
   <td>
    <p>
     Cache at global level (cache in L2 and below, not L1).
    </p>
    <p>
     Use
     <span class="pre">
      st.cg
     </span>
     to cache global store data only globally, bypassing the L1 cache, and cache only
in the L2 cache.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .cs
     </span>
    </p>
   </td>
   <td>
    <p>
     Cache streaming, likely to be accessed once.
    </p>
    <p>
     The
     <span class="pre">
      st.cs
     </span>
     store cached-streaming operation allocates cache lines with evict-first policy to
limit cache pollution by streaming output data.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .wt
     </span>
    </p>
   </td>
   <td>
    <p>
     Cache write-through (to system memory).
    </p>
    <p>
     The
     <span class="pre">
      st.wt
     </span>
     store write-through operation applied to a global System Memory address writes
through the L2 cache.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   9.7.8.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#cache-eviction-priority-hints">
   Cache Eviction Priority Hints
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#cache-eviction-priority-hints" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  PTX ISA version 7.4 adds optional cache eviction priority hints on load and store
instructions. Cache eviction priority requires target architecture
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  Cache eviction priority on load or store instructions is treated as a performance hint. It is
supported for
  <span class="pre">
   .global
  </span>
  state space and generic addresses where the address points to
  <span class="pre">
   .global
  </span>
  state space.
 </p>
 <table class="table-no-stripes docutils align-default" id="id87">
  <span class="caption-number">
   Table 29
  </span>
  <span class="caption-text">
   Cache Eviction Priority Hints for Memory Load and Store Instructions
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#id87" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Cache Eviction Priority
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      evict_normal
     </span>
    </p>
   </td>
   <td>
    <p>
     Cache data with normal eviction priority. This is the default eviction priority.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      evict_first
     </span>
    </p>
   </td>
   <td>
    <p>
     Data cached with this priority will be first in the eviction priority order and
will likely be evicted when cache eviction is required. This priority is suitable
for streaming data.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      evict_last
     </span>
    </p>
   </td>
   <td>
    <p>
     Data cached with this priority will be last in the eviction priority order and will
likely be evicted only after other data with
     <span class="pre">
      evict_normal
     </span>
     or
     <span class="pre">
      evict_first
     </span>
     eviction priotity is already evicted. This priority is suitable for data that
should remain persistent in cache.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      evict_unchanged
     </span>
    </p>
   </td>
   <td>
    <p>
     Do not change eviction priority order as part of this operation.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      no_allocate
     </span>
    </p>
   </td>
   <td>
    <p>
     Do not allocate data to cache. This priority is suitable for streaming data.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   9.7.8.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-mov">
   Data Movement and Conversion Instructions: mov
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-mov" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  mov
 </p>
 <p>
  Set a register variable with the value of a register variable or an immediate value. Take the
non-generic address of a variable in global, local, or shared state space.
 </p>
 <p>
  Syntax
 </p>
 <pre>mov.type  d, a;
mov.type  d, sreg;
mov.type  d, avar;       // get address of variable
mov.type  d, avar+imm;   // get address of variable with offset
mov.u32   d, fname;      // get address of device function
mov.u64   d, fname;      // get address of device function
mov.u32   d, kernel;     // get address of entry function
mov.u64   d, kernel;     // get address of entry function

.type = { .pred,
          .b16, .b32, .b64,
          .u16, .u32, .u64,
          .s16, .s32, .s64,
                .f32, .f64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Write register
  <span class="pre">
   d
  </span>
  with the value of
  <span class="pre">
   a
  </span>
  .
 </p>
 <p>
  Operand
  <span class="pre">
   a
  </span>
  may be a register, special register, variable with optional offset in an addressable
memory space, or function name.
 </p>
 <p>
  For variables declared in
  <span class="pre">
   .const
  </span>
  ,
  <span class="pre">
   .global
  </span>
  ,
  <span class="pre">
   .local
  </span>
  , and
  <span class="pre">
   .shared
  </span>
  state spaces,
  <span class="pre">
   mov
  </span>
  places the non-generic address of the variable (i.e., the address of the variable in its state
space) into the destination register. The generic address of a variable in
  <span class="pre">
   const
  </span>
  ,
  <span class="pre">
   global
  </span>
  ,
  <span class="pre">
   local
  </span>
  , or
  <span class="pre">
   shared
  </span>
  state space may be generated by first taking the address within the state
space with
  <span class="pre">
   mov
  </span>
  and then converting it to a generic address using the
  <span class="pre">
   cvta
  </span>
  instruction;
alternately, the generic address of a variable declared in
  <span class="pre">
   const
  </span>
  ,
  <span class="pre">
   global
  </span>
  ,
  <span class="pre">
   local
  </span>
  , or
  <span class="pre">
   shared
  </span>
  state space may be taken directly using the
  <span class="pre">
   cvta
  </span>
  instruction.
 </p>
 <p>
  Note that if the address of a device function parameter is moved to a register, the parameter will
be copied onto the stack and the address will be in the local state space.
 </p>
 <p>
  Semantics
 </p>
 <pre>d = a;
d = sreg;
d = &amp;avar;        // address is non-generic; i.e., within the variable's declared state space
d = &amp;avar+imm;
</pre>
 <p>
  Notes
 </p>
 <ul class="simple">
  <li>
   <p>
    Although only predicate and bit-size types are required, we include the arithmetic types for the
programmerâs convenience: their use enhances program readability and allows additional type
checking.
   </p>
  </li>
  <li>
   <p>
    When moving address of a kernel or a device function, only
    <span class="pre">
     .u32
    </span>
    or
    <span class="pre">
     .u64
    </span>
    instruction types
are allowed. However, if a signed type is used, it is not treated as a compilation error. The
compiler issues a warning in this case.
   </p>
  </li>
 </ul>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Taking the address of kernel entry functions requires PTX ISA version 3.1 or later. Kernel function
addresses should only be used in the context of CUDA Dynamic Parallelism system calls. See the
  CUDA
Dynamic Parallelism Programming Guide
  for details.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   mov.f64
  </span>
  requires
  <span class="pre">
   sm_13
  </span>
  or higher.
 </p>
 <p>
  Taking the address of kernel entry functions requires
  <span class="pre">
   sm_35
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>mov.f32  d,a;
mov.u16  u,v;
mov.f32  k,0.1;
mov.u32  ptr, A;        // move address of A into ptr
mov.u32  ptr, A[5];     // move address of A[5] into ptr
mov.u32  ptr, A+20;     // move address with offset into ptr
mov.u32  addr, myFunc;  // get address of device function 'myFunc'
mov.u64  kptr, main;    // get address of entry function 'main'
</pre>
 <h4>
  <span class="section-number">
   9.7.8.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-mov-2">
   Data Movement and Conversion Instructions: mov
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-mov-2" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  mov
 </p>
 <p>
  Move vector-to-scalar (pack) or scalar-to-vector (unpack).
 </p>
 <p>
  Syntax
 </p>
 <pre>mov.type  d, a;

.type = { .b16, .b32, .b64, .b128 };
</pre>
 <p>
  Description
 </p>
 <p>
  Write scalar register
  <span class="pre">
   d
  </span>
  with the packed value of vector register
  <span class="pre">
   a
  </span>
  , or write vector register
  <span class="pre">
   d
  </span>
  with the unpacked values from scalar register
  <span class="pre">
   a
  </span>
  .
 </p>
 <p>
  When destination operand
  <span class="pre">
   d
  </span>
  is a vector register, the sink symbol
  <span class="pre">
   '_'
  </span>
  may be used for one or
more elements provided that at least one element is a scalar register.
 </p>
 <p>
  For bit-size types,
  <span class="pre">
   mov
  </span>
  may be used to pack vector elements into a scalar register or unpack
sub-fields of a scalar register into a vector. Both the overall size of the vector and the size of
the scalar must match the size of the instruction type.
 </p>
 <p>
  Semantics
 </p>
 <pre>// pack two 8-bit elements into .b16
d = a.x | (a.y &lt;&lt; 8)
// pack four 8-bit elements into .b32
d = a.x | (a.y &lt;&lt; 8)  | (a.z &lt;&lt; 16) | (a.w &lt;&lt; 24)
// pack two 16-bit elements into .b32
d = a.x | (a.y &lt;&lt; 16)
// pack four 16-bit elements into .b64
d = a.x | (a.y &lt;&lt; 16)  | (a.z &lt;&lt; 32) | (a.w &lt;&lt; 48)
// pack two 32-bit elements into .b64
d = a.x | (a.y &lt;&lt; 32)
// pack four 32-bit elements into .b128
d = a.x | (a.y &lt;&lt; 32)  | (a.z &lt;&lt; 64) | (a.w &lt;&lt; 96)
// pack two 64-bit elements into .b128
d = a.x | (a.y &lt;&lt; 64)

// unpack 8-bit elements from .b16
{ d.x, d.y } = { a[0..7], a[8..15] }
// unpack 8-bit elements from .b32
{ d.x, d.y, d.z, d.w }
        { a[0..7], a[8..15], a[16..23], a[24..31] }

// unpack 16-bit elements from .b32
{ d.x, d.y }  = { a[0..15], a[16..31] }
// unpack 16-bit elements from .b64
{ d.x, d.y, d.z, d.w } =
        { a[0..15], a[16..31], a[32..47], a[48..63] }

// unpack 32-bit elements from .b64
{ d.x, d.y } = { a[0..31], a[32..63] }

// unpack 32-bit elements from .b128
{ d.x, d.y, d.z, d.w } =
        { a[0..31], a[32..63], a[64..95], a[96..127] }
// unpack 64-bit elements from .b128
{ d.x, d.y } = { a[0..63], a[64..127] }
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Support for
  <span class="pre">
   .b128
  </span>
  type introduced in PTX ISA version 8.3.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Support for
  <span class="pre">
   .b128
  </span>
  type requires
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>mov.b32 %r1,{a,b};      // a,b have type .u16
mov.b64 {lo,hi}, %x;    // %x is a double; lo,hi are .u32
mov.b32 %r1,{x,y,z,w};  // x,y,z,w have type .b8
mov.b32 {r,g,b,a},%r1;  // r,g,b,a have type .u8
mov.b64 {%r1, _}, %x;   // %x is.b64, %r1 is .b32
mov.b128 {%b1, %b2}, %y;   // %y is.b128, %b1 and % b2 are .b64
mov.b128 %y, {%b1, %b2};   // %y is.b128, %b1 and % b2 are .b64
</pre>
 <h4>
  <span class="section-number">
   9.7.8.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-shfl">
   Data Movement and Conversion Instructions: shfl (deprecated)
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-shfl-deprecated" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  shfl (deprecated)
 </p>
 <p>
  Register data shuffle within threads of a warp.
 </p>
 <p>
  Syntax
 </p>
 <pre>shfl.mode.b32  d[|p], a, b, c;

.mode = { .up, .down, .bfly, .idx };
</pre>
 <p>
  Deprecation Note
 </p>
 <p>
  The
  <span class="pre">
   shfl
  </span>
  instruction without a
  <span class="pre">
   .sync
  </span>
  qualifier is deprecated in PTX ISA version 6.0.
 </p>
 <ul class="simple">
  <li>
   <p>
    Support for this instruction with
    <span class="pre">
     .target
    </span>
    lower than
    <span class="pre">
     sm_70
    </span>
    may be removed in a future PTX ISA version.
   </p>
  </li>
 </ul>
 <p>
  Removal Note
 </p>
 <p>
  Support for
  <span class="pre">
   shfl
  </span>
  instruction without a
  <span class="pre">
   .sync
  </span>
  qualifier is removed in PTX ISA version 6.4 for
  <span class="pre">
   .target
  </span>
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  Description
 </p>
 <p>
  Exchange register data between threads of a warp.
 </p>
 <p>
  Each thread in the currently executing warp will compute a source lane index
  j
  based on input
operands
  <span class="pre">
   b
  </span>
  and
  <span class="pre">
   c
  </span>
  and the
  mode
  . If the computed source lane index
  j
  is in range, the
thread will copy the input operand
  <span class="pre">
   a
  </span>
  from lane
  j
  into its own destination register
  <span class="pre">
   d
  </span>
  ;
otherwise, the thread will simply copy its own input
  <span class="pre">
   a
  </span>
  to destination
  <span class="pre">
   d
  </span>
  . The optional
destination predicate
  <span class="pre">
   p
  </span>
  is set to
  <span class="pre">
   True
  </span>
  if the computed source lane is in range, and
otherwise set to
  <span class="pre">
   False
  </span>
  .
 </p>
 <p>
  Note that an out of range value of
  <span class="pre">
   b
  </span>
  may still result in a valid computed source lane index
  j
  . In this case, a data transfer occurs and the destination predicate
  <span class="pre">
   p
  </span>
  is True.
 </p>
 <p>
  Note that results are undefined in divergent control flow within a warp, if an active thread sources
a register from an inactive thread.
 </p>
 <p>
  Operand
  <span class="pre">
   b
  </span>
  specifies a source lane or source lane offset, depending on the mode.
 </p>
 <p>
  Operand
  <span class="pre">
   c
  </span>
  contains two packed values specifying a mask for logically splitting warps into
sub-segments and an upper bound for clamping the source lane index.
 </p>
 <p>
  Semantics
 </p>
 <pre>lane[4:0]  = [Thread].laneid;  // position of thread in warp
bval[4:0] = b[4:0];            // source lane or lane offset (0..31)
cval[4:0] = c[4:0];            // clamp value
mask[4:0] = c[12:8];

// get value of source register a if thread is active and
// guard predicate true, else unpredictable
if (isActive(Thread) &amp;&amp; isGuardPredicateTrue(Thread)) {
    SourceA[lane] = a;
} else {
    // Value of SourceA[lane] is unpredictable for
    // inactive/predicated-off threads in warp
}
maxLane = (lane[4:0] &amp; mask[4:0]) | (cval[4:0] &amp; ~mask[4:0]);
minLane = (lane[4:0] &amp; mask[4:0]);

switch (.mode) {
    case .up:    j = lane - bval; pval = (j &gt;= maxLane); break;
    case .down:  j = lane + bval; pval = (j &lt;= maxLane); break;
    case .bfly:  j = lane ^ bval; pval = (j &lt;= maxLane); break;
    case .idx:   j = minLane  | (bval[4:0] &amp; ~mask[4:0]);
                                 pval = (j &lt;= maxLane); break;
}
if (!pval) j = lane;  // copy from own lane
d = SourceA[j];       // copy input a from lane j
if (dest predicate selected)
    p = pval;
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 3.0.
 </p>
 <p>
  Deprecated in PTX ISA version 6.0 in favor of
  <span class="pre">
   shfl.sync
  </span>
  .
 </p>
 <p>
  Not supported in PTX ISA version 6.4 for .target
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   shfl
  </span>
  requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   shfl
  </span>
  is not supported on
  <span class="pre">
   sm_70
  </span>
  or higher starting PTX ISA version 6.4.
 </p>
 <p>
  Examples
 </p>
 <pre>    // Warp-level INCLUSIVE PLUS SCAN:
    //
    // Assumes input in following registers:
    //     - Rx  = sequence value for this thread
    //
    shfl.up.b32  Ry|p, Rx, 0x1,  0x0;
@p  add.f32      Rx, Ry, Rx;
    shfl.up.b32  Ry|p, Rx, 0x2,  0x0;
@p  add.f32      Rx, Ry, Rx;
    shfl.up.b32  Ry|p, Rx, 0x4,  0x0;
@p  add.f32      Rx, Ry, Rx;
    shfl.up.b32  Ry|p, Rx, 0x8,  0x0;
@p  add.f32      Rx, Ry, Rx;
    shfl.up.b32  Ry|p, Rx, 0x10, 0x0;
@p  add.f32      Rx, Ry, Rx;


    // Warp-level INCLUSIVE PLUS REVERSE-SCAN:
    //
    // Assumes input in following registers:
    //     - Rx  = sequence value for this thread
    //
    shfl.down.b32  Ry|p, Rx, 0x1,  0x1f;
@p  add.f32        Rx, Ry, Rx;
    shfl.down.b32  Ry|p, Rx, 0x2,  0x1f;
@p  add.f32        Rx, Ry, Rx;
    shfl.down.b32  Ry|p, Rx, 0x4,  0x1f;
@p  add.f32        Rx, Ry, Rx;
    shfl.down.b32  Ry|p, Rx, 0x8,  0x1f;
@p  add.f32        Rx, Ry, Rx;
    shfl.down.b32  Ry|p, Rx, 0x10, 0x1f;
@p  add.f32        Rx, Ry, Rx;


    // BUTTERFLY REDUCTION:
    //
    // Assumes input in following registers:
    //     - Rx  = sequence value for this thread
    //
    shfl.bfly.b32  Ry, Rx, 0x10, 0x1f;   // no predicate dest
    add.f32        Rx, Ry, Rx;
    shfl.bfly.b32  Ry, Rx, 0x8,  0x1f;
    add.f32        Rx, Ry, Rx;
    shfl.bfly.b32  Ry, Rx, 0x4,  0x1f;
    add.f32        Rx, Ry, Rx;
    shfl.bfly.b32  Ry, Rx, 0x2,  0x1f;
    add.f32        Rx, Ry, Rx;
    shfl.bfly.b32  Ry, Rx, 0x1,  0x1f;
    add.f32        Rx, Ry, Rx;
    //
    // All threads now hold sum in Rx
</pre>
 <h4>
  <span class="section-number">
   9.7.8.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-shfl-sync">
   Data Movement and Conversion Instructions: shfl.sync
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-shfl-sync" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  shfl.sync
 </p>
 <p>
  Register data shuffle within threads of a warp.
 </p>
 <p>
  Syntax
 </p>
 <pre>shfl.sync.mode.b32  d[|p], a, b, c, membermask;

.mode = { .up, .down, .bfly, .idx };
</pre>
 <p>
  Description
 </p>
 <p>
  Exchange register data between threads of a warp.
 </p>
 <p>
  <span class="pre">
   shfl.sync
  </span>
  will cause executing thread to wait until all non-exited threads corresponding to
  <span class="pre">
   membermask
  </span>
  have executed
  <span class="pre">
   shfl.sync
  </span>
  with the same qualifiers and same
  <span class="pre">
   membermask
  </span>
  value
before resuming execution.
 </p>
 <p>
  Operand
  <span class="pre">
   membermask
  </span>
  specifies a 32-bit integer which is a mask indicating threads participating
in barrier where the bit position corresponds to threadâs
  <span class="pre">
   laneid
  </span>
  .
 </p>
 <p>
  <span class="pre">
   shfl.sync
  </span>
  exchanges register data between threads in
  <span class="pre">
   membermask
  </span>
  .
 </p>
 <p>
  Each thread in the currently executing warp will compute a source lane index
  j
  based on input
operands
  <span class="pre">
   b
  </span>
  and
  <span class="pre">
   c
  </span>
  and the
  mode
  . If the computed source lane index
  j
  is in range, the
thread will copy the input operand
  <span class="pre">
   a
  </span>
  from lane
  j
  into its own destination register
  <span class="pre">
   d
  </span>
  ;
otherwise, the thread will simply copy its own input
  <span class="pre">
   a
  </span>
  to destination
  <span class="pre">
   d
  </span>
  . The optional
destination predicate
  <span class="pre">
   p
  </span>
  is set to
  <span class="pre">
   True
  </span>
  if the computed source lane is in range, and
otherwise set to
  <span class="pre">
   False
  </span>
  .
 </p>
 <p>
  Note that an out of range value of
  <span class="pre">
   b
  </span>
  may still result in a valid computed source lane index
  j
  . In this case, a data transfer occurs and the destination predicate
  <span class="pre">
   p
  </span>
  is True.
 </p>
 <p>
  Note that results are undefined if a thread sources a register from an inactive thread or a thread
that is not in
  <span class="pre">
   membermask
  </span>
  .
 </p>
 <p>
  Operand
  <span class="pre">
   b
  </span>
  specifies a source lane or source lane offset, depending on the mode.
 </p>
 <p>
  Operand
  <span class="pre">
   c
  </span>
  contains two packed values specifying a mask for logically splitting warps into
sub-segments and an upper bound for clamping the source lane index.
 </p>
 <p>
  The behavior of
  <span class="pre">
   shfl.sync
  </span>
  is undefined if the executing thread is not in the
  <span class="pre">
   membermask
  </span>
  .
 </p>
 <p class="admonition-title">
  Note
 </p>
 <p>
  For .target
  <span class="pre">
   sm_6x
  </span>
  or below, all threads in
  <span class="pre">
   membermask
  </span>
  must execute the same
  <span class="pre">
   shfl.sync
  </span>
  instruction in convergence, and only threads belonging to some
  <span class="pre">
   membermask
  </span>
  can be active when
the
  <span class="pre">
   shfl.sync
  </span>
  instruction is executed. Otherwise, the behavior is undefined.
 </p>
 <p>
  Semantics
 </p>
 <pre>// wait for all threads in membermask to arrive
wait_for_specified_threads(membermask);

lane[4:0]  = [Thread].laneid;  // position of thread in warp
bval[4:0] = b[4:0];            // source lane or lane offset (0..31)
cval[4:0] = c[4:0];            // clamp value
segmask[4:0] = c[12:8];

// get value of source register a if thread is active and
// guard predicate true, else unpredictable
if (isActive(Thread) &amp;&amp; isGuardPredicateTrue(Thread)) {
    SourceA[lane] = a;
} else {
    // Value of SourceA[lane] is unpredictable for
    // inactive/predicated-off threads in warp
}
maxLane = (lane[4:0] &amp; segmask[4:0]) | (cval[4:0] &amp; ~segmask[4:0]);
minLane = (lane[4:0] &amp; segmask[4:0]);

switch (.mode) {
    case .up:    j = lane - bval; pval = (j &gt;= maxLane); break;
    case .down:  j = lane + bval; pval = (j &lt;= maxLane); break;
    case .bfly:  j = lane ^ bval; pval = (j &lt;= maxLane); break;
    case .idx:   j = minLane  | (bval[4:0] &amp; ~segmask[4:0]);
                                 pval = (j &lt;= maxLane); break;
}
if (!pval) j = lane;  // copy from own lane
d = SourceA[j];       // copy input a from lane j
if (dest predicate selected)
    p = pval;
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 6.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>shfl.sync.up.b32  Ry|p, Rx, 0x1,  0x0, 0xffffffff;
</pre>
 <h4>
  <span class="section-number">
   9.7.8.7.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-prmt">
   Data Movement and Conversion Instructions: prmt
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-prmt" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  prmt
 </p>
 <p>
  Permute bytes from register pair.
 </p>
 <p>
  Syntax
 </p>
 <pre>prmt.b32{.mode}  d, a, b, c;

.mode = { .f4e, .b4e, .rc8, .ecl, .ecr, .rc16 };
</pre>
 <p>
  Description
 </p>
 <p>
  Pick four arbitrary bytes from two 32-bit registers, and reassemble them into a 32-bit destination
register.
 </p>
 <p>
  In the generic form (no mode specified), the permute control consists of four 4-bit selection
values. The bytes in the two source registers are numbered from 0 to 7:
  <span class="pre">
   {b,
  </span>
  <span class="pre">
   a}
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   {{b7,
  </span>
  <span class="pre">
   b6,
  </span>
  <span class="pre">
   b5,
  </span>
  <span class="pre">
   b4},
  </span>
  <span class="pre">
   {b3,
  </span>
  <span class="pre">
   b2,
  </span>
  <span class="pre">
   b1,
  </span>
  <span class="pre">
   b0}}
  </span>
  . For each byte in the target register, a 4-bit selection value is defined.
 </p>
 <p>
  The 3 lsbs of the selection value specify which of the 8 source bytes should be moved into the
target position. The msb defines if the byte value should be copied, or if the sign (msb of the
byte) should be replicated over all 8 bits of the target position (sign extend of the byte value);
  <span class="pre">
   msb=0
  </span>
  means copy the literal value;
  <span class="pre">
   msb=1
  </span>
  means replicate the sign. Note that the sign
extension is only performed as part of generic form.
 </p>
 <p>
  Thus, the four 4-bit values fully specify an arbitrary byte permute, as a
  <span class="pre">
   16b
  </span>
  permute code.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     default mode
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      d.b3
     </span>
    </p>
    <p>
     source select
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      d.b2
     </span>
    </p>
    <p>
     source select
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      d.b1
     </span>
    </p>
    <p>
     source select
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      d.b0
     </span>
    </p>
    <p>
     source select
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     index
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      c[15:12]
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      c[11:8]
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      c[7:4]
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      c[3:0]
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The more specialized form of the permute control uses the two lsbâs of operand
  <span class="pre">
   c
  </span>
  (which is
typically an address pointer) to control the byte extraction.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     mode
    </p>
   </th>
   <th class="head">
    <p>
     selector
    </p>
    <p>
     <span class="pre">
      c[1:0]
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      d.b3
     </span>
    </p>
    <p>
     source
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      d.b2
     </span>
    </p>
    <p>
     source
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      d.b1
     </span>
    </p>
    <p>
     source
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      d.b0
     </span>
    </p>
    <p>
     source
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      f4e
     </span>
     (forward 4 extract)
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     3
    </p>
   </td>
   <td>
    <p>
     2
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     4
    </p>
   </td>
   <td>
    <p>
     3
    </p>
   </td>
   <td>
    <p>
     2
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     2
    </p>
   </td>
   <td>
    <p>
     5
    </p>
   </td>
   <td>
    <p>
     4
    </p>
   </td>
   <td>
    <p>
     3
    </p>
   </td>
   <td>
    <p>
     2
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     3
    </p>
   </td>
   <td>
    <p>
     6
    </p>
   </td>
   <td>
    <p>
     5
    </p>
   </td>
   <td>
    <p>
     4
    </p>
   </td>
   <td>
    <p>
     3
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      b4e
     </span>
     (backward 4 extract)
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     5
    </p>
   </td>
   <td>
    <p>
     6
    </p>
   </td>
   <td>
    <p>
     7
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     6
    </p>
   </td>
   <td>
    <p>
     7
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     2
    </p>
   </td>
   <td>
    <p>
     7
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     2
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     3
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     2
    </p>
   </td>
   <td>
    <p>
     3
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      rc8
     </span>
     (replicate 8)
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     2
    </p>
   </td>
   <td>
    <p>
     2
    </p>
   </td>
   <td>
    <p>
     2
    </p>
   </td>
   <td>
    <p>
     2
    </p>
   </td>
   <td>
    <p>
     2
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     3
    </p>
   </td>
   <td>
    <p>
     3
    </p>
   </td>
   <td>
    <p>
     3
    </p>
   </td>
   <td>
    <p>
     3
    </p>
   </td>
   <td>
    <p>
     3
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ecl
     </span>
     (edge clamp left)
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     3
    </p>
   </td>
   <td>
    <p>
     2
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     3
    </p>
   </td>
   <td>
    <p>
     2
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     2
    </p>
   </td>
   <td>
    <p>
     3
    </p>
   </td>
   <td>
    <p>
     2
    </p>
   </td>
   <td>
    <p>
     2
    </p>
   </td>
   <td>
    <p>
     2
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     3
    </p>
   </td>
   <td>
    <p>
     3
    </p>
   </td>
   <td>
    <p>
     3
    </p>
   </td>
   <td>
    <p>
     3
    </p>
   </td>
   <td>
    <p>
     3
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ecr
     </span>
     (edge clamp right)
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     2
    </p>
   </td>
   <td>
    <p>
     2
    </p>
   </td>
   <td>
    <p>
     2
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     3
    </p>
   </td>
   <td>
    <p>
     3
    </p>
   </td>
   <td>
    <p>
     2
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      rc16
     </span>
     (replicate 16)
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     3
    </p>
   </td>
   <td>
    <p>
     2
    </p>
   </td>
   <td>
    <p>
     3
    </p>
   </td>
   <td>
    <p>
     2
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     2
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     3
    </p>
   </td>
   <td>
    <p>
     3
    </p>
   </td>
   <td>
    <p>
     2
    </p>
   </td>
   <td>
    <p>
     3
    </p>
   </td>
   <td>
    <p>
     2
    </p>
   </td>
  </tr>
 </table>
 <p>
  Semantics
 </p>
 <pre>tmp64 = (b&lt;&lt;32) | a;  // create 8 byte source

if ( ! mode ) {
   ctl[0] = (c &gt;&gt;  0) &amp; 0xf;
   ctl[1] = (c &gt;&gt;  4) &amp; 0xf;
   ctl[2] = (c &gt;&gt;  8) &amp; 0xf;
   ctl[3] = (c &gt;&gt; 12) &amp; 0xf;
} else {
   ctl[0] = ctl[1] = ctl[2] = ctl[3] = (c &gt;&gt;  0) &amp; 0x3;
}

tmp[07:00] = ReadByte( mode, ctl[0], tmp64 );
tmp[15:08] = ReadByte( mode, ctl[1], tmp64 );
tmp[23:16] = ReadByte( mode, ctl[2], tmp64 );
tmp[31:24] = ReadByte( mode, ctl[3], tmp64 );
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   prmt
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>prmt.b32      r1, r2, r3, r4;
prmt.b32.f4e  r1, r2, r3, r4;
</pre>
 <h4>
  <span class="section-number">
   9.7.8.8.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-ld">
   Data Movement and Conversion Instructions: ld
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-ld" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  ld
 </p>
 <p>
  Load a register variable from an addressable state space variable.
 </p>
 <p>
  Syntax
 </p>
 <pre>ld{.weak}{.ss}{.cop}{.level::cache_hint}{.level::prefetch_size}{.vec}.type  d, [a]{.unified}{, cache-policy};

ld{.weak}{.ss}{.level::eviction_priority}{.level::cache_hint}{.level::prefetch_size}{.vec}.type  d, [a]{.unified}{, cache-policy};

ld.volatile{.ss}{.level::prefetch_size}{.vec}.type  d, [a];

ld.relaxed.scope{.ss}{.level::eviction_priority}{.level::cache_hint}{.level::prefetch_size}{.vec}.type  d, [a]{, cache-policy};

ld.acquire.scope{.ss}{.level::eviction_priority}{.level::cache_hint}{.level::prefetch_size}{.vec}.type  d, [a]{, cache-policy};

ld.mmio.relaxed.sys{.global}.type  d, [a];

.ss =                       { .const, .global, .local, .param{::entry, ::func}, .shared{::cta, ::cluster} };
.cop =                      { .ca, .cg, .cs, .lu, .cv };
.level::eviction_priority = { .L1::evict_normal, .L1::evict_unchanged,
                              .L1::evict_first, .L1::evict_last, .L1::no_allocate };
.level::cache_hint =        { .L2::cache_hint };
.level::prefetch_size =     { .L2::64B, .L2::128B, .L2::256B }
.scope =                    { .cta, .cluster, .gpu, .sys };
.vec =                      { .v2, .v4 };
.type =                     { .b8, .b16, .b32, .b64, .b128,
                              .u8, .u16, .u32, .u64,
                              .s8, .s16, .s32, .s64,
                              .f32, .f64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Load register variable
  <span class="pre">
   d
  </span>
  from the location specified by the source address operand
  <span class="pre">
   a
  </span>
  in
specified state space. If no state space is given, perform the load using
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#generic-addressing">
   Generic Addressing
  </a>
  .
 </p>
 <p>
  If no sub-qualifier is specified with
  <span class="pre">
   .shared
  </span>
  state space, then
  <span class="pre">
   ::cta
  </span>
  is assumed by default.
 </p>
 <p>
  Supported addressing modes for operand
  <span class="pre">
   a
  </span>
  and alignment requirements are described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#addresses-as-operands">
   Addresses
as Operands
  </a>
 </p>
 <p>
  If no sub-qualifier is specified with
  <span class="pre">
   .param
  </span>
  state space, thenâ¯:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     ::func
    </span>
    is assumed when access is inside a device function.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     ::entry
    </span>
    is assumed when accessing kernel function parameters from entry function. Otherwise, when
accessing device function parameters or any other
    <span class="pre">
     .param
    </span>
    variables from entry function
    <span class="pre">
     ::func
    </span>
    is assumed by default.
   </p>
  </li>
 </ul>
 <p>
  For
  <span class="pre">
   ld.param::entry
  </span>
  instruction, operand a must be a kernel parameter address, otherwise behavior
is undefined. For
  <span class="pre">
   ld.param::func
  </span>
  instruction, operand a must be a device function parameter address,
otherwise behavior is undefined.
 </p>
 <p>
  Instruction
  <span class="pre">
   ld.param{::func}
  </span>
  used for reading value returned from device function call cannot be
predicated. See
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parameter-state-space">
   Parameter State Space
  </a>
  and
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#function-declarations-and-definitions">
   Function Declarations and Definitions
  </a>
  for descriptions
of the proper use of
  <span class="pre">
   ld.param
  </span>
  .
 </p>
 <p>
  The
  <span class="pre">
   .relaxed
  </span>
  and
  <span class="pre">
   .acquire
  </span>
  qualifiers indicate memory synchronization as described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory Consistency Model
  </a>
  . The
  <span class="pre">
   .scope
  </span>
  qualifier
indicates the set of threads with which an
  <span class="pre">
   ld.relaxed
  </span>
  or
  <span class="pre">
   ld.acquire
  </span>
  instruction can directly
synchronize
  1
  . The
  <span class="pre">
   .weak
  </span>
  qualifier indicates a memory instruction with no synchronization.
The effects of this instruction become visible to other threads only when synchronization is established
by other means.
 </p>
 <p>
  The semantic details of
  <span class="pre">
   .mmio
  </span>
  qualifier are described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory Consistency Model
  </a>
  . Only
  <span class="pre">
   .sys
  </span>
  thread scope is valid for
  <span class="pre">
   ld.mmio
  </span>
  operation. The
qualifiers
  <span class="pre">
   .mmio
  </span>
  and
  <span class="pre">
   .relaxed
  </span>
  must be specified together.
 </p>
 <p>
  The
  <span class="pre">
   .weak
  </span>
  ,
  <span class="pre">
   .volatile
  </span>
  ,
  <span class="pre">
   .relaxed
  </span>
  and
  <span class="pre">
   .acquire
  </span>
  qualifiers are mutually exclusive. When
none of these is specified, the
  <span class="pre">
   .weak
  </span>
  qualifier is assumed by default.
 </p>
 <p>
  An
  <span class="pre">
   ld.volatile
  </span>
  operation is always performed and it will not be reordered with respect to other
  <span class="pre">
   volatile
  </span>
  operations to the same memory location.
  <span class="pre">
   volatile
  </span>
  and non-volatile load operations
to the same memory location may be reordered.
  <span class="pre">
   ld.volatile
  </span>
  has the same memory synchronization
semantics as
  <span class="pre">
   ld.relaxed.sys
  </span>
  .
 </p>
 <p>
  The qualifiers
  <span class="pre">
   .volatile
  </span>
  ,
  <span class="pre">
   .relaxed
  </span>
  and
  <span class="pre">
   .acquire
  </span>
  may be used only with
  <span class="pre">
   .global
  </span>
  and
  <span class="pre">
   .shared
  </span>
  spaces and with generic addressing, where the address points to
  <span class="pre">
   .global
  </span>
  or
  <span class="pre">
   .shared
  </span>
  space. Cache operations are not permitted with these qualifiers. The qualifier
  <span class="pre">
   .mmio
  </span>
  may be used only with
  <span class="pre">
   .global
  </span>
  space and with generic addressing, where the address points to
  <span class="pre">
   .global
  </span>
  space.
 </p>
 <p>
  The optional qualifier
  <span class="pre">
   .unified
  </span>
  must be specified on operand
  <span class="pre">
   a
  </span>
  if
  <span class="pre">
   a
  </span>
  is the address of a
variable declared with
  <span class="pre">
   .unified
  </span>
  attribute as described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#variable-and-function-attribute-directive-attribute">
   Variable and Function Attribute
Directive: .attribute
  </a>
  .
 </p>
 <p>
  The qualifier
  <span class="pre">
   .level::eviction_priority
  </span>
  specifies the eviction policy that will be used during
memory access.
 </p>
 <p>
  The
  <span class="pre">
   .level::prefetch_size
  </span>
  qualifier is a hint to fetch additional data of the specified size
into the respective cache level.The sub-qualifier
  <span class="pre">
   prefetch_size
  </span>
  can be set to either of
  <span class="pre">
   64B
  </span>
  ,
  <span class="pre">
   128B
  </span>
  ,
  <span class="pre">
   256B
  </span>
  thereby allowing the prefetch size to be 64 Bytes, 128 Bytes or 256 Bytes
respectively.
 </p>
 <p>
  The qualifier
  <span class="pre">
   .level::prefetch_size
  </span>
  may only be used with
  <span class="pre">
   .global
  </span>
  state space and with
generic addressing where the address points to
  <span class="pre">
   .global
  </span>
  state space. If the generic address does
not fall within the address window of the global memory, then the prefetching behavior is undefined.
 </p>
 <p>
  The
  <span class="pre">
   .level::prefetch_size
  </span>
  qualifier is treated as a performance hint only.
 </p>
 <p>
  When the optional argument
  <span class="pre">
   cache-policy
  </span>
  is specified, the qualifier
  <span class="pre">
   .level::cache_hint
  </span>
  is
required. The 64-bit operand
  <span class="pre">
   cache-policy
  </span>
  specifies the cache eviction policy that may be used
during the memory access.
 </p>
 <p>
  The qualifiers
  <span class="pre">
   .unified
  </span>
  and
  <span class="pre">
   .level::cache_hint
  </span>
  are only supported for
  <span class="pre">
   .global
  </span>
  state
space and for generic addressing where the address points to the
  <span class="pre">
   .global
  </span>
  state space.
 </p>
 <p>
  <span class="pre">
   cache-policy
  </span>
  is a hint to the cache subsystem and may not always be respected. It is treated as
a performance hint only, and does not change the memory consistency behavior of the program.
 </p>
 <p>
  1
  This synchronization is further extended to other threads through the transitive nature of
  causality order
  , as described in the memory consistency model.
 </p>
 <p>
  Semantics
 </p>
 <pre>d = a;             // named variable a
d = *(&amp;a+immOff)   // variable-plus-offset
d = *a;            // register
d = *(a+immOff);   // register-plus-offset
d = *(immAddr);    // immediate address
</pre>
 <p>
  Notes
 </p>
 <p>
  Destination
  <span class="pre">
   d
  </span>
  must be in the
  <span class="pre">
   .reg
  </span>
  state space.
 </p>
 <p>
  A destination register wider than the specified type may be used. The value loaded is sign-extended
to the destination register width for signed integers, and is zero-extended to the destination
register width for unsigned and bit-size types. See
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#operand-size-exceeding-instruction-type-size-relaxed-type-checking-rules-destination-operands">
   <span class="std std-numref">
    Table 25
   </span>
  </a>
  for a description of these relaxed type-checking rules.
 </p>
 <p>
  <span class="pre">
   .f16
  </span>
  data may be loaded using
  <span class="pre">
   ld.b16
  </span>
  , and then converted to
  <span class="pre">
   .f32
  </span>
  or
  <span class="pre">
   .f64
  </span>
  using
  <span class="pre">
   cvt
  </span>
  or can be used in half precision floating point instructions.
 </p>
 <p>
  <span class="pre">
   .f16x2
  </span>
  data may be loaded using
  <span class="pre">
   ld.b32
  </span>
  and then used in half precision floating point
instructions.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  ld introduced in PTX ISA version 1.0.
  <span class="pre">
   ld.volatile
  </span>
  introduced in PTX ISA version 1.1.
 </p>
 <p>
  Generic addressing and cache operations introduced in PTX ISA version 2.0.
 </p>
 <p>
  Support for scope qualifier,
  <span class="pre">
   .relaxed
  </span>
  ,
  <span class="pre">
   .acquire
  </span>
  ,
  <span class="pre">
   .weak
  </span>
  qualifiers introduced in PTX ISA
version 6.0.
 </p>
 <p>
  Support for generic addressing of .const space added in PTX ISA version 3.1.
 </p>
 <p>
  Support for
  <span class="pre">
   .level::eviction_priority
  </span>
  ,
  <span class="pre">
   .level::prefetch_size
  </span>
  and
  <span class="pre">
   .level::cache_hint
  </span>
  qualifiers introduced in PTX ISA version 7.4.
 </p>
 <p>
  Support for
  <span class="pre">
   .cluster
  </span>
  scope qualifier introduced in PTX ISA version 7.8.
 </p>
 <p>
  Support for
  <span class="pre">
   ::cta
  </span>
  and
  <span class="pre">
   ::cluster
  </span>
  sub-qualifiers introduced in PTX ISA version 7.8.
 </p>
 <p>
  Support for
  <span class="pre">
   .unified
  </span>
  qualifier introduced in PTX ISA version 8.0.
 </p>
 <p>
  Support for
  <span class="pre">
   .mmio
  </span>
  qualifier introduced in PTX ISA version 8.2.
 </p>
 <p>
  Support for
  <span class="pre">
   ::entry
  </span>
  and
  <span class="pre">
   ::func
  </span>
  sub-qualifiers on
  <span class="pre">
   .param
  </span>
  space introduced in PTX ISA
version 8.3.
 </p>
 <p>
  Support for
  <span class="pre">
   .b128
  </span>
  type introduced in PTX ISA version 8.3.
 </p>
 <p>
  Support for
  <span class="pre">
   .sys
  </span>
  scope with
  <span class="pre">
   .b128
  </span>
  type introduced in PTX ISA version 8.4.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   ld.f64
  </span>
  requires
  <span class="pre">
   sm_13
  </span>
  or higher.
 </p>
 <p>
  Support for scope qualifier,
  <span class="pre">
   .relaxed
  </span>
  ,
  <span class="pre">
   .acquire
  </span>
  ,
  <span class="pre">
   .weak
  </span>
  qualifiers require
  <span class="pre">
   sm_70
  </span>
  or
higher.
 </p>
 <p>
  Generic addressing requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Cache operations require
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Support for
  <span class="pre">
   .level::eviction_priority
  </span>
  qualifier requires
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  Support for
  <span class="pre">
   .level::prefetch_size
  </span>
  qualifier requires
  <span class="pre">
   sm_75
  </span>
  or higher.
 </p>
 <p>
  Support for
  <span class="pre">
   .L2::256B
  </span>
  and
  <span class="pre">
   .L2::cache_hint
  </span>
  qualifiers requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  Support for
  <span class="pre">
   .cluster
  </span>
  scope qualifier requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Sub-qualifier
  <span class="pre">
   ::cta
  </span>
  requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Sub-qualifier
  <span class="pre">
   ::cluster
  </span>
  requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Support for
  <span class="pre">
   .unified
  </span>
  qualifier requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Support for
  <span class="pre">
   .mmio
  </span>
  qualifier requires
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  Support for
  <span class="pre">
   .b128
  </span>
  type requires
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>ld.global.f32    d,[a];
ld.shared.v4.b32 Q,[p];
ld.const.s32     d,[p+4];
ld.local.b32     x,[p+-8]; // negative offset
ld.local.b64     x,[240];  // immediate address

ld.global.b16    %r,[fs];  // load .f16 data into 32-bit reg
cvt.f32.f16      %r,%r;    // up-convert f16 data to f32

ld.global.b32    %r0, [fs];     // load .f16x2 data in 32-bit reg
ld.global.b32    %r1, [fs + 4]; // load .f16x2 data in 32-bit reg
add.rn.f16x2     %d0, %r0, %r1; // addition of f16x2 data
ld.global.relaxed.gpu.u32 %r0, [gbl];
ld.shared.acquire.gpu.u32 %r1, [sh];
ld.global.relaxed.cluster.u32 %r2, [gbl];
ld.shared::cta.acquire.gpu.u32 %r2, [sh + 4];
ld.shared::cluster.u32 %r3, [sh + 8];
ld.global.mmio.relaxed.sys.u32 %r3, [gbl];

ld.global.f32    d,[ugbl].unified;
ld.b32           %r0, [%r1].unified;

ld.global.L1::evict_last.u32  d, [p];

ld.global.L2::64B.b32   %r0, [gbl]; // Prefetch 64B to L2
ld.L2::128B.f64         %r1, [gbl]; // Prefetch 128B to L2
ld.global.L2::256B.f64  %r2, [gbl]; // Prefetch 256B to L2

createpolicy.fractional.L2::evict_last.L2::evict_unchanged.b64 cache-policy, 1;
ld.global.L2::cache_hint.b64  x, [p], cache-policy;
ld.param::entry.b32 %rp1, [kparam1];

ld.global.b128   %r0, [gbl];   // 128-bit load
</pre>
 <h4>
  <span class="section-number">
   9.7.8.9.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-ld-global-nc">
   Data Movement and Conversion Instructions: ld.global.nc
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-ld-global-nc" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  ld.global.nc
 </p>
 <p>
  Load a register variable from global state space via non-coherent cache.
 </p>
 <p>
  Syntax
 </p>
 <pre>ld.global{.cop}.nc{.level::cache_hint}{.level::prefetch_size}.type                 d, [a]{, cache-policy};
ld.global{.cop}.nc{.level::cache_hint}{.level::prefetch_size}.vec.type             d, [a]{, cache-policy};

ld.global.nc{.level::eviction_priority}{.level::cache_hint}{.level::prefetch_size}.type      d, [a]{, cache-policy};
ld.global.nc{.level::eviction_priority}{.level::cache_hint}{.level::prefetch_size}.vec.type  d, [a]{, cache-policy};

.cop  =                     { .ca, .cg, .cs };     // cache operation
.level::eviction_priority = { .L1::evict_normal, .L1::evict_unchanged,
                              .L1::evict_first, .L1::evict_last, .L1::no_allocate};
.level::cache_hint =        { .L2::cache_hint };
.level::prefetch_size =     { .L2::64B, .L2::128B, .L2::256B }
.vec  =                     { .v2, .v4 };
.type =                     { .b8, .b16, .b32, .b64, .b128,
                              .u8, .u16, .u32, .u64,
                              .s8, .s16, .s32, .s64,
                              .f32, .f64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Load register variable
  <span class="pre">
   d
  </span>
  from the location specified by the source address operand
  <span class="pre">
   a
  </span>
  in the
global state space, and optionally cache in non-coherent read-only cache.
 </p>
 <p class="admonition-title">
  Note
 </p>
 <p>
  On some architectures, the texture cache is larger, has higher bandwidth, and longer latency than
the global memory cache. For applications with sufficient parallelism to cover the longer
latency,
  <span class="pre">
   ld.global.nc
  </span>
  should offer better performance than
  <span class="pre">
   ld.global
  </span>
  on such
architectures.
 </p>
 <p>
  The address operand
  <span class="pre">
   a
  </span>
  may contain a
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#generic-addressing">
   generic address
  </a>
  pointing to the
  <span class="pre">
   .global
  </span>
  state space. Supported addressing modes for operand
  <span class="pre">
   a
  </span>
  and alignment requirements are
described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#addresses-as-operands">
   Addresses as Operands
  </a>
 </p>
 <p>
  The qualifier
  <span class="pre">
   .level::eviction_priority
  </span>
  specifies the eviction policy that will be used during
memory access.
 </p>
 <p>
  The
  <span class="pre">
   .level::prefetch_size
  </span>
  qualifier is a hint to fetch additional data of the specified size
into the respective cache level.The sub-qualifier
  <span class="pre">
   prefetch_size
  </span>
  can be set to either of
  <span class="pre">
   64B
  </span>
  ,
  <span class="pre">
   128B
  </span>
  ,
  <span class="pre">
   256B
  </span>
  thereby allowing the prefetch size to be 64 Bytes, 128 Bytes or 256 Bytes
respectively.
 </p>
 <p>
  The
  <span class="pre">
   .level::prefetch_size
  </span>
  qualifier is treated as a performance hint only.
 </p>
 <p>
  When the optional argument
  <span class="pre">
   cache-policy
  </span>
  is specified, the qualifier
  <span class="pre">
   .level::cache_hint
  </span>
  is
required. The 64-bit operand
  <span class="pre">
   cache-policy
  </span>
  specifies the cache eviction policy that may be used
during the memory access.
 </p>
 <p>
  <span class="pre">
   cache-policy
  </span>
  is a hint to the cache subsystem and may not always be respected. It is treated as
a performance hint only, and does not change the memory consistency behavior of the program.
 </p>
 <p>
  Semantics
 </p>
 <pre>d = a;             // named variable a
d = *(&amp;a+immOff)   // variable-plus-offset
d = *a;            // register
d = *(a+immOff);   // register-plus-offset
d = *(immAddr);    // immediate address
</pre>
 <p>
  Notes
 </p>
 <p>
  Destination
  <span class="pre">
   d
  </span>
  must be in the
  <span class="pre">
   .reg
  </span>
  state space.
 </p>
 <p>
  A destination register wider than the specified type may be used. The value loaded is sign-extended
to the destination register width for signed integers, and is zero-extended to the destination
register width for unsigned and bit-size types.
 </p>
 <p>
  <span class="pre">
   .f16
  </span>
  data may be loaded using
  <span class="pre">
   ld.b16
  </span>
  , and then converted to
  <span class="pre">
   .f32
  </span>
  or
  <span class="pre">
   .f64
  </span>
  using
  <span class="pre">
   cvt
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 3.1.
 </p>
 <p>
  Support for
  <span class="pre">
   .level::eviction_priority
  </span>
  ,
  <span class="pre">
   .level::prefetch_size
  </span>
  and
  <span class="pre">
   .level::cache_hint
  </span>
  qualifiers introduced in PTX ISA version 7.4.
 </p>
 <p>
  Support for
  <span class="pre">
   .b128
  </span>
  type introduced in PTX ISA version 8.3.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_32
  </span>
  or higher.
 </p>
 <p>
  Support for
  <span class="pre">
   .level::eviction_priority
  </span>
  qualifier requires
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  Support for
  <span class="pre">
   .level::prefetch_size
  </span>
  qualifier requires
  <span class="pre">
   sm_75
  </span>
  or higher.
 </p>
 <p>
  Support for
  <span class="pre">
   .level::cache_hint
  </span>
  qualifier requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  Support for
  <span class="pre">
   .b128
  </span>
  type requires
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>ld.global.nc.f32           d, [a];
ld.gloal.nc.L1::evict_last.u32 d, [a];

createpolicy.fractional.L2::evict_last.b64 cache-policy, 0.5;
ld.global.nc.L2::cache_hint.f32  d, [a], cache-policy;

ld.global.nc.L2::64B.b32      d,  [a];     // Prefetch 64B to L2
ld.global.nc.L2::256B.f64     d,  [a];     // Prefetch 256B to L2

ld.global.nc.b128             d,  [a];
</pre>
 <h4>
  <span class="section-number">
   9.7.8.10.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-ldu">
   Data Movement and Conversion Instructions: ldu
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-ldu" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  ldu
 </p>
 <p>
  Load read-only data from an address that is common across threads in the warp.
 </p>
 <p>
  Syntax
 </p>
 <pre>ldu{.ss}.type      d, [a];       // load from address
ldu{.ss}.vec.type  d, [a];       // vec load from address

.ss   = { .global };             // state space
.vec  = { .v2, .v4 };
.type = { .b8, .b16, .b32, .b64, .b128,
          .u8, .u16, .u32, .u64,
          .s8, .s16, .s32, .s64,
                     .f32, .f64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Load
  read-only
  data into register variable
  <span class="pre">
   d
  </span>
  from the location specified by the source address
operand
  <span class="pre">
   a
  </span>
  in the global state space, where the address is guaranteed to be the same across all
threads in the warp. If no state space is given, perform the load using
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#generic-addressing">
   Generic Addressing
  </a>
  .
 </p>
 <p>
  Supported addressing modes for operand
  <span class="pre">
   a
  </span>
  and alignment requirements are described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#addresses-as-operands">
   Addresses
as Operands
  </a>
 </p>
 <p>
  Semantics
 </p>
 <pre>d = a;             // named variable a
d = *(&amp;a+immOff)   // variable-plus-offset
d = *a;            // register
d = *(a+immOff);   // register-plus-offset
d = *(immAddr);    // immediate address
</pre>
 <p>
  Notes
 </p>
 <p>
  Destination
  <span class="pre">
   d
  </span>
  must be in the
  <span class="pre">
   .reg
  </span>
  state space.
 </p>
 <p>
  A destination register wider than the specified type may be used. The value loaded is sign-extended
to the destination register width for signed integers, and is zero-extended to the destination
register width for unsigned and bit-size types. See
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#operand-size-exceeding-instruction-type-size-relaxed-type-checking-rules-destination-operands">
   <span class="std std-numref">
    Table 25
   </span>
  </a>
  for a description of these relaxed type-checking rules.
 </p>
 <p>
  <span class="pre">
   .f16
  </span>
  data may be loaded using
  <span class="pre">
   ldu.b16
  </span>
  , and then converted to
  <span class="pre">
   .f32
  </span>
  or
  <span class="pre">
   .f64
  </span>
  using
  <span class="pre">
   cvt
  </span>
  or can be used in half precision floating point instructions.
 </p>
 <p>
  <span class="pre">
   .f16x2
  </span>
  data may be loaded using
  <span class="pre">
   ldu.b32
  </span>
  and then used in half precision floating point
instructions.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0.
 </p>
 <p>
  Support for
  <span class="pre">
   .b128
  </span>
  type introduced in PTX ISA version 8.3.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   ldu.f64
  </span>
  requires
  <span class="pre">
   sm_13
  </span>
  or higher.
 </p>
 <p>
  Support for
  <span class="pre">
   .b128
  </span>
  type requires
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>ldu.global.f32    d,[a];
ldu.global.b32    d,[p+4];
ldu.global.v4.f32 Q,[p];
ldu.global.b128   d,[a];
</pre>
 <h4>
  <span class="section-number">
   9.7.8.11.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-st">
   Data Movement and Conversion Instructions: st
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-st" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  st
 </p>
 <p>
  Store data to an addressable state space variable.
 </p>
 <p>
  Syntax
 </p>
 <pre>st{.weak}{.ss}{.cop}{.level::cache_hint}{.vec}.type   [a], b{, cache-policy};
st{.weak}{.ss}{.level::eviction_priority}{.level::cache_hint}{.vec}.type
                                                      [a], b{, cache-policy};
st.volatile{.ss}{.vec}.type                           [a], b;
st.relaxed.scope{.ss}{.level::eviction_priority}{.level::cache_hint}{.vec}.type
                                                      [a], b{, cache-policy};
st.release.scope{.ss}{.level::eviction_priority}{.level::cache_hint}{.vec}.type
                                                      [a], b{, cache-policy};
st.mmio.relaxed.sys{.global}.type         [a], b;

.ss =                       { .global, .local, .param{::func}, .shared{::cta, ::cluster} };
.level::eviction_priority = { .L1::evict_normal, .L1::evict_unchanged,
                              .L1::evict_first, .L1::evict_last, .L1::no_allocate };
.level::cache_hint =        { .L2::cache_hint };
.cop =                      { .wb, .cg, .cs, .wt };
.sem =                      { .relaxed, .release };
.scope =                    { .cta, .cluster, .gpu, .sys };
.vec =                      { .v2, .v4 };
.type =                     { .b8, .b16, .b32, .b64, .b128,
                              .u8, .u16, .u32, .u64,
                              .s8, .s16, .s32, .s64,
                              .f32, .f64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Store the value of operand
  <span class="pre">
   b
  </span>
  in the location specified by the destination address
operand
  <span class="pre">
   a
  </span>
  in specified state space. If no state space is given, perform the store using
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#generic-addressing">
   Generic
Addressing
  </a>
  . Stores to const memory are illegal.
 </p>
 <p>
  If no sub-qualifier is specified with
  <span class="pre">
   .shared
  </span>
  state space, then
  <span class="pre">
   ::cta
  </span>
  is assumed by default.
 </p>
 <p>
  Supported addressing modes for operand
  <span class="pre">
   a
  </span>
  and alignment requirements are described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#addresses-as-operands">
   Addresses
as Operands
  </a>
 </p>
 <p>
  If
  <span class="pre">
   .param
  </span>
  is specified without any sub-qualifiers then it defaults to
  <span class="pre">
   .param::func
  </span>
  .
 </p>
 <p>
  Instruction
  <span class="pre">
   st.param{::func}
  </span>
  used for passing arguments to device function cannot be predicated.
See
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parameter-state-space">
   Parameter State Space
  </a>
  and
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#function-declarations-and-definitions">
   Function Declarations and
Definitions
  </a>
  for descriptions of the proper use
of
  <span class="pre">
   st.param
  </span>
  .
 </p>
 <p>
  The qualifiers
  <span class="pre">
   .relaxed
  </span>
  and
  <span class="pre">
   .release
  </span>
  indicate memory synchronization as described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory Consistency Model
  </a>
  . The
  <span class="pre">
   .scope
  </span>
  qualifier
indicates the set of threads with which an
  <span class="pre">
   st.relaxed
  </span>
  or
  <span class="pre">
   st.release
  </span>
  instruction can directly
synchronize
  1
  . The
  <span class="pre">
   .weak
  </span>
  qualifier indicates a memory instruction with no synchronization.
The effects of this instruction become visible to other threads only when synchronization is established
by other means.
 </p>
 <p>
  The semantic details of
  <span class="pre">
   .mmio
  </span>
  qualifier are described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory Consistency Model
  </a>
  . Only
  <span class="pre">
   .sys
  </span>
  thread scope is valid for
  <span class="pre">
   st.mmio
  </span>
  operation. The
qualifiers
  <span class="pre">
   .mmio
  </span>
  and
  <span class="pre">
   .relaxed
  </span>
  must be specified together.
 </p>
 <p>
  The
  <span class="pre">
   .weak
  </span>
  ,
  <span class="pre">
   .volatile
  </span>
  ,
  <span class="pre">
   .relaxed
  </span>
  and
  <span class="pre">
   .release
  </span>
  qualifiers are mutually exclusive. When
none of these is specified, the
  <span class="pre">
   .weak
  </span>
  qualifier is assumed by default.
 </p>
 <p>
  An
  <span class="pre">
   st.volatile
  </span>
  operation is always performed and it will not be reordered with respect to other
  <span class="pre">
   volatile
  </span>
  operations to the same memory location.
  <span class="pre">
   st.volatile
  </span>
  has the same memory
synchronization semantics as
  <span class="pre">
   st.relaxed.sys
  </span>
  .
 </p>
 <p>
  The qualifiers
  <span class="pre">
   .volatile
  </span>
  ,
  <span class="pre">
   .relaxed
  </span>
  and
  <span class="pre">
   .release
  </span>
  may be used only with
  <span class="pre">
   .global
  </span>
  and
  <span class="pre">
   .shared
  </span>
  spaces and with generic addressing, where the address points to
  <span class="pre">
   .global
  </span>
  or
  <span class="pre">
   .shared
  </span>
  space. Cache operations are not permitted with these qualifiers. The qualifier
  <span class="pre">
   .mmio
  </span>
  may be used only with
  <span class="pre">
   .global
  </span>
  space and with generic addressing, where the address points to
  <span class="pre">
   .global
  </span>
  space.
 </p>
 <p>
  The qualifier
  <span class="pre">
   .level::eviction_priority
  </span>
  specifies the eviction policy that will be used during
memory access.
 </p>
 <p>
  When the optional argument
  <span class="pre">
   cache-policy
  </span>
  is specified, the qualifier
  <span class="pre">
   .level::cache_hint
  </span>
  is
required. The 64-bit operand
  <span class="pre">
   cache-policy
  </span>
  specifies the cache eviction policy that may be used
during the memory access.
 </p>
 <p>
  The qualifier
  <span class="pre">
   .level::cache_hint
  </span>
  is only supported for
  <span class="pre">
   .global
  </span>
  state space and for generic
addressing where the address points to the
  <span class="pre">
   .global
  </span>
  state space.
 </p>
 <p>
  <span class="pre">
   cache-policy
  </span>
  is a hint to the cache subsystem and may not always be respected. It is treated as
a performance hint only, and does not change the memory consistency behavior of the program.
 </p>
 <p>
  1
  This synchronization is further extended to other threads through the transitive nature of
  causality order
  , as described in the memory consistency model.
 </p>
 <p>
  Semantics
 </p>
 <pre>d = a;                // named variable d
*(&amp;a+immOffset) = b;            // variable-plus-offset
*a = b;               // register
*(a+immOffset) = b;   // register-plus-offset
*(immAddr) = b;       // immediate address
</pre>
 <p>
  Notes
 </p>
 <p>
  Operand
  <span class="pre">
   b
  </span>
  must be in the
  <span class="pre">
   .reg
  </span>
  state space.
 </p>
 <p>
  A source register wider than the specified type may be used. The lower
  <span class="pre">
   n
  </span>
  bits corresponding to
the instruction-type width are stored to memory. See
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#operand-size-exceeding-instruction-type-size-relaxed-type-checking-rules-source-operands">
   <span class="std std-numref">
    Table 24
   </span>
  </a>
  for a description of these relaxed type-checking rules.
 </p>
 <p>
  <span class="pre">
   .f16
  </span>
  data resulting from a
  <span class="pre">
   cvt
  </span>
  instruction may be stored using
  <span class="pre">
   st.b16
  </span>
  .
 </p>
 <p>
  <span class="pre">
   .f16x2
  </span>
  data may be stored using
  <span class="pre">
   st.b32
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  st introduced in PTX ISA version 1.0.
  <span class="pre">
   st.volatile
  </span>
  introduced in PTX ISA version 1.1.
 </p>
 <p>
  Generic addressing and cache operations introduced in PTX ISA version 2.0.
 </p>
 <p>
  Support for scope qualifier,
  <span class="pre">
   .relaxed
  </span>
  ,
  <span class="pre">
   .release
  </span>
  ,
  <span class="pre">
   .weak
  </span>
  qualifiers introduced in PTX ISA
version 6.0.
 </p>
 <p>
  Support for
  <span class="pre">
   .level::eviction_priority
  </span>
  and
  <span class="pre">
   .level::cache_hint
  </span>
  qualifiers introduced in PTX
ISA version 7.4.
 </p>
 <p>
  Support for
  <span class="pre">
   .cluster
  </span>
  scope qualifier introduced in PTX ISA version 7.8.
 </p>
 <p>
  Support for
  <span class="pre">
   ::cta
  </span>
  and
  <span class="pre">
   ::cluster
  </span>
  sub-qualifiers introduced in PTX ISA version 7.8.
 </p>
 <p>
  Support for
  <span class="pre">
   .mmio
  </span>
  qualifier introduced in PTX ISA version 8.2.
 </p>
 <p>
  Support for
  <span class="pre">
   ::func
  </span>
  sub-qualifier on
  <span class="pre">
   .param
  </span>
  space introduced in PTX ISA version 8.3.
 </p>
 <p>
  Support for
  <span class="pre">
   .b128
  </span>
  type introduced in PTX ISA version 8.3.
 </p>
 <p>
  Support for
  <span class="pre">
   .sys
  </span>
  scope with
  <span class="pre">
   .b128
  </span>
  type introduced in PTX ISA version 8.4.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   st.f64
  </span>
  requires
  <span class="pre">
   sm_13
  </span>
  or higher.
 </p>
 <p>
  Support for scope qualifier,
  <span class="pre">
   .relaxed
  </span>
  ,
  <span class="pre">
   .release
  </span>
  ,
  <span class="pre">
   .weak
  </span>
  qualifiers require
  <span class="pre">
   sm_70
  </span>
  or
higher.
 </p>
 <p>
  Generic addressing requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Cache operations require
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Support for
  <span class="pre">
   .level::eviction_priority
  </span>
  qualifier requires
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  Support for
  <span class="pre">
   .level::cache_hint
  </span>
  qualifier requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  Support for
  <span class="pre">
   .cluster
  </span>
  scope qualifier requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Sub-qualifier
  <span class="pre">
   ::cta
  </span>
  requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Sub-qualifier
  <span class="pre">
   ::cluster
  </span>
  requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Support for
  <span class="pre">
   .mmio
  </span>
  qualifier requires
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  Support for
  <span class="pre">
   .b128
  </span>
  type requires
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>st.global.f32    [a],b;
st.local.b32     [q+4],a;
st.global.v4.s32 [p],Q;
st.local.b32     [q+-8],a; // negative offset
st.local.s32     [100],r7; // immediate address

cvt.f16.f32      %r,%r;    // %r is 32-bit register
st.b16           [fs],%r;  // store lower
st.global.relaxed.sys.u32 [gbl], %r0;
st.shared.release.cta.u32 [sh], %r1;
st.global.relaxed.cluster.u32 [gbl], %r2;
st.shared::cta.release.cta.u32 [sh + 4], %r1;
st.shared::cluster.u32 [sh + 8], %r1;
st.global.mmio.relaxed.sys.u32 [gbl], %r1;

st.global.L1::no_allocate.f32 [p], a;

createpolicy.fractional.L2::evict_last.b64 cache-policy, 0.25;
st.global.L2::cache_hint.b32  [a], b, cache-policy;

st.param::func.b64 [param1], %rp1;

st.global.b128  [a], b;  // 128-bit store
</pre>
 <h4>
  <span class="section-number">
   9.7.8.12.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-st-async">
   Data Movement and Conversion Instructions: st.async
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-st-async" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  st.async
 </p>
 <p>
  Asynchronous store operation on shared memory.
 </p>
 <p>
  Syntax
 </p>
 <pre>st.async{.weak}{.ss}{.completion_mechanism}{.vec}.type [a], b, [mbar];

.ss   =                 { .shared::cluster };
.type =                 { .b32, .b64,
                          .u32, .u64,
                          .s32, .s64,
                          .f32, .f64 };
.vec  =                 { .v2, .v4 };
.completion_mechanism = { .mbarrier::complete_tx::bytes };
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   st.async
  </span>
  is a non-blocking instruction which initiates an asynchronous store operation that
stores the value specified by source operand
  <span class="pre">
   b
  </span>
  to the destination memory location
specified by operand
  <span class="pre">
   a
  </span>
  .
 </p>
 <p>
  The modifier
  <span class="pre">
   .completion_mechanism
  </span>
  specifies that upon completion of the asynchronous operation,
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-complete-tx-operation">
   complete-tx
  </a>
  operation, with
  <span class="pre">
   completeCount
  </span>
  argument equal to amount of data stored in bytes, will be
performed on the
  mbarrier object
  specified by the operand
  <span class="pre">
   mbar
  </span>
  .
 </p>
 <p>
  Operand
  <span class="pre">
   a
  </span>
  represents destination address and must be a register or of the form
  <span class="pre">
   register
  </span>
  <span class="pre">
   +
  </span>
  <span class="pre">
   immOff
  </span>
  as described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#addresses-as-operands">
   Addresses as Operands
  </a>
  .
 </p>
 <p>
  The shared memory addresses of destination operand
  <span class="pre">
   a
  </span>
  and the
  mbarrier object
  <span class="pre">
   mbar
  </span>
  , must
meet all of the following conditions:
 </p>
 <ul class="simple">
  <li>
   <p>
    They belong to the same CTA.
   </p>
  </li>
  <li>
   <p>
    They are different to the CTA of the executing thread but must be within the same cluster.
   </p>
  </li>
 </ul>
 <p>
  Otherwise, the behavior is undefined.
 </p>
 <p>
  The state space of the address
  <span class="pre">
   {.ss}
  </span>
  , if specified, is applicable to both operands
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   mbar
  </span>
  . If not specified, then
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#generic-addressing">
   Generic Addressing
  </a>
  is used for
both
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   mbar
  </span>
  . If the generic addresses specified do not fall within the address window of
  <span class="pre">
   .shared::cluster
  </span>
  state space, then the behaviour is undefined.
 </p>
 <p>
  The store operation in
  <span class="pre">
   st.async
  </span>
  is treated as a weak memory operation and the
  complete_tx
  operation on the mbarrier has
  <span class="pre">
   .release
  </span>
  semantics at the
  <span class="pre">
   .cluster
  </span>
  scope as described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory Consistency Model
  </a>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 8.1.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>st.async.shared::cluster.mbarrier::complete_tx::bytes.u32 [addr], b, [mbar_addr]
</pre>
 <h4>
  <span class="section-number">
   9.7.8.13.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-multimem">
   Data Movement and Conversion Instructions: multimem.ld_reduce, multimem.st, multimem.red
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-multimem-ld-reduce-multimem-st-multimem-red" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The multimem.* operations operate on multimem addresses and accesses all of the multiple memory
locations which the multimem address points to.
 </p>
 <p>
  Multimem addresses can only be accessed only by multimem.* operations. Accessing a multimem address
with
  <span class="pre">
   ld
  </span>
  ,
  <span class="pre">
   st
  </span>
  or any other memory operations results in undefined behavior.
 </p>
 <p>
  Refer to
  CUDA programming guide
  for creation and management of the multimem addresses.
 </p>
 <p>
  multimem.ld_reduce, multimem.st, multimem.red
 </p>
 <p>
  Perform memory operations on the multimem address.
 </p>
 <p>
  Syntax
 </p>
 <pre>// Integer type:

multimem.ld_reduce{.ldsem}{.scope}{.ss}.op.type      d, [a];
multimem.st{.stsem}{.scope}{.ss}.type                [a], b;
multimem.red{.redsem}{.scope}{.ss}.op.type           [a], b;

.ss =       { .global }
.ldsem =    { .weak, .relaxed, .acquire }
.stsem =    { .weak, .relaxed, .release }
.redsem =   { .relaxed, .release }
.scope =    { .cta, .cluster, .gpu, .sys }
.op  =      { .min, .max, .add, .and, .or, .xor }
.type =     { .b32, .b64,  .u32, .u64, .s32, .s64 }

// Floating point type:

multimem.ld_reduce{.ldsem}{.scope}{.ss}.op{.acc_prec}{.vec}.type    d, [a];
multimem.st{.stsem}{.scope}{.ss}{.vec}.type                         [a], b;
multimem.red{.redsem}{.scope}{.ss}.redop{.vec}.type                 [a], b;

.ss =       { .global }
.ldsem =    { .weak, .relaxed, .acquire }
.stsem =    { .weak, .relaxed, .release }
.redsem =   { .relaxed, .release }
.scope =    { .cta, .cluster, .gpu, .sys }
.op  =      { .min, .max, .add }
.redop  =   { .add }
.acc_prec = { .acc::f32 }
.vec =      { .v2, .v4, .v8 }
.type=      { .f16, .f16x2, .bf16, .bf16x2, .f32, .f64 }
</pre>
 <p>
  Description
 </p>
 <p>
  Instruction
  <span class="pre">
   multimem.ld_reduce
  </span>
  performs the following operations:
 </p>
 <ul class="simple">
  <li>
   <p>
    load operation on the multimem address
    <span class="pre">
     a
    </span>
    , which involves loading of data from all of the
multiple memory locations pointed to by the multimem address
    <span class="pre">
     a
    </span>
    ,
   </p>
  </li>
  <li>
   <p>
    reduction operation specified by
    <span class="pre">
     .op
    </span>
    on the multiple data loaded from the multimem address
    <span class="pre">
     a
    </span>
    .
   </p>
  </li>
 </ul>
 <p>
  The result of the reduction operation in returned in register
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  Instruction
  <span class="pre">
   multimem.st
  </span>
  performs a store operation of the input operand
  <span class="pre">
   b
  </span>
  to all the memory
locations pointed to by the multimem address
  <span class="pre">
   a
  </span>
  .
 </p>
 <p>
  Instruction
  <span class="pre">
   multimem.red
  </span>
  performs a reduction operation on all the memory locations pointed to
by the multimem address
  <span class="pre">
   a
  </span>
  , with operand
  <span class="pre">
   b
  </span>
  .
 </p>
 <p>
  Instruction
  <span class="pre">
   multimem.ld_reduce
  </span>
  performs reduction on the values loaded from all the memory
locations that the multimem address points to. In contrast, the
  <span class="pre">
   multimem.red
  </span>
  perform reduction
on all the memory locations that the multimem address points to.
 </p>
 <p>
  Address operand
  <span class="pre">
   a
  </span>
  must be a multimem address. Otherwise, the behavior is undefined.  Supported
addressing modes for operand a and alignment requirements are described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#addresses-as-operands">
   Addresses as Operands
  </a>
  .
 </p>
 <p>
  If no state space is specified then
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#generic-addressing">
   Generic Addressing
  </a>
  is
used. If the address specified by
  <span class="pre">
   a
  </span>
  does not fall within the address window of
  <span class="pre">
   .global
  </span>
  state
space then the behavior is undefined.
 </p>
 <p>
  For floating-point type multi- operations, the size of the specified type along with
  <span class="pre">
   .vec
  </span>
  must
equal either 32-bits or 64-bits or 128-bits. No other combinations of
  <span class="pre">
   .vec
  </span>
  and type are
allowed. Type
  <span class="pre">
   .f64
  </span>
  cannot be used with
  <span class="pre">
   .vec
  </span>
  qualifier.
 </p>
 <p>
  The following table describes the valid combinations of
  <span class="pre">
   .op
  </span>
  and base type:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     op
    </p>
   </th>
   <th class="head">
    <p>
     Base type
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .add
     </span>
    </p>
   </td>
   <td>
    <span class="pre">
     .u32
    </span>
    ,
    <span class="pre">
     .u64
    </span>
    ,
    <span class="pre">
     .s32
    </span>
    <span class="pre">
     .f16
    </span>
    ,
    <span class="pre">
     .f16x2
    </span>
    ,
    <span class="pre">
     .bf16
    </span>
    ,
    <span class="pre">
     .bf16x2
    </span>
    <span class="pre">
     .f32
    </span>
    ,
    <span class="pre">
     .f64
    </span>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .and
     </span>
     ,
     <span class="pre">
      .or
     </span>
     ,
     <span class="pre">
      .xor
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .b32
     </span>
     ,
     <span class="pre">
      .b64
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .min
     </span>
     ,
     <span class="pre">
      .max
     </span>
    </p>
   </td>
   <td>
    <span class="pre">
     .u32
    </span>
    ,
    <span class="pre">
     .s32
    </span>
    ,
    <span class="pre">
     .u64
    </span>
    ,
    <span class="pre">
     .s644
    </span>
    <span class="pre">
     .f16
    </span>
    ,
    <span class="pre">
     .f16x2
    </span>
    ,
    <span class="pre">
     .bf16
    </span>
    ,
    <span class="pre">
     .bf16x2
    </span>
   </td>
  </tr>
 </table>
 <p>
  For
  <span class="pre">
   multimem.ld_reduce
  </span>
  , the default precision of the intermediate accumulation is same as the
specified type. Optionally for
  <span class="pre">
   .f16
  </span>
  ,
  <span class="pre">
   .f16x2
  </span>
  ,
  <span class="pre">
   .bf16
  </span>
  and
  <span class="pre">
   .bf16x2
  </span>
  types,
  <span class="pre">
   .acc::f32
  </span>
  can be specified to change the precision of the intermediate accumulation to
  <span class="pre">
   .f32
  </span>
  .
 </p>
 <p>
  Optional qualifiers
  <span class="pre">
   .ldsem
  </span>
  ,
  <span class="pre">
   .stsem
  </span>
  and
  <span class="pre">
   .redsem
  </span>
  specify the memory synchronizing effect
of the
  <span class="pre">
   multimem.ld_reduce
  </span>
  ,
  <span class="pre">
   multimem.st
  </span>
  and
  <span class="pre">
   multimem.red
  </span>
  respectively, as described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory Consistency Model
  </a>
  . If explicit semantics qualifiers
are not specified, then
  <span class="pre">
   multimem.ld_reduce
  </span>
  and
  <span class="pre">
   multimem.st
  </span>
  default to
  <span class="pre">
   .weak
  </span>
  and
  <span class="pre">
   multimem.red
  </span>
  defaults to
  <span class="pre">
   .relaxed
  </span>
  .
 </p>
 <p>
  The optional
  <span class="pre">
   .scope
  </span>
  qualifier specifies the set of threads that can directly observe the memory
synchronizing effect of this operation, as described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory Consistency Model
  </a>
  . If the
  <span class="pre">
   .scope
  </span>
  qualifier is not specified for
  <span class="pre">
   multimem.red
  </span>
  then
  <span class="pre">
   .sys
  </span>
  scope is assumed by default.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 8.1.
 </p>
 <p>
  Support for
  <span class="pre">
   .acc::f32
  </span>
  qualifier introduced in PTX ISA version 8.2.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>multimem.ld_reduce.and.b32                    val1_b32, [addr1];
multimem.ld_reduce.acquire.gpu.global.add.u32 val2_u32, [addr2];

multimem.st.relaxed.gpu.b32                [addr3], val3_b32;
multimem.st.release.cta.global.u32         [addr4], val4_u32;

multimem.red.relaxed.gpu.max.f64           [addr5], val5_f64;
multimem.red.release.cta.global.add.v4.f32 [addr6], {val6, val7, val8, val9};
multimem.ld_reduce.add.acc::f32.v2.f16x2   {val_10, val_11}, [addr7];
</pre>
 <h4>
  <span class="section-number">
   9.7.8.14.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-prefetch-prefetchu">
   Data Movement and Conversion Instructions: prefetch, prefetchu
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-prefetch-prefetchu" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  prefetch, prefetchu
 </p>
 <p>
  Prefetch line containing a generic address at a specified level of memory hierarchy, in specified
state space.
 </p>
 <p>
  Syntax
 </p>
 <pre>prefetch{.space}.level                    [a];   // prefetch to data cache
prefetch.global.level::eviction_priority  [a];   // prefetch to data cache

prefetchu.L1  [a];             // prefetch to uniform cache

prefetch{.tensormap_space}.tensormap [a];  // prefetch the tensormap

.space =                    { .global, .local };
.level =                    { .L1, .L2 };
.level::eviction_priority = { .L2::evict_last, .L2::evict_normal };
.tensormap_space =          { .const, .param };
</pre>
 <p>
  Description
 </p>
 <p>
  The
  <span class="pre">
   prefetch
  </span>
  instruction brings the cache line containing the specified address in global or
local memory state space into the specified cache level.
 </p>
 <p>
  If the
  <span class="pre">
   .tensormap
  </span>
  qualifier is specified then the
  <span class="pre">
   prefetch
  </span>
  instruction brings the cache line
containing the specified address in the
  <span class="pre">
   .const
  </span>
  or
  <span class="pre">
   .param
  </span>
  memory state space for subsequent
use by the
  <span class="pre">
   cp.async.bulk.tensor
  </span>
  instruction.
 </p>
 <p>
  If no state space is given, the
  <span class="pre">
   prefetch
  </span>
  uses
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#generic-addressing">
   Generic Addressing
  </a>
  .
 </p>
 <p>
  Optionally, the eviction priority to be applied on the prefetched cache line can be specified by the
modifier
  <span class="pre">
   .level::eviction_priority
  </span>
  .
 </p>
 <p>
  Supported addressing modes for operand
  <span class="pre">
   a
  </span>
  and alignment requirements are described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#addresses-as-operands">
   Addresses
as Operands
  </a>
 </p>
 <p>
  The
  <span class="pre">
   prefetchu
  </span>
  instruction brings the cache line containing the specified generic address into
the specified uniform cache level.
 </p>
 <p>
  A
  <span class="pre">
   prefetch
  </span>
  to a shared memory location performs no operation.
 </p>
 <p>
  A
  <span class="pre">
   prefetch
  </span>
  into the uniform cache requires a generic address, and no operation occurs if the
address maps to a
  <span class="pre">
   const
  </span>
  ,
  <span class="pre">
   local
  </span>
  , or
  <span class="pre">
   shared
  </span>
  memory location.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0.
 </p>
 <p>
  Support for
  <span class="pre">
   .level::eviction_priority
  </span>
  qualifier introduced in PTX ISA version 7.4.
 </p>
 <p>
  Support for the
  <span class="pre">
   .tensormap
  </span>
  qualifier is introduced in PTX ISA version 8.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   prefetch
  </span>
  and
  <span class="pre">
   prefetchu
  </span>
  require
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Support for
  <span class="pre">
   .level::eviction_priority
  </span>
  qualifier requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  Support for the
  <span class="pre">
   .tensormap
  </span>
  qualifier requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>prefetch.global.L1             [ptr];
prefetch.global.L2::evict_last [ptr];
prefetchu.L1  [addr];
prefetch.global.tensormap      [ptr];
</pre>
 <h4>
  <span class="section-number">
   9.7.8.15.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-applypriority">
   Data Movement and Conversion Instructions: applypriority
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-applypriority" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  applypriority
 </p>
 <p>
  Apply the cache eviction priority to the specified address in the specified cache level.
 </p>
 <p>
  Syntax
 </p>
 <pre>applypriority{.global}.level::eviction_priority  [a], size;

.level::eviction_priority = { .L2::evict_normal };
</pre>
 <p>
  Description
 </p>
 <p>
  The
  <span class="pre">
   applypriority
  </span>
  instruction applies the cache eviction priority specified by the
  <span class="pre">
   .level::eviction_priority
  </span>
  qualifier to the address range
  <span class="pre">
   [a..a+size)
  </span>
  in the specified cache
level.
 </p>
 <p>
  If no state space is specified then
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#generic-addressing">
   Generic Addressing
  </a>
  is
used. If the specified address does not fall within the address window of
  <span class="pre">
   .global
  </span>
  state space
then the behavior is undefined.
 </p>
 <p>
  The operand
  <span class="pre">
   size
  </span>
  is an integer constant that specifies the amount of data, in bytes, in the
specified cache level on which the priority is to be applied. The only supported value for the
  <span class="pre">
   size
  </span>
  operand is 128.
 </p>
 <p>
  Supported addressing modes for operand
  <span class="pre">
   a
  </span>
  are described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#addresses-as-operands">
   Addresses as Operands
  </a>
  .
  <span class="pre">
   a
  </span>
  must be aligned to 128 bytes.
 </p>
 <p>
  If the data pointed to by address
  <span class="pre">
   a
  </span>
  is not already present in the specified cache level, then
the data will be prefetched before applying the specified priority.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.4.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>applypriority.global.L2::evict_normal [ptr], 128;
</pre>
 <h4>
  <span class="section-number">
   9.7.8.16.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-discard">
   Data Movement and Conversion Instructions: discard
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-discard" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  discard
 </p>
 <p>
  Invalidate the data in cache at the specified address and cache level.
 </p>
 <p>
  Syntax
 </p>
 <pre>discard{.global}.level  [a], size;

.level = { .L2 };
</pre>
 <p>
  Description
 </p>
 <p>
  The
  <span class="pre">
   discard
  </span>
  instruction invalidates the data at the address range
  <span class="pre">
   [a
  </span>
  <span class="pre">
   ..
  </span>
  <span class="pre">
   a
  </span>
  <span class="pre">
   +
  </span>
  <span class="pre">
   (size
  </span>
  <span class="pre">
   -
  </span>
  <span class="pre">
   1)]
  </span>
  in
the cache level specified by the
  <span class="pre">
   .level
  </span>
  qualifier without writing back the data in the cache to
the memory. Therefore after the discard operation, the data at the address range
  <span class="pre">
   [a
  </span>
  <span class="pre">
   ..
  </span>
  <span class="pre">
   a+
  </span>
  <span class="pre">
   (size
  </span>
  <span class="pre">
   -
  </span>
  <span class="pre">
   1)]
  </span>
  has undetermined value.
 </p>
 <p>
  The operand
  <span class="pre">
   size
  </span>
  is an integer constant that specifies the amount of data, in bytes, in the
cache level specified by the
  <span class="pre">
   .level
  </span>
  qualifier to be discarded. The only supported value for the
  <span class="pre">
   size
  </span>
  operand is 128.
 </p>
 <p>
  If no state space is specified then
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#generic-addressing">
   Generic Addressing
  </a>
  is
used. If the specified address does not fall within the address window of
  <span class="pre">
   .global
  </span>
  state space
then the behavior is undefined.
 </p>
 <p>
  Supported addressing modes for address operand
  <span class="pre">
   a
  </span>
  are described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#addresses-as-operands">
   Addresses as Operands
  </a>
  .
  <span class="pre">
   a
  </span>
  must be aligned to 128 bytes.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.4.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>discard.global.L2 [ptr], 128;
</pre>
 <h4>
  <span class="section-number">
   9.7.8.17.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-createpolicy">
   Data Movement and Conversion Instructions: createpolicy
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-createpolicy" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  createpolicy
 </p>
 <p>
  Create a cache eviction policy for the specified cache level.
 </p>
 <p>
  Syntax
 </p>
 <pre>// Range-based policy
createpolicy.range{.global}.level::primary_priority{.level::secondary_priority}.b64
                                   cache-policy, [a], primary-size, total-size;

// Fraction-based policy
createpolicy.fractional.level::primary_priority{.level::secondary_priority}.b64
                                   cache-policy{, fraction};

// Converting the access property from CUDA APIs
createpolicy.cvt.L2.b64            cache-policy, access-property;

.level::primary_priority =   { .L2::evict_last, .L2::evict_normal,
                               .L2::evict_first, .L2::evict_unchanged };
.level::secondary_priority = { .L2::evict_first, .L2::evict_unchanged };
</pre>
 <p>
  Description
 </p>
 <p>
  The
  <span class="pre">
   createpolicy
  </span>
  instruction creates a cache eviction policy for the specified cache level in an
opaque 64-bit register specified by the destination operand
  <span class="pre">
   cache-policy
  </span>
  . The cache eviction
policy specifies how cache eviction priorities are applied to global memory addresses used in memory
operations with
  <span class="pre">
   .level::cache_hint
  </span>
  qualifier.
 </p>
 <p>
  There are two types of cache eviction policies:
 </p>
 <ul>
  <li>
   <p>
    Range-based policy
   </p>
   <p>
    The cache eviction policy created using
    <span class="pre">
     createpolicy.range
    </span>
    specifies the cache eviction
behaviors for the following three address ranges:
   </p>
   <ul class="simple">
    <li>
     <p>
      <span class="pre">
       [a
      </span>
      <span class="pre">
       ..
      </span>
      <span class="pre">
       a
      </span>
      <span class="pre">
       +
      </span>
      <span class="pre">
       (primary-size
      </span>
      <span class="pre">
       -
      </span>
      <span class="pre">
       1)]
      </span>
      referred to as primary range.
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       [a
      </span>
      <span class="pre">
       +
      </span>
      <span class="pre">
       primary-size
      </span>
      <span class="pre">
       ..
      </span>
      <span class="pre">
       a
      </span>
      <span class="pre">
       +
      </span>
      <span class="pre">
       (total-size
      </span>
      <span class="pre">
       -
      </span>
      <span class="pre">
       1)]
      </span>
      referred to as trailing secondary range.
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       [a
      </span>
      <span class="pre">
       -
      </span>
      <span class="pre">
       (total-size
      </span>
      <span class="pre">
       -
      </span>
      <span class="pre">
       primary-size)
      </span>
      <span class="pre">
       ..
      </span>
      <span class="pre">
       (a
      </span>
      <span class="pre">
       -
      </span>
      <span class="pre">
       1)]
      </span>
      referred to as preceding secondary range.
     </p>
    </li>
   </ul>
   <p>
    When a range-based cache eviction policy is used in a memory operation with
    <span class="pre">
     .level::cache_hint
    </span>
    qualifier, the eviction priorities are applied as follows:
   </p>
   <ul class="simple">
    <li>
     <p>
      If the memory address falls in the primary range, the eviction priority specified by
      <span class="pre">
       .L2::primary_priority
      </span>
      is applied.
     </p>
    </li>
    <li>
     <p>
      If the memory address falls in any of the secondary ranges, the eviction priority specified by
      <span class="pre">
       .L2::secondary_priority
      </span>
      is applied.
     </p>
    </li>
    <li>
     <p>
      If the memory address does not fall in either of the above ranges, then the applied eviction
priority is unspecified.
     </p>
    </li>
   </ul>
   <p>
    The 32-bit operand
    <span class="pre">
     primary-size
    </span>
    specifies the size, in bytes, of the primary range. The
32-bit operand
    <span class="pre">
     total-size
    </span>
    specifies the combined size, in bytes, of the address range
including primary and secondary ranges. The value of
    <span class="pre">
     primary-size
    </span>
    must be less than or equal
to the value of
    <span class="pre">
     total-size
    </span>
    . Maximum allowed value of
    <span class="pre">
     total-size
    </span>
    is 4GB.
   </p>
   <p>
    If
    <span class="pre">
     .L2::secondary_priority
    </span>
    is not specified, then it defaults to
    <span class="pre">
     .L2::evict_unchanged
    </span>
    .
   </p>
   <p>
    If no state space is specified then
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#generic-addressing">
     Generic Addressing
    </a>
    is
used. If the specified address does not fall within the address window of
    <span class="pre">
     .global
    </span>
    state space
then the behavior is undefined.
   </p>
  </li>
  <li>
   <p>
    Fraction-based policy
   </p>
   <p>
    A memory operation with
    <span class="pre">
     .level::cache_hint
    </span>
    qualifier can use the fraction-based cache
eviction policy to request the cache eviction priority specified by
    <span class="pre">
     .L2:primary_priority
    </span>
    to
be applied to a fraction of cache accesses specified by the 32-bit floating point operand
    <span class="pre">
     fraction
    </span>
    . The remainder of the cache accesses get the eviction priority specified by
    <span class="pre">
     .L2::secondary_priority
    </span>
    . This implies that in a memory operation that uses a fraction-based
cache policy, the memory access has a probability specified by the operand
    <span class="pre">
     fraction
    </span>
    of
getting the cache eviction priority specified by
    <span class="pre">
     .L2::primary_priority
    </span>
    .
   </p>
   <p>
    The valid range of values for the operand
    <span class="pre">
     fraction
    </span>
    is
    <span class="pre">
     (0.0,..,
    </span>
    <span class="pre">
     1.0]
    </span>
    . If the operand
    <span class="pre">
     fraction
    </span>
    is not specified, it defaults to 1.0.
   </p>
   <p>
    If
    <span class="pre">
     .L2::secondary_priority
    </span>
    is not specified, then it defaults to
    <span class="pre">
     .L2::evict_unchanged
    </span>
    .
   </p>
  </li>
 </ul>
 <p>
  The access property created using the CUDA APIs can be converted into cache eviction policy by the
instruction
  <span class="pre">
   createpolicy.cvt
  </span>
  . The source operand
  <span class="pre">
   access-property
  </span>
  is a 64-bit opaque
register. Refer to
  CUDA programming guide
  for more details.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.4.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>createpolicy.fractional.L2::evict_last.b64                      policy, 1.0;
createpolicy.fractional.L2::evict_last.L2::evict_unchanged.b64  policy, 0.5;

createpolicy.range.L2::evict_last.L2::evict_first.b64
                                            policy, [ptr], 0x100000, 0x200000;

// access-prop is created by CUDA APIs.
createpolicy.cvt.L2.b64 policy, access-prop;
</pre>
 <h4>
  <span class="section-number">
   9.7.8.18.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-isspacep">
   Data Movement and Conversion Instructions: isspacep
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-isspacep" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  isspacep
 </p>
 <p>
  Query whether a generic address falls within a specified state space window.
 </p>
 <p>
  Syntax
 </p>
 <pre>isspacep.space  p, a;    // result is .pred

.space = { const, .global, .local, .shared{::cta, ::cluster}, .param{::entry} };
</pre>
 <p>
  Description
 </p>
 <p>
  Write predicate register
  <span class="pre">
   p
  </span>
  with
  <span class="pre">
   1
  </span>
  if generic address a falls within the specified state
space window and with
  <span class="pre">
   0
  </span>
  otherwise. Destination
  <span class="pre">
   p
  </span>
  has type
  <span class="pre">
   .pred
  </span>
  ; the source address
operand must be of type
  <span class="pre">
   .u32
  </span>
  or
  <span class="pre">
   .u64
  </span>
  .
 </p>
 <p>
  <span class="pre">
   isspacep.param{::entry}
  </span>
  returns
  <span class="pre">
   1
  </span>
  if the generic address falls within the window of
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-function-parameters">
   Kernel Function Parameters
  </a>
  , otherwise returns
  <span class="pre">
   0
  </span>
  . If
  <span class="pre">
   .param
  </span>
  is specified without any sub-qualifiers then it defaults to
  <span class="pre">
   .param::entry
  </span>
  .
 </p>
 <p>
  <span class="pre">
   isspacep.global
  </span>
  returns
  <span class="pre">
   1
  </span>
  for
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-function-parameters">
   Kernel Function Parameters
  </a>
  as
  <span class="pre">
   .param
  </span>
  window is contained within the
  <span class="pre">
   .global
  </span>
  window.
 </p>
 <p>
  If no sub-qualifier is specified with
  <span class="pre">
   .shared
  </span>
  state space, then
  <span class="pre">
   ::cta
  </span>
  is assumed by default.
 </p>
 <p class="admonition-title">
  Note
 </p>
 <p>
  <span class="pre">
   ispacep.shared::cluster
  </span>
  will return 1 for every shared memory address that is accessible to
the threads in the cluster, whereas
  <span class="pre">
   ispacep.shared::cta
  </span>
  will return 1 only if the address is
of a variable declared in the executing CTA.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0.
 </p>
 <p>
  <span class="pre">
   isspacep.const
  </span>
  introduced in PTX ISA version 3.1.
 </p>
 <p>
  <span class="pre">
   isspacep.param
  </span>
  introduced in PTX ISA version 7.7.
 </p>
 <p>
  Support for
  <span class="pre">
   ::cta
  </span>
  and
  <span class="pre">
   ::cluster
  </span>
  sub-qualifiers introduced in PTX ISA version 7.8.
 </p>
 <p>
  Support for sub-qualifier
  <span class="pre">
   ::entry
  </span>
  on
  <span class="pre">
   .param
  </span>
  space introduced in PTX ISA version 8.3.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   isspacep
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   isspacep.param{::entry}
  </span>
  requires
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  Sub-qualifier
  <span class="pre">
   ::cta
  </span>
  requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Sub-qualifier
  <span class="pre">
   ::cluster
  </span>
  requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>isspacep.const           iscnst, cptr;
isspacep.global          isglbl, gptr;
isspacep.local           islcl,  lptr;
isspacep.shared          isshrd, sptr;
isspacep.param::entry    isparam, pptr;
isspacep.shared::cta     isshrdcta, sptr;
isspacep.shared::cluster ishrdany sptr;
</pre>
 <h4>
  <span class="section-number">
   9.7.8.19.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cvta">
   Data Movement and Conversion Instructions: cvta
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cvta" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  cvta
 </p>
 <p>
  Convert address from
  <span class="pre">
   .const
  </span>
  ,
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-function-parameters">
   Kernel Function Parameters
  </a>
  (
  <span class="pre">
   .param
  </span>
  ),
  <span class="pre">
   .global
  </span>
  ,
  <span class="pre">
   .local
  </span>
  , or
  <span class="pre">
   .shared
  </span>
  state space to generic, or vice-versa. Take the generic address of a variable declared in
  <span class="pre">
   .const
  </span>
  ,
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-function-parameters">
   Kernel Function Parameters
  </a>
  (
  <span class="pre">
   .param
  </span>
  ),
  <span class="pre">
   .global
  </span>
  ,
  <span class="pre">
   .local
  </span>
  , or
  <span class="pre">
   .shared
  </span>
  state space.
 </p>
 <p>
  Syntax
 </p>
 <pre>// convert const, global, local, or shared address to generic address
cvta.space.size  p, a;        // source address in register a
cvta.space.size  p, var;      // get generic address of var
cvta.space.size  p, var+imm;  // generic address of var+offset

// convert generic address to const, global, local, or shared address
cvta.to.space.size  p, a;

.space = { .const, .global, .local, .shared{::cta, ::cluster}, .param{::entry} };
.size  = { .u32, .u64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Convert a
  <span class="pre">
   const
  </span>
  ,
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-function-parameters">
   Kernel Function Parameters
  </a>
  (
  <span class="pre">
   .param
  </span>
  ),
  <span class="pre">
   global
  </span>
  ,
  <span class="pre">
   local
  </span>
  , or
  <span class="pre">
   shared
  </span>
  address to a generic address, or vice-versa. The
source and destination addresses must be the same size. Use
  <span class="pre">
   cvt.u32.u64
  </span>
  or
  <span class="pre">
   cvt.u64.u32
  </span>
  to
truncate or zero-extend addresses.
 </p>
 <p>
  For variables declared in
  <span class="pre">
   .const
  </span>
  ,
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-function-parameters">
   Kernel Function Parameters
  </a>
  (
  <span class="pre">
   .param
  </span>
  ),
  <span class="pre">
   .global
  </span>
  ,
  <span class="pre">
   .local
  </span>
  , or
  <span class="pre">
   .shared
  </span>
  state space, the generic address of the variable may be taken using
  <span class="pre">
   cvta
  </span>
  . The source is either a
register or a variable defined in
  <span class="pre">
   const
  </span>
  ,
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-function-parameters">
   Kernel Function Parameters
  </a>
  (
  <span class="pre">
   .param
  </span>
  ),
  <span class="pre">
   global
  </span>
  ,
  <span class="pre">
   local
  </span>
  , or
  <span class="pre">
   shared
  </span>
  memory
with an optional offset.
 </p>
 <p>
  When converting a generic address into a
  <span class="pre">
   const
  </span>
  ,
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-function-parameters">
   Kernel Function Parameters
  </a>
  (
  <span class="pre">
   .param
  </span>
  ),
  <span class="pre">
   global
  </span>
  ,
  <span class="pre">
   local
  </span>
  , or
  <span class="pre">
   shared
  </span>
  address, the resulting address is undefined in cases where the generic address does not fall within
the address window of the specified state space. A program may use
  <span class="pre">
   isspacep
  </span>
  to guard against
such incorrect behavior.
 </p>
 <p>
  For
  <span class="pre">
   cvta
  </span>
  with
  <span class="pre">
   .shared
  </span>
  state space, the address must belong to the space specified by
  <span class="pre">
   ::cta
  </span>
  or
  <span class="pre">
   ::cluster
  </span>
  sub-qualifier, otherwise the behavior is undefined. If no sub-qualifier
is specified with
  <span class="pre">
   .shared
  </span>
  state space, then
  <span class="pre">
   ::cta
  </span>
  is assumed by default.
 </p>
 <p>
  If
  <span class="pre">
   .param
  </span>
  is specified without any sub-qualifiers then it defaults to
  <span class="pre">
   .param::entry
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0.
 </p>
 <p>
  <span class="pre">
   cvta.const
  </span>
  and
  <span class="pre">
   cvta.to.const
  </span>
  introduced in PTX ISA version 3.1.
 </p>
 <p>
  <span class="pre">
   cvta.param
  </span>
  and
  <span class="pre">
   cvta.to.param
  </span>
  introduced in PTX ISA version 7.7.
 </p>
 <p>
  Note:
  The current implementation does not allow generic pointers to
  <span class="pre">
   const
  </span>
  space variables in
programs that contain pointers to constant buffers passed as kernel parameters.
 </p>
 <p>
  Support for
  <span class="pre">
   ::cta
  </span>
  and
  <span class="pre">
   ::cluster
  </span>
  sub-qualifiers introduced in PTX ISA version 7.8.
 </p>
 <p>
  Support for sub-qualifier
  <span class="pre">
   ::entry
  </span>
  on
  <span class="pre">
   .param
  </span>
  space introduced in PTX ISA version 8.3.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   cvta
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   cvta.param{::entry}
  </span>
  and
  <span class="pre">
   cvta.to.param{::entry}
  </span>
  requires
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  Sub-qualifier
  <span class="pre">
   ::cta
  </span>
  requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Sub-qualifier
  <span class="pre">
   ::cluster
  </span>
  requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>cvta.const.u32   ptr,cvar;
cvta.local.u32   ptr,lptr;
cvta.shared::cta.u32  p,As+4;
cvta.shared::cluster.u32 ptr, As;
cvta.to.global.u32  p,gptr;
cvta.param.u64   ptr,pvar;
cvta.to.param::entry.u64  epptr, ptr;
</pre>
 <h4>
  <span class="section-number">
   9.7.8.20.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cvt">
   Data Movement and Conversion Instructions: cvt
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cvt" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  cvt
 </p>
 <p>
  Convert a value from one type to another.
 </p>
 <p>
  Syntax
 </p>
 <pre>cvt{.irnd}{.ftz}{.sat}.dtype.atype         d, a;  // integer rounding
cvt{.frnd}{.ftz}{.sat}.dtype.atype         d, a;  // fp rounding
cvt.frnd2{.relu}{.satfinite}.f16.f32       d, a;
cvt.frnd2{.relu}{.satfinite}.f16x2.f32     d, a, b;
cvt.frnd2{.relu}{.satfinite}.bf16.f32      d, a;
cvt.frnd2{.relu}{.satfinite}.bf16x2.f32    d, a, b;
cvt.rna{.satfinite}.tf32.f32               d, a;
cvt.frnd2{.relu}.tf32.f32                  d, a;
cvt.rn.satfinite{.relu}.f8x2type.f32       d, a, b;
cvt.rn.satfinite{.relu}.f8x2type.f16x2     d, a;
cvt.rn.{.relu}.f16x2.f8x2type              d, a;

.irnd   = { .rni, .rzi, .rmi, .rpi };
.frnd   = { .rn,  .rz,  .rm,  .rp  };
.frnd2  = { .rn,  .rz };
.dtype = .atype = { .u8,   .u16, .u32, .u64,
                    .s8,   .s16, .s32, .s64,
                    .bf16, .f16, .f32, .f64 };
.f8x2type = { .e4m3x2, .e5m2x2 };
</pre>
 <p>
  Description
 </p>
 <p>
  Convert between different types and sizes.
 </p>
 <p>
  For
  <span class="pre">
   .f16x2
  </span>
  and
  <span class="pre">
   .bf16x2
  </span>
  instruction type, two inputs
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  of
  <span class="pre">
   .f32
  </span>
  type are
converted into
  <span class="pre">
   .f16
  </span>
  or
  <span class="pre">
   .bf16
  </span>
  type and the converted values are packed in the destination
register
  <span class="pre">
   d
  </span>
  , such that the value converted from input
  <span class="pre">
   a
  </span>
  is stored in the upper half of
  <span class="pre">
   d
  </span>
  and the value converted from input
  <span class="pre">
   b
  </span>
  is stored in the lower half of
  <span class="pre">
   d
  </span>
 </p>
 <p>
  For
  <span class="pre">
   .f16x2
  </span>
  instruction type, destination operand
  <span class="pre">
   d
  </span>
  has
  <span class="pre">
   .f16x2
  </span>
  or
  <span class="pre">
   .b32
  </span>
  type. For
  <span class="pre">
   .bf16
  </span>
  instruction type, operand
  <span class="pre">
   d
  </span>
  has
  <span class="pre">
   .b16
  </span>
  type. For
  <span class="pre">
   .bf16x2
  </span>
  instruction type,
operand
  <span class="pre">
   d
  </span>
  has
  <span class="pre">
   .b32
  </span>
  type. For
  <span class="pre">
   .tf32
  </span>
  instruction type, operand
  <span class="pre">
   d
  </span>
  has
  <span class="pre">
   .b32
  </span>
  type.
 </p>
 <p>
  When converting to
  <span class="pre">
   .e4m3x2
  </span>
  /
  <span class="pre">
   .e5m2x2
  </span>
  data formats, the destination operand
  <span class="pre">
   d
  </span>
  has
  <span class="pre">
   .b16
  </span>
  type. When converting two
  <span class="pre">
   .f32
  </span>
  inputs to
  <span class="pre">
   .e4m3x2
  </span>
  /
  <span class="pre">
   .e5m2x2
  </span>
  , each input is converted to the
specified format, and the converted values are packed in the destination operand
  <span class="pre">
   d
  </span>
  such that the
value converted from input
  <span class="pre">
   a
  </span>
  is stored in the upper 8 bits of
  <span class="pre">
   d
  </span>
  and the value converted from
input
  <span class="pre">
   b
  </span>
  is stored in the lower 8 bits of
  <span class="pre">
   d
  </span>
  . When converting an
  <span class="pre">
   .f16x2
  </span>
  input to
  <span class="pre">
   .e4m3x2
  </span>
  /
  <span class="pre">
   .e5m2x2
  </span>
  , each
  <span class="pre">
   .f16
  </span>
  input from operand
  <span class="pre">
   a
  </span>
  is converted to the specified
format. The converted values are packed in the destination operand
  <span class="pre">
   d
  </span>
  such that the value
converted from the upper 16 bits of input
  <span class="pre">
   a
  </span>
  is stored in the upper 8 bits of
  <span class="pre">
   d
  </span>
  and the value
converted from the lower 16 bits of input
  <span class="pre">
   a
  </span>
  is stored in the lower 8 bits of
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  When converting from
  <span class="pre">
   .e4m3x2
  </span>
  /
  <span class="pre">
   .e5m2x2
  </span>
  to
  <span class="pre">
   .f16x2
  </span>
  , source operand
  <span class="pre">
   a
  </span>
  has
  <span class="pre">
   .b16
  </span>
  type. Each 8-bit input value in operand
  <span class="pre">
   a
  </span>
  is converted to
  <span class="pre">
   .f16
  </span>
  type. The converted values
are packed in the destination operand
  <span class="pre">
   d
  </span>
  such that the value converted from the upper 8 bits of
  <span class="pre">
   a
  </span>
  is stored in the upper 16 bits of
  <span class="pre">
   d
  </span>
  and the value converted from the lower 8 bits of
  <span class="pre">
   a
  </span>
  is stored in the lower 16 bits of
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  Rounding modifier is mandatory in all of the following cases:
 </p>
 <ul class="simple">
  <li>
   <p>
    float-to-float conversions, when destination type is smaller than source type
   </p>
  </li>
  <li>
   <p>
    All float-to-int conversions
   </p>
  </li>
  <li>
   <p>
    All int-to-float conversions
   </p>
  </li>
  <li>
   <p>
    All conversions involving
    <span class="pre">
     .f16x2
    </span>
    ,
    <span class="pre">
     .e4m3x2,
    </span>
    <span class="pre">
     .e5m2x2,
    </span>
    <span class="pre">
     .bf16x2
    </span>
    and
    <span class="pre">
     .tf32
    </span>
    instruction
types.
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   .satfinite
  </span>
  modifier is only supported for conversions involving the following types:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     .e4m3x2
    </span>
    and
    <span class="pre">
     .e5m2x2
    </span>
    destination types.
    <span class="pre">
     .satfinite
    </span>
    modifier is mandatory for such
conversions.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .f16
    </span>
    ,
    <span class="pre">
     .bf16
    </span>
    ,
    <span class="pre">
     .f16x2
    </span>
    ,
    <span class="pre">
     .bf16x2
    </span>
    as destination types.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .tf32
    </span>
    as destination type with rounding mode specified as round to nearest, ties away from
zero.
   </p>
  </li>
 </ul>
 <p>
  Semantics
 </p>
 <pre>if (/* inst type is .f16x2 or .bf16x2 */) {
    d[31:16] = convert(a);
    d[15:0]  = convert(b);
} else {
    d = convert(a);
}
</pre>
 <p>
  Integer Notes
 </p>
 <p>
  Integer rounding is required for float-to-integer conversions, and for same-size float-to-float
conversions where the value is rounded to an integer. Integer rounding is illegal in all other
instances.
 </p>
 <p>
  Integer rounding modifiers:
 </p>
 <span class="pre">
  .rni
 </span>
 <p>
  round to nearest integer, choosing even integer if source is equidistant between two integers
 </p>
 <span class="pre">
  .rzi
 </span>
 <p>
  round to nearest integer in the direction of zero
 </p>
 <span class="pre">
  .rmi
 </span>
 <p>
  round to nearest integer in direction of negative infinity
 </p>
 <span class="pre">
  .rpi
 </span>
 <p>
  round to nearest integer in direction of positive infinity
 </p>
 <p>
  In float-to-integer conversion,
  <span class="pre">
   NaN
  </span>
  inputs are converted to 0.
 </p>
 <p>
  Subnormal numbers:
 </p>
 <span class="pre">
  sm_20+
 </span>
 <p>
  By default, subnormal numbers are supported.
 </p>
 <p>
  For
  <span class="pre">
   cvt.ftz.dtype.f32
  </span>
  float-to-integer conversions and
  <span class="pre">
   cvt.ftz.f32.f32
  </span>
  float-to-float
conversions with integer rounding, subnormal inputs are flushed to sign-preserving zero. Modifier
  <span class="pre">
   .ftz
  </span>
  can only be specified when either
  <span class="pre">
   .dtype
  </span>
  or
  <span class="pre">
   .atype
  </span>
  is
  <span class="pre">
   .f32
  </span>
  and applies only
to single precision (
  <span class="pre">
   .f32
  </span>
  ) inputs and results.
 </p>
 <span class="pre">
  sm_1x
 </span>
 <p>
  For
  <span class="pre">
   cvt.ftz.dtype.f32
  </span>
  float-to-integer conversions and
  <span class="pre">
   cvt.ftz.f32.f32
  </span>
  float-to-float conversions with integer rounding, subnormal inputs are flushed to sign-preserving
zero. The optional
  <span class="pre">
   .ftz
  </span>
  modifier may be specified in these cases for clarity.
 </p>
 <p>
  Note:
  In PTX ISA versions 1.4 and earlier, the
  <span class="pre">
   cvt
  </span>
  instruction did not flush single-precision
subnormal inputs or results to zero if the destination type size was 64-bits. The compiler will
preserve this behavior for legacy PTX code.
 </p>
 <p>
  Saturation modifier:
 </p>
 <span class="pre">
  .sat
 </span>
 <p>
  For integer destination types,
  <span class="pre">
   .sat
  </span>
  limits the result to
  <span class="pre">
   MININT..MAXINT
  </span>
  for the size of
the operation. Note that saturation applies to both signed and unsigned integer types.
 </p>
 <p>
  The saturation modifier is allowed only in cases where the destination typeâs value range is not
a superset of the source typeâs value range; i.e., the
  <span class="pre">
   .sat
  </span>
  modifier is illegal in cases
where saturation is not possible based on the source and destination types.
 </p>
 <p>
  For float-to-integer conversions, the result is clamped to the destination range by default; i.e,
  <span class="pre">
   .sat
  </span>
  is redundant.
 </p>
 <p>
  Floating Point Notes
 </p>
 <p>
  Floating-point rounding is required for float-to-float conversions that result in loss of precision,
and for integer-to-float conversions. Floating-point rounding is illegal in all other instances.
 </p>
 <p>
  Floating-point rounding modifiers:
 </p>
 <span class="pre">
  .rn
 </span>
 <p>
  mantissa LSB rounds to nearest even
 </p>
 <span class="pre">
  .rna
 </span>
 <p>
  mantissa LSB rounds to nearest, ties away from zero
 </p>
 <span class="pre">
  .rz
 </span>
 <p>
  mantissa LSB rounds towards zero
 </p>
 <span class="pre">
  .rm
 </span>
 <p>
  mantissa LSB rounds towards negative infinity
 </p>
 <span class="pre">
  .rp
 </span>
 <p>
  mantissa LSB rounds towards positive infinity
 </p>
 <p>
  A floating-point value may be rounded to an integral value using the integer rounding modifiers (see
Integer Notes). The operands must be of the same size. The result is an integral value, stored in
floating-point format.
 </p>
 <p>
  Subnormal numbers:
 </p>
 <span class="pre">
  sm_20+
 </span>
 <p>
  By default, subnormal numbers are supported. Modifier
  <span class="pre">
   .ftz
  </span>
  may be specified to flush
single-precision subnormal inputs and results to sign-preserving zero. Modifier
  <span class="pre">
   .ftz
  </span>
  can only
be specified when either
  <span class="pre">
   .dtype
  </span>
  or
  <span class="pre">
   .atype
  </span>
  is
  <span class="pre">
   .f32
  </span>
  and applies only to single
precision (
  <span class="pre">
   .f32
  </span>
  ) inputs and results.
 </p>
 <span class="pre">
  sm_1x
 </span>
 <p>
  Single-precision subnormal inputs and results are flushed to sign-preserving zero. The optional
  <span class="pre">
   .ftz
  </span>
  modifier may be specified in these cases for clarity.
 </p>
 <p>
  Note:
  In PTX ISA versions 1.4 and earlier, the
  <span class="pre">
   cvt
  </span>
  instruction did not flush
single-precision subnormal inputs or results to zero if either source or destination type was
  <span class="pre">
   .f64
  </span>
  . The compiler will preserve this behavior for legacy PTX code. Specifically, if the PTX
ISA version is 1.4 or earlier, single-precision subnormal inputs and results are flushed to
sign-preserving zero only for
  <span class="pre">
   cvt.f32.f16
  </span>
  ,
  <span class="pre">
   cvt.f16.f32
  </span>
  , and
  <span class="pre">
   cvt.f32.f32
  </span>
  instructions.
 </p>
 <p>
  Saturation modifier:
 </p>
 <span class="pre">
  .sat
 </span>
 :
 <p>
  For floating-point destination types,
  <span class="pre">
   .sat
  </span>
  limits the result to the range [0.0, 1.0].
  <span class="pre">
   NaN
  </span>
  results are flushed to positive zero. Applies to
  <span class="pre">
   .f16
  </span>
  ,
  <span class="pre">
   .f32
  </span>
  , and
  <span class="pre">
   .f64
  </span>
  types.
 </p>
 <span class="pre">
  .relu
 </span>
 :
 <p>
  For
  <span class="pre">
   .f16
  </span>
  ,
  <span class="pre">
   .f16x2
  </span>
  ,
  <span class="pre">
   .bf16
  </span>
  ,
  <span class="pre">
   .bf16x2
  </span>
  ,
  <span class="pre">
   .e4m3x2
  </span>
  ,
  <span class="pre">
   .e5m2x2
  </span>
  and
  <span class="pre">
   .tf32
  </span>
  destination types,
  <span class="pre">
   .relu
  </span>
  clamps the result to 0 if negative.
  <span class="pre">
   NaN
  </span>
  results are converted to
canonical
  <span class="pre">
   NaN
  </span>
  .
 </p>
 <span class="pre">
  .satfinite
 </span>
 :
 <p>
  For
  <span class="pre">
   .f16
  </span>
  ,
  <span class="pre">
   .f16x2
  </span>
  ,
  <span class="pre">
   .bf16
  </span>
  ,
  <span class="pre">
   .bf16x2
  </span>
  ,
  <span class="pre">
   .e4m3x2
  </span>
  ,
  <span class="pre">
   .e5m2x2
  </span>
  and
  <span class="pre">
   .tf32
  </span>
  destination formats, if the input value is
  <span class="pre">
   NaN
  </span>
  , then the result is
  <span class="pre">
   NaN
  </span>
  in the specified
destination format. If the absolute value of input (ignoring sign) is greater than
  MAX_NORM
  of
the specified destination format, then the result is sign-preserved
  MAX_NORM
  of the destination
format.
 </p>
 <p>
  Notes
 </p>
 <p>
  A source register wider than the specified type may be used, except when the source operand has
  <span class="pre">
   .bf16
  </span>
  or
  <span class="pre">
   .bf16x2
  </span>
  format. The lower
  <span class="pre">
   n
  </span>
  bits corresponding to the instruction-type width
are used in the conversion. See
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#operand-size-exceeding-instruction-type-size">
   Operand Size Exceeding Instruction-Type Size
  </a>
  for a description of these relaxed
type-checking rules.
 </p>
 <p>
  A destination register wider than the specified type may be used, except when the destination
operand has
  <span class="pre">
   .bf16
  </span>
  ,
  <span class="pre">
   .bf16x2
  </span>
  or
  <span class="pre">
   .tf32
  </span>
  format. The result of conversion is sign-extended to
the destination register width for signed integers, and is zero-extended to the destination register
width for unsigned, bit-size, and floating-point types. See
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#operand-size-exceeding-instruction-type-size">
   Operand Size Exceeding Instruction-Type
Size
  </a>
  for a description of these relaxed
type-checking rules.
 </p>
 <p>
  For
  <span class="pre">
   cvt.f32.bf16
  </span>
  ,
  <span class="pre">
   NaN
  </span>
  input yields unspecified
  <span class="pre">
   NaN
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  <span class="pre">
   .relu
  </span>
  modifier and {
  <span class="pre">
   .f16x2
  </span>
  ,
  <span class="pre">
   .bf16
  </span>
  ,
  <span class="pre">
   .bf16x2
  </span>
  ,
  <span class="pre">
   .tf32
  </span>
  } destination formats
introduced in PTX ISA version 7.0.
 </p>
 <p>
  <span class="pre">
   cvt.bf16.{u8/s8/u16/s16/u32/s32/u64/s64/f16/f64/bf16}
  </span>
  ,
  <span class="pre">
   cvt.{u8/s8/u16/s16/u32/s32/u64/s64/f16/f64}.bf16
  </span>
  , and
  <span class="pre">
   cvt.tf32.f32.{relu}.{rn/rz}
  </span>
  introduced
in PTX ISA 7.8.
 </p>
 <p>
  <span class="pre">
   cvt
  </span>
  with
  <span class="pre">
   .e4m3x2
  </span>
  /
  <span class="pre">
   .e5m2x2
  </span>
  for
  <span class="pre">
   sm_90
  </span>
  or higher introduced in PTX ISA version 7.8.
 </p>
 <p>
  <span class="pre">
   cvt.satfinite.{e4m3x2,
  </span>
  <span class="pre">
   e5m2x2}.{f32,
  </span>
  <span class="pre">
   f16x2}
  </span>
  for
  <span class="pre">
   sm_90
  </span>
  or higher introduced in PTX ISA version 7.8.
 </p>
 <p>
  <span class="pre">
   cvt
  </span>
  with
  <span class="pre">
   .e4m3x2
  </span>
  /
  <span class="pre">
   .e5m2x2
  </span>
  for
  <span class="pre">
   sm_89
  </span>
  introduced in PTX ISA version 8.1.
 </p>
 <p>
  <span class="pre">
   cvt.satfinite.{e4m3x2,
  </span>
  <span class="pre">
   e5m2x2}.{f32,
  </span>
  <span class="pre">
   f16x2}
  </span>
  for
  <span class="pre">
   sm_89
  </span>
  introduced in PTX ISA version 8.1.
 </p>
 <p>
  <span class="pre">
   cvt.satfinite.{f16,
  </span>
  <span class="pre">
   bf16,
  </span>
  <span class="pre">
   f16x2,
  </span>
  <span class="pre">
   bf16x2,
  </span>
  <span class="pre">
   tf32}.f32
  </span>
  introduced in PTX ISA version 8.1.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   cvt
  </span>
  to or from
  <span class="pre">
   .f64
  </span>
  requires
  <span class="pre">
   sm_13
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   .relu
  </span>
  modifier and {
  <span class="pre">
   .f16x2
  </span>
  ,
  <span class="pre">
   .bf16
  </span>
  ,
  <span class="pre">
   .bf16x2
  </span>
  ,
  <span class="pre">
   .tf32
  </span>
  } destination formats require
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   cvt.bf16.{u8/s8/u16/s16/u32/s32/u64/s64/f16/f64/bf16}
  </span>
  ,
  <span class="pre">
   cvt.{u8/s8/u16/s16/u32/s32/u64/s64/f16/f64}.bf16
  </span>
  , and
  <span class="pre">
   cvt.tf32.f32.{relu}.{rn/rz}
  </span>
  require
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   cvt
  </span>
  with
  <span class="pre">
   .e4m3x2
  </span>
  /
  <span class="pre">
   .e5m2x2
  </span>
  requires
  <span class="pre">
   sm89
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   cvt.satfinite.{e4m3x2,
  </span>
  <span class="pre">
   e5m2x2}.{f32,
  </span>
  <span class="pre">
   f16x2}
  </span>
  requires
  <span class="pre">
   sm_89
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>cvt.f32.s32 f,i;
cvt.s32.f64 j,r;     // float-to-int saturates by default
cvt.rni.f32.f32 x,y; // round to nearest int, result is fp
cvt.f32.f32 x,y;     // note .ftz behavior for sm_1x targets
cvt.rn.relu.f16.f32      b, f;        // result is saturated with .relu saturation mode
cvt.rz.f16x2.f32         b1, f, f1;   // convert two fp32 values to packed fp16 outputs
cvt.rn.relu.satfinite.f16x2.f32    b1, f, f1;   // convert two fp32 values to packed fp16 outputs with .relu saturation on each output
cvt.rn.bf16.f32          b, f;        // convert fp32 to bf16
cvt.rz.relu.satfinite.bf16.f3 2    b, f;        // convert fp32 to bf16 with .relu and .satfinite saturation
cvt.rz.satfinite.bf16x2.f32        b1, f, f1;   // convert two fp32 values to packed bf16 outputs
cvt.rn.relu.bf16x2.f32   b1, f, f1;   // convert two fp32 values to packed bf16 outputs with .relu saturation on each output
cvt.rna.satfinite.tf32.f32         b1, f;       // convert fp32 to tf32 format
cvt.rn.relu.tf32.f32     d, a;        // convert fp32 to tf32 format
cvt.f64.bf16.rp          f, b;        // convert bf16 to f64 format
cvt.bf16.f16.rz          b, f         // convert f16 to bf16 format
cvt.bf16.u64.rz          b, u         // convert u64 to bf16 format
cvt.s8.bf16.rpi          s, b         // convert bf16 to s8 format
cvt.bf16.bf16.rpi        b1, b2       // convert bf16 to corresponding int represented in bf16 format
cvt.rn.satfinite.e4m3x2.f32 d, a, b;  // convert a, b to .e4m3 and pack as .e4m3x2 output
cvt.rn.relu.satfinite.e5m2x2.f16x2 d, a; // unpack a and convert the values to .e5m2 outputs with .relu
                                         // saturation on each output and pack as .e5m2x2
cvt.rn.f16x2.e4m3x2 d, a;             // unpack a, convert two .e4m3 values to packed f16x2 output
</pre>
 <h4>
  <span class="section-number">
   9.7.8.21.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cvt-pack">
   Data Movement and Conversion Instructions: cvt.pack
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cvt-pack" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  cvt.pack
 </p>
 <p>
  Convert two integer values from one integer type to another and pack the results.
 </p>
 <p>
  Syntax
 </p>
 <pre>cvt.pack.sat.convertType.abType  d, a, b;
    .convertType  = { .u16, .s16 }
    .abType       = { .s32 }

cvt.pack.sat.convertType.abType.cType  d, a, b, c;
    .convertType  = { .u2, .s2, .u4, .s4, .u8, .s8 }
    .abType       = { .s32 }
    .cType        = { .b32 }
</pre>
 <p>
  Description
 </p>
 <p>
  Convert two 32-bit integers
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  into specified type and pack the results into
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  Destination
  <span class="pre">
   d
  </span>
  is an unsigned 32-bit integer. Source operands
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  are integers of
type
  <span class="pre">
   .abType
  </span>
  and the source operand
  <span class="pre">
   c
  </span>
  is an integer of type
  <span class="pre">
   .cType
  </span>
  .
 </p>
 <p>
  The inputs
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  are converted to values of type specified by
  <span class="pre">
   .convertType
  </span>
  with
saturation and the results after conversion are packed into lower bits of
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  If operand
  <span class="pre">
   c
  </span>
  is specified then remaining bits of
  <span class="pre">
   d
  </span>
  are copied from lower bits of
  <span class="pre">
   c
  </span>
  .
 </p>
 <p>
  Semantics
 </p>
 <pre>ta = a &lt; MIN(convertType) ? MIN(convertType) : a;
ta = a &gt; MAX(convertType) ? MAX(convertType) : a;
tb = b &lt; MIN(convertType) ? MIN(convertType) : b;
tb = b &gt; MAX(convertType) ? MAX(convertType) : b;

size = sizeInBits(convertType);
td = tb ;
for (i = size; i &lt;= 2 * size - 1; i++) {
    td[i] = ta[i - size];
}

if (isU16(convertType) || isS16(convertType)) {
    d = td;
} else {
    for (i = 0; i &lt; 2 * size; i++) {
        d[i] = td[i];
    }
    for (i = 2 * size; i &lt;= 31; i++) {
        d[i] = c[i - 2 * size];
    }
}
</pre>
 <p>
  <span class="pre">
   .sat
  </span>
  modifier limits the converted values to
  <span class="pre">
   MIN(convertType)
  </span>
  ..
  <span class="pre">
   MAX(convertedType)
  </span>
  (no
overflow) if the corresponding inputs are not in the range of datatype specified as
  <span class="pre">
   .convertType
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 6.5.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_72
  </span>
  or higher.
 </p>
 <p>
  Sub byte types (
  <span class="pre">
   .u4
  </span>
  /
  <span class="pre">
   .s4
  </span>
  and
  <span class="pre">
   .u2
  </span>
  /
  <span class="pre">
   .s2
  </span>
  ) requires
  <span class="pre">
   sm_75
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>cvt.pack.sat.s16.s32      %r1, %r2, %r3;           // 32-bit to 16-bit conversion
cvt.pack.sat.u8.s32.b32   %r4, %r5, %r6, 0;        // 32-bit to 8-bit conversion
cvt.pack.sat.u8.s32.b32   %r7, %r8, %r9, %r4;      // %r7 = { %r5, %r6, %r8, %r9 }
cvt.pack.sat.u4.s32.b32   %r10, %r12, %r13, %r14;  // 32-bit to 4-bit conversion
cvt.pack.sat.s2.s32.b32   %r15, %r16, %r17, %r18;  // 32-bits to 2-bit conversion
</pre>
 <h4>
  <span class="section-number">
   9.7.8.22.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-mapa">
   Data Movement and Conversion Instructions: mapa
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-mapa" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  mapa
 </p>
 <p>
  Map the address of the shared variable in the target CTA.
 </p>
 <p>
  Syntax
 </p>
 <pre>mapa{.space}.type          d, a, b;

// Maps shared memory address in register a into CTA b.
mapa.shared::cluster.type  d, a, b;

// Maps shared memory variable into CTA b.
mapa.shared::cluster.type  d, sh, b;

// Maps shared memory variable into CTA b.
mapa.shared::cluster.type  d, sh + imm, b;

// Maps generic address in register a into CTA b.
mapa.type                  d, a, b;

.space = { .shared::cluster }
.type  = { .u32, .u64 }
</pre>
 <p>
  Description
 </p>
 <p>
  Get address in the CTA specified by operand
  <span class="pre">
   b
  </span>
  which corresponds to the address specified by
operand
  <span class="pre">
   a
  </span>
  .
 </p>
 <p>
  Instruction type
  <span class="pre">
   .type
  </span>
  indicates the type of the destination operand
  <span class="pre">
   d
  </span>
  and the source
operand
  <span class="pre">
   a
  </span>
  .
 </p>
 <p>
  When space is
  <span class="pre">
   .shared::cluster
  </span>
  , source
  <span class="pre">
   a
  </span>
  is either a shared memory variable or a register
containing a valid shared memory address and register
  <span class="pre">
   d
  </span>
  contains a shared memory address. When
the optional qualifier
  <span class="pre">
   .space
  </span>
  is not specified, both
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   d
  </span>
  are registers containing
generic addresses pointing to shared memory.
 </p>
 <p>
  <span class="pre">
   b
  </span>
  is a 32-bit integer operand representing the rank of the target CTA.
 </p>
 <p>
  Destination register
  <span class="pre">
   d
  </span>
  will hold an address in CTA
  <span class="pre">
   b
  </span>
  corresponding to operand
  <span class="pre">
   a
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.8.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>mapa.shared::cluster.u64 d1, %reg1, cta;
mapa.shared::cluster.u32 d2, sh, 3;
mapa.u64                 d3, %reg2, cta;
</pre>
 <h4>
  <span class="section-number">
   9.7.8.23.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-getctarank">
   Data Movement and Conversion Instructions: getctarank
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-getctarank" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  getctarank
 </p>
 <p>
  Generate the CTA rank of the address.
 </p>
 <p>
  Syntax
 </p>
 <pre>getctarank{.space}.type d, a;

// Get cta rank from source shared memory address in register a.
getctarank.shared::cluster.type d, a;

// Get cta rank from shared memory variable.
getctarank.shared::cluster.type d, var;

// Get cta rank from shared memory variable+offset.
getctarank.shared::cluster.type d, var + imm;

// Get cta rank from generic address of shared memory variable in register a.
getctarank.type d, a;

.space = { .shared::cluster }
.type  = { .u32, .u64 }
</pre>
 <p>
  Description
 </p>
 <p>
  Write the destination register
  <span class="pre">
   d
  </span>
  with the rank of the CTA which contains the address specified
in operand
  <span class="pre">
   a
  </span>
  .
 </p>
 <p>
  Instruction type
  <span class="pre">
   .type
  </span>
  indicates the type of source operand
  <span class="pre">
   a
  </span>
  .
 </p>
 <p>
  When space is
  <span class="pre">
   .shared::cluster
  </span>
  , source
  <span class="pre">
   a
  </span>
  is either a shared memory variable or a register
containing a valid shared memory address. When the optional qualifier
  <span class="pre">
   .space
  </span>
  is not specified,
  <span class="pre">
   a
  </span>
  is a register containing a generic addresses pointing to shared memory. Destination
  <span class="pre">
   d
  </span>
  is
always a 32-bit register which holds the rank of the CTA.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.8.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>getctarank.shared::cluster.u32 d1, addr;
getctarank.shared::cluster.u64 d2, sh + 4;
getctarank.u64                 d3, src;
</pre>
 <h4>
  <span class="section-number">
   9.7.8.24.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-asynchronous-copy">
   Data Movement and Conversion Instructions: Asynchronous copy
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-asynchronous-copy" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  An asynchronous copy operation performs the underlying operation asynchronously in the background,
thus allowing the issuing threads to perform subsequent tasks.
 </p>
 <p>
  An asynchronous copy operation can be a
  bulk
  operation that operates on a large amount of data, or
a
  non-bulk
  operation that operates on smaller sized data. The amount of data handled by a bulk
asynchronous operation must be a multiple of 16 bytes.
 </p>
 <h5>
  <span class="section-number">
   9.7.8.24.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-asynchronous-copy-completion-mechanisms">
   Completion Mechanisms for Asynchronous Copy Operations
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#completion-mechanisms-for-asynchronous-copy-operations" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  A thread must explicitly wait for the completion of an asynchronous copy operation in order to
access the result of the operation. Once an asynchronous copy operation is initiated, modifying the
source memory location or reading from the destination memory location before the asynchronous
operation completes, will cause unpredictable results.
 </p>
 <p>
  This section describes two asynchronous copy operation completion mechanisms supported in PTX:
Async-group mechanism and mbarrier-based mechanism.
 </p>
 <p>
  Async-group mechanism
 </p>
 <p>
  When using the async-group completion mechanism, the issuing thread specifies a group of
asynchronous operations, called
  async-group
  , using a
  commit
  operation and tracks the completion
of this group using a
  wait
  operation. The thread issuing the asynchronous operation must create
separate
  async-groups
  for bulk and non-bulk asynchronous operations.
 </p>
 <p>
  A
  commit
  operation creates a per-thread
  async-group
  containing all prior asynchronous operations
initiated by the executing thread but none of the asynchronous operations following the commit
operation. A committed asynchronous operation belongs to a single
  async-group
  .
 </p>
 <p>
  When an
  async-group
  completes, all the asynchronous operations belonging to that group are
complete and the executing thread that initiated the asynchronous operations can read the result of
the asynchronous operations. All
  async-groups
  committed by an executing thread always complete in
the order in which they were committed. There is no ordering between asynchronous operations within
an
  async-group
  .
 </p>
 <p>
  A typical pattern of using
  async-group
  as the completion mechanism is as follows:
 </p>
 <ul class="simple">
  <li>
   <p>
    Initiate the asynchronous operations.
   </p>
  </li>
  <li>
   <p>
    Group the asynchronous operations into an
    async-group
    using a
    commit
    operation.
   </p>
  </li>
  <li>
   <p>
    Wait for the completion of the async-group using the wait operation.
   </p>
  </li>
  <li>
   <p>
    Once the
    async-group
    completes, access the results of all asynchronous operations in that
    async-group
    .
   </p>
  </li>
 </ul>
 <p>
  Mbarrier-based mechanism
 </p>
 <p>
  A thread can track the completion of one or more asynchronous operations using the current phase of
an
  mbarrier object
  . When the current phase of the
  mbarrier object
  is complete, it implies that
all asynchronous operations tracked by this phase are complete, and all threads participating in
that
  mbarrier object
  can access the result of the asynchronous operations.
 </p>
 <p>
  The
  mbarrier object
  to be used for tracking the completion of an asynchronous operation can be
either specified along with the asynchronous operation as part of its syntax, or as a separate
operation. For a bulk asynchronous operation, the
  mbarrier object
  must be specified in the
asynchronous operation, whereas for non-bulk operations, it can be specified after the asynchronous
operation.
 </p>
 <p>
  A typical pattern of using mbarrier-based completion mechanism is as follows:
 </p>
 <ul class="simple">
  <li>
   <p>
    Initiate the asynchronous operations.
   </p>
  </li>
  <li>
   <p>
    Set up an
    mbarrier object
    to track the asynchronous operations in its current phase, either as
part of the asynchronous operation or as a separate operation.
   </p>
  </li>
  <li>
   <p>
    Wait for the
    mbarrier object
    to complete its current phase using
    <span class="pre">
     mbarrier.test_wait
    </span>
    or
    <span class="pre">
     mbarrier.try_wait
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Once the
    <span class="pre">
     mbarrier.test_wait
    </span>
    or
    <span class="pre">
     mbarrier.try_wait
    </span>
    operation returns
    <span class="pre">
     True
    </span>
    , access the
results of the asynchronous operations tracked by the
    mbarrier object
    .
   </p>
  </li>
 </ul>
 <h5>
  <span class="section-number">
   9.7.8.24.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#async-proxy">
   Async Proxy
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#async-proxy" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  The
  <span class="pre">
   cp{.reduce}.async.bulk
  </span>
  operations are performed in the
  asynchronous proxy
  (or
  async
proxy
  ).
 </p>
 <p>
  Accessing the same memory location across multiple proxies needs a cross-proxy fence. For the
  async proxy
  ,
  <span class="pre">
   fence.proxy.async
  </span>
  should be used to synchronize memory between
  generic
proxy
  and the
  async proxy
  .
 </p>
 <p>
  The completion of a
  <span class="pre">
   cp{.reduce}.async.bulk
  </span>
  operation is followed by an implicit
  generic-async
  proxy fence. So the result of the asynchronous operation is made visible to the generic proxy as
soon as its completion is observed.
  Async-group
  OR
  mbarrier-based
  completion mechanism must
be used to wait for the completion of the
  <span class="pre">
   cp{.reduce}.async.bulk
  </span>
  instructions.
 </p>
 <h5>
  <span class="section-number">
   9.7.8.24.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async">
   Data Movement and Conversion Instructions: cp.async
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  cp.async
 </p>
 <p>
  Initiates an asynchronous copy operation from one state space to another.
 </p>
 <p>
  Syntax
 </p>
 <pre>cp.async.ca.shared{::cta}.global{.level::cache_hint}{.level::prefetch_size}
                         [dst], [src], cp-size{, src-size}{, cache-policy} ;
cp.async.cg.shared{::cta}.global{.level::cache_hint}{.level::prefetch_size}
                         [dst], [src], 16{, src-size}{, cache-policy} ;
cp.async.ca.shared{::cta}.global{.level::cache_hint}{.level::prefetch_size}
                         [dst], [src], cp-size{, ignore-src}{, cache-policy} ;
cp.async.cg.shared{::cta}.global{.level::cache_hint}{.level::prefetch_size}
                         [dst], [src], 16{, ignore-src}{, cache-policy} ;

.level::cache_hint =     { .L2::cache_hint }
.level::prefetch_size =  { .L2::64B, .L2::128B, .L2::256B }
cp-size =                { 4, 8, 16 }
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   cp.async
  </span>
  is a non-blocking instruction which initiates an asynchronous copy operation of data
from the location specified by source address operand
  <span class="pre">
   src
  </span>
  to the location specified by
destination address operand
  <span class="pre">
   dst
  </span>
  . Operand
  <span class="pre">
   src
  </span>
  specifies a location in the global state space
and
  <span class="pre">
   dst
  </span>
  specifies a location in the shared state space.
 </p>
 <p>
  Operand
  <span class="pre">
   cp-size
  </span>
  is an integer constant which specifies the size of data in bytes to be copied to
the destination
  <span class="pre">
   dst
  </span>
  .
  <span class="pre">
   cp-size
  </span>
  can only be 4, 8 and 16.
 </p>
 <p>
  Instruction
  <span class="pre">
   cp.async
  </span>
  allows optionally specifying a 32-bit integer operand
  <span class="pre">
   src-size
  </span>
  . Operand
  <span class="pre">
   src-size
  </span>
  represents the size of the data in bytes to be copied from
  <span class="pre">
   src
  </span>
  to
  <span class="pre">
   dst
  </span>
  and must
be less than
  <span class="pre">
   cp-size
  </span>
  . In such case, remaining bytes in destination
  <span class="pre">
   dst
  </span>
  are filled with
zeros. Specifying
  <span class="pre">
   src-size
  </span>
  larger than
  <span class="pre">
   cp-size
  </span>
  results in undefined behavior.
 </p>
 <p>
  The optional and non-immediate predicate argument
  <span class="pre">
   ignore-src
  </span>
  specifies whether the data from the
source location
  <span class="pre">
   src
  </span>
  should be ignored completely. If the source data is ignored then zeros will
be copied to destination
  <span class="pre">
   dst
  </span>
  . If the argument
  <span class="pre">
   ignore-src
  </span>
  is not specified then it defaults
to
  <span class="pre">
   False
  </span>
  .
 </p>
 <p>
  Supported alignment requirements and addressing modes for operand
  <span class="pre">
   src
  </span>
  and
  <span class="pre">
   dst
  </span>
  are described
in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#addresses-as-operands">
   Addresses as Operands
  </a>
  .
 </p>
 <p>
  The mandatory
  <span class="pre">
   .async
  </span>
  qualifier indicates that the
  <span class="pre">
   cp
  </span>
  instruction will initiate the memory
copy operation asynchronously and control will return to the executing thread before the copy
operation is complete. The executing thread can then use
  <span class="pre">
   cp.async.wait_all
  </span>
  or
  <span class="pre">
   cp.async.wait_group
  </span>
  or
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier">
   mbarrier instructions
  </a>
  to wait for
completion of the asynchronous copy operation. No other synchronization mechanisms described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory Consistency Model
  </a>
  can be used to guarantee the
completion of the asynchronous copy operations.
 </p>
 <p>
  There is no ordering guarantee between two
  <span class="pre">
   cp.async
  </span>
  operations if they are not explicitly
synchronized using
  <span class="pre">
   cp.async.wait_all
  </span>
  or
  <span class="pre">
   cp.async.wait_group
  </span>
  or
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier">
   mbarrier instructions
  </a>
  .
 </p>
 <p>
  As described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#cache-operators">
   Cache Operators
  </a>
  , the
  <span class="pre">
   .cg
  </span>
  qualifier indicates
caching of data only at global level cache L2 and not at L1 whereas
  <span class="pre">
   .ca
  </span>
  qualifier indicates
caching of data at all levels including L1 cache. Cache operator are treated as performance hints
only.
 </p>
 <p>
  <span class="pre">
   cp.async
  </span>
  is treated as a weak memory operation in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory Consistency Model
  </a>
  .
 </p>
 <p>
  The
  <span class="pre">
   .level::prefetch_size
  </span>
  qualifier is a hint to fetch additional data of the specified size
into the respective cache level.The sub-qualifier
  <span class="pre">
   prefetch_size
  </span>
  can be set to either of
  <span class="pre">
   64B
  </span>
  ,
  <span class="pre">
   128B
  </span>
  ,
  <span class="pre">
   256B
  </span>
  thereby allowing the prefetch size to be 64 Bytes, 128 Bytes or 256 Bytes
respectively.
 </p>
 <p>
  The qualifier
  <span class="pre">
   .level::prefetch_size
  </span>
  may only be used with
  <span class="pre">
   .global
  </span>
  state space and with
generic addressing where the address points to
  <span class="pre">
   .global
  </span>
  state space. If the generic address does
not fall within the address window of the global memory, then the prefetching behavior is undefined.
 </p>
 <p>
  The
  <span class="pre">
   .level::prefetch_size
  </span>
  qualifier is treated as a performance hint only.
 </p>
 <p>
  When the optional argument
  <span class="pre">
   cache-policy
  </span>
  is specified, the qualifier
  <span class="pre">
   .level::cache_hint
  </span>
  is
required. The 64-bit operand
  <span class="pre">
   cache-policy
  </span>
  specifies the cache eviction policy that may be used
during the memory access.
 </p>
 <p>
  The qualifier
  <span class="pre">
   .level::cache_hint
  </span>
  is only supported for
  <span class="pre">
   .global
  </span>
  state space and for generic
addressing where the address points to the
  <span class="pre">
   .global
  </span>
  state space.
 </p>
 <p>
  <span class="pre">
   cache-policy
  </span>
  is a hint to the cache subsystem and may not always be respected. It is treated as
a performance hint only, and does not change the memory consistency behavior of the program.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.0.
 </p>
 <p>
  Support for
  <span class="pre">
   .level::cache_hint
  </span>
  and
  <span class="pre">
   .level::prefetch_size
  </span>
  qualifiers introduced in PTX ISA
version 7.4.
 </p>
 <p>
  Support for
  <span class="pre">
   ignore-src
  </span>
  operand introduced in PTX ISA version 7.5.
 </p>
 <p>
  Support for sub-qualifier
  <span class="pre">
   ::cta
  </span>
  introduced in PTX ISA version 7.8.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  Sub-qualifier
  <span class="pre">
   ::cta
  </span>
  requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>cp.async.ca.shared.global  [shrd],    [gbl + 4], 4;
cp.async.ca.shared::cta.global  [%r0 + 8], [%r1],     8;
cp.async.cg.shared.global  [%r2],     [%r3],     16;

cp.async.cg.shared.global.L2::64B   [%r2],      [%r3],     16;
cp.async.cg.shared.global.L2::128B  [%r0 + 16], [%r1],     16;
cp.async.cg.shared.global.L2::256B  [%r2 + 32], [%r3],     16;

createpolicy.fractional.L2::evict_last.L2::evict_unchanged.b64 cache-policy, 0.25;
cp.async.ca.shared.global.L2::cache_hint [%r2], [%r1], 4, cache-policy;

cp.async.ca.shared.global                   [shrd], [gbl], 4, p;
cp.async.cg.shared.global.L2::cache_hint   [%r0], [%r2], 16, q, cache-policy;
</pre>
 <h5>
  <span class="section-number">
   9.7.8.24.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-commit-group">
   Data Movement and Conversion Instructions: cp.async.commit_group
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-commit-group" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  cp.async.commit_group
 </p>
 <p>
  Commits all prior initiated but uncommitted
  <span class="pre">
   cp.async
  </span>
  instructions into a
  cp.async-group
  .
 </p>
 <p>
  Syntax
 </p>
 <pre>cp.async.commit_group ;
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   cp.async.commit_group
  </span>
  instruction creates a new
  cp.async-group
  per thread and batches all
prior
  <span class="pre">
   cp.async
  </span>
  instructions initiated by the executing thread but not committed to any
  cp.async-group
  into the new
  cp.async-group
  . If there are no uncommitted
  <span class="pre">
   cp.async
  </span>
  instructions then
  <span class="pre">
   cp.async.commit_group
  </span>
  results in an empty
  cp.async-group.
 </p>
 <p>
  An executing thread can wait for the completion of all
  <span class="pre">
   cp.async
  </span>
  operations in a
  cp.async-group
  using
  <span class="pre">
   cp.async.wait_group
  </span>
  .
 </p>
 <p>
  There is no memory ordering guarantee provided between any two
  <span class="pre">
   cp.async
  </span>
  operations within the
same
  cp.async-group
  . So two or more
  <span class="pre">
   cp.async
  </span>
  operations within a
  cp.async-group
  copying data
to the same location results in undefined behavior.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>// Example 1:
cp.async.ca.shared.global [shrd], [gbl], 4;
cp.async.commit_group ; // Marks the end of a cp.async group

// Example 2:
cp.async.ca.shared.global [shrd1],   [gbl1],   8;
cp.async.ca.shared.global [shrd1+8], [gbl1+8], 8;
cp.async.commit_group ; // Marks the end of cp.async group 1

cp.async.ca.shared.global [shrd2],    [gbl2],    16;
cp.async.cg.shared.global [shrd2+16], [gbl2+16], 16;
cp.async.commit_group ; // Marks the end of cp.async group 2
</pre>
 <h5>
  <span class="section-number">
   9.7.8.24.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-wait-group">
   Data Movement and Conversion Instructions: cp.async.wait_group / cp.async.wait_all
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-wait-group-cp-async-wait-all" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  cp.async.wait_group/cp.async.wait_all
 </p>
 <p>
  Wait for completion of prior asynchronous copy operations.
 </p>
 <p>
  Syntax
 </p>
 <pre>cp.async.wait_group N;
cp.async.wait_all ;
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   cp.async.wait_group
  </span>
  instruction will cause executing thread to wait till only
  <span class="pre">
   N
  </span>
  or fewer of
the most recent
  cp.async-group
  s are pending and all the prior
  cp.async-group
  s committed by
the executing threads are complete. For example, when
  <span class="pre">
   N
  </span>
  is 0, the executing thread waits on all
the prior
  cp.async-group
  s to complete. Operand
  <span class="pre">
   N
  </span>
  is an integer constant.
 </p>
 <p>
  <span class="pre">
   cp.async.wait_all
  </span>
  is equivalent to :
 </p>
 <pre>cp.async.commit_group;
cp.async.wait_group 0;
</pre>
 <p>
  An empty
  cp.async-group
  is considered to be trivially complete.
 </p>
 <p>
  Writes performed by
  <span class="pre">
   cp.async
  </span>
  operations are made visible to the executing thread only after:
 </p>
 <ol class="arabic simple">
  <li>
   <p>
    The completion of
    <span class="pre">
     cp.async.wait_all
    </span>
    or
   </p>
  </li>
  <li>
   <p>
    The completion of
    <span class="pre">
     cp.async.wait_group
    </span>
    on the
    cp.async-group
    in which the
    <span class="pre">
     cp.async
    </span>
    belongs to or
   </p>
  </li>
  <li>
   <p>
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-test-wait-try-wait">
     mbarrier.test_wait
    </a>
    returns
    <span class="pre">
     True
    </span>
    on an
    mbarrier object
    which is tracking the completion of the
    <span class="pre">
     cp.async
    </span>
    operation.
   </p>
  </li>
 </ol>
 <p>
  There is no ordering between two
  <span class="pre">
   cp.async
  </span>
  operations that are not synchronized with
  <span class="pre">
   cp.async.wait_all
  </span>
  or
  <span class="pre">
   cp.async.wait_group
  </span>
  or
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier">
   mbarrier objects
  </a>
  .
 </p>
 <p>
  <span class="pre">
   cp.async.wait_group
  </span>
  and
  <span class="pre">
   cp.async.wait_all
  </span>
  does not provide any ordering and visibility
guarantees for any other memory operation apart from
  <span class="pre">
   cp.async
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>// Example of .wait_all:
cp.async.ca.shared.global [shrd1], [gbl1], 4;
cp.async.cg.shared.global [shrd2], [gbl2], 16;
cp.async.wait_all;  // waits for all prior cp.async to complete

// Example of .wait_group :
cp.async.ca.shared.global [shrd3], [gbl3], 8;
cp.async.commit_group;  // End of group 1

cp.async.cg.shared.global [shrd4], [gbl4], 16;
cp.async.commit_group;  // End of group 2

cp.async.cg.shared.global [shrd5], [gbl5], 16;
cp.async.commit_group;  // End of group 3

cp.async.wait_group 1;  // waits for group 1 and group 2 to complete
</pre>
 <h5>
  <span class="section-number">
   9.7.8.24.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk">
   Data Movement and Conversion Instructions: cp.async.bulk
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  cp.async.bulk
 </p>
 <p>
  Initiates an asynchronous copy operation from one state space to another.
 </p>
 <p>
  Syntax
 </p>
 <pre>cp.async.bulk.dst.src.completion_mechanism{.multicast}{.level::cache_hint}
                      [dstMem], [srcMem], size, [mbar] {, ctaMask} {, cache-policy}

.dst =                  { .shared::cluster }
.src =                  { .global }
.completion_mechanism = { .mbarrier::complete_tx::bytes }
.level::cache_hint =    { .L2::cache_hint }
.multicast =            { .multicast::cluster  }


cp.async.bulk.dst.src.completion_mechanism [dstMem], [srcMem], size, [mbar]

.dst =                  { .shared::cluster }
.src =                  { .shared::cta }
.completion_mechanism = { .mbarrier::complete_tx::bytes }


cp.async.bulk.dst.src.completion_mechanism{.level::cache_hint} [dstMem], [srcMem], size{, cache-policy}

.dst =                  { .global }
.src =                  { .shared::cta }
.completion_mechanism = { .bulk_group }
.level::cache_hint =    { .L2::cache_hint }
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   cp.async.bulk
  </span>
  is a non-blocking instruction which initiates an asynchronous bulk-copy operation
from the location specified by source address operand
  <span class="pre">
   srcMem
  </span>
  to the location specified by
destination address operand
  <span class="pre">
   dstMem
  </span>
  .
 </p>
 <p>
  The direction of bulk-copy is from the state space specified by the
  <span class="pre">
   .src
  </span>
  modifier to the state
space specified by the
  <span class="pre">
   .dst
  </span>
  modifiers.
 </p>
 <p>
  The 32-bit operand
  <span class="pre">
   size
  </span>
  specifies the amount of memory to be copied, in terms of number of
bytes.
  <span class="pre">
   size
  </span>
  must be a multiple of 16. If the value is not a multiple of 16, then the behavior is
undefined. The memory range
  <span class="pre">
   [dstMem,
  </span>
  <span class="pre">
   dstMem
  </span>
  <span class="pre">
   +
  </span>
  <span class="pre">
   size
  </span>
  <span class="pre">
   -
  </span>
  <span class="pre">
   1]
  </span>
  must not overflow the destination memory
space and the memory range
  <span class="pre">
   [srcMem,
  </span>
  <span class="pre">
   srcMem
  </span>
  <span class="pre">
   +
  </span>
  <span class="pre">
   size
  </span>
  <span class="pre">
   -
  </span>
  <span class="pre">
   1]
  </span>
  must not overflow the source memory
space. Otherwise, the behavior is undefined. The addresses
  <span class="pre">
   dstMem
  </span>
  and
  <span class="pre">
   srcMem
  </span>
  must be aligned
to 16 bytes.
 </p>
 <p>
  When the source of the copy is
  <span class="pre">
   .shared::cta
  </span>
  and the destination is
  <span class="pre">
   .shared::cluster
  </span>
  , the
destination has to be in the shared memory of a different CTA within the cluster.
 </p>
 <p>
  The modifier
  <span class="pre">
   .completion_mechanism
  </span>
  specifies the completion mechanism that is supported on the
instruction variant. The completion mechanisms that are supported for different variants are
summarized in the following table:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Completion mechanism
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      .dst
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      .src
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td rowspan="2">
    <p>
     <span class="pre">
      .mbarrier::...
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .shared::cluster
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .global
     </span>
    </p>
   </td>
   <td rowspan="2">
    <p>
     mbarrier based completion mechanism
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .shared::cluster
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .shared::cta
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .bulk_group
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .global
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .shared::cta
     </span>
    </p>
   </td>
   <td>
    <p>
     Bulk async-group
     based completion mechanism
    </p>
   </td>
  </tr>
 </table>
 <p>
  The modifier
  <span class="pre">
   .mbarrier::complete_tx::bytes
  </span>
  specifies that the
  <span class="pre">
   cp.async.bulk
  </span>
  variant uses
mbarrier based completion mechanism. The
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-complete-tx-operation">
   complete-tx
  </a>
  operation, with
  <span class="pre">
   completeCount
  </span>
  argument equal to amount of data copied in bytes, will be
performed on the mbarrier object specified by the operand
  <span class="pre">
   mbar
  </span>
  .
 </p>
 <p>
  The modifier
  <span class="pre">
   .bulk_group
  </span>
  specifies that the
  <span class="pre">
   cp.async.bulk
  </span>
  variant uses
  bulk async-group
  based completion mechanism.
 </p>
 <p>
  The optional modifier
  <span class="pre">
   .multicast::cluster
  </span>
  allows copying of data from global memory to shared
memory of multiple CTAs in the cluster. Operand
  <span class="pre">
   ctaMask
  </span>
  specifies the destination CTAs in the
cluster such that each bit position in the 16-bit
  <span class="pre">
   ctaMask
  </span>
  operand corresponds to the
  <span class="pre">
   %ctaid
  </span>
  of the destination CTA. The source data is multicast to the same CTA-relative offset as
  <span class="pre">
   dstMem
  </span>
  in the shared memory of each destination CTA. The mbarrier signal is also multicast to the same
CTA-relative offset as
  <span class="pre">
   mbar
  </span>
  in the shared memory of the destination CTA.
 </p>
 <p>
  When the optional argument
  <span class="pre">
   cache-policy
  </span>
  is specified, the qualifier
  <span class="pre">
   .level::cache_hint
  </span>
  is
required. The 64-bit operand
  <span class="pre">
   cache-policy
  </span>
  specifies the cache eviction policy that may be used
during the memory access.
 </p>
 <p>
  <span class="pre">
   cache-policy
  </span>
  is a hint to the cache subsystem and may not always be respected. It is treated as
a performance hint only, and does not change the memory consistency behavior of the program. The
qualifier
  <span class="pre">
   .level::cache_hint
  </span>
  is only supported when at least one of the
  <span class="pre">
   .src
  </span>
  or
  <span class="pre">
   .dst
  </span>
  statespaces is
  <span class="pre">
   .global
  </span>
  state space.
 </p>
 <p>
  The copy operation in
  <span class="pre">
   cp.async.bulk
  </span>
  is treated as a weak memory operation and the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-complete-tx-operation">
   complete-tx
  </a>
  operation on the mbarrier has
  <span class="pre">
   .release
  </span>
  semantics at the
  <span class="pre">
   .cluster
  </span>
  scope as described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory Consistency Model
  </a>
  .
 </p>
 <p>
  Notes
 </p>
 <p>
  <span class="pre">
   .multicast::cluster
  </span>
  qualifier is optimized for target architecture
  <span class="pre">
   sm_90a
  </span>
  and may have
substantially reduced performance on other targets and hence
  <span class="pre">
   .multicast::cluster
  </span>
  is advised to
be used with
  <span class="pre">
   .target
  </span>
  <span class="pre">
   sm_90a
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 8.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   .multicast::cluster
  </span>
  qualifier advised to be used with
  <span class="pre">
   .target
  </span>
  <span class="pre">
   sm_90a
  </span>
  .
 </p>
 <p>
  Examples
 </p>
 <pre>// .global -&gt; .shared::cluster:
cp.async.bulk.shared::cluster.global.mbarrier::complete_tx::bytes [dstMem], [srcMem], size, [mbar];

cp.async.bulk.shared::cluster.global.mbarrier::complete_tx::bytes.multicast::cluster
                                             [dstMem], [srcMem], size, [mbar], ctaMask;

cp.async.bulk.shared::cluster.global.mbarrier::complete_tx::bytes.L2::cache_hint
                                             [dstMem], [srcMem], size, [mbar], cache-policy;


// .shared::cta -&gt; .shared::cluster (strictly remote):
cp.async.bulk.shared::cluster.shared::cta.mbarrier::complete_tx::bytes [dstMem], [srcMem], size, [mbar];

// .shared::cta -&gt; .global:
cp.async.bulk.global.shared::cta.bulk_group [dstMem], [srcMem], size;

cp.async.bulk.global.shared::cta.bulk_group.L2::cache_hint} [dstMem], [srcMem], size, cache-policy;
</pre>
 <h5>
  <span class="section-number">
   9.7.8.24.7.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-reduce-async-bulk">
   Data Movement and Conversion Instructions: cp.reduce.async.bulk
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-reduce-async-bulk" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  cp.reduce.async.bulk
 </p>
 <p>
  Initiates an asynchronous reduction operation.
 </p>
 <p>
  Syntax
 </p>
 <pre>cp.reduce.async.bulk.dst.src.completion_mechanism.redOp.type
              [dstMem], [srcMem], size, [mbar]

.dst =                  { .shared::cluster }
.src =                  { .shared::cta }
.completion_mechanism = { .mbarrier::complete_tx::bytes }
.redOp=                 { .and, .or, .xor,
                          .add, .inc, .dec,
                          .min, .max }
.type =                 { .b32, .u32, .s32, .b64, .u64 }


cp.reduce.async.bulk.dst.src.completion_mechanism{.level::cache_hint}.redOp.type
               [dstMem], [srcMem], size{, cache-policy}

.dst =                  { .global      }
.src =                  { .shared::cta }
.completion_mechanism = { .bulk_group }
.level::cache_hint    = { .L2::cache_hint }
.redOp=                 { .and, .or, .xor,
                          .add, .inc, .dec,
                          .min, .max }
.type =                 { .f16, .bf16, .b32, .u32, .s32, .b64, .u64, .s64, .f32, .f64 }


cp.reduce.async.bulk.dst.src.completion_mechanism{.level::cache_hint}.add.noftz.type
               [dstMem], [srcMem], size{, cache-policy}
.dst  =                 { .global }
.src  =                 { .shared::cta }
.completion_mechanism = { .bulk_group }
.type =                 { .f16, .bf16 }
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   cp.reduce.async.bulk
  </span>
  is a non-blocking instruction which initiates an asynchronous reduction
operation on an array of memory locations specified by the destination address operand
  <span class="pre">
   dstMem
  </span>
  with the source array whose location is specified by the source address operand
  <span class="pre">
   srcMem
  </span>
  . The size
of the source and the destination array must be the same and is specified by the operand
  <span class="pre">
   size
  </span>
  .
 </p>
 <p>
  Each data element in the destination array is reduced inline with the corresponding data element in
the source array with the reduction operation specified by the modifier
  <span class="pre">
   .redOp
  </span>
  . The type of each
data element in the source and the destination array is specified by the modifier
  <span class="pre">
   .type
  </span>
  .
 </p>
 <p>
  The source address operand
  <span class="pre">
   srcMem
  </span>
  is located in the state space specified by
  <span class="pre">
   .src
  </span>
  and the
destination address operand
  <span class="pre">
   dstMem
  </span>
  is located in the state specified by the
  <span class="pre">
   .dst
  </span>
  .
 </p>
 <p>
  The 32-bit operand
  <span class="pre">
   size
  </span>
  specifies the amount of memory to be copied from the source location and
used in the reduction operation, in terms of number of bytes.
  <span class="pre">
   size
  </span>
  must be a multiple of 16. If
the value is not a multiple of 16, then the behavior is undefined. The memory range
  <span class="pre">
   [dstMem,
  </span>
  <span class="pre">
   dstMem
  </span>
  <span class="pre">
   +
  </span>
  <span class="pre">
   size
  </span>
  <span class="pre">
   -
  </span>
  <span class="pre">
   1]
  </span>
  must not overflow the destination memory space and the memory range
  <span class="pre">
   [srcMem,
  </span>
  <span class="pre">
   srcMem
  </span>
  <span class="pre">
   +
  </span>
  <span class="pre">
   size
  </span>
  <span class="pre">
   -
  </span>
  <span class="pre">
   1]
  </span>
  must not overflow the source memory space. Otherwise, the behavior is
undefined. The addresses
  <span class="pre">
   dstMem
  </span>
  and
  <span class="pre">
   srcMem
  </span>
  must be aligned to 16 bytes.
 </p>
 <p>
  The operations supported by
  <span class="pre">
   .redOp
  </span>
  are classified as follows:
 </p>
 <ul class="simple">
  <li>
   <p>
    The bit-size operations are
    <span class="pre">
     .and
    </span>
    ,
    <span class="pre">
     .or
    </span>
    , and
    <span class="pre">
     .xor
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    The integer operations are
    <span class="pre">
     .add
    </span>
    ,
    <span class="pre">
     .inc
    </span>
    ,
    <span class="pre">
     .dec
    </span>
    ,
    <span class="pre">
     .min
    </span>
    , and
    <span class="pre">
     .max
    </span>
    . The
    <span class="pre">
     .inc
    </span>
    and
    <span class="pre">
     .dec
    </span>
    operations return a result in the range
    <span class="pre">
     [0..x]
    </span>
    where
    <span class="pre">
     x
    </span>
    is the value at the source
state space.
   </p>
  </li>
  <li>
   <p>
    The floating point operation
    <span class="pre">
     .add
    </span>
    rounds to the nearest even. The current implementation of
    <span class="pre">
     cp.reduce.async.bulk.add.f32
    </span>
    flushes subnormal inputs and results to sign-preserving zero. The
    <span class="pre">
     cp.reduce.async.bulk.add.f16
    </span>
    and
    <span class="pre">
     cp.reduce.async.bulk.add.bf16
    </span>
    operations require
    <span class="pre">
     .noftz
    </span>
    qualifier. It preserves input and result subnormals, and does not flush them to zero.
   </p>
  </li>
 </ul>
 <p>
  The following table describes the valid combinations of
  <span class="pre">
   .redOp
  </span>
  and element type:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      .dst
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      .redOp
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     Element type
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td rowspan="4">
    <p>
     <span class="pre">
      .shared::cluster
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .add
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .u32
     </span>
     ,
     <span class="pre">
      .s32
     </span>
     ,
     <span class="pre">
      .u64
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .min
     </span>
     ,
     <span class="pre">
      .max
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .u32
     </span>
     ,
     <span class="pre">
      .s32
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .inc
     </span>
     ,
     <span class="pre">
      .dec
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .u32
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .and
     </span>
     ,
     <span class="pre">
      .or
     </span>
     ,
     <span class="pre">
      .xor
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .b32
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td rowspan="4">
    <p>
     <span class="pre">
      .global
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .add
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .u32
     </span>
     ,
     <span class="pre">
      .s32
     </span>
     ,
     <span class="pre">
      .u64
     </span>
     ,
     <span class="pre">
      .f32
     </span>
     ,
     <span class="pre">
      .f64
     </span>
     ,
     <span class="pre">
      .f16
     </span>
     ,
     <span class="pre">
      .bf16
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .min
     </span>
     ,
     <span class="pre">
      .max
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .u32
     </span>
     ,
     <span class="pre">
      .s32
     </span>
     ,
     <span class="pre">
      .u64
     </span>
     ,
     <span class="pre">
      .s64
     </span>
     ,
     <span class="pre">
      .f16
     </span>
     ,
     <span class="pre">
      .bf16
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .inc
     </span>
     ,
     <span class="pre">
      .dec
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .u32
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .and
     </span>
     ,
     <span class="pre">
      .or
     </span>
     ,
     <span class="pre">
      .xor
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .b32
     </span>
     ,
     <span class="pre">
      .b64
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The modifier
  <span class="pre">
   .completion_mechanism
  </span>
  specifies the completion mechanism that is supported on the
instruction variant. The completion mechanisms that are supported for different variants are
summarized in the following table:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Completion mechanism
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      .dst
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      .src
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td rowspan="2">
    <p>
     <span class="pre">
      .mbarrier::...
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .shared::cluster
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .global
     </span>
    </p>
   </td>
   <td rowspan="2">
    <p>
     mbarrier based completion mechanism
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .shared::cluster
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .shared::cta
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .bulk_group
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .global
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .shared::cta
     </span>
    </p>
   </td>
   <td>
    <p>
     Bulk async-group
     based completion mechanism
    </p>
   </td>
  </tr>
 </table>
 <p>
  The modifier
  <span class="pre">
   .mbarrier::complete_tx::bytes
  </span>
  specifies that the
  <span class="pre">
   cp.reduce.async.bulk
  </span>
  variant
uses mbarrier based completion mechanism. The
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-complete-tx-operation">
   complete-tx
  </a>
  operation, with
  <span class="pre">
   completeCount
  </span>
  argument equal to amount of data copied in bytes, will be
performed on the mbarrier object specified by the operand
  <span class="pre">
   mbar
  </span>
  .
 </p>
 <p>
  The modifier
  <span class="pre">
   .bulk_group
  </span>
  specifies that the
  <span class="pre">
   cp.reduce.async.bulk
  </span>
  variant uses
  bulk
async-group
  based completion mechanism.
 </p>
 <p>
  When the optional argument
  <span class="pre">
   cache-policy
  </span>
  is specified, the qualifier
  <span class="pre">
   .level::cache_hint
  </span>
  is
required. The 64-bit operand
  <span class="pre">
   cache-policy
  </span>
  specifies the cache eviction policy that may be used
during the memory access.
 </p>
 <p>
  <span class="pre">
   cache-policy
  </span>
  is a hint to the cache subsystem and may not always be respected. It is treated as
a performance hint only, and does not change the memory consistency behavior of the program. The
qualifier
  <span class="pre">
   .level::cache_hint
  </span>
  is only supported when at least one of the
  <span class="pre">
   .src
  </span>
  or
  <span class="pre">
   .dst
  </span>
  statespaces is
  <span class="pre">
   .global
  </span>
  state space.
 </p>
 <p>
  Each reduction operation performed by the
  <span class="pre">
   cp.reduce.async.bulk
  </span>
  has individually
  <span class="pre">
   .relaxed.gpu
  </span>
  memory ordering semantics. The load operations in
  <span class="pre">
   cp.reduce.async.bulk
  </span>
  are treated as weak
memory operation and the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-complete-tx-operation">
   complete-tx
  </a>
  operation on the mbarrier has
  <span class="pre">
   .release
  </span>
  semantics at the
  <span class="pre">
   .cluster
  </span>
  scope as described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory Consistency Model
  </a>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 8.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>cp.reduce.async.bulk.shared::cluster.shared::cta.mbarrier::complete_tx::bytes.add.u64
                                                                  [dstMem], [srcMem], size, [mbar];

cp.reduce.async.bulk.shared::cluster.shared::cta.mbarrier::complete_tx::bytes.min.s32
                                                                  [dstMem], [srcMem], size, [mbar];

cp.reduce.async.bulk.global.shared::cta.bulk_group.min.f16 [dstMem], [srcMem], size;

cp.reduce.async.bulk.global.shared::cta.bulk_group.L2::cache_hint.xor.s32 [dstMem], [srcMem], size, policy;

cp.reduce.async.bulk.global.shared::cta.bulk_group.add.noftz.f16 [dstMem], [srcMem], size;
</pre>
 <h5>
  <span class="section-number">
   9.7.8.24.8.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk-prefetch">
   Data Movement and Conversion Instructions: cp.async.bulk.prefetch
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk-prefetch" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  cp.async.bulk.prefetch
 </p>
 <p>
  Provides a hint to the system to initiate the asynchronous prefetch of data to the cache.
 </p>
 <p>
  Syntax
 </p>
 <pre>cp.async.bulk.prefetch.L2.src{.level::cache_hint}   [srcMem], size {, cache-policy}

.src =                { .global }
.level::cache_hint =  { .L2::cache_hint }
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   cp.async.bulk.prefetch
  </span>
  is a non-blocking instruction which may initiate an asynchronous prefetch
of data from the location specified by source address operand
  <span class="pre">
   srcMem
  </span>
  , in
  <span class="pre">
   .src
  </span>
  statespace, to
the L2 cache.
 </p>
 <p>
  The 32-bit operand
  <span class="pre">
   size
  </span>
  specifies the amount of memory to be prefetched in terms of number of
bytes.
  <span class="pre">
   size
  </span>
  must be a multiple of 16. If the value is not a multiple of 16, then the behavior is
undefined. The memory range
  <span class="pre">
   [dstMem,
  </span>
  <span class="pre">
   dstMem
  </span>
  <span class="pre">
   +
  </span>
  <span class="pre">
   size
  </span>
  <span class="pre">
   -
  </span>
  <span class="pre">
   1]
  </span>
  must not overflow the destination memory
space and the memory range
  <span class="pre">
   [srcMem,
  </span>
  <span class="pre">
   srcMem
  </span>
  <span class="pre">
   +
  </span>
  <span class="pre">
   size
  </span>
  <span class="pre">
   -
  </span>
  <span class="pre">
   1]
  </span>
  must not overflow the source memory
space. Otherwise, the behavior is undefined. The address
  <span class="pre">
   srcMem
  </span>
  must be aligned to 16 bytes.
 </p>
 <p>
  When the optional argument
  <span class="pre">
   cache-policy
  </span>
  is specified, the qualifier
  <span class="pre">
   .level::cache_hint
  </span>
  is
required. The 64-bit operand
  <span class="pre">
   cache-policy
  </span>
  specifies the cache eviction policy that may be used
during the memory access.
 </p>
 <p>
  <span class="pre">
   cache-policy
  </span>
  is a hint to the cache subsystem and may not always be respected. It is treated as
a performance hint only, and does not change the memory consistency behavior of the program.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 8.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>cp.async.bulk.prefetch.L2.global                 [srcMem], size;

cp.async.bulk.prefetch.L2.global.L2::cache_hint  [srcMem], size, policy;
</pre>
 <h5>
  <span class="section-number">
   9.7.8.24.9.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk-tensor">
   Data Movement and Conversion Instructions: cp.async.bulk.tensor
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk-tensor" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  cp.async.bulk.tensor
 </p>
 <p>
  Initiates an asynchronous copy operation on the tensor data from one state space to another.
 </p>
 <p>
  Syntax
 </p>
 <pre>// global -&gt; shared::cluster:
cp.async.bulk.tensor.dim.dst.src{.load_mode}.completion_mechanism{.multicast}{.level::cache_hint}
                                   [dstMem], [tensorMap, tensorCoords], [mbar]{, im2colOffsets}
                                   {, ctaMask} {, cache-policy}

.dst =                  { .shared::cluster }
.src =                  { .global }
.dim =                  { .1d, .2d, .3d, .4d, .5d }
.completion_mechanism = { .mbarrier::complete_tx::bytes }
.load_mode =            { .tile, .im2col }
.level::cache_hint =    { .L2::cache_hint }
.multicast =            { .multicast::cluster  }


// shared::cta -&gt; global:
cp.async.bulk.tensor.dim.dst.src{.load_mode}.completion_mechanism{.level::cache_hint}
                                   [tensorMap, tensorCoords], [srcMem] {, cache-policy}

.dst =                  { .global }
.src =                  { .shared::cta }
.dim =                  { .1d, .2d, .3d, .4d, .5d }
.completion_mechanism = { .bulk_group }
.load_mode =            { .tile, .im2col_no_offs }
.level::cache_hint =    { .L2::cache_hint }
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   cp.async.bulk.tensor
  </span>
  is a non-blocking instruction which initiates an asynchronous copy
operation of tensor data from the location in
  <span class="pre">
   .src
  </span>
  state space to the location in the
  <span class="pre">
   .dst
  </span>
  state space.
 </p>
 <p>
  The operand
  <span class="pre">
   dstMem
  </span>
  specifies the location in the
  <span class="pre">
   .dst
  </span>
  state space into which the tensor data
has to be copied and
  <span class="pre">
   srcMem
  </span>
  specifies the location in the
  <span class="pre">
   .src
  </span>
  state space from which the
tensor data has to be copied.
 </p>
 <p>
  The operand
  <span class="pre">
   tensorMap
  </span>
  is the generic address of the opaque tensor-map object which resides
either in
  <span class="pre">
   .param
  </span>
  space or
  <span class="pre">
   .const
  </span>
  space or
  <span class="pre">
   .global
  </span>
  space. The operand
  <span class="pre">
   tensorMap
  </span>
  specifies
the properties of the tensor copy operation, as described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-tensormap">
   Tensor-map
  </a>
  .
The
  <span class="pre">
   tensorMap
  </span>
  is accessed in tensormap proxy. Refer to the
  CUDA programming guide
  for creating
the tensor-map objects on the host side.
 </p>
 <p>
  The dimension of the tensor data is specified by the
  <span class="pre">
   .dim
  </span>
  modifier.
 </p>
 <p>
  The vector operand
  <span class="pre">
   tensorCoords
  </span>
  specifies the starting coordinates in the tensor data in the
global memory from or to which the copy operation has to be performed. The number of tensor
coordinates in the vector argument
  <span class="pre">
   tensorCoords
  </span>
  should be equal to the dimension specified by
the modifier
  <span class="pre">
   .dim
  </span>
  . The individual tensor coordinates in
  <span class="pre">
   tensorCoords
  </span>
  are of type
  <span class="pre">
   .s32
  </span>
  .
 </p>
 <p>
  The modifier
  <span class="pre">
   .completion_mechanism
  </span>
  specifies the completion mechanism that is supported on the
instruction variant. The completion mechanisms that are supported for different variants are
summarized in the following table:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Completion mechanism
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      .dst
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      .src
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .mbarrier::...
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .shared::cluster
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .global
     </span>
    </p>
   </td>
   <td>
    <p>
     mbarrier based completion mechanism
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .bulk_group
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .global
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .shared::cta
     </span>
    </p>
   </td>
   <td>
    <p>
     Bulk async-group
     based completion mechanism
    </p>
   </td>
  </tr>
 </table>
 <p>
  The modifier
  <span class="pre">
   .mbarrier::complete_tx::bytes
  </span>
  specifies that the
  <span class="pre">
   cp.async.bulk.tensor
  </span>
  variant
uses mbarrier based completion mechanism. The
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-complete-tx-operation">
   complete-tx
  </a>
  operation, with
  <span class="pre">
   completeCount
  </span>
  argument equal to amount of data copied in bytes, will be
performed on the mbarrier object specified by the operand
  <span class="pre">
   mbar
  </span>
  .
 </p>
 <p>
  The modifier
  <span class="pre">
   .bulk_group
  </span>
  specifies that the
  <span class="pre">
   cp.async.bulk.tensor
  </span>
  variant uses
  bulk
async-group
  based completion mechanism.
 </p>
 <p>
  The qualifier
  <span class="pre">
   .load_mode
  </span>
  specifies how the data in the source location is copied into the
destination location. If
  <span class="pre">
   .load_mode
  </span>
  is not specified, it defaults to
  <span class="pre">
   .tile
  </span>
  . In
  <span class="pre">
   .tile
  </span>
  mode, the multi-dimensional layout of the source tensor is preserved at the destination. In
  <span class="pre">
   .im2col
  </span>
  mode, some dimensions of the source tensors are unrolled in a single dimensional column
at the destination. Details of the
  <span class="pre">
   im2col
  </span>
  mode are described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-im2col-mode">
   Im2col mode
  </a>
  . In
  <span class="pre">
   .im2col
  </span>
  mode, the tensor has to be at least
3-dimensional. The vector operand
  <span class="pre">
   im2colOffsets
  </span>
  can be specified only when
  <span class="pre">
   .load_mode
  </span>
  is
.im2col. The length of the vector operand
  <span class="pre">
   im2colOffsets
  </span>
  is two less than the number of dimension
  <span class="pre">
   .dim
  </span>
  of the tensor operation. The modifier
  <span class="pre">
   .im2col_no_offs
  </span>
  is the same as
  <span class="pre">
   .im2col
  </span>
  mode
except there is no
  <span class="pre">
   im2colOffsets
  </span>
  vector involved.
 </p>
 <p>
  The optional modifier
  <span class="pre">
   .multicast::cluster
  </span>
  allows copying of data from global memory to shared
memory of multiple CTAs in the cluster. Operand
  <span class="pre">
   ctaMask
  </span>
  specifies the destination CTAs in the
cluster such that each bit position in the 16-bit
  <span class="pre">
   ctaMask
  </span>
  operand corresponds to the
  <span class="pre">
   %ctaid
  </span>
  of the destination CTA. The source data is multicast to the same offset as
  <span class="pre">
   dstMem
  </span>
  in the shared
memory of each destination CTA. The mbarrier signal is also multicast to the same offset as
  <span class="pre">
   mbar
  </span>
  in the shared memory of the destination CTA.
 </p>
 <p>
  When the optional argument
  <span class="pre">
   cache-policy
  </span>
  is specified, the qualifier
  <span class="pre">
   .level::cache_hint
  </span>
  is
required. The 64-bit operand
  <span class="pre">
   cache-policy
  </span>
  specifies the cache eviction policy that may be used
during the memory access.
 </p>
 <p>
  <span class="pre">
   cache-policy
  </span>
  is a hint to the cache subsystem and may not always be respected. It is treated as
a performance hint only, and does not change the memory consistency behavior of the program. The
qualifier
  <span class="pre">
   .level::cache_hint
  </span>
  is only supported when at least one of the
  <span class="pre">
   .src
  </span>
  or
  <span class="pre">
   .dst
  </span>
  statespaces is
  <span class="pre">
   .global
  </span>
  state space.
 </p>
 <p>
  The copy operation in
  <span class="pre">
   cp.async.bulk.tensor
  </span>
  is treated as a weak memory operation and the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-complete-tx-operation">
   complete-tx
  </a>
  operation on the mbarrier has
  <span class="pre">
   .release
  </span>
  semantics at the
  <span class="pre">
   .cluster
  </span>
  scope as described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory Consistency Model
  </a>
  .
 </p>
 <p>
  Notes
 </p>
 <p>
  <span class="pre">
   .multicast::cluster
  </span>
  qualifier is optimized for target architecture
  <span class="pre">
   sm_90a
  </span>
  and may have
substantially reduced performance on other targets and hence
  <span class="pre">
   .multicast::cluster
  </span>
  is advised to
be used with
  <span class="pre">
   .target
  </span>
  <span class="pre">
   sm_90a
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 8.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   .multicast::cluster
  </span>
  qualifier advised to be used with
  <span class="pre">
   .target
  </span>
  <span class="pre">
   sm_90a
  </span>
  .
 </p>
 <p>
  Examples
 </p>
 <pre>.reg .b16 ctaMask;
.reg .u16 i2cOffW, i2cOffH, i2cOffD;
.reg .b64 l2CachePolicy;

cp.async.bulk.tensor.1d.shared::cluster.global.tile  [sMem0], [tensorMap0, {tc0}], [mbar0];

@p cp.async.bulk.tensor.2d.shared::cluster.global.mbarrier::complete_tx::bytes.multicast::cluster
                     [sMem1], [tensorMap1, {tc0, tc1}], [mbar2], ctaMask;

@p cp.async.bulk.tensor.5d.shared::cluster.global.im2col.mbarrier::complete_tx::bytes
                     [sMem2], [tensorMap2, {tc0, tc1, tc2, tc3, tc4}], [mbar2], {i2cOffW, i2cOffH, i2cOffD};

@p cp.async.bulk.tensor.3d.im2col.shared::cluster.global.mbarrier::complete_tx::bytes.L2::cache_hint
                     [sMem3], [tensorMap3, {tc0, tc1, tc2}], [mbar3], {i2cOffW}, policy;

@p cp.async.bulk.tensor.1d.global.shared::cta.bulk_group  [tensorMap3, {tc0}], [sMem3];
</pre>
 <h5>
  <span class="section-number">
   9.7.8.24.10.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-reduce-async-bulk-tensor">
   Data Movement and Conversion Instructions: cp.reduce.async.bulk.tensor
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-reduce-async-bulk-tensor" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  cp.reduce.async.bulk.tensor
 </p>
 <p>
  Initiates an asynchronous reduction operation on the tensor data.
 </p>
 <p>
  Syntax
 </p>
 <pre>// shared::cta -&gt; global:
cp.reduce.async.bulk.tensor.dim.dst.src.redOp{.load_mode}.completion_mechanism{.level::cache_hint}
                                          [tensorMap, tensorCoords], [srcMem] {,cache-policy}

.dst =                  { .global }
.src =                  { .shared::cta }
.dim =                  { .1d, .2d, .3d, .4d, .5d }
.completion_mechanism = { .bulk_group }
.load_mode =            { .tile, .im2col_no_offs }
.redOp =                { .add, .min, .max, .inc, .dec, .and, .or, .xor}
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   cp.reduce.async.bulk.tensor
  </span>
  is a non-blocking instruction which initiates an asynchronous
reduction operation of tensor data in the
  <span class="pre">
   .dst
  </span>
  state space with tensor data in the
  <span class="pre">
   .src
  </span>
  state space.
 </p>
 <p>
  The operand
  <span class="pre">
   srcMem
  </span>
  specifies the location of the tensor data in the
  <span class="pre">
   .src
  </span>
  state space using
which the reduction operation has to be performed.
 </p>
 <p>
  The operand
  <span class="pre">
   tensorMap
  </span>
  is the generic address of the opaque tensor-map object which resides
either in
  <span class="pre">
   .param
  </span>
  space or
  <span class="pre">
   .const
  </span>
  space or
  <span class="pre">
   .global
  </span>
  space. The operand
  <span class="pre">
   tensorMap
  </span>
  specifies
the properties of the tensor copy operation, as described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-tensormap">
   Tensor-map
  </a>
  .
The
  <span class="pre">
   tensorMap
  </span>
  is accessed in tensormap proxy. Refer to the
  CUDA programming guide
  for creating
the tensor-map objects on the host side.
 </p>
 <p>
  Each element of the tensor data in the
  <span class="pre">
   .dst
  </span>
  state space is reduced inline with the corresponding
element from the tensor data in the
  <span class="pre">
   .src
  </span>
  state space. The modifier
  <span class="pre">
   .redOp
  </span>
  specifies the
reduction operation used for the inline reduction. The type of each tensor data element in the
source and the destination tensor is specified in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-tensormap">
   Tensor-map
  </a>
  .
 </p>
 <p>
  The dimension of the tensor is specified by the
  <span class="pre">
   .dim
  </span>
  modifier.
 </p>
 <p>
  The vector operand
  <span class="pre">
   tensorCoords
  </span>
  specifies the starting coordinates of the tensor data in the
global memory on which the reduce operation is to be performed. The number of tensor coordinates in
the vector argument
  <span class="pre">
   tensorCoords
  </span>
  should be equal to the dimension specified by the modifier
  <span class="pre">
   .dim
  </span>
  . The individual tensor coordinates are of the type
  <span class="pre">
   .s32
  </span>
  .
 </p>
 <p>
  The following table describes the valid combinations of
  <span class="pre">
   .redOp
  </span>
  and element type:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      .redOp
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     Element type
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .add
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .u32
     </span>
     ,
     <span class="pre">
      .s32
     </span>
     ,
     <span class="pre">
      .u64
     </span>
     ,
     <span class="pre">
      .f32
     </span>
     ,
     <span class="pre">
      .f16
     </span>
     ,
     <span class="pre">
      .bf16
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .min
     </span>
     ,
     <span class="pre">
      .max
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .u32
     </span>
     ,
     <span class="pre">
      .s32
     </span>
     ,
     <span class="pre">
      .u64
     </span>
     ,
     <span class="pre">
      .s64
     </span>
     ,
     <span class="pre">
      .f16
     </span>
     ,
     <span class="pre">
      .bf16
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .inc
     </span>
     ,
     <span class="pre">
      .dec
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .u32
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .and
     </span>
     ,
     <span class="pre">
      .or
     </span>
     ,
     <span class="pre">
      .xor
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .b32
     </span>
     ,
     <span class="pre">
      .b64
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The modifier
  <span class="pre">
   .completion_mechanism
  </span>
  specifies the completion mechanism that is supported on the
instruction variant. Value
  <span class="pre">
   .bulk_group
  </span>
  of the modifier
  <span class="pre">
   .completion_mechanism
  </span>
  specifies that
  <span class="pre">
   cp.reduce.async.bulk.tensor
  </span>
  instruction uses
  bulk async-group
  based completion mechanism.
 </p>
 <p>
  The qualifier
  <span class="pre">
   .load_mode
  </span>
  specifies how the data in the source location is copied into the
destination location. If
  <span class="pre">
   .load_mode
  </span>
  is not specified, it defaults to
  <span class="pre">
   .tile
  </span>
  . In
  <span class="pre">
   .tile
  </span>
  mode, the multi-dimensional layout of the source tensor is preserved at the destination. In
  <span class="pre">
   .im2col_no_offs
  </span>
  mode, some dimensions of the source tensors are unrolled in a single dimensional
column at the destination. Details of the
  <span class="pre">
   im2col
  </span>
  mode are described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-im2col-mode">
   Im2col mode
  </a>
  . In
  <span class="pre">
   .im2col
  </span>
  mode, the tensor has to be at least
3-dimensional.
 </p>
 <p>
  When the optional argument
  <span class="pre">
   cache-policy
  </span>
  is specified, the qualifier
  <span class="pre">
   .level::cache_hint
  </span>
  is
required. The 64-bit operand
  <span class="pre">
   cache-policy
  </span>
  specifies the cache eviction policy that may be used
during the memory access.
 </p>
 <p>
  <span class="pre">
   cache-policy
  </span>
  is a hint to the cache subsystem and may not always be respected. It is treated as
a performance hint only, and does not change the memory consistency behavior of the program. The
qualifier
  <span class="pre">
   .level::cache_hint
  </span>
  is only supported when at least one of the
  <span class="pre">
   .src
  </span>
  or
  <span class="pre">
   .dst
  </span>
  statespaces is
  <span class="pre">
   .global
  </span>
  state space.
 </p>
 <p>
  Each reduction operation performed by
  <span class="pre">
   cp.reduce.async.bulk.tensor
  </span>
  has individually
  <span class="pre">
   .relaxed.gpu
  </span>
  memory ordering semantics. The load operations in
  <span class="pre">
   cp.reduce.async.bulk.tensor
  </span>
  are treated as weak memory operations and the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-complete-tx-operation">
   complete-tx
  </a>
  operation on the mbarrier has
  <span class="pre">
   .release
  </span>
  semantics at the
  <span class="pre">
   .cluster
  </span>
  scope as described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory Consistency Model
  </a>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 8.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>cp.reduce.async.bulk.tensor.1d.global.shared::cta.add.tile.bulk_group
                                             [tensorMap0, {tc0}], [sMem0];

cp.reduce.async.bulk.tensor.2d.global.shared::cta.and.bulk_group.L2::cache_hint
                                             [tensorMap1, {tc0, tc1}], [sMem1] , policy;

cp.reduce.async.bulk.tensor.3d.global.shared::cta.xor.im2col.bulk_group
                                             [tensorMap2, {tc0, tc1, tc2}], [sMem2]
</pre>
 <h5>
  <span class="section-number">
   9.7.8.24.11.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk-prefetch-tensor">
   Data Movement and Conversion Instructions: cp.async.bulk.prefetch.tensor
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk-prefetch-tensor" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  cp.async.bulk.prefetch.tensor
 </p>
 <p>
  Provides a hint to the system to initiate the asynchronous prefetch of tensor data to the cache.
 </p>
 <p>
  Syntax
 </p>
 <pre>// global -&gt; shared::cluster:
cp.async.bulk.prefetch.tensor.dim.L2.src{.load_mode}{.level::cache_hint} [tensorMap, tensorCoords]
                                                             {, im2colOffsets } {, cache-policy}

.src =                { .global }
.dim =                { .1d, .2d, .3d, .4d, .5d }
.load_mode =          { .tile, .im2col }
.level::cache_hint =  { .L2::cache_hint }
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   cp.async.bulk.prefetch.tensor
  </span>
  is a non-blocking instruction which may initiate an asynchronous
prefetch of tensor data from the location in
  <span class="pre">
   .src
  </span>
  statespace to the L2 cache.
 </p>
 <p>
  The operand
  <span class="pre">
   tensorMap
  </span>
  is the generic address of the opaque tensor-map object which resides
either in
  <span class="pre">
   .param
  </span>
  space or
  <span class="pre">
   .const
  </span>
  space or
  <span class="pre">
   .global
  </span>
  space. The operand
  <span class="pre">
   tensorMap
  </span>
  specifies
the properties of the tensor copy operation, as described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-tensormap">
   Tensor-map
  </a>
  .
The
  <span class="pre">
   tensorMap
  </span>
  is accessed in tensormap proxy. Refer to the
  CUDA programming guide
  for creating
the tensor-map objects on the host side.
 </p>
 <p>
  The dimension of the tensor data is specified by the
  <span class="pre">
   .dim
  </span>
  modifier.
 </p>
 <p>
  The vector operand
  <span class="pre">
   tensorCoords
  </span>
  specifies the starting coordinates in the tensor data in the
global memory from or to which the copy operation has to be performed. The number of tensor
coordinates in the vector argument
  <span class="pre">
   tensorCoords
  </span>
  should be equal to the dimension specified by
the modifier
  <span class="pre">
   .dim
  </span>
  . The individual tensor coordinates in
  <span class="pre">
   tensorCoords
  </span>
  are of type
  <span class="pre">
   .s32
  </span>
  .
 </p>
 <p>
  The qualifier
  <span class="pre">
   .load_mode
  </span>
  specifies how the data in the source location is copied into the
destination location. If
  <span class="pre">
   .load_mode
  </span>
  is not specified, it defaults to
  <span class="pre">
   .tile
  </span>
  . In
  <span class="pre">
   .tile
  </span>
  mode, the multi-dimensional layout of the source tensor is preserved at the destination. In
  <span class="pre">
   .im2col
  </span>
  mode, some dimensions of the source tensors are unrolled in a single dimensional column
at the destination. Details of the
  <span class="pre">
   im2col
  </span>
  mode are described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-im2col-mode">
   Im2col mode
  </a>
  . In
  <span class="pre">
   .im2col
  </span>
  mode, the tensor has to be at least
3-dimensional. The vector operand
  <span class="pre">
   im2colOffsets
  </span>
  can be specified only when
  <span class="pre">
   .load_mode
  </span>
  is
.im2col. The length of the vector operand
  <span class="pre">
   im2colOffsets
  </span>
  is two less than the number of dimension
  <span class="pre">
   .dim
  </span>
  of the tensor operation.
 </p>
 <p>
  When the optional argument
  <span class="pre">
   cache-policy
  </span>
  is specified, the qualifier
  <span class="pre">
   .level::cache_hint
  </span>
  is
required. The 64-bit operand
  <span class="pre">
   cache-policy
  </span>
  specifies the cache eviction policy that may be used
during the memory access.
 </p>
 <p>
  <span class="pre">
   cache-policy
  </span>
  is a hint to the cache subsystem and may not always be respected. It is treated as
a performance hint only, and does not change the memory consistency behavior of the program.
 </p>
 <p>
  <span class="pre">
   cp.async.bulk.prefetch.tensor
  </span>
  is treated as a weak memory operation in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory Consistency
Model
  </a>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 8.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>.reg .b16 ctaMask;
.reg .u16 i2cOffW, i2cOffH, i2cOffD;
.reg .b64 l2CachePolicy;

cp.async.bulk.prefetch.tensor.1d.L2.global.tile  [tensorMap0, {tc0}];

@p cp.async.bulk.prefetch.tensor.2d.L2.global    [tensorMap1, {tc0, tc1}];

@p cp.async.bulk.prefetch.tensor.5d.L2.global.im2col
                      [tensorMap2, {tc0, tc1, tc2, tc3, tc4}], {i2cOffW, i2cOffH, i2cOffD};

@p cp.async.bulk.prefetch.tensor.3d.L2.global.im2col.L2::cache_hint
                      [tensorMap3, {tc0, tc1, tc2}], {i2cOffW}, policy;
</pre>
 <h5>
  <span class="section-number">
   9.7.8.24.12.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk-commit-group">
   Data Movement and Conversion Instructions: cp.async.bulk.commit_group
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk-commit-group" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  cp.async.bulk.commit_group
 </p>
 <p>
  Commits all prior initiated but uncommitted
  <span class="pre">
   cp.async.bulk
  </span>
  instructions into a
  cp.async.bulk-group
  .
 </p>
 <p>
  Syntax
 </p>
 <pre>cp.async.bulk.commit_group;
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   cp.async.bulk.commit_group
  </span>
  instruction creates a new per-thread
  bulk async-group
  and batches
all prior
  <span class="pre">
   cp{.reduce}.async.bulk.{.prefetch}{.tensor}
  </span>
  instructions satisfying the following
conditions into the new
  bulk async-group
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    The prior
    <span class="pre">
     cp{.reduce}.async.bulk.{.prefetch}{.tensor}
    </span>
    instructions use
    bulk_group
    based
completion mechanism, and
   </p>
  </li>
  <li>
   <p>
    They are initiated by the executing thread but not committed to any
    bulk async-group
    .
   </p>
  </li>
 </ul>
 <p>
  If there are no uncommitted
  <span class="pre">
   cp{.reduce}.async.bulk.{.prefetch}{.tensor}
  </span>
  instructions then
  <span class="pre">
   cp.async.bulk.commit_group
  </span>
  results in an empty
  bulk async-group
  .
 </p>
 <p>
  An executing thread can wait for the completion of all
  <span class="pre">
   cp{.reduce}.async.bulk.{.prefetch}{.tensor}
  </span>
  operations in a
  bulk async-group
  using
  <span class="pre">
   cp.async.wait_group
  </span>
  .
 </p>
 <p>
  There is no memory ordering guarantee provided between any two
  <span class="pre">
   cp{.reduce}.async.bulk.{.prefetch}{.tensor}
  </span>
  operations within the same
  bulk async-group
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 8.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>cp.async.bulk.commit_group;
</pre>
 <h5>
  <span class="section-number">
   9.7.8.24.13.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk-wait-group">
   Data Movement and Conversion Instructions: cp.async.bulk.wait_group
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk-wait-group" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  cp.async.bulk.wait_group
 </p>
 <p>
  Wait for completion of
  bulk async-groups
  .
 </p>
 <p>
  Syntax
 </p>
 <pre>cp.async.bulk.wait_group{.read} N;
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   cp.async.bulk.wait_group
  </span>
  instruction will cause the executing thread to wait until only N or
fewer of the most recent
  bulk async-groups
  are pending and all the prior
  bulk async-groups
  committed by the executing threads are complete. For example, when N is 0, the executing thread
waits on all the prior
  bulk async-groups
  to complete. Operand N is an integer constant.
 </p>
 <p>
  By default,
  <span class="pre">
   cp.async.bulk.wait_group
  </span>
  instruction will cause the executing thread to wait till
all the bulk async operations in the specified
  bulk async-group
  have completed all of the
following:
 </p>
 <ul class="simple">
  <li>
   <p>
    Reading from the source locations.
   </p>
  </li>
  <li>
   <p>
    Writing to their respective destination locations.
   </p>
  </li>
  <li>
   <p>
    Writes being made visible to the executing thread.
   </p>
  </li>
 </ul>
 <p>
  The optional
  <span class="pre">
   .read
  </span>
  modifier indicates that the waiting has to be done until all the bulk async
operations in the specified
  bulk async-group
  have completed reading from their source locations.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 8.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>cp.async.bulk.wait_group.read   0;
cp.async.bulk.wait_group        2;
</pre>
 <h4>
  <span class="section-number">
   9.7.8.25.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-tensormap-replace">
   Data Movement and Conversion Instructions: tensormap.replace
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-tensormap-replace" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  tensormap.replace
 </p>
 <p>
  Modifies the field of a tensor-map object.
 </p>
 <p>
  Syntax
 </p>
 <pre>tensormap.replace.mode.field1{.ss}.b1024.type  [addr], new_val;
tensormap.replace.mode.field2{.ss}.b1024.type  [addr], ord, new_val;
tensormap.replace.mode.field3{.ss}.b1024.type  [addr], new_val;

.mode    = { .tile }
.field1  = { .global_address, .rank }
.field2  = { .box_dim, .global_dim, .global_stride, .element_stride  }
.field3  = { .elemtype,  .interleave_layout, .swizzle_mode, .fill_mode }
.ss      = { .global, .shared::cta }
.type    = { .b32, .b64 }
</pre>
 <p>
  Description
 </p>
 <p>
  The
  <span class="pre">
   tensormap.replace
  </span>
  instruction replaces the field, specified by
  <span class="pre">
   .field
  </span>
  qualifier,
of the tensor-map object at the location specified by the address operand
  <span class="pre">
   addr
  </span>
  with a
new value. The new value is specified by the argument
  <span class="pre">
   new_val
  </span>
  .
 </p>
 <p>
  Qualifier
  <span class="pre">
   .mode
  </span>
  specifies the mode of the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-tensormap">
   tensor-map
  </a>
  object
located at the address operand
  <span class="pre">
   addr
  </span>
  .
 </p>
 <p>
  Instruction type
  <span class="pre">
   .b1024
  </span>
  indicates the size of the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-tensormap">
   tensor-map
  </a>
  object, which is 1024 bits.
 </p>
 <p>
  Operand
  <span class="pre">
   new_val
  </span>
  has the type
  <span class="pre">
   .type
  </span>
  . When
  <span class="pre">
   .field
  </span>
  is specified as
  <span class="pre">
   .global_address
  </span>
  or
  <span class="pre">
   .global_stride
  </span>
  ,
  <span class="pre">
   .type
  </span>
  must be
  <span class="pre">
   .b64
  </span>
  . Otherwise,
  <span class="pre">
   .type
  </span>
  must be
  <span class="pre">
   .b32
  </span>
  .
 </p>
 <p>
  The immediate integer operand
  <span class="pre">
   ord
  </span>
  specifies the ordinal of the field across the rank of the
tensor which needs to be replaced in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-tensormap">
   tensor-map
  </a>
  object.
 </p>
 <p>
  For field
  <span class="pre">
   .rank
  </span>
  , the operand
  <span class="pre">
   new_val
  </span>
  must be ones less than the desired tensor rank as
this field uses zero-based numbering.
 </p>
 <p>
  When
  <span class="pre">
   .field3
  </span>
  is specified, the operand
  <span class="pre">
   new_val
  </span>
  must be an immediate and the
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensormap-new-val-validity">
   <span class="std std-numref">
    Table 30
   </span>
  </a>
  shows the mapping of the operand
  <span class="pre">
   new_val
  </span>
  across various fields.
 </p>
 <table class="table-no-stripes docutils align-default" id="tensormap-new-val-validity">
  <span class="caption-number">
   Table 30
  </span>
  <span class="caption-text">
   Tensormap new_val validity
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensormap-new-val-validity" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head" rowspan="2">
    <p>
     new_val
    </p>
   </th>
   <th class="head" colspan="4">
    <p>
     .field3
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <th class="head">
    <p>
     .elemtype
    </p>
   </th>
   <th class="head">
    <p>
     .interleave_layout
    </p>
   </th>
   <th class="head">
    <p>
     .swizzle_mode
    </p>
   </th>
   <th class="head">
    <p>
     .fill_mode
    </p>
   </th>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .u8
     </span>
    </p>
   </td>
   <td>
    <p>
     No interleave
    </p>
   </td>
   <td>
    <p>
     No swizzling
    </p>
   </td>
   <td>
    <p>
     Zero fill
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .u16
     </span>
    </p>
   </td>
   <td>
    <p>
     16B interleave
    </p>
   </td>
   <td>
    <p>
     32B swizzling
    </p>
   </td>
   <td>
    <p>
     OOB-NaN fill
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     2
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .u32
     </span>
    </p>
   </td>
   <td>
    <p>
     32B interleave
    </p>
   </td>
   <td>
    <p>
     64B swizzling
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     3
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .s32
     </span>
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     128B swizzling
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     4
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .u64
     </span>
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     5
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .s64
     </span>
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     6
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .f16
     </span>
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     7
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .f32
     </span>
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     8
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .f32.ftz
     </span>
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     9
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .f64
     </span>
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     10
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .bf16
     </span>
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     11
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .tf32
     </span>
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     12
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .tf32.ftz
     </span>
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
   <td>
    <p>
     x
    </p>
   </td>
  </tr>
 </table>
 <p>
  If no state space is specified then
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#generic-addressing">
   Generic Addressing
  </a>
  is used.
If the address specified by
  <span class="pre">
   addr
  </span>
  does not fall within the address window of
  <span class="pre">
   .global
  </span>
  or
  <span class="pre">
   .shared::cta
  </span>
  state space then the behavior is undefined.
 </p>
 <p>
  <span class="pre">
   tensormap.replace
  </span>
  is treated as a weak memory operation, on the entire 1024-bit opaque
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-tensormap">
   tensor-map
  </a>
  object, in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory Consistency Model
  </a>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 8.3.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90a
  </span>
  .
 </p>
 <p>
  Examples
 </p>
 <pre>tensormap.replace.tile.global_address.shared::cta.b1024.b64   [sMem], new_val;
</pre>
 <h3>
  <span class="section-number">
   9.7.9.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texture-instructions">
   Texture Instructions
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texture-instructions" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  This section describes PTX instructions for accessing textures and samplers. PTX supports the
following operations on texture and sampler descriptors:
 </p>
 <ul class="simple">
  <li>
   <p>
    Static initialization of texture and sampler descriptors.
   </p>
  </li>
  <li>
   <p>
    Module-scope and per-entry scope definitions of texture and sampler descriptors.
   </p>
  </li>
  <li>
   <p>
    Ability to query fields within texture and sampler descriptors.
   </p>
  </li>
 </ul>
 <h4>
  <span class="section-number">
   9.7.9.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texturing-modes">
   Texturing Modes
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texturing-modes" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  For working with textures and samplers, PTX has two modes of operation. In the
  unified mode,
  texture and sampler information is accessed through a single
  <span class="pre">
   .texref
  </span>
  handle. In the
  independent
mode
  , texture and sampler information each have their own handle, allowing them to be defined
separately and combined at the site of usage in the program.
 </p>
 <p>
  The advantage of unified mode is that it allows 256 samplers per kernel (128 for architectures prior
to
  <span class="pre">
   sm_3x
  </span>
  ), with the restriction that they correspond 1-to-1 with the 256 possible textures per
kernel (128 for architectures prior to
  <span class="pre">
   sm_3x
  </span>
  ). The advantage of independent mode is that
textures and samplers can be mixed and matched, but the number of samplers is greatly restricted to
32 per kernel (16 for architectures prior to
  <span class="pre">
   sm_3x
  </span>
  ).
 </p>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texturing-modes-textures-samplers-surfaces">
   <span class="std std-numref">
    Table 31
   </span>
  </a>
  summarizes the number of textures, samplers and
surfaces available in different texturing modes.
 </p>
 <table class="table-no-stripes docutils align-default" id="texturing-modes-textures-samplers-surfaces">
  <span class="caption-number">
   Table 31
  </span>
  <span class="caption-text">
   Texture, sampler and surface limits
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texturing-modes-textures-samplers-surfaces" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     Texturing mode
    </p>
   </th>
   <th class="head">
    <p>
     Resource
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      sm_1x
     </span>
     ,
     <span class="pre">
      sm_2x
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      sm_3x+
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     Unified mode
    </p>
   </td>
   <td>
    <p>
     Textures
    </p>
   </td>
   <td>
    <p>
     128
    </p>
   </td>
   <td>
    <p>
     256
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     Samplers
    </p>
   </td>
   <td>
    <p>
     128
    </p>
   </td>
   <td>
    <p>
     256
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     Surfaces
    </p>
   </td>
   <td>
    <p>
     8
    </p>
   </td>
   <td>
    <p>
     16
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     Independent mode
    </p>
   </td>
   <td>
    <p>
     Textures
    </p>
   </td>
   <td>
    <p>
     128
    </p>
   </td>
   <td>
    <p>
     256
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     Samplers
    </p>
   </td>
   <td>
    <p>
     16
    </p>
   </td>
   <td>
    <p>
     32
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     Surfaces
    </p>
   </td>
   <td>
    <p>
     8
    </p>
   </td>
   <td>
    <p>
     16
    </p>
   </td>
  </tr>
 </table>
 <p>
  The texturing mode is selected using
  <span class="pre">
   .target
  </span>
  options
  <span class="pre">
   texmode_unified
  </span>
  and
  <span class="pre">
   texmode_independent
  </span>
  . A PTX module may declare only one texturing mode. If no texturing mode is
declared, the module is assumed to use unified mode.
 </p>
 <p>
  Example
  : calculate an elementâs power contribution as elementâs power/total number of elements.
 </p>
 <pre>.target texmode_independent
.global .samplerref tsamp1 = { addr_mode_0 = clamp_to_border,
                               filter_mode = nearest
                             };
...
.entry compute_power
  ( .param .texref tex1 )
{
  txq.width.b32  r6, [tex1]; // get tex1's width
  txq.height.b32 r5, [tex1]; // get tex1's height
  tex.2d.v4.f32.f32  {r1,r2,r3,r4}, [tex1, tsamp1, {f1,f2}];
  mul.u32 r5, r5, r6;
  add.f32 r1, r1, r2;
  add.f32 r3, r3, r4;
  add.f32 r1, r1, r3;
  cvt.f32.u32 r5, r5;
  div.f32 r1, r1, r5;
}
</pre>
 <h4>
  <span class="section-number">
   9.7.9.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mipmaps">
   Mipmaps
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mipmaps" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  A
  mipmap
  is a sequence of textures, each of which is a progressively lower resolution
representation of the same image. The height and width of each image, or level of detail (LOD), in
the mipmap is a power of two smaller than the previous level. Mipmaps are used in graphics
applications to improve rendering speed and reduce aliasing artifacts. For example, a
high-resolution mipmap image is used for objects that are close to the user; lower-resolution images
are used as the object appears farther away. Mipmap filtering modes are provided when switching
between two levels of detail (LODs) in order to avoid abrupt changes in visual fidelity.
 </p>
 <p>
  Example:
  If the texture has a basic size of 256 by 256 pixels, then the associated mipmap set
may contain a series of eight images, each one-fourth the total area of the previous one: 128Ã128
pixels, 64Ã64, 32Ã32, 16Ã16, 8Ã8, 4Ã4, 2Ã2, 1Ã1 (a single pixel). If, for example, a scene is
rendering this texture in a space of 40Ã40 pixels, then either a scaled up version of the 32Ã32
(without trilinear interpolation) or an interpolation of the 64Ã64 and the 32Ã32 mipmaps (with
trilinear interpolation) would be used.
 </p>
 <p>
  The total number of LODs in a complete mipmap pyramid is calculated through the following equation:
 </p>
 <pre>numLODs = 1 + floor(log2(max(w, h, d)))
</pre>
 <p>
  The finest LOD is called the base level and is the 0th level. The next (coarser) level is the 1st
level, and so on. The coarsest level is the level of size (1 x 1 x 1). Each successively smaller
mipmap level has half the {width, height, depth} of the previous level, but if this half value is a
fractional value, itâs rounded down to the next largest integer. Essentially, the size of a mipmap
level can be specified as:
 </p>
 <pre>max(1, floor(w_b / 2^i)) x
max(1, floor(h_b / 2^i)) x
max(1, floor(d_b / 2^i))
</pre>
 <p>
  where
  i
  is the ith level beyond the 0th level (the base level). And
  w_b
  ,
  h_b
  and
  d_b
  are the
width, height and depth of the base level respectively.
 </p>
 <p>
  PTX support for mipmaps
 </p>
 <p>
  The PTX
  <span class="pre">
   tex
  </span>
  instruction supports three modes for specifying the LOD:
  base
  ,
  level
  , and
  grad
  ient. In base mode, the instruction always picks level 0. In level mode, an additional
argument is provided to specify the LOD to fetch from. In gradmode, two floating-point vector
arguments provide
  partials
  (e.g.,
  <span class="pre">
   {ds/dx,
  </span>
  <span class="pre">
   dt/dx}
  </span>
  and
  <span class="pre">
   {ds/dy,
  </span>
  <span class="pre">
   dt/dy}
  </span>
  for a 2d texture),
which the
  <span class="pre">
   tex
  </span>
  instruction uses to compute the LOD.
 </p>
 <p>
  These instructions provide access to texture memory.
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     tex
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     tld4
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     txq
    </span>
   </p>
  </li>
 </ul>
 <h4>
  <span class="section-number">
   9.7.9.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texture-instructions-tex">
   Texture Instructions: tex
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texture-instructions-tex" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  tex
 </p>
 <p>
  Perform a texture memory lookup.
 </p>
 <p>
  Syntax
 </p>
 <pre>tex.geom.v4.dtype.ctype  d, [a, c] {, e} {, f};
tex.geom.v4.dtype.ctype  d[|p], [a, b, c] {, e} {, f};  // explicit sampler

tex.geom.v2.f16x2.ctype  d[|p], [a, c] {, e} {, f};
tex.geom.v2.f16x2.ctype  d[|p], [a, b, c] {, e} {, f};  // explicit sampler

// mipmaps
tex.base.geom.v4.dtype.ctype   d[|p], [a, {b,} c] {, e} {, f};
tex.level.geom.v4.dtype.ctype  d[|p], [a, {b,} c], lod {, e} {, f};
tex.grad.geom.v4.dtype.ctype   d[|p], [a, {b,} c], dPdx, dPdy {, e} {, f};

tex.base.geom.v2.f16x2.ctype   d[|p], [a, {b,} c] {, e} {, f};
tex.level.geom.v2.f16x2.ctype  d[|p], [a, {b,} c], lod {, e} {, f};
tex.grad.geom.v2.f16x2.ctype   d[|p], [a, {b,} c], dPdx, dPdy {, e} {, f};

.geom  = { .1d, .2d, .3d, .a1d, .a2d, .cube, .acube, .2dms, .a2dms };
.dtype = { .u32, .s32, .f16,  .f32 };
.ctype = {       .s32, .f32 };          // .cube, .acube require .f32
                                        // .2dms, .a2dms require .s32
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   tex.{1d,2d,3d}
  </span>
 </p>
 <p>
  Texture lookup using a texture coordinate vector. The instruction loads data from the texture named
by operand
  <span class="pre">
   a
  </span>
  at coordinates given by operand
  <span class="pre">
   c
  </span>
  into destination
  <span class="pre">
   d
  </span>
  . Operand
  <span class="pre">
   c
  </span>
  is a
scalar or singleton tuple for 1d textures; is a two-element vector for 2d textures; and is a
four-element vector for 3d textures, where the fourth element is ignored. An optional texture
sampler
  <span class="pre">
   b
  </span>
  may be specified. If no sampler is specified, the sampler behavior is a property of
the named texture. The optional destination predicate
  <span class="pre">
   p
  </span>
  is set to
  <span class="pre">
   True
  </span>
  if data from texture
at specified coordinates is resident in memory,
  <span class="pre">
   False
  </span>
  otherwise. When optional destination
predicate
  <span class="pre">
   p
  </span>
  is set to
  <span class="pre">
   False
  </span>
  , data loaded will be all zeros. Memory residency of Texture Data
at specified coordinates is dependent on execution environment setup using Driver API calls, prior
to kernel launch. Refer to Driver API documentation for more details including any
system/implementation specific behavior.
 </p>
 <p>
  An optional operand
  <span class="pre">
   e
  </span>
  may be specified. Operand
  <span class="pre">
   e
  </span>
  is a vector of
  <span class="pre">
   .s32
  </span>
  values that
specifies coordinate offset. Offset is applied to coordinates before doing texture lookup. Offset
value is in the range of -8 to +7. Operand
  <span class="pre">
   e
  </span>
  is a singleton tuple for 1d textures; is a two
element vector 2d textures; and is four-element vector for 3d textures, where the fourth element is
ignored.
 </p>
 <p>
  An optional operand
  <span class="pre">
   f
  </span>
  may be specified for
  <span class="pre">
   depth
  </span>
  <span class="pre">
   textures
  </span>
  . Depth textures are special type
of textures which hold data from the depth buffer. Depth buffer contains depth information of each
pixel. Operand
  <span class="pre">
   f
  </span>
  is
  <span class="pre">
   .f32
  </span>
  scalar value that specifies depth compare value for depth
textures. Each element fetched from texture is compared against value given in
  <span class="pre">
   f
  </span>
  operand. If
comparison passes, result is 1.0; otherwise result is 0.0. These per-element comparison results are
used for the filtering. When using depth compare operand, the elements in texture coordinate vector
  <span class="pre">
   c
  </span>
  have
  <span class="pre">
   .f32
  </span>
  type.
 </p>
 <p>
  Depth compare operand is not supported for
  <span class="pre">
   3d
  </span>
  textures.
 </p>
 <p>
  The instruction returns a two-element vector for destination type
  <span class="pre">
   .f16x2
  </span>
  . For all other
destination types, the instruction returns a four-element vector. Coordinates may be given in either
signed 32-bit integer or 32-bit floating point form.
 </p>
 <p>
  A texture base address is assumed to be aligned to a 16 byte boundary, and the address given by the
coordinate vector must be naturally aligned to a multiple of the access size. If an address is not
properly aligned, the resulting behavior is undefined; i.e., the access may proceed by silently
masking off low-order address bits to achieve proper rounding, or the instruction may fault.
 </p>
 <p>
  <span class="pre">
   tex.{a1d,a2d}
  </span>
 </p>
 <p>
  Texture array selection, followed by texture lookup. The instruction first selects a texture from
the texture array named by operand
  <span class="pre">
   a
  </span>
  using the index given by the first element of the array
coordinate vector
  <span class="pre">
   c
  </span>
  . The instruction then loads data from the selected texture at coordinates
given by the remaining elements of operand
  <span class="pre">
   c
  </span>
  into destination
  <span class="pre">
   d
  </span>
  . Operand
  <span class="pre">
   c
  </span>
  is a bit-size
type vector or tuple containing an index into the array of textures followed by coordinates within
the selected texture, as follows:
 </p>
 <ul class="simple">
  <li>
   <p>
    For 1d texture arrays, operand
    <span class="pre">
     c
    </span>
    has type
    <span class="pre">
     .v2.b32
    </span>
    . The first element is interpreted as an
unsigned integer index (
    <span class="pre">
     .u32
    </span>
    ) into the texture array, and the second element is interpreted as
a 1d texture coordinate of type
    <span class="pre">
     .ctype
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    For 2d texture arrays, operand
    <span class="pre">
     c
    </span>
    has type
    <span class="pre">
     .v4.b32
    </span>
    . The first element is interpreted as an
unsigned integer index (
    <span class="pre">
     .u32
    </span>
    ) into the texture array, and the next two elements are
interpreted as 2d texture coordinates of type
    <span class="pre">
     .ctype
    </span>
    . The fourth element is ignored.
   </p>
  </li>
 </ul>
 <p>
  An optional texture sampler
  <span class="pre">
   b
  </span>
  may be specified. If no sampler is specified, the sampler behavior
is a property of the named texture.
 </p>
 <p>
  An optional operand
  <span class="pre">
   e
  </span>
  may be specified. Operand
  <span class="pre">
   e
  </span>
  is a vector of
  <span class="pre">
   .s32
  </span>
  values that
specifies coordinate offset. Offset is applied to coordinates before doing texture lookup. Offset
value is in the range of -8 to +7. Operand
  <span class="pre">
   e
  </span>
  is a singleton tuple for 1d texture arrays; and is
a two element vector 2d texture arrays.
 </p>
 <p>
  An optional operand
  <span class="pre">
   f
  </span>
  may be specified for depth textures arrays. Operand
  <span class="pre">
   f
  </span>
  is
  <span class="pre">
   .f32
  </span>
  scalar value that specifies depth compare value for depth textures. When using depth compare
operand, the coordinates in texture coordinate vector
  <span class="pre">
   c
  </span>
  have
  <span class="pre">
   .f32
  </span>
  type.
 </p>
 <p>
  The instruction returns a two-element vector for destination type
  <span class="pre">
   .f16x2
  </span>
  . For all other
destination types, the instruction returns a four-element vector. The texture array index is a
32-bit unsigned integer, and texture coordinate elements are 32-bit signed integer or floating point
values.
 </p>
 <p>
  The optional destination predicate
  <span class="pre">
   p
  </span>
  is set to
  <span class="pre">
   True
  </span>
  if data from texture at specified
coordinates is resident in memory,
  <span class="pre">
   False
  </span>
  otherwise. When optional destination predicate
  <span class="pre">
   p
  </span>
  is
set to
  <span class="pre">
   False
  </span>
  , data loaded will be all zeros. Memory residency of Texture Data at specified
coordinates is dependent on execution environment setup using Driver API calls, prior to kernel
launch. Refer to Driver API documentation for more details including any system/implementation
specific behavior.
 </p>
 <p>
  <span class="pre">
   tex.cube
  </span>
 </p>
 <p>
  Cubemap
  texture lookup. The instruction loads data from the cubemap texture named by operand
  <span class="pre">
   a
  </span>
  at coordinates given by operand
  <span class="pre">
   c
  </span>
  into destination
  <span class="pre">
   d
  </span>
  . Cubemap textures are special
two-dimensional layered textures consisting of six layers that represent the faces of a cube. All
layers in a cubemap are of the same size and are square (i.e., width equals height).
 </p>
 <p>
  When accessing a cubemap, the texture coordinate vector
  <span class="pre">
   c
  </span>
  has type
  <span class="pre">
   .v4.f32
  </span>
  , and comprises
three floating-point coordinates (
  <span class="pre">
   s
  </span>
  ,
  <span class="pre">
   t
  </span>
  ,
  <span class="pre">
   r
  </span>
  ) and a fourth padding argument which is
ignored. Coordinates (
  <span class="pre">
   s
  </span>
  ,
  <span class="pre">
   t
  </span>
  ,
  <span class="pre">
   r
  </span>
  ) are projected onto one of the six cube faces. The (
  <span class="pre">
   s
  </span>
  ,
  <span class="pre">
   t
  </span>
  ,
  <span class="pre">
   r
  </span>
  ) coordinates can be thought of as a direction vector emanating from the center of the
cube. Of the three coordinates (
  <span class="pre">
   s
  </span>
  ,
  <span class="pre">
   t
  </span>
  ,
  <span class="pre">
   r
  </span>
  ), the coordinate of the largest magnitude (the
major axis) selects the cube face. Then, the other two coordinates (the minor axes) are divided by
the absolute value of the major axis to produce a new (
  <span class="pre">
   s
  </span>
  ,
  <span class="pre">
   t
  </span>
  ) coordinate pair to lookup into
the selected cube face.
 </p>
 <p>
  An optional texture sampler
  <span class="pre">
   b
  </span>
  may be specified. If no sampler is specified, the sampler behavior
is a property of the named texture.
 </p>
 <p>
  Offset vector operand
  <span class="pre">
   e
  </span>
  is not supported for cubemap textures.
 </p>
 <p>
  an optional operand
  <span class="pre">
   f
  </span>
  may be specified for cubemap depth textures. operand
  <span class="pre">
   f
  </span>
  is
  <span class="pre">
   .f32
  </span>
  scalar value that specifies depth compare value for cubemap depth textures.
 </p>
 <p>
  The optional destination predicate
  <span class="pre">
   p
  </span>
  is set to
  <span class="pre">
   True
  </span>
  if data from texture at specified
coordinates is resident in memory,
  <span class="pre">
   False
  </span>
  otherwise. When optional destination predicate
  <span class="pre">
   p
  </span>
  is
set to
  <span class="pre">
   False
  </span>
  , data loaded will be all zeros. Memory residency of Texture Data at specified
coordinates is dependent on execution environment setup using Driver API calls, prior to kernel
launch. Refer to Driver API documentation for more details including any system/implementation
specific behavior.
 </p>
 <p>
  <span class="pre">
   tex.acube
  </span>
 </p>
 <p>
  Cubemap array selection, followed by cubemap lookup. The instruction first selects a cubemap texture
from the cubemap array named by operand
  <span class="pre">
   a
  </span>
  using the index given by the first element of the
array coordinate vector
  <span class="pre">
   c
  </span>
  . The instruction then loads data from the selected cubemap texture at
coordinates given by the remaining elements of operand
  <span class="pre">
   c
  </span>
  into destination
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  Cubemap array
  textures consist of an array of cubemaps, i.e., the total number of layers is a
multiple of six. When accessing a cubemap array texture, the coordinate vector
  <span class="pre">
   c
  </span>
  has type
  <span class="pre">
   .v4.b32
  </span>
  . The first element is interpreted as an unsigned integer index (
  <span class="pre">
   .u32
  </span>
  ) into the
cubemap array, and the remaining three elements are interpreted as floating-point cubemap
coordinates (
  <span class="pre">
   s
  </span>
  ,
  <span class="pre">
   t
  </span>
  ,
  <span class="pre">
   r
  </span>
  ), used to lookup in the selected cubemap as described above.
 </p>
 <p>
  An optional texture sampler
  <span class="pre">
   b
  </span>
  may be specified. If no sampler is specified, the sampler behavior
is a property of the named texture.
 </p>
 <p>
  Offset vector operand
  <span class="pre">
   e
  </span>
  is not supported for cubemap texture arrays.
 </p>
 <p>
  An optional operand
  <span class="pre">
   f
  </span>
  may be specified for cubemap depth texture arrays. Operand
  <span class="pre">
   f
  </span>
  is
  <span class="pre">
   .f32
  </span>
  scalar value that specifies depth compare value for cubemap depth textures.
 </p>
 <p>
  The optional destination predicate
  <span class="pre">
   p
  </span>
  is set to
  <span class="pre">
   True
  </span>
  if data from texture at specified
coordinates is resident in memory,
  <span class="pre">
   False
  </span>
  otherwise. When optional destination predicate
  <span class="pre">
   p
  </span>
  is
set to
  <span class="pre">
   False
  </span>
  , data loaded will be all zeros. Memory residency of Texture Data at specified
coordinates is dependent on execution environment setup using Driver API calls, prior to kernel
launch. Refer to Driver API documentation for more details including any system/implementation
specific behavior.
 </p>
 <p>
  <span class="pre">
   tex.2dms
  </span>
 </p>
 <p>
  Multi-sample texture lookup using a texture coordinate vector. Multi-sample textures consist of
multiple samples per data element. The instruction loads data from the texture named by operand
  <span class="pre">
   a
  </span>
  from sample number given by first element of the operand
  <span class="pre">
   c
  </span>
  , at coordinates given by
remaining elements of operand
  <span class="pre">
   c
  </span>
  into destination
  <span class="pre">
   d
  </span>
  . When accessing a multi-sample texture,
texture coordinate vector
  <span class="pre">
   c
  </span>
  has type
  <span class="pre">
   .v4.b32
  </span>
  . The first element in operand
  <span class="pre">
   c
  </span>
  is
interpreted as unsigned integer sample number (
  <span class="pre">
   .u32
  </span>
  ), and the next two elements are interpreted
as signed integer (
  <span class="pre">
   .s32
  </span>
  ) 2d texture coordinates. The fourth element is ignored. An optional
texture sampler
  <span class="pre">
   b
  </span>
  may be specified. If no sampler is specified, the sampler behavior is a
property of the named texture.
 </p>
 <p>
  An optional operand
  <span class="pre">
   e
  </span>
  may be specified. Operand
  <span class="pre">
   e
  </span>
  is a vector of type
  <span class="pre">
   .v2.s32
  </span>
  that
specifies coordinate offset. Offset is applied to coordinates before doing texture lookup. Offset
value is in the range of -8 to +7.
 </p>
 <p>
  Depth compare operand
  <span class="pre">
   f
  </span>
  is not supported for multi-sample textures.
 </p>
 <p>
  The optional destination predicate
  <span class="pre">
   p
  </span>
  is set to
  <span class="pre">
   True
  </span>
  if data from texture at specified
coordinates is resident in memory,
  <span class="pre">
   False
  </span>
  otherwise. When optional destination predicate
  <span class="pre">
   p
  </span>
  is
set to
  <span class="pre">
   False
  </span>
  , data loaded will be all zeros. Memory residency of Texture Data at specified
coordinates is dependent on execution environment setup using Driver API calls, prior to kernel
launch. Refer to Driver API documentation for more details including any system/implementation
specific behavior.
 </p>
 <p>
  <span class="pre">
   tex.a2dms
  </span>
 </p>
 <p>
  Multi-sample texture array selection, followed by multi-sample texture lookup. The instruction first
selects a multi-sample texture from the multi-sample texture array named by operand a using the
index given by the first element of the array coordinate vector
  <span class="pre">
   c
  </span>
  . The instruction then loads
data from the selected multi-sample texture from sample number given by second element of the
operand
  <span class="pre">
   c
  </span>
  , at coordinates given by remaining elements of operand
  <span class="pre">
   c
  </span>
  into destination
  <span class="pre">
   d
  </span>
  . When accessing a multi-sample texture array, texture coordinate vector
  <span class="pre">
   c
  </span>
  has type
  <span class="pre">
   .v4.b32
  </span>
  . The first element in operand c is interpreted as unsigned integer sampler number, the
second element is interpreted as unsigned integer index (
  <span class="pre">
   .u32
  </span>
  ) into the multi-sample texture
array and the next two elements are interpreted as signed integer (
  <span class="pre">
   .s32
  </span>
  ) 2d texture
coordinates. An optional texture sampler
  <span class="pre">
   b
  </span>
  may be specified. If no sampler is specified, the
sampler behavior is a property of the named texture.
 </p>
 <p>
  An optional operand
  <span class="pre">
   e
  </span>
  may be specified. Operand
  <span class="pre">
   e
  </span>
  is a vector of type
  <span class="pre">
   .v2.s32
  </span>
  values
that specifies coordinate offset. Offset is applied to coordinates before doing texture
lookup. Offset value is in the range of -8 to +7.
 </p>
 <p>
  Depth compare operand
  <span class="pre">
   f
  </span>
  is not supported for multi-sample texture arrays.
 </p>
 <p>
  The optional destination predicate
  <span class="pre">
   p
  </span>
  is set to
  <span class="pre">
   True
  </span>
  if data from texture at specified
coordinates is resident in memory,
  <span class="pre">
   False
  </span>
  otherwise. When optional destination predicate
  <span class="pre">
   p
  </span>
  is
set to
  <span class="pre">
   False
  </span>
  , data loaded will be all zeros. Memory residency of Texture Data at specified
coordinates is dependent on execution environment setup using Driver API calls, prior to kernel
launch. Refer to Driver API documentation for more details including any system/implementation
specific behavior.
 </p>
 <p>
  Mipmaps
 </p>
 <span class="pre">
  .base
 </span>
 (lod zero)
 <p>
  Pick level 0 (base level). This is the default if no mipmap mode is specified. No additional arguments.
 </p>
 <span class="pre">
  .level
 </span>
 (lod explicit)
 <p>
  Requires an additional 32-bit scalar argument,
  <span class="pre">
   lod
  </span>
  , which contains the LOD to fetch from. The
type of
  <span class="pre">
   lod
  </span>
  follows
  <span class="pre">
   .ctype
  </span>
  (either
  <span class="pre">
   .s32
  </span>
  or
  <span class="pre">
   .f32
  </span>
  ). Geometries
  <span class="pre">
   .2dms
  </span>
  and
  <span class="pre">
   .a2dms
  </span>
  are not supported in this mode.
 </p>
 <span class="pre">
  .grad
 </span>
 (lod gradient)
 <p>
  Requires two
  <span class="pre">
   .f32
  </span>
  vectors,
  <span class="pre">
   dPdx
  </span>
  and
  <span class="pre">
   dPdy
  </span>
  , that specify the partials. The vectors are
singletons for 1d and a1d textures; are two-element vectors for 2d and a2d textures; and are
four-element vectors for 3d, cube and acube textures, where the fourth element is ignored for 3d
and cube geometries. Geometries
  <span class="pre">
   .2dms
  </span>
  and
  <span class="pre">
   .a2dms
  </span>
  are not supported in this mode.
 </p>
 <p>
  For mipmap texture lookup, an optional operand
  <span class="pre">
   e
  </span>
  may be specified. Operand
  <span class="pre">
   e
  </span>
  is a vector of
  <span class="pre">
   .s32
  </span>
  that specifies coordinate offset. Offset is applied to coordinates before doing texture
lookup. Offset value is in the range of -8 to +7. Offset vector operand is not supported for cube
and cubemap geometries.
 </p>
 <p>
  An optional operand
  <span class="pre">
   f
  </span>
  may be specified for mipmap textures. Operand
  <span class="pre">
   f
  </span>
  is
  <span class="pre">
   .f32
  </span>
  scalar
value that specifies depth compare value for depth textures. When using depth compare operand, the
coordinates in texture coordinate vector
  <span class="pre">
   c
  </span>
  have
  <span class="pre">
   .f32
  </span>
  type.
 </p>
 <p>
  The optional destination predicate
  <span class="pre">
   p
  </span>
  is set to
  <span class="pre">
   True
  </span>
  if data from texture at specified
coordinates is resident in memory,
  <span class="pre">
   False
  </span>
  otherwise. When optional destination predicate
  <span class="pre">
   p
  </span>
  is
set to
  <span class="pre">
   False
  </span>
  , data loaded will be all zeros. Memory residency of Texture Data at specified
coordinates is dependent on execution environment setup using Driver API calls, prior to kernel
launch. Refer to Driver API documentation for more details including any system/implementation
specific behavior.
 </p>
 <p>
  Depth compare operand is not supported for
  <span class="pre">
   3d
  </span>
  textures.
 </p>
 <p>
  Indirect texture access
 </p>
 <p>
  Beginning with PTX ISA version 3.1, indirect texture access is supported in unified mode for target
architecture
  <span class="pre">
   sm_20
  </span>
  or higher. In indirect access, operand
  <span class="pre">
   a
  </span>
  is a
  <span class="pre">
   .u64
  </span>
  register holding
the address of a
  <span class="pre">
   .texref
  </span>
  variable.
 </p>
 <p>
  Notes
 </p>
 <p>
  For compatibility with prior versions of PTX, the square brackets are not required and
  <span class="pre">
   .v4
  </span>
  coordinate vectors are allowed for any geometry, with the extra elements being ignored.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Unified mode texturing introduced in PTX ISA version 1.0. Extension using opaque
  <span class="pre">
   .texref
  </span>
  and
  <span class="pre">
   .samplerref
  </span>
  types and independent mode texturing introduced in PTX ISA version 1.5.
 </p>
 <p>
  Texture arrays
  <span class="pre">
   tex.{a1d,a2d}
  </span>
  introduced in PTX ISA version 2.3.
 </p>
 <p>
  Cubemaps and cubemap arrays introduced in PTX ISA version 3.0.
 </p>
 <p>
  Support for mipmaps introduced in PTX ISA version 3.1.
 </p>
 <p>
  Indirect texture access introduced in PTX ISA version 3.1.
 </p>
 <p>
  Multi-sample textures and multi-sample texture arrays introduced in PTX ISA version 3.2.
 </p>
 <p>
  Support for textures returning
  <span class="pre">
   .f16
  </span>
  and
  <span class="pre">
   .f16x2
  </span>
  data introduced in PTX ISA version 4.2.
 </p>
 <p>
  Support for
  <span class="pre">
   tex.grad.{cube,
  </span>
  <span class="pre">
   acube}
  </span>
  introduced in PTX ISA version 4.3.
 </p>
 <p>
  Offset vector operand introduced in PTX ISA version 4.3.
 </p>
 <p>
  Depth compare operand introduced in PTX ISA version 4.3.
 </p>
 <p>
  Support for optional destination predicate introduced in PTX ISA version 7.1.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  The cubemap array geometry (
  <span class="pre">
   .acube
  </span>
  ) requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Mipmaps require
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Indirect texture access requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Multi-sample textures and multi-sample texture arrays require
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Texture fetch returning
  <span class="pre">
   .f16
  </span>
  and
  <span class="pre">
   .f16x2
  </span>
  data require
  <span class="pre">
   sm_53
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   tex.grad.{cube,
  </span>
  <span class="pre">
   acube}
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Offset vector operand requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Depth compare operand requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Support for optional destination predicate requires
  <span class="pre">
   sm_60
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre> // Example of unified mode texturing
 // - f4 is required to pad four-element tuple and is ignored
 tex.3d.v4.s32.s32  {r1,r2,r3,r4}, [tex_a,{f1,f2,f3,f4}];

 // Example of independent mode texturing
 tex.1d.v4.s32.f32  {r1,r2,r3,r4}, [tex_a,smpl_x,{f1}];

 // Example of 1D texture array, independent texturing mode
 tex.a1d.v4.s32.s32 {r1,r2,r3,r4}, [tex_a,smpl_x,{idx,s1}];

 // Example of 2D texture array, unified texturing mode
 // - f3 is required to pad four-element tuple and is ignored
 tex.a2d.v4.s32.f32 {r1,r2,r3,r4}, [tex_a,{idx,f1,f2,f3}];

 // Example of cubemap array, unified textureing mode
 tex.acube.v4.f32.f32 {r0,r1,r2,r3}, [tex_cuarray,{idx,f1,f2,f3}];

 // Example of multi-sample texture, unified texturing mode
 tex.2dms.v4.s32.s32 {r0,r1,r2,r3}, [tex_ms,{sample,r6,r7,r8}];

 // Example of multi-sample texture, independent texturing mode
 tex.2dms.v4.s32.s32 {r0,r1,r2,r3}, [tex_ms, smpl_x,{sample,r6,r7,r8}];

 // Example of multi-sample texture array, unified texturing mode
 tex.a2dms.v4.s32.s32 {r0,r1,r2,r3}, [tex_ams,{idx,sample,r6,r7}];

 // Example of texture returning .f16 data
 tex.1d.v4.f16.f32  {h1,h2,h3,h4}, [tex_a,smpl_x,{f1}];

 // Example of texture returning .f16x2 data
 tex.1d.v2.f16x2.f32  {h1,h2}, [tex_a,smpl_x,{f1}];

 // Example of 3d texture array access with tex.grad,unified texturing mode
 tex.grad.3d.v4.f32.f32 {%f4,%f5,%f6,%f7},[tex_3d,{%f0,%f0,%f0,%f0}],
                 {fl0,fl1,fl2,fl3},{fl0,fl1,fl2,fl3};

// Example of cube texture array access with tex.grad,unified texturing mode
 tex.grad.cube.v4.f32.f32{%f4,%f5,%f6,%f7},[tex_cube,{%f0,%f0,%f0,%f0}],
                 {fl0,fl1,fl2,fl3},{fl0,fl1,fl2,fl3};

 // Example of 1d texture lookup with offset, unified texturing mode
 tex.1d.v4.s32.f32  {r1,r2,r3,r4}, [tex_a, {f1}], {r5};

 // Example of 2d texture array lookup with offset, unified texturing mode
 tex.a2d.v4.s32.f32  {r1,r2,r3,r4}, [tex_a,{idx,f1,f2}], {f5,f6};

 // Example of 2d mipmap texture lookup with offset, unified texturing mode
 tex.level.2d.v4.s32.f32  {r1,r2,r3,r4}, [tex_a,{f1,f2}],
                          flvl, {r7, r8};

 // Example of 2d depth texture lookup with compare, unified texturing mode
 tex.1d.v4.f32.f32  {f1,f2,f3,f4}, [tex_a, {f1}], f0;

 // Example of depth 2d texture array lookup with offset, compare
 tex.a2d.v4.s32.f32  {f0,f1,f2,f3}, [tex_a,{idx,f4,f5}], {r5,r6}, f6;

 // Example of destination predicate use
 tex.3d.v4.s32.s32 {r1,r2,r3,r4}|p, [tex_a,{f1,f2,f3,f4}];
</pre>
 <h4>
  <span class="section-number">
   9.7.9.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texture-instructions-tld4">
   Texture Instructions: tld4
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texture-instructions-tld4" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  tld4
 </p>
 <p>
  Perform a texture fetch of the 4-texel bilerp footprint.
 </p>
 <p>
  Syntax
 </p>
 <pre>tld4.comp.2d.v4.dtype.f32    d[|p], [a, c] {, e} {, f};
tld4.comp.geom.v4.dtype.f32  d[|p], [a, b, c] {, e} {, f};  // explicit sampler

.comp  = { .r, .g, .b, .a };
.geom  = { .2d, .a2d, .cube, .acube };
.dtype = { .u32, .s32, .f32 };
</pre>
 <p>
  Description
 </p>
 <p>
  Texture fetch of the 4-texel bilerp footprint using a texture coordinate vector. The instruction
loads the bilerp footprint from the texture named by operand
  <span class="pre">
   a
  </span>
  at coordinates given by operand
  <span class="pre">
   c
  </span>
  into vector destination
  <span class="pre">
   d
  </span>
  . The texture component fetched for each texel sample is
specified by
  <span class="pre">
   .comp
  </span>
  . The four texel samples are placed into destination vector
  <span class="pre">
   d
  </span>
  in
counter-clockwise order starting at lower left.
 </p>
 <p>
  An optional texture sampler
  <span class="pre">
   b
  </span>
  may be specified. If no sampler is specified, the sampler behavior
is a property of the named texture.
 </p>
 <p>
  The optional destination predicate
  <span class="pre">
   p
  </span>
  is set to
  <span class="pre">
   True
  </span>
  if data from texture at specified
coordinates is resident in memory,
  <span class="pre">
   False
  </span>
  otherwise. When optional destination predicate
  <span class="pre">
   p
  </span>
  is
set to
  <span class="pre">
   False
  </span>
  , data loaded will be all zeros. Memory residency of Texture Data at specified
coordinates is dependent on execution environment setup using Driver API calls, prior to kernel
launch. Refer to Driver API documentation for more details including any system/implementation
specific behavior.
 </p>
 <p>
  An optional operand
  <span class="pre">
   f
  </span>
  may be specified for
  depth textures
  . Depth textures are special type of
textures which hold data from the depth buffer. Depth buffer contains depth information of each
pixel. Operand
  <span class="pre">
   f
  </span>
  is
  <span class="pre">
   .f32
  </span>
  scalar value that specifies depth compare value for depth
textures. Each element fetched from texture is compared against value given in
  <span class="pre">
   f
  </span>
  operand. If
comparison passes, result is 1.0; otherwise result is 0.0. These per-element comparison results are
used for the filtering.
 </p>
 <p>
  A texture base address is assumed to be aligned to a 16 byte boundary, and the address given by the
coordinate vector must be naturally aligned to a multiple of the access size. If an address is not
properly aligned, the resulting behavior is undefined; i.e., the access may proceed by silently
masking off low-order address bits to achieve proper rounding, or the instruction may fault.
 </p>
 <p>
  <span class="pre">
   tld4.2d
  </span>
 </p>
 <p>
  For 2D textures, operand
  <span class="pre">
   c
  </span>
  specifies coordinates as a two-element, 32-bit floating-point vector.
 </p>
 <p>
  An optional operand
  <span class="pre">
   e
  </span>
  may be specified. Operand
  <span class="pre">
   e
  </span>
  is a vector of type
  <span class="pre">
   .v2.s32
  </span>
  that
specifies coordinate offset. Offset is applied to coordinates before doing texture fetch. Offset
value is in the range of -8 to +7.
 </p>
 <p>
  <span class="pre">
   tld4.a2d
  </span>
 </p>
 <p>
  Texture array selection, followed by
  <span class="pre">
   tld4
  </span>
  texture fetch of 2d texture. For 2d texture arrays
operand
  <span class="pre">
   c
  </span>
  is a four element, 32-bit vector. The first element in operand c is interpreted as an
unsigned integer index (
  <span class="pre">
   .u32
  </span>
  ) into the texture array, and the next two elements are interpreted
as 32-bit floating point coordinates of 2d texture. The fourth element is ignored.
 </p>
 <p>
  An optional operand
  <span class="pre">
   e
  </span>
  may be specified. Operand
  <span class="pre">
   e
  </span>
  is a vector of type
  <span class="pre">
   .v2.s32
  </span>
  that
specifies coordinate offset. Offset is applied to coordinates before doing texture fetch. Offset
value is in the range of -8 to +7.
 </p>
 <p>
  <span class="pre">
   tld4.cube
  </span>
 </p>
 <p>
  For cubemap textures, operand
  <span class="pre">
   c
  </span>
  specifies four-element vector which comprises three
floating-point coordinates (s, t, r) and a fourth padding argument which is ignored.
 </p>
 <p>
  Cubemap textures are special two-dimensional layered textures consisting of six layers that
represent the faces of a cube. All layers in a cubemap are of the same size and are square (i.e.,
width equals height).
 </p>
 <p>
  Coordinates (s, t, r) are projected onto one of the six cube faces. The (s, t, r) coordinates can be
thought of as a direction vector emanating from the center of the cube. Of the three coordinates (s,
t, r), the coordinate of the largest magnitude (the major axis) selects the cube face. Then, the
other two coordinates (the minor axes) are divided by the absolute value of the major axis to
produce a new (s, t) coordinate pair to lookup into the selected cube face.
 </p>
 <p>
  Offset vector operand
  <span class="pre">
   e
  </span>
  is not supported for cubemap textures.
 </p>
 <p>
  <span class="pre">
   tld4.acube
  </span>
 </p>
 <p>
  Cubemap array selection, followed by
  <span class="pre">
   tld4
  </span>
  texture fetch of cubemap texture. The first element in
operand
  <span class="pre">
   c
  </span>
  is interpreted as an unsigned integer index (
  <span class="pre">
   .u32
  </span>
  ) into the cubemap texture array,
and the remaining three elements are interpreted as floating-point cubemap coordinates (s, t, r),
used to lookup in the selected cubemap.
 </p>
 <p>
  Offset vector operand
  <span class="pre">
   e
  </span>
  is not supported for cubemap texture arrays.
 </p>
 <p>
  Indirect texture access
 </p>
 <p>
  Beginning with PTX ISA version 3.1, indirect texture access is supported in unified mode for target
architecture
  <span class="pre">
   sm_20
  </span>
  or higher. In indirect access, operand
  <span class="pre">
   a
  </span>
  is a
  <span class="pre">
   .u64
  </span>
  register holding
the address of a
  <span class="pre">
   .texref
  </span>
  variable.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.2.
 </p>
 <p>
  Indirect texture access introduced in PTX ISA version 3.1.
 </p>
 <p>
  <span class="pre">
   tld4.{a2d,cube,acube}
  </span>
  introduced in PTX ISA version 4.3.
 </p>
 <p>
  Offset vector operand introduced in PTX ISA version 4.3.
 </p>
 <p>
  Depth compare operand introduced in PTX ISA version 4.3.
 </p>
 <p>
  Support for optional destination predicate introduced in PTX ISA version 7.1.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   tld4
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Indirect texture access requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   tld4.{a2d,cube,acube}
  </span>
  requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Offset vector operand requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Depth compare operand requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Support for optional destination predicate requires
  <span class="pre">
   sm_60
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>//Example of unified mode texturing
tld4.r.2d.v4.s32.f32  {r1,r2,r3,r4}, [tex_a,{f1,f2}];

// Example of independent mode texturing
tld4.r.2d.v4.u32.f32  {u1,u2,u3,u4}, [tex_a,smpl_x,{f1,f2}];

// Example of unified mode texturing using offset
tld4.r.2d.v4.s32.f32  {r1,r2,r3,r4}, [tex_a,{f1,f2}], {r5, r6};

// Example of unified mode texturing using compare
tld4.r.2d.v4.f32.f32  {f1,f2,f3,f4}, [tex_a,{f5,f6}], f7;

// Example of optional destination predicate
tld4.r.2d.v4.f32.f32 {f1,f2,f3,f4}|p, [tex_a,{f5,f6}], f7;
</pre>
 <h4>
  <span class="section-number">
   9.7.9.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texture-instructions-txq">
   Texture Instructions: txq
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texture-instructions-txq" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  txq
 </p>
 <p>
  Query texture and sampler attributes.
 </p>
 <p>
  Syntax
 </p>
 <pre>txq.tquery.b32         d, [a];       // texture attributes
txq.level.tlquery.b32  d, [a], lod;  // texture attributes
txq.squery.b32         d, [a];       // sampler attributes

.tquery  = { .width, .height, .depth,
             .channel_data_type, .channel_order,
             .normalized_coords, .array_size,
             .num_mipmap_levels, .num_samples};

.tlquery = { .width, .height, .depth };

.squery  = { .force_unnormalized_coords, .filter_mode,
             .addr_mode_0, addr_mode_1, addr_mode_2 };
</pre>
 <p>
  Description
 </p>
 <p>
  Query an attribute of a texture or sampler. Operand
  <span class="pre">
   a
  </span>
  is either a
  <span class="pre">
   .texref
  </span>
  or
  <span class="pre">
   .samplerref
  </span>
  variable, or a
  <span class="pre">
   .u64
  </span>
  register.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Query
    </p>
   </th>
   <th class="head">
    <p>
     Returns
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .width
     </span>
    </p>
    <p>
     <span class="pre">
      .height
     </span>
    </p>
    <p>
     <span class="pre">
      .depth
     </span>
    </p>
   </td>
   <td>
    <p>
     value in elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .channel_data_type
     </span>
    </p>
   </td>
   <td>
    <p>
     Unsigned integer corresponding to source languageâs channel data type
enumeration. If the source language combines channel data type and channel
order into a single enumeration type, that value is returned for both
     <span class="pre">
      channel_data_type
     </span>
     and channel_order queries.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .channel_order
     </span>
    </p>
   </td>
   <td>
    <p>
     Unsigned integer corresponding to source languageâs channel order
enumeration. If the source language combines channel data type and channel
order into a single enumeration type, that value is returned for both
     <span class="pre">
      channel_data_type
     </span>
     and
     <span class="pre">
      channel_order
     </span>
     queries.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .normalized_coords
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      1
     </span>
     (
     <span class="pre">
      True
     </span>
     ) or
     <span class="pre">
      0
     </span>
     (
     <span class="pre">
      False
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .force_unnormalized_coords
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      1
     </span>
     (
     <span class="pre">
      True)
     </span>
     or
     <span class="pre">
      0
     </span>
     (
     <span class="pre">
      False).
     </span>
     Defined only for
     <span class="pre">
      .samplerref
     </span>
     variables in independent texture mode. Overrides the
     <span class="pre">
      normalized_coords
     </span>
     field of a
     <span class="pre">
      .texref
     </span>
     variable used with a
     <span class="pre">
      .samplerref
     </span>
     in a
     <span class="pre">
      tex
     </span>
     instruction.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .filter_mode
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer from
     <span class="pre">
      enum
     </span>
     <span class="pre">
      {
     </span>
     <span class="pre">
      nearest,
     </span>
     <span class="pre">
      linear
     </span>
     <span class="pre">
      }
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .addr_mode_0
     </span>
    </p>
    <p>
     <span class="pre">
      .addr_mode_1
     </span>
    </p>
    <p>
     <span class="pre">
      .addr_mode_2
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer from
     <span class="pre">
      enum
     </span>
     <span class="pre">
      {
     </span>
     <span class="pre">
      wrap,
     </span>
     <span class="pre">
      mirror,
     </span>
     <span class="pre">
      clamp_ogl,
     </span>
     <span class="pre">
      clamp_to_edge,
     </span>
     <span class="pre">
      clamp_to_border
     </span>
     <span class="pre">
      }
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .array_size
     </span>
    </p>
   </td>
   <td>
    <p>
     For a texture array, number of textures in array, 0 otherwise.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .num_mipmap_levels
     </span>
    </p>
   </td>
   <td>
    <p>
     For a mipmapped texture, number of levels of details (LOD), 0 otherwise.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .num_samples
     </span>
    </p>
   </td>
   <td>
    <p>
     For a multi-sample texture, number of samples, 0 otherwise.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Texture attributes are queried by supplying a
  <span class="pre">
   .texref
  </span>
  argument to
  <span class="pre">
   txq
  </span>
  . In unified mode,
sampler attributes are also accessed via a
  <span class="pre">
   .texref
  </span>
  argument, and in independent mode sampler
attributes are accessed via a separate
  <span class="pre">
   .samplerref
  </span>
  argument.
 </p>
 <p>
  <span class="pre">
   txq.level
  </span>
 </p>
 <p>
  <span class="pre">
   txq.level
  </span>
  requires an additional 32bit integer argument,
  <span class="pre">
   lod
  </span>
  , which specifies LOD and
queries requested attribute for the specified LOD.
 </p>
 <p>
  Indirect texture access
 </p>
 <p>
  Beginning with PTX ISA version 3.1, indirect texture access is supported in unified mode for target
architecture
  <span class="pre">
   sm_20
  </span>
  or higher. In indirect access, operand
  <span class="pre">
   a
  </span>
  is a
  <span class="pre">
   .u64
  </span>
  register holding
the address of a
  <span class="pre">
   .texref
  </span>
  variable.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.5.
 </p>
 <p>
  Channel data type and channel order queries were added in PTX ISA version 2.1.
 </p>
 <p>
  The
  <span class="pre">
   .force_unnormalized_coords
  </span>
  query was added in PTX ISA version 2.2.
 </p>
 <p>
  Indirect texture access introduced in PTX ISA version 3.1.
 </p>
 <p>
  <span class="pre">
   .array_size
  </span>
  ,
  <span class="pre">
   .num_mipmap_levels
  </span>
  ,
  <span class="pre">
   .num_samples
  </span>
  samples queries were added in PTX ISA
version 4.1.
 </p>
 <p>
  <span class="pre">
   txq.level
  </span>
  introduced in PTX ISA version 4.3.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Indirect texture access requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Querying the number of mipmap levels requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Querying the number of samples requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   txq.level
  </span>
  requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>txq.width.b32       %r1, [tex_A];
txq.filter_mode.b32 %r1, [tex_A];   // unified mode
txq.addr_mode_0.b32 %r1, [smpl_B];  // independent mode
txq.level.width.b32 %r1, [tex_A], %r_lod;
</pre>
 <h4>
  <span class="section-number">
   9.7.9.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texture-instructions-istypep">
   Texture Instructions: istypep
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#texture-instructions-istypep" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  istypep
 </p>
 <p>
  Query whether a register points to an opaque variable of a specified type.
 </p>
 <p>
  Syntax
 </p>
 <pre>istypep.type   p, a;  // result is .pred

.type = { .texref, .samplerref, .surfref };
</pre>
 <p>
  Description
 </p>
 <p>
  Write predicate register
  <span class="pre">
   p
  </span>
  with 1 if register
  <span class="pre">
   a
  </span>
  points to an opaque variable of the
specified type, and with 0 otherwise. Destination
  <span class="pre">
   p
  </span>
  has type
  <span class="pre">
   .pred
  </span>
  ; the source address
operand must be of type
  <span class="pre">
   .u64
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 4.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  istypep requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>istypep.texref istex, tptr;
istypep.samplerref issampler, sptr;
istypep.surfref issurface, surfptr;
</pre>
 <h3>
  <span class="section-number">
   9.7.10.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#surface-instructions">
   Surface Instructions
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#surface-instructions" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  This section describes PTX instructions for accessing surfaces. PTX supports the following
operations on surface descriptors:
 </p>
 <ul class="simple">
  <li>
   <p>
    Static initialization of surface descriptors.
   </p>
  </li>
  <li>
   <p>
    Module-scope and per-entry scope definitions of surface descriptors.
   </p>
  </li>
  <li>
   <p>
    Ability to query fields within surface descriptors.
   </p>
  </li>
 </ul>
 <p>
  These instructions provide access to surface memory.
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     suld
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     sust
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     sured
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     suq
    </span>
   </p>
  </li>
 </ul>
 <h4>
  <span class="section-number">
   9.7.10.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#surface-instructions-suld">
   Surface Instructions: suld
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#surface-instructions-suld" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  suld
 </p>
 <p>
  Load from surface memory.
 </p>
 <p>
  Syntax
 </p>
 <pre>suld.b.geom{.cop}.vec.dtype.clamp  d, [a, b];  // unformatted

.geom  = { .1d, .2d, .3d, .a1d, .a2d };
.cop   = { .ca, .cg, .cs, .cv };               // cache operation
.vec   = { none, .v2, .v4 };
.dtype = { .b8 , .b16, .b32, .b64 };
.clamp = { .trap, .clamp, .zero };
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   suld.b.{1d,2d,3d}
  </span>
 </p>
 <p>
  Load from surface memory using a surface coordinate vector. The instruction loads data from the
surface named by operand
  <span class="pre">
   a
  </span>
  at coordinates given by operand
  <span class="pre">
   b
  </span>
  into destination
  <span class="pre">
   d
  </span>
  . Operand
  <span class="pre">
   a
  </span>
  is a
  <span class="pre">
   .surfref
  </span>
  variable or
  <span class="pre">
   .u64
  </span>
  register. Operand
  <span class="pre">
   b
  </span>
  is a scalar or singleton tuple
for 1d surfaces; is a two-element vector for 2d surfaces; and is a four-element vector for 3d
surfaces, where the fourth element is ignored. Coordinate elements are of type
  <span class="pre">
   .s32
  </span>
  .
 </p>
 <p>
  <span class="pre">
   suld.b
  </span>
  performs an unformatted load of binary data. The lowest dimension coordinate represents a
byte offset into the surface and is not scaled, and the size of the data transfer matches the size
of destination operand
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  <span class="pre">
   suld.b.{a1d,a2d}
  </span>
 </p>
 <p>
  Surface layer selection, followed by a load from the selected surface. The instruction first selects
a surface layer from the surface array named by operand
  <span class="pre">
   a
  </span>
  using the index given by the first
element of the array coordinate vector
  <span class="pre">
   b
  </span>
  . The instruction then loads data from the selected
surface at coordinates given by the remaining elements of operand
  <span class="pre">
   b
  </span>
  into destination
  <span class="pre">
   d
  </span>
  . Operand
  <span class="pre">
   a
  </span>
  is a
  <span class="pre">
   .surfref
  </span>
  variable or
  <span class="pre">
   .u64
  </span>
  register. Operand
  <span class="pre">
   b
  </span>
  is a bit-size
type vector or tuple containing an index into the array of surfaces followed by coordinates within
the selected surface, as follows:
 </p>
 <p>
  For 1d surface arrays, operand
  <span class="pre">
   b
  </span>
  has type
  <span class="pre">
   .v2.b32
  </span>
  . The first element is interpreted as an
unsigned integer index (
  <span class="pre">
   .u32
  </span>
  ) into the surface array, and the second element is interpreted as a
1d surface coordinate of type
  <span class="pre">
   .s32
  </span>
  .
 </p>
 <p>
  For 2d surface arrays, operand
  <span class="pre">
   b
  </span>
  has type
  <span class="pre">
   .v4.b32
  </span>
  . The first element is interpreted as an
unsigned integer index (
  <span class="pre">
   .u32
  </span>
  ) into the surface array, and the next two elements are interpreted
as 2d surface coordinates of type
  <span class="pre">
   .s32
  </span>
  . The fourth element is ignored.
 </p>
 <p>
  A surface base address is assumed to be aligned to a 16 byte boundary, and the address given by the
coordinate vector must be naturally aligned to a multiple of the access size. If an address is not
properly aligned, the resulting behavior is undefined; i.e., the access may proceed by silently
masking off low-order address bits to achieve proper rounding, or the instruction may fault.
 </p>
 <p>
  The
  <span class="pre">
   .clamp
  </span>
  field specifies how to handle out-of-bounds addresses:
 </p>
 <span class="pre">
  .trap
 </span>
 <p>
  causes an execution trap on out-of-bounds addresses
 </p>
 <span class="pre">
  .clamp
 </span>
 <p>
  loads data at the nearest surface location (sized appropriately)
 </p>
 <span class="pre">
  .zero
 </span>
 <p>
  loads zero for out-of-bounds addresses
 </p>
 <p>
  Indirect surface access
 </p>
 <p>
  Beginning with PTX ISA version 3.1, indirect surface access is supported for target architecture
  <span class="pre">
   sm_20
  </span>
  or higher. In indirect access, operand
  <span class="pre">
   a
  </span>
  is a
  <span class="pre">
   .u64
  </span>
  register holding the address of
a
  <span class="pre">
   .surfref
  </span>
  variable.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  <span class="pre">
   suld.b.trap
  </span>
  introduced in PTX ISA version 1.5.
 </p>
 <p>
  Additional clamp modifiers and cache operations introduced in PTX ISA version 2.0.
 </p>
 <p>
  <span class="pre">
   suld.b.3d
  </span>
  and
  <span class="pre">
   suld.b.{a1d,a2d}
  </span>
  introduced in PTX ISA version 3.0.
 </p>
 <p>
  Indirect surface access introduced in PTX ISA version 3.1.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   suld.b
  </span>
  supported on all target architectures.
 </p>
 <p>
  <span class="pre">
   sm_1x
  </span>
  targets support only the
  <span class="pre">
   .trap
  </span>
  clamping modifier.
 </p>
 <p>
  <span class="pre">
   suld.3d
  </span>
  and
  <span class="pre">
   suld.{a1d,a2d}
  </span>
  require
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Indirect surface access requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Cache operations require
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>suld.b.1d.v4.b32.trap  {s1,s2,s3,s4}, [surf_B, {x}];
suld.b.3d.v2.b64.trap  {r1,r2}, [surf_A, {x,y,z,w}];
suld.b.a1d.v2.b32      {r0,r1}, [surf_C, {idx,x}];
suld.b.a2d.b32         r0, [surf_D, {idx,x,y,z}];  // z ignored
</pre>
 <h4>
  <span class="section-number">
   9.7.10.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#surface-instructions-sust">
   Surface Instructions: sust
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#surface-instructions-sust" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  sust
 </p>
 <p>
  Store to surface memory.
 </p>
 <p>
  Syntax
 </p>
 <pre>sust.b.{1d,2d,3d}{.cop}.vec.ctype.clamp  [a, b], c;  // unformatted
sust.p.{1d,2d,3d}.vec.b32.clamp          [a, b], c;  // formatted

sust.b.{a1d,a2d}{.cop}.vec.ctype.clamp   [a, b], c;  // unformatted

.cop   = { .wb, .cg, .cs, .wt };                     // cache operation
.vec   = { none, .v2, .v4 };
.ctype = { .b8 , .b16, .b32, .b64 };
.clamp = { .trap, .clamp, .zero };
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   sust.{1d,2d,3d}
  </span>
 </p>
 <p>
  Store to surface memory using a surface coordinate vector. The instruction stores data from operand
  <span class="pre">
   c
  </span>
  to the surface named by operand
  <span class="pre">
   a
  </span>
  at coordinates given by operand
  <span class="pre">
   b
  </span>
  . Operand
  <span class="pre">
   a
  </span>
  is
a
  <span class="pre">
   .surfref
  </span>
  variable or
  <span class="pre">
   .u64
  </span>
  register. Operand
  <span class="pre">
   b
  </span>
  is a scalar or singleton tuple for 1d
surfaces; is a two-element vector for 2d surfaces; and is a four-element vector for 3d surfaces,
where the fourth element is ignored. Coordinate elements are of type
  <span class="pre">
   .s32
  </span>
  .
 </p>
 <p>
  <span class="pre">
   sust.b
  </span>
  performs an unformatted store of binary data. The lowest dimension coordinate represents
a byte offset into the surface and is not scaled. The size of the data transfer matches the size of
source operand
  <span class="pre">
   c
  </span>
  .
 </p>
 <p>
  <span class="pre">
   sust.p
  </span>
  performs a formatted store of a vector of 32-bit data values to a surface sample. The
source vector elements are interpreted left-to-right as
  <span class="pre">
   R
  </span>
  ,
  <span class="pre">
   G
  </span>
  ,
  <span class="pre">
   B
  </span>
  , and
  <span class="pre">
   A
  </span>
  surface
components. These elements are written to the corresponding surface sample components. Source
elements that do not occur in the surface sample are ignored. Surface sample components that do not
occur in the source vector will be written with an unpredictable value. The lowest dimension
coordinate represents a sample offset rather than a byte offset.
 </p>
 <p>
  The source data interpretation is based on the surface sample format as follows: If the surface
format contains
  <span class="pre">
   UNORM
  </span>
  ,
  <span class="pre">
   SNORM
  </span>
  , or
  <span class="pre">
   FLOAT
  </span>
  data, then
  <span class="pre">
   .f32
  </span>
  is assumed; if the surface
format contains
  <span class="pre">
   UINT
  </span>
  data, then
  <span class="pre">
   .u32
  </span>
  is assumed; if the surface format contains
  <span class="pre">
   SINT
  </span>
  data, then
  <span class="pre">
   .s32
  </span>
  is assumed. The source data is then converted from this type to the surface
sample format.
 </p>
 <p>
  <span class="pre">
   sust.b.{a1d,a2d}
  </span>
 </p>
 <p>
  Surface layer selection, followed by an unformatted store to the selected surface. The instruction
first selects a surface layer from the surface array named by operand
  <span class="pre">
   a
  </span>
  using the index given by
the first element of the array coordinate vector
  <span class="pre">
   b
  </span>
  . The instruction then stores the data in
operand
  <span class="pre">
   c
  </span>
  to the selected surface at coordinates given by the remaining elements of operand
  <span class="pre">
   b
  </span>
  . Operand
  <span class="pre">
   a
  </span>
  is a .surfref variable or
  <span class="pre">
   .u64
  </span>
  register. Operand
  <span class="pre">
   b
  </span>
  is a bit-size type
vector or tuple containing an index into the array of surfaces followed by coordinates within the
selected surface, as follows:
 </p>
 <ul class="simple">
  <li>
   <p>
    For 1d surface arrays, operand
    <span class="pre">
     b
    </span>
    has type
    <span class="pre">
     .v2.b32
    </span>
    . The first element is interpreted as an
unsigned integer index (
    <span class="pre">
     .u32
    </span>
    ) into the surface array, and the second element is interpreted as
a 1d surface coordinate of type
    <span class="pre">
     .s32
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    For 2d surface arrays, operand
    <span class="pre">
     b
    </span>
    has type
    <span class="pre">
     .v4.b32
    </span>
    . The first element is interpreted as an
unsigned integer index (
    <span class="pre">
     .u32
    </span>
    ) into the surface array, and the next two elements are
interpreted as 2d surface coordinates of type
    <span class="pre">
     .s32
    </span>
    . The fourth element is ignored.
   </p>
  </li>
 </ul>
 <p>
  A surface base address is assumed to be aligned to a 16 byte boundary, and the address given by the
coordinate vector must be naturally aligned to a multiple of the access size. If an address is not
properly aligned, the resulting behavior is undefined; i.e., the access may proceed by silently
masking off low-order address bits to achieve proper rounding, or the instruction may fault.
 </p>
 <p>
  The
  <span class="pre">
   .clamp
  </span>
  field specifies how to handle out-of-bounds addresses:
 </p>
 <span class="pre">
  .trap
 </span>
 <p>
  causes an execution trap on out-of-bounds addresses
 </p>
 <span class="pre">
  .clamp
 </span>
 <p>
  stores data at the nearest surface location (sized appropriately)
 </p>
 <span class="pre">
  .zero
 </span>
 <p>
  drops stores to out-of-bounds addresses
 </p>
 <p>
  Indirect surface access
 </p>
 <p>
  Beginning with PTX ISA version 3.1, indirect surface access is supported for target architecture
  <span class="pre">
   sm_20
  </span>
  or higher. In indirect access, operand
  <span class="pre">
   a
  </span>
  is a
  <span class="pre">
   .u64
  </span>
  register holding the address of
a
  <span class="pre">
   .surfref
  </span>
  variable.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  <span class="pre">
   sust.b.trap
  </span>
  introduced in PTX ISA version 1.5.Â
  <span class="pre">
   sust.p
  </span>
  , additional clamp modifiers, and
cache operations introduced in PTX ISA version 2.0.
 </p>
 <p>
  <span class="pre">
   sust.b.3d
  </span>
  and
  <span class="pre">
   sust.b.{a1d,a2d}
  </span>
  introduced in PTX ISA version 3.0.
 </p>
 <p>
  Indirect surface access introduced in PTX ISA version 3.1.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   sust.b
  </span>
  supported on all target architectures.
 </p>
 <p>
  <span class="pre">
   sm_1x
  </span>
  targets support only the
  <span class="pre">
   .trap
  </span>
  clamping modifier.
 </p>
 <p>
  <span class="pre">
   sust.3d
  </span>
  and
  <span class="pre">
   sust.{a1d,a2d}
  </span>
  require
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   sust.p
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Indirect surface access requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Cache operations require
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>sust.p.1d.v4.b32.trap  [surf_B, {x}], {f1,f2,f3,f4};
sust.b.3d.v2.b64.trap  [surf_A, {x,y,z,w}], {r1,r2};
sust.b.a1d.v2.b64      [surf_C, {idx,x}], {r1,r2};
sust.b.a2d.b32         [surf_D, {idx,x,y,z}], r0;  // z ignored
</pre>
 <h4>
  <span class="section-number">
   9.7.10.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#surface-instructions-sured">
   Surface Instructions: sured
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#surface-instructions-sured" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  sured
 </p>
 <p>
  Reduce surface memory.
 </p>
 <p>
  Syntax
 </p>
 <pre>sured.b.op.geom.ctype.clamp  [a,b],c; // byte addressing
sured.p.op.geom.ctype.clamp  [a,b],c; // sample addressing

.op    = { .add, .min, .max, .and, .or };
.geom  = { .1d, .2d, .3d };
.ctype = { .u32, .u64, .s32, .b32, .s64 };  // for sured.b
.ctype = { .b32, .b64 };                    // for sured.p
.clamp = { .trap, .clamp, .zero };
</pre>
 <p>
  Description
 </p>
 <p>
  Reduction to surface memory using a surface coordinate vector. The instruction performs a reduction
operation with data from operand
  <span class="pre">
   c
  </span>
  to the surface named by operand
  <span class="pre">
   a
  </span>
  at coordinates given by
operand
  <span class="pre">
   b
  </span>
  . Operand
  <span class="pre">
   a
  </span>
  is a
  <span class="pre">
   .surfref
  </span>
  variable or
  <span class="pre">
   .u64
  </span>
  register. Operand
  <span class="pre">
   b
  </span>
  is a
scalar or singleton tuple for 1d surfaces; is a two-element vector for 2d surfaces; and is a
four-element vector for 3d surfaces, where the fourth element is ignored. Coordinate elements are of
type
  <span class="pre">
   .s32
  </span>
  .
 </p>
 <p>
  <span class="pre">
   sured.b
  </span>
  performs an unformatted reduction on
  <span class="pre">
   .u32
  </span>
  ,
  <span class="pre">
   .s32
  </span>
  ,
  <span class="pre">
   .b32
  </span>
  ,
  <span class="pre">
   .u64
  </span>
  , or
  <span class="pre">
   .s64
  </span>
  data. The lowest dimension coordinate represents a byte offset into the surface and is not
scaled. Operation
  <span class="pre">
   add
  </span>
  applies to
  <span class="pre">
   .u32
  </span>
  ,
  <span class="pre">
   .u64
  </span>
  , and
  <span class="pre">
   .s32
  </span>
  types;
  <span class="pre">
   min
  </span>
  and
  <span class="pre">
   max
  </span>
  apply to
  <span class="pre">
   .u32
  </span>
  ,
  <span class="pre">
   .s32
  </span>
  ,
  <span class="pre">
   .u64
  </span>
  and
  <span class="pre">
   .s64
  </span>
  types; operations
  <span class="pre">
   and
  </span>
  and
  <span class="pre">
   or
  </span>
  apply to
  <span class="pre">
   .b32
  </span>
  type.
 </p>
 <p>
  <span class="pre">
   sured.p
  </span>
  performs a reduction on sample-addressed data. The lowest dimension coordinate
represents a sample offset rather than a byte offset. The instruction type
  <span class="pre">
   .b64
  </span>
  is restricted to
  <span class="pre">
   min
  </span>
  and
  <span class="pre">
   max
  </span>
  operations. For type
  <span class="pre">
   .b32
  </span>
  , the data is interpreted as
  <span class="pre">
   .u32
  </span>
  or
  <span class="pre">
   .s32
  </span>
  based on the surface sample format as follows: if the surface format contains
  <span class="pre">
   UINT
  </span>
  data, then
  <span class="pre">
   .u32
  </span>
  is assumed; if the surface format contains
  <span class="pre">
   SINT
  </span>
  data, then
  <span class="pre">
   .s32
  </span>
  is assumed. For
type
  <span class="pre">
   .b64
  </span>
  , if the surface format contains
  <span class="pre">
   UINT
  </span>
  data, then
  <span class="pre">
   .u64
  </span>
  is assumed; if the
surface format contains
  <span class="pre">
   SINT
  </span>
  data, then
  <span class="pre">
   .s64
  </span>
  is assumed.
 </p>
 <p>
  A surface base address is assumed to be aligned to a 16 byte boundary, and the address given by the
coordinate vector must be naturally aligned to a multiple of the access size. If an address is not
properly aligned, the resulting behavior is undefined; i.e., the access may proceed by silently
masking off low-order address bits to achieve proper rounding, or the instruction may fault.
 </p>
 <p>
  The
  <span class="pre">
   .clamp
  </span>
  field specifies how to handle out-of-bounds addresses:
 </p>
 <span class="pre">
  .trap
 </span>
 <p>
  causes an execution trap on out-of-bounds addresses
 </p>
 <span class="pre">
  .clamp
 </span>
 <p>
  stores data at the nearest surface location (sized appropriately)
 </p>
 <span class="pre">
  .zero
 </span>
 <p>
  drops stores to out-of-bounds addresses
 </p>
 <p>
  Indirect surface access
 </p>
 <p>
  Beginning with PTX ISA version 3.1, indirect surface access is supported for target architecture
  <span class="pre">
   sm_20
  </span>
  or higher. In indirect access, operand
  <span class="pre">
   a
  </span>
  is a
  <span class="pre">
   .u64
  </span>
  register holding the address of
a
  <span class="pre">
   .surfref
  </span>
  variable.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0.
 </p>
 <p>
  Indirect surface access introduced in PTX ISA version 3.1.
 </p>
 <p>
  <span class="pre">
   .u64
  </span>
  /
  <span class="pre">
   .s64
  </span>
  /
  <span class="pre">
   .b64
  </span>
  types with
  <span class="pre">
   .min
  </span>
  /
  <span class="pre">
   .max
  </span>
  operations introduced in PTX ISA version
8.1.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  sured requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Indirect surface access requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   .u64
  </span>
  /
  <span class="pre">
   .s64
  </span>
  /
  <span class="pre">
   .b64
  </span>
  types with
  <span class="pre">
   .min
  </span>
  /
  <span class="pre">
   .max
  </span>
  operations requires
  <span class="pre">
   sm_50
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>sured.b.add.2d.u32.trap  [surf_A, {x,y}], r1;
sured.p.min.1d.u32.trap  [surf_B, {x}], r1;
sured.b.max.1d.u64.trap  [surf_C, {x}], r1;
sured.p.min.1d.b64.trap  [surf_D, {x}], r1;
</pre>
 <h4>
  <span class="section-number">
   9.7.10.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#surface-instructions-suq">
   Surface Instructions: suq
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#surface-instructions-suq" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  suq
 </p>
 <p>
  Query a surface attribute.
 </p>
 <p>
  Syntax
 </p>
 <pre>suq.query.b32   d, [a];

.query = { .width, .height, .depth,
           .channel_data_type, .channel_order,
           .array_size, .memory_layout };
</pre>
 <p>
  Description
 </p>
 <p>
  Query an attribute of a surface. Operand
  <span class="pre">
   a
  </span>
  is a
  <span class="pre">
   .surfref
  </span>
  variable or a
  <span class="pre">
   .u64
  </span>
  register.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Query
    </p>
   </th>
   <th class="head">
    <p>
     Returns
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .width
     </span>
    </p>
    <p>
     <span class="pre">
      .height
     </span>
    </p>
    <p>
     <span class="pre">
      .depth
     </span>
    </p>
   </td>
   <td>
    <p>
     value in elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .channel_data_type
     </span>
    </p>
   </td>
   <td>
    <p>
     Unsigned integer corresponding to source languageâs channel data
type enumeration. If the source language combines channel data
type and channel order into a single enumeration type, that value
is returned for both
     <span class="pre">
      channel_data_type
     </span>
     and
     <span class="pre">
      channel_order
     </span>
     queries.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .channel_order
     </span>
    </p>
   </td>
   <td>
    <p>
     Unsigned integer corresponding to source languageâs channel order
enumeration. If the source language combines channel data type and
channel order into a single enumeration type, that value is
returned for both
     <span class="pre">
      channel_data_type
     </span>
     and
     <span class="pre">
      channel_order
     </span>
     queries.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .array_size
     </span>
    </p>
   </td>
   <td>
    <p>
     For a surface array, number of surfaces in array, 0 otherwise.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .memory_layout
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      1
     </span>
     for surface with linear memory layout;
     <span class="pre">
      0
     </span>
     otherwise
    </p>
   </td>
  </tr>
 </table>
 <p>
  Indirect surface access
 </p>
 <p>
  Beginning with PTX ISA version 3.1, indirect surface access is supported for target architecture
  <span class="pre">
   sm_20
  </span>
  or higher. In indirect access, operand
  <span class="pre">
   a
  </span>
  is a
  <span class="pre">
   .u64
  </span>
  register holding the address of
a
  <span class="pre">
   .surfref
  </span>
  variable.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.5.
 </p>
 <p>
  Channel data type and channel order queries added in PTX ISA version 2.1.
 </p>
 <p>
  Indirect surface access introduced in PTX ISA version 3.1.
 </p>
 <p>
  The
  <span class="pre">
   .array_size
  </span>
  query was added in PTX ISA version 4.1.
 </p>
 <p>
  The
  <span class="pre">
   .memory_layout
  </span>
  query was added in PTX ISA version 4.2.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Indirect surface access requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>suq.width.b32       %r1, [surf_A];
</pre>
 <h3>
  <span class="section-number">
   9.7.11.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-instructions">
   Control Flow Instructions
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-instructions" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The following PTX instructions and syntax are for controlling execution in a PTX program:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     {}
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     @
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     bra
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     call
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     ret
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     exit
    </span>
   </p>
  </li>
 </ul>
 <h4>
  <span class="section-number">
   9.7.11.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-instructions-curly-braces">
   Control Flow Instructions: {}
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-instructions-curly-braces" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  {}
 </p>
 <p>
  Instruction grouping.
 </p>
 <p>
  Syntax
 </p>
 <pre>{ instructionList }
</pre>
 <p>
  Description
 </p>
 <p>
  The curly braces create a group of instructions, used primarily for defining a function body. The
curly braces also provide a mechanism for determining the scope of a variable: any variable declared
within a scope is not available outside the scope.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>{ add.s32  a,b,c; mov.s32  d,a; }
</pre>
 <h4>
  <span class="section-number">
   9.7.11.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-instructions-at">
   Control Flow Instructions: @
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-instructions-at" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  @
 </p>
 <p>
  Predicated execution.
 </p>
 <p>
  Syntax
 </p>
 <pre>@{!}p    instruction;
</pre>
 <p>
  Description
 </p>
 <p>
  Execute an instruction or instruction block for threads that have the guard predicate
  <span class="pre">
   True
  </span>
  . Threads with a
  <span class="pre">
   False
  </span>
  guard predicate do nothing.
 </p>
 <p>
  Semantics
 </p>
 <p>
  If
  <span class="pre">
   {!}p
  </span>
  then instruction
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>    setp.eq.f32  p,y,0;     // is y zero?
@!p div.f32      ratio,x,y  // avoid division by zero

@q  bra L23;                // conditional branch
</pre>
 <h4>
  <span class="section-number">
   9.7.11.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-instructions-bra">
   Control Flow Instructions: bra
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-instructions-bra" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  bra
 </p>
 <p>
  Branch to a target and continue execution there.
 </p>
 <p>
  Syntax
 </p>
 <pre>@p   bra{.uni}  tgt;           // tgt is a label
     bra{.uni}  tgt;           // unconditional branch
</pre>
 <p>
  Description
 </p>
 <p>
  Continue execution at the target. Conditional branches are specified by using a guard predicate. The
branch target must be a label.
 </p>
 <p>
  <span class="pre">
   bra.uni
  </span>
  is guaranteed to be non-divergent, i.e. all active threads in a warp that are currently
executing this instruction have identical values for the guard predicate and branch target.
 </p>
 <p>
  Semantics
 </p>
 <pre>if (p) {
    pc = tgt;
}
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Unimplemented indirect branch introduced in PTX ISA version 2.1 has been removed from the spec.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>bra.uni  L_exit;    // uniform unconditional jump
@q  bra      L23;   // conditional branch
</pre>
 <h4>
  <span class="section-number">
   9.7.11.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-instructions-brx-idx">
   Control Flow Instructions: brx.idx
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-instructions-brx-idx" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  brx.idx
 </p>
 <p>
  Branch to a label indexed from a list of potential branch targets.
 </p>
 <p>
  Syntax
 </p>
 <pre>@p    brx.idx{.uni} index, tlist;
      brx.idx{.uni} index, tlist;
</pre>
 <p>
  Description
 </p>
 <p>
  Index into a list of possible destination labels, and continue execution from the chosen
label. Conditional branches are specified by using a guard predicate.
 </p>
 <p>
  <span class="pre">
   brx.idx.uni
  </span>
  guarantees that the branch is non-divergent, i.e. all active threads in a warp that
are currently executing this instruction have identical values for the guard predicate and the
  <span class="pre">
   index
  </span>
  argument.
 </p>
 <p>
  The
  <span class="pre">
   index
  </span>
  operand is a
  <span class="pre">
   .u32
  </span>
  register. The
  <span class="pre">
   tlist
  </span>
  operand must be the label of a
  <span class="pre">
   .branchtargets
  </span>
  directive. It is accessed as a zero-based sequence using
  <span class="pre">
   index
  </span>
  . Behaviour is
undefined if the value of
  <span class="pre">
   index
  </span>
  is greater than or equal to the length of
  <span class="pre">
   tlist
  </span>
  .
 </p>
 <p>
  The
  <span class="pre">
   .branchtargets
  </span>
  directive must be defined in the local function scope before it is used. It
must refer to labels within the current function.
 </p>
 <p>
  Semantics
 </p>
 <pre>if (p) {
    if (index &lt; length(tlist)) {
      pc = tlist[index];
    } else {
      pc = undefined;
    }
}
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 6.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>.function foo () {
    .reg .u32 %r0;
    ...
    L1:
    ...
    L2:
    ...
    L3:
    ...
    ts: .branchtargets L1, L2, L3;
    @p brx.idx %r0, ts;
    ...
}
</pre>
 <h4>
  <span class="section-number">
   9.7.11.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-instructions-call">
   Control Flow Instructions: call
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-instructions-call" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  call
 </p>
 <p>
  Call a function, recording the return location.
 </p>
 <p>
  Syntax
 </p>
 <pre>// direct call to named function, func is a symbol
call{.uni} (ret-param), func, (param-list);
call{.uni} func, (param-list);
call{.uni} func;

// indirect call via pointer, with full list of call targets
call{.uni} (ret-param), fptr, (param-list), flist;
call{.uni} fptr, (param-list), flist;
call{.uni} fptr, flist;

// indirect call via pointer, with no knowledge of call targets
call{.uni} (ret-param), fptr, (param-list), fproto;
call{.uni} fptr, (param-list), fproto;
call{.uni} fptr, fproto;
</pre>
 <p>
  Description
 </p>
 <p>
  The
  <span class="pre">
   call
  </span>
  instruction stores the address of the next instruction, so execution can resume at that
point after executing a
  <span class="pre">
   ret
  </span>
  instruction. A
  <span class="pre">
   call
  </span>
  is assumed to be divergent unless the
  <span class="pre">
   .uni
  </span>
  suffix is present. The
  <span class="pre">
   .uni
  </span>
  suffix indicates that the
  <span class="pre">
   call
  </span>
  is guaranteed to be
non-divergent, i.e. all active threads in a warp that are currently executing this instruction have
identical values for the guard predicate and
  <span class="pre">
   call
  </span>
  target.
 </p>
 <p>
  For direct calls, the called location
  <span class="pre">
   func
  </span>
  must be a symbolic function name; for indirect calls,
the called location
  <span class="pre">
   fptr
  </span>
  must be an address of a function held in a register. Input arguments
and return values are optional.Â Arguments may be registers, immediate constants, or variables in
  <span class="pre">
   .param
  </span>
  space. Arguments are pass-by-value.
 </p>
 <p>
  Indirect calls require an additional operand,
  <span class="pre">
   flist
  </span>
  or
  <span class="pre">
   fproto
  </span>
  , to communicate the list of
potential
  <span class="pre">
   call
  </span>
  targets or the common function prototype of all
  <span class="pre">
   call
  </span>
  targets,
respectively. In the first case,
  <span class="pre">
   flist
  </span>
  gives a complete list of potential
  <span class="pre">
   call
  </span>
  targets and
the optimizing backend is free to optimize the calling convention. In the second case, where the
complete list of potential
  <span class="pre">
   call
  </span>
  targets may not be known, the common function prototype is given
and the
  <span class="pre">
   call
  </span>
  must obey the ABIâs calling convention.
 </p>
 <p>
  The
  <span class="pre">
   flist
  </span>
  operand is either the name of an array (call table) initialized to a list of function
names; or a label associated with a
  <span class="pre">
   .calltargets
  </span>
  directive, which declares a list of potential
  <span class="pre">
   call
  </span>
  targets. In both cases the fptr register holds the address of a function listed in the call
table or
  <span class="pre">
   .calltargets
  </span>
  list, and the
  <span class="pre">
   call
  </span>
  operands are type-checked against the type
signature of the functions indicated by
  <span class="pre">
   flist
  </span>
  .
 </p>
 <p>
  The fproto operand is the name of a label associated with a
  <span class="pre">
   .callprototype
  </span>
  directive. This
operand is used when a complete list of potential targets is not known. The
  <span class="pre">
   call
  </span>
  operands are
type-checked against the prototype, and code generation will follow the ABI calling convention. If a
function that doesnât match the prototype is called, the behavior is undefined.
 </p>
 <p>
  Call tables may be declared at module scope or local scope, in either the constant or global state
space. The
  <span class="pre">
   .calltargets
  </span>
  and
  <span class="pre">
   .callprototype
  </span>
  directives must be declared within a function
body. All functions must be declared prior to being referenced in a
  <span class="pre">
   call
  </span>
  table initializer or
  <span class="pre">
   .calltargets
  </span>
  directive.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Direct
  <span class="pre">
   call
  </span>
  introduced in PTX ISA version 1.0. Indirect
  <span class="pre">
   call
  </span>
  introduced in PTX ISA version 2.1.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Direct
  <span class="pre">
   call
  </span>
  supported on all target architectures. Indirect
  <span class="pre">
   call
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>// examples of direct call
    call     init;    // call function 'init'
    call.uni g, (a);  // call function 'g' with parameter 'a'
@p  call     (d), h, (a, b);  // return value into register d

// call-via-pointer using jump table
.func (.reg .u32 rv) foo (.reg .u32 a, .reg .u32 b) ...
.func (.reg .u32 rv) bar (.reg .u32 a, .reg .u32 b) ...
.func (.reg .u32 rv) baz (.reg .u32 a, .reg .u32 b) ...

.global .u32 jmptbl[5] = { foo, bar, baz };
      ...
@p    ld.global.u32  %r0, [jmptbl+4];
@p    ld.global.u32  %r0, [jmptbl+8];
      call  (retval), %r0, (x, y), jmptbl;

// call-via-pointer using .calltargets directive
.func (.reg .u32 rv) foo (.reg .u32 a, .reg .u32 b) ...
.func (.reg .u32 rv) bar (.reg .u32 a, .reg .u32 b) ...
.func (.reg .u32 rv) baz (.reg .u32 a, .reg .u32 b) ...
      ...
@p    mov.u32  %r0, foo;
@q    mov.u32  %r0, baz;
Ftgt: .calltargets foo, bar, baz;
      call  (retval), %r0, (x, y), Ftgt;

// call-via-pointer using .callprototype directive
.func dispatch (.reg .u32 fptr, .reg .u32 idx)
{
...
Fproto: .callprototype _ (.param .u32 _, .param .u32 _);
      call  %fptr, (x, y), Fproto;
...
</pre>
 <h4>
  <span class="section-number">
   9.7.11.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-instructions-ret">
   Control Flow Instructions: ret
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-instructions-ret" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  ret
 </p>
 <p>
  Return from function to instruction after call.
 </p>
 <p>
  Syntax
 </p>
 <pre>ret{.uni};
</pre>
 <p>
  Description
 </p>
 <p>
  Return execution to callerâs environment. A divergent return suspends threads until all threads are
ready to return to the caller. This allows multiple divergent
  <span class="pre">
   ret
  </span>
  instructions.
 </p>
 <p>
  A
  <span class="pre">
   ret
  </span>
  is assumed to be divergent unless the
  <span class="pre">
   .uni
  </span>
  suffix is present, indicating that the
return is guaranteed to be non-divergent.
 </p>
 <p>
  Any values returned from a function should be moved into the return parameter variables prior to
executing the
  <span class="pre">
   ret
  </span>
  instruction.
 </p>
 <p>
  A return instruction executed in a top-level entry routine will terminate thread execution.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>    ret;
@p  ret;
</pre>
 <h4>
  <span class="section-number">
   9.7.11.7.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-instructions-exit">
   Control Flow Instructions: exit
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-instructions-exit" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  exit
 </p>
 <p>
  Terminate a thread.
 </p>
 <p>
  Syntax
 </p>
 <pre>exit;
</pre>
 <p>
  Description
 </p>
 <p>
  Ends execution of a thread.
 </p>
 <p>
  As threads exit, barriers waiting on all threads are checked to see if the exiting threads are the
only threads that have not yet made it to a barrier{.cta} for all threads in the CTA or to a
  <span class="pre">
   barrier.cluster
  </span>
  for all threads in the cluster. If the exiting threads are holding up the
barrier, the barrier is released.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>    exit;
@p  exit;
</pre>
 <h3>
  <span class="section-number">
   9.7.12.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions">
   Parallel Synchronization and Communication Instructions
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  These instructions are:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     bar{.cta}
    </span>
    ,
    <span class="pre">
     barrier{.cta}
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     barrier.cluster
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     bar.warp.sync
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     membar
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     atom
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     red
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     red.async
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     vote
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     match.sync
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     activemask
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     redux.sync
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     griddepcontrol
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     elect.sync
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     mbarrier.init
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     mbarrier.inval
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     mbarrier.arrive
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     mbarrier.arrive_drop
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     mbarrier.test_wait
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     mbarrier.try_wait
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     mbarrier.pending_count
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     cp.async.mbarrier.arrive
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     tensormap.cp_fenceproxy
    </span>
   </p>
  </li>
 </ul>
 <h4>
  <span class="section-number">
   9.7.12.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-bar">
   Parallel Synchronization and Communication Instructions: bar, barrier
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-bar-barrier" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  bar{.cta}, barrier{.cta}
 </p>
 <p>
  Barrier synchronization.
 </p>
 <p>
  Syntax
 </p>
 <pre>barrier{.cta}.sync{.aligned}      a{, b};
barrier{.cta}.arrive{.aligned}    a, b;

barrier{.cta}.red.popc{.aligned}.u32  d, a{, b}, {!}c;
barrier{.cta}.red.op{.aligned}.pred   p, a{, b}, {!}c;

bar{.cta}.sync      a{, b};
bar{.cta}.arrive    a, b;

bar{.cta}.red.popc.u32  d, a{, b}, {!}c;
bar{.cta}.red.op.pred   p, a{, b}, {!}c;

.op = { .and, .or };
</pre>
 <p>
  Description
 </p>
 <p>
  Performs barrier synchronization and communication within a CTA. Each CTA instance has sixteen
barriers numbered
  <span class="pre">
   0..15
  </span>
  .
 </p>
 <p>
  <span class="pre">
   barrier{.cta}
  </span>
  instructions can be used by the threads within the CTA for synchronization and
communication.
 </p>
 <p>
  Operands
  <span class="pre">
   a
  </span>
  ,
  <span class="pre">
   b
  </span>
  , and
  <span class="pre">
   d
  </span>
  have type
  <span class="pre">
   .u32
  </span>
  ; operands
  <span class="pre">
   p
  </span>
  and
  <span class="pre">
   c
  </span>
  are predicates. Source
operand
  <span class="pre">
   a
  </span>
  specifies a logical barrier resource as an immediate constant or register with value
  <span class="pre">
   0
  </span>
  through
  <span class="pre">
   15
  </span>
  . Operand
  <span class="pre">
   b
  </span>
  specifies the number of threads participating in the barrier. If
no thread count is specified, all threads in the CTA participate in the barrier. When specifying a
thread count, the value must be a multiple of the warp size. Note that a non-zero thread count is
required for
  <span class="pre">
   barrier{.cta}.arrive
  </span>
  .
 </p>
 <p>
  Depending on operand
  <span class="pre">
   b
  </span>
  , either specified number of threads (in multiple of warp size) or all
threads in the CTA participate in
  <span class="pre">
   barrier{.cta}
  </span>
  instruction. The
  <span class="pre">
   barrier{.cta}
  </span>
  instructions
signal the arrival of the executing threads at the named barrier.
 </p>
 <p>
  <span class="pre">
   barrier{.cta}
  </span>
  instruction causes executing thread to wait for all non-exited threads from its
warp and marks warpsâ arrival at barrier. In addition to signaling its arrival at the barrier, the
  <span class="pre">
   barrier{.cta}.red
  </span>
  and
  <span class="pre">
   barrier{.cta}.sync
  </span>
  instructions causes executing thread to wait for
non-exited threads of all other warps participating in the barrier to
arrive.
  <span class="pre">
   barrier{.cta}.arrive
  </span>
  does not cause executing thread to wait for threads of other
participating warps.
 </p>
 <p>
  When a barrier completes, the waiting threads are restarted without delay, and the barrier is
reinitialized so that it can be immediately reused.
 </p>
 <p>
  The
  <span class="pre">
   barrier{.cta}.sync
  </span>
  or
  <span class="pre">
   barrier{.cta}.red
  </span>
  or
  <span class="pre">
   barrier{.cta}.arrive
  </span>
  instruction
guarantees that when the barrier completes, prior memory accesses requested by this thread are
performed relative to all threads participating in the barrier. The
  <span class="pre">
   barrier{.cta}.sync
  </span>
  and
  <span class="pre">
   barrier{.cta}.red
  </span>
  instruction further guarantees that no new memory access is requested by this
thread before the barrier completes.
 </p>
 <p>
  A memory read (e.g., by
  <span class="pre">
   ld
  </span>
  or
  <span class="pre">
   atom
  </span>
  ) has been performed when the value read has been
transmitted from memory and cannot be modified by another thread participating in the barrier. A
memory write (e.g., by
  <span class="pre">
   st
  </span>
  ,
  <span class="pre">
   red
  </span>
  or
  <span class="pre">
   atom
  </span>
  ) has been performed when the value written has
become visible to other threads participating in the barrier, that is, when the previous value can
no longer be read.
 </p>
 <p>
  <span class="pre">
   barrier{.cta}.red
  </span>
  performs a reduction operation across threads. The
  <span class="pre">
   c
  </span>
  predicate (or its
complement) from all threads in the CTA are combined using the specified reduction operator. Once
the barrier count is reached, the final value is written to the destination register in all threads
waiting at the barrier.
 </p>
 <p>
  The reduction operations for
  <span class="pre">
   barrier{.cta}.red
  </span>
  are population-count (
  <span class="pre">
   .popc
  </span>
  ),
all-threads-True (
  <span class="pre">
   .and
  </span>
  ), and any-thread-True (
  <span class="pre">
   .or
  </span>
  ). The result of
  <span class="pre">
   .popc
  </span>
  is the number of
threads with a
  <span class="pre">
   True
  </span>
  predicate, while
  <span class="pre">
   .and
  </span>
  and
  <span class="pre">
   .or
  </span>
  indicate if all the threads had a
  <span class="pre">
   True
  </span>
  predicate or if any of the threads had a
  <span class="pre">
   True
  </span>
  predicate.
 </p>
 <p>
  Instruction
  <span class="pre">
   barrier{.cta}
  </span>
  has optional
  <span class="pre">
   .aligned
  </span>
  modifier. When specified, it indicates that
all threads in CTA will execute the same
  <span class="pre">
   barrier{.cta}
  </span>
  instruction. In conditionally executed
code, an aligned
  <span class="pre">
   barrier{.cta}
  </span>
  instruction should only be used if it is known that all threads
in CTA evaluate the condition identically, otherwise behavior is undefined.
 </p>
 <p>
  Different warps may execute different forms of the
  <span class="pre">
   barrier{.cta}
  </span>
  instruction using the same
barrier name and thread count. One example mixes
  <span class="pre">
   barrier{.cta}.sync
  </span>
  and
  <span class="pre">
   barrier{.cta}.arrive
  </span>
  to implement producer/consumer models. The producer threads execute
  <span class="pre">
   barrier{.cta}.arrive
  </span>
  to
announce their arrival at the barrier and continue execution without delay to produce the next
value, while the consumer threads execute the
  <span class="pre">
   barrier{.cta}.sync
  </span>
  to wait for a resource to be
produced. The roles are then reversed, using a different barrier, where the producer threads execute
a
  <span class="pre">
   barrier{.cta}.sync
  </span>
  to wait for a resource to consumed, while the consumer threads announce
that the resource has been consumed with
  <span class="pre">
   barrier{.cta}.arrive
  </span>
  . Care must be taken to keep a warp
from executing more
  <span class="pre">
   barrier{.cta}
  </span>
  instructions than intended (
  <span class="pre">
   barrier{.cta}.arrive
  </span>
  followed
by any other
  <span class="pre">
   barrier{.cta}
  </span>
  instruction to the same barrier) prior to the reset of the
barrier.
  <span class="pre">
   barrier{.cta}.red
  </span>
  should not be intermixed with
  <span class="pre">
   barrier{.cta}.sync
  </span>
  or
  <span class="pre">
   barrier{.cta}.arrive
  </span>
  using the same active barrier. Execution in this case is unpredictable.
 </p>
 <p>
  The optional
  <span class="pre">
   .cta
  </span>
  qualifier simply indicates CTA-level applicability of the barrier and it
doesnât change the semantics of the instruction.
 </p>
 <p>
  <span class="pre">
   bar{.cta}.sync
  </span>
  is equivalent to
  <span class="pre">
   barrier{.cta}.sync.aligned
  </span>
  .
  <span class="pre">
   bar{.cta}.arrive
  </span>
  is
equivalent to
  <span class="pre">
   barrier{.cta}.arrive.aligned
  </span>
  .
  <span class="pre">
   bar{.cta}.red
  </span>
  is equivalent to
  <span class="pre">
   barrier{.cta}.red.aligned
  </span>
  .
 </p>
 <p class="admonition-title">
  Note
 </p>
 <p>
  For .target
  <span class="pre">
   sm_6x
  </span>
  or below,
 </p>
 <ol class="arabic simple">
  <li>
   <p>
    <span class="pre">
     barrier{.cta}
    </span>
    instruction without
    <span class="pre">
     .aligned
    </span>
    modifier is equivalent to
    <span class="pre">
     .aligned
    </span>
    variant and has the same restrictions as of
    <span class="pre">
     .aligned
    </span>
    variant.
   </p>
  </li>
  <li>
   <p>
    All threads in warp (except for those have exited) must execute
    <span class="pre">
     barrier{.cta}
    </span>
    instruction
in convergence.
   </p>
  </li>
 </ol>
 <p>
  PTX ISA Notes
 </p>
 <p>
  <span class="pre">
   bar.sync
  </span>
  without a thread count introduced in PTX ISA version 1.0.
 </p>
 <p>
  Register operands, thread count, and
  <span class="pre">
   bar.{arrive,red}
  </span>
  introduced in PTX ISA version 2.0.
 </p>
 <p>
  <span class="pre">
   barrier
  </span>
  instruction introduced in PTX ISA version 6.0.
 </p>
 <p>
  <span class="pre">
   .cta
  </span>
  qualifier introduced in PTX ISA version 7.8.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Register operands, thread count, and
  <span class="pre">
   bar{.cta}.{arrive,red}
  </span>
  require
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Only
  <span class="pre">
   bar{.cta}.sync
  </span>
  with an immediate barrier number is supported for
  <span class="pre">
   sm_1x
  </span>
  targets.
 </p>
 <p>
  <span class="pre">
   barrier{.cta}
  </span>
  instruction requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>// Use bar.sync to arrive at a pre-computed barrier number and
// wait for all threads in CTA to also arrive:
    st.shared [r0],r1;  // write my result to shared memory
    bar.cta.sync  1;    // arrive, wait for others to arrive
    ld.shared r2,[r3];  // use shared results from other threads

// Use bar.sync to arrive at a pre-computed barrier number and
// wait for fixed number of cooperating threads to arrive:
    #define CNT1 (8*12) // Number of cooperating threads

    st.shared [r0],r1;     // write my result to shared memory
    bar.cta.sync  1, CNT1; // arrive, wait for others to arrive
    ld.shared r2,[r3];     // use shared results from other threads

// Use bar.red.and to compare results across the entire CTA:
    setp.eq.u32 p,r1,r2;         // p is True if r1==r2
    bar.cta.red.and.pred r3,1,p; // r3=AND(p) forall threads in CTA

// Use bar.red.popc to compute the size of a group of threads
// that have a specific condition True:
    setp.eq.u32 p,r1,r2;         // p is True if r1==r2
    bar.cta.red.popc.u32 r3,1,p; // r3=SUM(p) forall threads in CTA

/* Producer/consumer model. The producer deposits a value in
 * shared memory, signals that it is complete but does not wait
 * using bar.arrive, and begins fetching more data from memory.
 * Once the data returns from memory, the producer must wait
 * until the consumer signals that it has read the value from
 * the shared memory location. In the meantime, a consumer
 * thread waits until the data is stored by the producer, reads
 * it, and then signals that it is done (without waiting).
 */
    // Producer code places produced value in shared memory.
    st.shared   [r0],r1;
    bar.arrive  0,64;
    ld.global   r1,[r2];
    bar.sync    1,64;
    ...

    // Consumer code, reads value from shared memory
    bar.sync   0,64;
    ld.shared  r1,[r0];
    bar.arrive 1,64;
    ...

    // Examples of barrier.cta.sync
    st.shared         [r0],r1;
    barrier.cta.sync  0;
    ld.shared         r1, [r0];
</pre>
 <h4>
  <span class="section-number">
   9.7.12.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-bar-warp-sync">
   Parallel Synchronization and Communication Instructions: bar.warp.sync
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-bar-warp-sync" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  bar.warp.sync
 </p>
 <p>
  Barrier synchronization for threads in a warp.
 </p>
 <p>
  Syntax
 </p>
 <pre>bar.warp.sync      membermask;
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   bar.warp.sync
  </span>
  will cause executing thread to wait until all threads corresponding to
  <span class="pre">
   membermask
  </span>
  have executed a
  <span class="pre">
   bar.warp.sync
  </span>
  with the same
  <span class="pre">
   membermask
  </span>
  value before resuming
execution.
 </p>
 <p>
  Operand
  <span class="pre">
   membermask
  </span>
  specifies a 32-bit integer which is a mask indicating threads participating
in barrier where the bit position corresponds to threadâs
  <span class="pre">
   laneid
  </span>
  .
 </p>
 <p>
  The behavior of
  <span class="pre">
   bar.warp.sync
  </span>
  is undefined if the executing thread is not in the
  <span class="pre">
   membermask
  </span>
  .
 </p>
 <p>
  <span class="pre">
   bar.warp.sync
  </span>
  also guarantee memory ordering among threads participating in barrier. Thus,
threads within warp that wish to communicate via memory can store to memory, execute
  <span class="pre">
   bar.warp.sync
  </span>
  , and then safely read values stored by other threads in warp.
 </p>
 <p class="admonition-title">
  Note
 </p>
 <p>
  For .target
  <span class="pre">
   sm_6x
  </span>
  or below, all threads in
  <span class="pre">
   membermask
  </span>
  must execute the same
  <span class="pre">
   bar.warp.sync
  </span>
  instruction in convergence, and only threads belonging to some
  <span class="pre">
   membermask
  </span>
  can be active when the
  <span class="pre">
   bar.warp.sync
  </span>
  instruction is executed. Otherwise, the behavior is
undefined.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 6.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>st.shared.u32 [r0],r1;         // write my result to shared memory
bar.warp.sync  0xffffffff;     // arrive, wait for others to arrive
ld.shared.u32 r2,[r3];         // read results written by other threads
</pre>
 <h4>
  <span class="section-number">
   9.7.12.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-barrier-cluster">
   Parallel Synchronization and Communication Instructions: barrier.cluster
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-barrier-cluster" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  barrier.cluster
 </p>
 <p>
  Barrier synchronization within a cluster.
 </p>
 <p>
  Syntax
 </p>
 <pre>barrier.cluster.arrive{.sem}{.aligned};
barrier.cluster.wait{.acquire}{.aligned};

.sem = {.release, .relaxed}
</pre>
 <p>
  Description
 </p>
 <p>
  Performs barrier synchronization and communication within a cluster.
 </p>
 <p>
  <span class="pre">
   barrier.cluster
  </span>
  instructions can be used by the threads within the cluster for synchronization
and communication.
 </p>
 <p>
  <span class="pre">
   barrier.cluster.arrive
  </span>
  instruction marks warpsâ arrival at barrier without causing executing
thread to wait for threads of other participating warps.
 </p>
 <p>
  <span class="pre">
   barrier.cluster.wait
  </span>
  instruction causes the executing thread to wait for all non-exited threads
of the cluster to perform
  <span class="pre">
   barrier.cluster.arrive
  </span>
  .
 </p>
 <p>
  In addition,
  <span class="pre">
   barrier.cluster
  </span>
  instructions cause the executing thread to wait for all non-exited
threads from its warp.
 </p>
 <p>
  When all non-exited threads that executed
  <span class="pre">
   barrier.cluster.arrive
  </span>
  have executed
  <span class="pre">
   barrier.cluster.wait
  </span>
  , the barrier completes and is reinitialized so it can be reused
immediately. Each thread must arrive at the barrier only once before the barrier completes.
 </p>
 <p>
  The
  <span class="pre">
   barrier.cluster.wait
  </span>
  instruction guarantees that when it completes the execution, memory
accesses (except asynchronous operations) requested, in program order, prior to the preceding
  <span class="pre">
   barrier.cluster.arrive
  </span>
  by all threads in the cluster are complete and visible to the executing
thread.
 </p>
 <p>
  There is no memory ordering and visibility guarantee for memory accesses requested by the executing
thread, in program order, after
  <span class="pre">
   barrier.cluster.arrive
  </span>
  and prior to
  <span class="pre">
   barrier.cluster.wait
  </span>
  .
 </p>
 <p>
  The optional
  <span class="pre">
   .relaxed
  </span>
  qualifier on
  <span class="pre">
   barrier.cluster.arrive
  </span>
  specifies that there are no memory
ordering and visibility guarantees provided for the memory accesses performed prior to
  <span class="pre">
   barrier.cluster.arrive
  </span>
  .
 </p>
 <p>
  The optional
  <span class="pre">
   .sem
  </span>
  and
  <span class="pre">
   .acquire
  </span>
  qualifiers on instructions
  <span class="pre">
   barrier.cluster.arrive
  </span>
  and
  <span class="pre">
   barrier.cluster.wait
  </span>
  specify the memory synchronization as described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory Consistency
Model
  </a>
  . If the optional
  <span class="pre">
   .sem
  </span>
  qualifier is absent for
  <span class="pre">
   barrier.cluster.arrive
  </span>
  ,
  <span class="pre">
   .release
  </span>
  is assumed by default. If the optional
  <span class="pre">
   .acquire
  </span>
  qualifier is absent for
  <span class="pre">
   barrier.cluster.wait
  </span>
  ,
  <span class="pre">
   .acquire
  </span>
  is assumed by default.
 </p>
 <p>
  The optional
  <span class="pre">
   .aligned
  </span>
  qualifier indicates that all threads in the warp must execute the same
  <span class="pre">
   barrier.cluster
  </span>
  instruction. In conditionally executed code, an aligned
  <span class="pre">
   barrier.cluster
  </span>
  instruction should only be used if it is known that all threads in the warp evaluate the condition
identically, otherwise behavior is undefined.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.8.
 </p>
 <p>
  Support for
  <span class="pre">
   .acquire
  </span>
  ,
  <span class="pre">
   .relaxed
  </span>
  ,
  <span class="pre">
   .release
  </span>
  qualifiers introduced in PTX ISA version 8.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>// use of arrive followed by wait
ld.shared::cluster.u32 r0, [addr];
barrier.cluster.arrive.aligned;
...
barrier.cluster.wait.aligned;
st.shared::cluster.u32 [addr], r1;

// use memory fence prior to arrive for relaxed barrier
@cta0 ld.shared::cluster.u32 r0, [addr];
fence.cluster.acq_rel;
barrier.cluster.arrive.relaxed.aligned;
...
barrier.cluster.wait.aligned;
@cta1 st.shared::cluster.u32 [addr], r1;
</pre>
 <h4>
  <span class="section-number">
   9.7.12.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-membar">
   Parallel Synchronization and Communication Instructions: membar/fence
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-membar-fence" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  membar/fence
 </p>
 <p>
  Enforce an ordering of memory operations.
 </p>
 <p>
  Syntax
 </p>
 <pre>// Thread fence :
fence{.sem}.scope;

// Operation fence :
fence.op_restrict.release.cluster;

// Proxy fence (bi-directional) :
fence.proxy.proxykind;

// Proxy fence (uni-directional) :
fence.proxy.to_proxykind::from_proxykind.release.scope;
fence.proxy.to_proxykind::from_proxykind.acquire.scope  [addr], size;

// Old style membar :
membar.level;
membar.proxy.proxykind;

.sem       = { .sc, .acq_rel };
.scope     = { .cta, .cluster, .gpu, .sys };
.level     = { .cta, .gl, .sys };
.proxykind = { .alias, .async, async.global, .async.shared::{cta, cluster} };
.op_restrict = { .mbarrier_init };
.to_proxykind::from_proxykind = {.tensormap::generic};
</pre>
 <p>
  Description
 </p>
 <p>
  The
  <span class="pre">
   membar
  </span>
  instruction guarantees that prior memory accesses requested by this thread (
  <span class="pre">
   ld
  </span>
  ,
  <span class="pre">
   st
  </span>
  ,
  <span class="pre">
   atom
  </span>
  and
  <span class="pre">
   red
  </span>
  instructions) are performed at the specified
  <span class="pre">
   level
  </span>
  , before later
memory operations requested by this thread following the
  <span class="pre">
   membar
  </span>
  instruction. The
  <span class="pre">
   level
  </span>
  qualifier specifies the set of threads that may observe the ordering effect of this operation.
 </p>
 <p>
  A memory read (e.g., by
  <span class="pre">
   ld
  </span>
  or
  <span class="pre">
   atom
  </span>
  ) has been performed when the value read has been
transmitted from memory and cannot be modified by another thread at the indicated level. A memory
write (e.g., by
  <span class="pre">
   st
  </span>
  ,
  <span class="pre">
   red
  </span>
  or
  <span class="pre">
   atom
  </span>
  ) has been performed when the value written has become
visible to other threads at the specified level, that is, when the previous value can no longer be
read.
 </p>
 <p>
  The
  <span class="pre">
   fence
  </span>
  instruction establishes an ordering between memory accesses requested by this thread
(
  <span class="pre">
   ld
  </span>
  ,
  <span class="pre">
   st
  </span>
  ,
  <span class="pre">
   atom
  </span>
  and
  <span class="pre">
   red
  </span>
  instructions) as described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory Consistency Model
  </a>
  . The scope qualifier specifies the set of threads that may
observe the ordering effect of this operation.
 </p>
 <p>
  <span class="pre">
   fence.acq_rel
  </span>
  is a light-weight fence that is sufficient for memory synchronization in most
programs. Instances of
  <span class="pre">
   fence.acq_rel
  </span>
  synchronize when combined with additional memory operations
as described in
  <span class="pre">
   acquire
  </span>
  and
  <span class="pre">
   release
  </span>
  patterns in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory Consistency Model
  </a>
  . If the optional
  <span class="pre">
   .sem
  </span>
  qualifier is absent,
  <span class="pre">
   .acq_rel
  </span>
  is assumed by default.
 </p>
 <p>
  <span class="pre">
   fence.sc
  </span>
  is a slower fence that can restore
  sequential consistency
  when used in sufficient
places, at the cost of performance. Instances of
  <span class="pre">
   fence.sc
  </span>
  with sufficient scope always
synchronize by forming a total order per scope, determined at runtime. This total order can be
constrained further by other synchronization in the program.
 </p>
 <p>
  Qualifier
  <span class="pre">
   .op_restrict
  </span>
  restricts the class of prior memory operations for which the
  <span class="pre">
   fence
  </span>
  instruction provides the memory ordering guarantees. When
  <span class="pre">
   .op_restrict
  </span>
  is
  <span class="pre">
   .mbarrier_init
  </span>
  ,
the fence only applies to the prior
  <span class="pre">
   mbarrier.init
  </span>
  operations executed by the same thread on
  mbarrier objects
  in
  <span class="pre">
   .shared::cta
  </span>
  state space.
 </p>
 <p>
  The address operand
  <span class="pre">
   addr
  </span>
  and the operand
  <span class="pre">
   size
  </span>
  together specifies the memory range
  <span class="pre">
   [addr,
  </span>
  <span class="pre">
   addr+size-1]
  </span>
  on which the ordering guarantees on the memory accesses across the proxies is to be
provided. The only supported value for the
  <span class="pre">
   size
  </span>
  operand is 128.
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#generic-addressing">
   Generic Addressing
  </a>
  is used unconditionally, and the address specified by the operand
  <span class="pre">
   addr
  </span>
  must fall within the
  <span class="pre">
   .global
  </span>
  state space. Otherwise, the behavior is undefined.
 </p>
 <p>
  On
  <span class="pre">
   sm_70
  </span>
  and higher
  <span class="pre">
   membar
  </span>
  is a synonym for
  <span class="pre">
   fence.sc
  </span>
  1
  , and the
  <span class="pre">
   membar
  </span>
  levels
  <span class="pre">
   cta
  </span>
  ,
  <span class="pre">
   gl
  </span>
  and
  <span class="pre">
   sys
  </span>
  are synonymous with the
  <span class="pre">
   fence
  </span>
  scopes
  <span class="pre">
   cta
  </span>
  ,
  <span class="pre">
   gpu
  </span>
  and
  <span class="pre">
   sys
  </span>
  respectively.
 </p>
 <p>
  <span class="pre">
   membar.proxy
  </span>
  and
  <span class="pre">
   fence.proxy
  </span>
  instructions establish an ordering between memory accesses that
may happen through different
  proxies
  .
 </p>
 <p>
  A
  uni-directional
  proxy ordering from the
  from-proxykind
  to the
  to-proxykind
  establishes
ordering between a prior memory access performed via the
  from-proxykind
  and a subsequent memory access
performed via the
  to-proxykind
  .
 </p>
 <p>
  A
  bi-directional
  proxy ordering between two proxykinds establishes two
  uni-directional
  proxy orderings
: one from the first proxykind to the second proxykind and the other from the second proxykind to the first
proxykind.
 </p>
 <p>
  The
  <span class="pre">
   .proxykind
  </span>
  qualifier indicates the
  bi-directional
  proxy ordering that is established between the memory
accesses done between the generic proxy and the proxy specified by
  <span class="pre">
   .proxykind
  </span>
  .
 </p>
 <p>
  Value
  <span class="pre">
   .alias
  </span>
  of the
  <span class="pre">
   .proxykind
  </span>
  qualifier refers to memory accesses performed using virtually
aliased addresses to the same memory location. Value
  <span class="pre">
   .async
  </span>
  of the
  <span class="pre">
   .proxykind
  </span>
  qualifier specifies
that the memory ordering is established between the async proxy and the generic proxy. The memory
ordering is limited only to the state space specified. If no state space is specified, then the memory
ordering applies on all state spaces.
 </p>
 <p>
  A
  <span class="pre">
   .release
  </span>
  proxy fence can form a release sequence that synchronizes with an acquire
sequence that contains a
  <span class="pre">
   .acquire
  </span>
  proxy fence. The
  <span class="pre">
   .to_proxykind
  </span>
  and
  <span class="pre">
   .from_proxykind
  </span>
  qualifiers indicate the
  uni-directional
  proxy ordering that is established.
 </p>
 <p>
  On
  <span class="pre">
   sm_70
  </span>
  and higher,
  <span class="pre">
   membar.proxy
  </span>
  is a synonym for
  <span class="pre">
   fence.proxy
  </span>
  .
 </p>
 <p>
  1
  The semantics of
  <span class="pre">
   fence.sc
  </span>
  introduced with
  <span class="pre">
   sm_70
  </span>
  is a superset of the semantics of
  <span class="pre">
   membar
  </span>
  and the two are compatible; when executing on
  <span class="pre">
   sm_70
  </span>
  or later architectures,
  <span class="pre">
   membar
  </span>
  acquires the full semantics of
  <span class="pre">
   fence.sc
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  <span class="pre">
   membar.{cta,gl}
  </span>
  introduced in PTX ISA version 1.4.
 </p>
 <p>
  <span class="pre">
   membar.sys
  </span>
  introduced in PTX ISA version 2.0.
 </p>
 <p>
  <span class="pre">
   fence
  </span>
  introduced in PTX ISA version 6.0.
 </p>
 <p>
  <span class="pre">
   membar.proxy
  </span>
  and
  <span class="pre">
   fence.proxy
  </span>
  introduced in PTX ISA version 7.5.
 </p>
 <p>
  <span class="pre">
   .cluster
  </span>
  scope qualifier introduced in PTX ISA version 7.8.
 </p>
 <p>
  <span class="pre">
   .op_restrict
  </span>
  qualifier introduced in PTX ISA version 8.0.
 </p>
 <p>
  <span class="pre">
   fence.proxy.async
  </span>
  is introduced in PTX ISA version 8.0.
 </p>
 <p>
  <span class="pre">
   .to_proxykind::from_proxykind
  </span>
  qualifier introduced in PTX ISA version 8.3.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   membar.{cta,gl}
  </span>
  supported on all target architectures.
 </p>
 <p>
  <span class="pre">
   membar.sys
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   fence
  </span>
  requires
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   membar.proxy
  </span>
  requires
  <span class="pre">
   sm_60
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   fence.proxy
  </span>
  requires
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   .cluster
  </span>
  scope qualifier requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   .op_restrict
  </span>
  qualifier requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   fence.proxy.async
  </span>
  requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   .to_proxykind::from_proxykind
  </span>
  qualifier requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>membar.gl;
membar.cta;
membar.sys;
fence.sc;
fence.sc.cluster;
fence.proxy.alias;
membar.proxy.alias;
fence.mbarrier_init.release.cluster;
fence.proxy.async;
fence.proxy.async.shared::cta;
fence.proxy.async.shared::cluster;
fence.proxy.async.global;

tensormap.replace.tile.global_address.global.b1024.b64   [gbl], new_addr;
fence.proxy.tensormap::generic.release.gpu;
fence.proxy.tensormap::generic.acquire.gpu [tmap], 128;
cvta.global.u64  tmap, gbl;
cp.async.bulk.tensor.1d.shared::cluster.global.tile  [addr0], [tmap, {tc0}], [mbar0];
</pre>
 <h4>
  <span class="section-number">
   9.7.12.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-atom">
   Parallel Synchronization and Communication Instructions: atom
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-atom" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  atom
 </p>
 <p>
  Atomic reduction operations for thread-to-thread communication.
 </p>
 <p>
  Syntax
 </p>
 <p>
  Atomic operation with scalar type:
 </p>
 <pre>atom{.sem}{.scope}{.space}.op{.level::cache_hint}.type d, [a], b{, cache-policy};
atom{.sem}{.scope}{.space}.op.type d, [a], b, c;

atom{.sem}{.scope}{.space}.cas.b16 d, [a], b, c;

atom{.sem}{.scope}{.space}.cas.b128 d, [a], b, c {, cache-policy};
atom{.sem}{.scope}{.space}.exch{.level::cache_hint}.b128 d, [a], b {, cache-policy};

atom{.sem}{.scope}{.space}.add.noftz{.level::cache_hint}.f16     d, [a], b{, cache-policy};
atom{.sem}{.scope}{.space}.add.noftz{.level::cache_hint}.f16x2   d, [a], b{, cache-policy};

atom{.sem}{.scope}{.space}.add.noftz{.level::cache_hint}.bf16    d, [a], b{, cache-policy};
atom{.sem}{.scope}{.space}.add.noftz{.level::cache_hint}.bf16x2  d, [a], b{, cache-policy};

.space =              { .global, .shared{::cta, ::cluster} };
.sem =                { .relaxed, .acquire, .release, .acq_rel };
.scope =              { .cta, .cluster, .gpu, .sys };

.op =                 { .and, .or, .xor,
                        .cas, .exch,
                        .add, .inc, .dec,
                        .min, .max };
.level::cache_hint =  { .L2::cache_hint };
.type =               { .b32, .b64, .u32, .u64, .s32, .s64, .f32, .f64 };
</pre>
 <p>
  Atomic operation with vector type:
 </p>
 <pre>atom{.sem}{.scope}{.global}.add{.level::cache_hint}.vec_32_bit.f32                  d, [a], b{, cache-policy};
atom{.sem}{.scope}{.global}.op.noftz{.level::cache_hint}.vec_16_bit.half_word_type  d, [a], b{, cache-policy};
atom{.sem}{.scope}{.global}.op.noftz{.level::cache_hint}.vec_32_bit.packed_type     d, [a], b{, cache-policy};

.sem =               { .relaxed, .acquire, .release, .acq_rel };
.scope =             { .cta, .cluster, .gpu, .sys };
.op =                { .add, .min, .max };
.half_word_type =    { .f16, .bf16 };
.packed_type =       { .f16x2, .bf16x2 };
.vec_16_bit =        { .v2, .v4, .v8 }
.vec_32_bit =        { .v2, .v4 };
.level::cache_hint = { .L2::cache_hint }
</pre>
 <p>
  Description
 </p>
 <p>
  Atomically loads the original value at location
  <span class="pre">
   a
  </span>
  into destination register
  <span class="pre">
   d
  </span>
  , performs a
reduction operation with operand
  <span class="pre">
   b
  </span>
  and the value in location
  <span class="pre">
   a
  </span>
  , and stores the result of the
specified operation at location
  <span class="pre">
   a
  </span>
  , overwriting the original value. Operand
  <span class="pre">
   a
  </span>
  specifies a
location in the specified state space. If no state space is given, perform the memory accesses using
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#generic-addressing">
   Generic Addressing
  </a>
  .
  <span class="pre">
   atom
  </span>
  with scalar type may be used only
with
  <span class="pre">
   .global
  </span>
  and
  <span class="pre">
   .shared
  </span>
  spaces and with generic addressing, where the address points to
  <span class="pre">
   .global
  </span>
  or
  <span class="pre">
   .shared
  </span>
  space.
  <span class="pre">
   atom
  </span>
  with vector type may be used only with
  <span class="pre">
   .global
  </span>
  space
and with generic addressing where the address points to
  <span class="pre">
   .global
  </span>
  space.
 </p>
 <p>
  For
  <span class="pre">
   atom
  </span>
  with vector type, operands
  <span class="pre">
   d
  </span>
  and
  <span class="pre">
   b
  </span>
  are brace-enclosed vector expressions, size
of which is equal to the size of vector qualifier.
 </p>
 <p>
  If no sub-qualifier is specified with
  <span class="pre">
   .shared
  </span>
  state space, then
  <span class="pre">
   ::cta
  </span>
  is assumed by default.
 </p>
 <p>
  The optional
  <span class="pre">
   .sem
  </span>
  qualifier specifies a memory synchronizing effect as described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory
Consistency Model
  </a>
  . If the
  <span class="pre">
   .sem
  </span>
  qualifier is absent,
  <span class="pre">
   .relaxed
  </span>
  is assumed by default.
 </p>
 <p>
  The optional
  <span class="pre">
   .scope
  </span>
  qualifier specifies the set of threads that can directly observe the memory
synchronizing effect of this operation, as described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory Consistency Model
  </a>
  . If the
  <span class="pre">
   .scope
  </span>
  qualifier is absent,
  <span class="pre">
   .gpu
  </span>
  scope is
assumed by default.
 </p>
 <p>
  For
  <span class="pre">
   atom
  </span>
  with vector type, the supported combinations of vector qualifier and types, and atomic
operations supported on these combinations are depicted in the following table:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head" rowspan="2">
    <p>
     Vector qualifier
    </p>
   </th>
   <th class="head" colspan="3">
    <p>
     Types
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <th class="head">
    <p>
     <span class="pre">
      .f16
     </span>
     /
     <span class="pre">
      bf16
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      .f16x2
     </span>
     /
     <span class="pre">
      bf16x2
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      .f32
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .v2
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .add
     </span>
     ,
     <span class="pre">
      .min
     </span>
     ,
     <span class="pre">
      .max
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .add
     </span>
     ,
     <span class="pre">
      .min
     </span>
     ,
     <span class="pre">
      .max
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .add
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .v4
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .add
     </span>
     ,
     <span class="pre">
      .min
     </span>
     ,
     <span class="pre">
      .max
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .add
     </span>
     ,
     <span class="pre">
      .min
     </span>
     ,
     <span class="pre">
      .max
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .add
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .v8
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .add
     </span>
     ,
     <span class="pre">
      .min
     </span>
     ,
     <span class="pre">
      .max
     </span>
    </p>
   </td>
   <td>
    <p>
     Not supported
    </p>
   </td>
   <td>
    <p>
     Not Supported
    </p>
   </td>
  </tr>
 </table>
 <p>
  Two atomic operations {
  <span class="pre">
   atom
  </span>
  or
  <span class="pre">
   red
  </span>
  } are performed atomically with respect to each other only
if each operation specifies a scope that includes the other. When this condition is not met, each
operation observes the other operation being performed as if it were split into a read followed by a
dependent write.
 </p>
 <p>
  <span class="pre">
   atom
  </span>
  instruction on packed type or vector type, accesses adjacent scalar elements in memory. In
such cases, the atomicity is guaranteed separately for each of the individual scalar elements; the
entire
  <span class="pre">
   atom
  </span>
  is not guaranteed to be atomic as a single access.
 </p>
 <p>
  For
  <span class="pre">
   sm_6x
  </span>
  and earlier architectures,
  <span class="pre">
   atom
  </span>
  operations on
  <span class="pre">
   .shared
  </span>
  state space do not
guarantee atomicity with respect to normal store instructions to the same address. It is the
programmerâs responsibility to guarantee correctness of programs that use shared memory atomic
instructions, e.g., by inserting barriers between normal stores and atomic operations to a common
address, or by using atom.exch to store to locations accessed by other atomic operations.
 </p>
 <p>
  Supported addressing modes for operand
  <span class="pre">
   a
  </span>
  and alignment requirements are described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#addresses-as-operands">
   Addresses
as Operands
  </a>
 </p>
 <p>
  The bit-size operations are
  <span class="pre">
   .and
  </span>
  ,
  <span class="pre">
   .or
  </span>
  ,
  <span class="pre">
   .xor
  </span>
  ,
  <span class="pre">
   .cas
  </span>
  (compare-and-swap), and
  <span class="pre">
   .exch
  </span>
  (exchange).
 </p>
 <p>
  The integer operations are
  <span class="pre">
   .add
  </span>
  ,
  <span class="pre">
   .inc
  </span>
  ,
  <span class="pre">
   .dec
  </span>
  ,
  <span class="pre">
   .min
  </span>
  ,
  <span class="pre">
   .max
  </span>
  . The
  <span class="pre">
   .inc
  </span>
  and
  <span class="pre">
   .dec
  </span>
  operations return a result in the range
  <span class="pre">
   [0..b]
  </span>
  .
 </p>
 <p>
  The floating-point operation
  <span class="pre">
   .add
  </span>
  operation rounds to nearest even. Current implementation of
  <span class="pre">
   atom.add.f32
  </span>
  on global memory flushes subnormal inputs and results to sign-preserving zero;
whereas
  <span class="pre">
   atom.add.f32
  </span>
  on shared memory supports subnormal inputs and results and doesnât flush
them to zero.
 </p>
 <p>
  <span class="pre">
   atom.add.f16
  </span>
  ,
  <span class="pre">
   atom.add.f16x2
  </span>
  ,
  <span class="pre">
   atom.add.bf16
  </span>
  and
  <span class="pre">
   atom.add.bf16x2
  </span>
  operation requires
the
  <span class="pre">
   .noftz
  </span>
  qualifier; it preserves subnormal inputs and results, and does not flush them to
zero.
 </p>
 <p>
  When the optional argument
  <span class="pre">
   cache-policy
  </span>
  is specified, the qualifier
  <span class="pre">
   .level::cache_hint
  </span>
  is
required. The 64-bit operand
  <span class="pre">
   cache-policy
  </span>
  specifies the cache eviction policy that may be used
during the memory access.
 </p>
 <p>
  The qualifier
  <span class="pre">
   .level::cache_hint
  </span>
  is only supported for
  <span class="pre">
   .global
  </span>
  state space and for generic
addressing where the address points to the
  <span class="pre">
   .global
  </span>
  state space.
 </p>
 <p>
  <span class="pre">
   cache-policy
  </span>
  is a hint to the cache subsystem and may not always be respected. It is treated as
a performance hint only, and does not change the memory consistency behavior of the program.
 </p>
 <p>
  Semantics
 </p>
 <pre>atomic {
    d = *a;
    *a = (operation == cas) ? operation(*a, b, c)
                            : operation(*a, b);
}
where
    inc(r, s)  = (r &gt;= s) ? 0 : r+1;
    dec(r, s)  = (r==0 || r &gt; s)  ? s : r-1;
    exch(r, s) =  s;
    cas(r,s,t) = (r == s) ? t : r;
</pre>
 <p>
  Notes
 </p>
 <p>
  Simple reductions may be specified by using the
  bit bucket
  destination operand
  <span class="pre">
   _
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  32-bit atom.global introduced in PTX ISA version 1.1.
 </p>
 <p>
  <span class="pre">
   atom.shared
  </span>
  and 64-bit
  <span class="pre">
   atom.global.{add,cas,exch}
  </span>
  introduced in PTX ISA 1.2.
 </p>
 <p>
  <span class="pre">
   atom.add.f32
  </span>
  and 64-bit
  <span class="pre">
   atom.shared.{add,cas,exch}
  </span>
  introduced in PTX ISA 2.0.
 </p>
 <p>
  64-bit
  <span class="pre">
   atom.{and,or,xor,min,max}
  </span>
  introduced in PTX ISA 3.1.
 </p>
 <p>
  <span class="pre">
   atom.add.f64
  </span>
  introduced in PTX ISA 5.0.
 </p>
 <p>
  <span class="pre">
   .scope
  </span>
  qualifier introduced in PTX ISA 5.0.
 </p>
 <p>
  <span class="pre">
   .sem
  </span>
  qualifier introduced in PTX ISA version 6.0.
 </p>
 <p>
  <span class="pre">
   atom.add.noftz.f16x2
  </span>
  introduced in PTX ISA 6.2.
 </p>
 <p>
  <span class="pre">
   atom.add.noftz.f16
  </span>
  and
  <span class="pre">
   atom.cas.b16
  </span>
  introduced in PTX ISA 6.3.
 </p>
 <p>
  Per-element atomicity of
  <span class="pre">
   atom.f16x2
  </span>
  clarified in PTX ISA version 6.3, with retrospective effect
from PTX ISA version 6.2.
 </p>
 <p>
  Support for
  <span class="pre">
   .level::cache_hint
  </span>
  qualifier introduced in PTX ISA version 7.4.
 </p>
 <p>
  <span class="pre">
   atom.add.noftz.bf16
  </span>
  and
  <span class="pre">
   atom.add.noftz.bf16x2
  </span>
  introduced in PTX ISA 7.8.
 </p>
 <p>
  Support for
  <span class="pre">
   .cluster
  </span>
  scope qualifier introduced in PTX ISA version 7.8.
 </p>
 <p>
  Support for
  <span class="pre">
   ::cta
  </span>
  and
  <span class="pre">
   ::cluster
  </span>
  sub-qualifiers introduced in PTX ISA version 7.8.
 </p>
 <p>
  Support for vector types introduced in PTX ISA version 8.1.
 </p>
 <p>
  Support for
  <span class="pre">
   .b128
  </span>
  type introduced in PTX ISA version 8.3.
 </p>
 <p>
  Support for
  <span class="pre">
   .sys
  </span>
  scope with
  <span class="pre">
   .b128
  </span>
  type introduced in PTX ISA version 8.4.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   atom.global
  </span>
  requires
  <span class="pre">
   sm_11
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   atom.shared
  </span>
  requires
  <span class="pre">
   sm_12
  </span>
  or higher.
 </p>
 <p>
  64-bit
  <span class="pre">
   atom.global.{add,cas,exch}
  </span>
  require
  <span class="pre">
   sm_12
  </span>
  or higher.
 </p>
 <p>
  64-bit
  <span class="pre">
   atom.shared.{add,cas,exch}
  </span>
  require
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  64-bit
  <span class="pre">
   atom.{and,or,xor,min,max}
  </span>
  require
  <span class="pre">
   sm_32
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   atom.add.f32
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   atom.add.f64
  </span>
  requires
  <span class="pre">
   sm_60
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   .scope
  </span>
  qualifier requires
  <span class="pre">
   sm_60
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   .sem
  </span>
  qualifier requires
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  Use of generic addressing requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   atom.add.noftz.f16x2
  </span>
  requires
  <span class="pre">
   sm_60
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   atom.add.noftz.f16
  </span>
  and
  <span class="pre">
   atom.cas.b16
  </span>
  requires
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  Support for
  <span class="pre">
   .level::cache_hint
  </span>
  qualifier requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   atom.add.noftz.bf16
  </span>
  and
  <span class="pre">
   atom.add.noftz.bf16x2
  </span>
  require
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Support for
  <span class="pre">
   .cluster
  </span>
  scope qualifier requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Sub-qualifier
  <span class="pre">
   ::cta
  </span>
  requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Sub-qualifier
  <span class="pre">
   ::cluster
  </span>
  requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Support for vector types requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Support for
  <span class="pre">
   .b128
  </span>
  type requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>atom.global.add.s32  d,[a],1;
atom.shared::cta.max.u32  d,[x+4],0;
@p  atom.global.cas.b32  d,[p],my_val,my_new_val;
atom.global.sys.add.u32 d, [a], 1;
atom.global.acquire.sys.inc.u32 ans, [gbl], %r0;
atom.add.noftz.f16x2 d, [a], b;
atom.add.noftz.f16   hd, [ha], hb;
atom.global.cas.b16  hd, [ha], hb, hc;
atom.add.noftz.bf16   hd, [a], hb;
atom.add.noftz.bf16x2 bd, [b], bb;
atom.add.shared::cluster.noftz.f16   hd, [ha], hb;
atom.shared.b128.cas d, a, b, c; // 128-bit atom
atom.global.b128.exch d, a, b;   // 128-bit atom

atom.global.cluster.relaxed.add.u32 d, [a], 1;

createpolicy.fractional.L2::evict_last.b64 cache-policy, 0.25;
atom.global.add.L2::cache_hint.s32  d, [a], 1, cache-policy;

atom.global.v8.f16.max.noftz  {%hd0, %hd1, %hd2, %hd3, %hd4, %hd5, %hd6, %hd7}, [gbl],
                                              {%h0, %h1, %h2, %h3, %h4, %h5, %h6, %h7};
atom.global.v8.bf16.add.noftz  {%hd0, %hd1, %hd2, %hd3, %hd4, %hd5, %hd6, %hd7}, [gbl],
                                              {%h0, %h1, %h2, %h3, %h4, %h5, %h6, %h7};
atom.global.v2.f16.add.noftz  {%hd0, %hd1}, [gbl], {%h0, %h1};
atom.global.v2.bf16.add.noftz  {%hd0, %hd1}, [gbl], {%h0, %h1};
atom.global.v4.b16x2.min.noftz  {%hd0, %hd1, %hd2, %hd3}, [gbl], {%h0, %h1, %h2, %h3};
atom.global.v4.f32.add  {%f0, %f1, %f2, %f3}, [gbl], {%f0, %f1, %f2, %f3};
atom.global.v2.f16x2.min.noftz  {%bd0, %bd1}, [g], {%b0, %b1};
atom.global.v2.bf16x2.max.noftz  {%bd0, %bd1}, [g], {%b0, %b1};
atom.global.v2.f32.add  {%f0, %f1}, [g], {%f0, %f1};
</pre>
 <h4>
  <span class="section-number">
   9.7.12.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-red">
   Parallel Synchronization and Communication Instructions: red
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-red" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  red
 </p>
 <p>
  Reduction operations on global and shared memory.
 </p>
 <p>
  Syntax
 </p>
 <p>
  Reduction operation with scalar type:
 </p>
 <pre>red{.sem}{.scope}{.space}.op{.level::cache_hint}.type          [a], b{, cache-policy};

red{.sem}{.scope}{.space}.add.noftz{.level::cache_hint}.f16    [a], b{, cache-policy};

red{.sem}{.scope}{.space}.add.noftz{.level::cache_hint}.f16x2  [a], b{, cache-policy};

red{.sem}{.scope}{.space}.add.noftz{.level::cache_hint}.bf16
                                                      [a], b {, cache-policy};

red{.sem}{.scope}{.space}.add.noftz{.level::cache_hint}.bf16x2
                                                      [a], b {, cache-policy};

.space =              { .global, .shared{::cta, ::cluster} };
.sem =                {.relaxed, .release};
.scope =              {.cta, .cluster, .gpu, .sys};

.op =                 { .and, .or, .xor,
                        .add, .inc, .dec,
                        .min, .max };
.level::cache_hint =  { .L2::cache_hint };
.type =               { .b32, .b64, .u32, .u64, .s32, .s64, .f32, .f64 };
</pre>
 <p>
  Reduction operation with vector type:
 </p>
 <pre>red{.sem}{.scope}{.global}.add{.level::cache_hint}.vec_32_bit.f32 [a], b{, cache-policy};
red{.sem}{.scope}{.global}.op.noftz{.level::cache_hint}. vec_16_bit.half_word_type [a], b{, cache-policy};
red{.sem}{.scope}{.global}.op.noftz{.level::cache_hint}.vec_32_bit.packed_type [a], b {, cache-policy};

.sem =                { .relaxed, .release };
.scope =              { .cta, .cluster, .gpu, .sys };
.op =                 { .add, .min, .max };
.half_word_type =     { .f16, .bf16 };
.packed_type =        { .f16x2,.bf16x2 };
.vec_16_bit =         { .v2, .v4, .v8 }
.vec_32_bit =         { .v2, .v4 };
.level::cache_hint =  { .L2::cache_hint }
</pre>
 <p>
  Description
 </p>
 <p>
  Performs a reduction operation with operand
  <span class="pre">
   b
  </span>
  and the value in location
  <span class="pre">
   a
  </span>
  , and stores the
result of the specified operation at location
  <span class="pre">
   a
  </span>
  , overwriting the original value. Operand
  <span class="pre">
   a
  </span>
  specifies a location in the specified state space. If no state space is given, perform the memory
accesses using
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#generic-addressing">
   Generic Addressing
  </a>
  .
  <span class="pre">
   red
  </span>
  with scalar type may
be used only with
  <span class="pre">
   .global
  </span>
  and
  <span class="pre">
   .shared
  </span>
  spaces and with generic addressing, where the address
points to
  <span class="pre">
   .global
  </span>
  or
  <span class="pre">
   .shared
  </span>
  space.
  <span class="pre">
   red
  </span>
  with vector type may be used only with
  <span class="pre">
   .global
  </span>
  space and with generic addressing where the address points to
  <span class="pre">
   .global
  </span>
  space.
 </p>
 <p>
  For
  <span class="pre">
   red
  </span>
  with vector type, operand
  <span class="pre">
   b
  </span>
  is brace-enclosed vector expressions, size of which is
equal to the size of vector qualifier.
 </p>
 <p>
  If no sub-qualifier is specified with
  <span class="pre">
   .shared
  </span>
  state space, then
  <span class="pre">
   ::cta
  </span>
  is assumed by default.
 </p>
 <p>
  The optional
  <span class="pre">
   .sem
  </span>
  qualifier specifies a memory synchronizing effect as described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory
Consistency Model
  </a>
  . If the
  <span class="pre">
   .sem
  </span>
  qualifier is absent,
  <span class="pre">
   .relaxed
  </span>
  is assumed by default.
 </p>
 <p>
  The optional
  <span class="pre">
   .scope
  </span>
  qualifier specifies the set of threads that can directly observe the memory
synchronizing effect of this operation, as described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory Consistency Model
  </a>
  . If the
  <span class="pre">
   .scope
  </span>
  qualifier is absent,
  <span class="pre">
   .gpu
  </span>
  scope is
assumed by default.
 </p>
 <p>
  For
  <span class="pre">
   red
  </span>
  with vector type, the supported combinations of vector qualifier, types and reduction
operations supported on these combinations are depicted in following table:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head" rowspan="2">
    <p>
     Vector qualifier
    </p>
   </th>
   <th class="head" colspan="3">
    <p>
     Types
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <th class="head">
    <p>
     <span class="pre">
      .f16
     </span>
     /
     <span class="pre">
      bf16
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      .f16x2
     </span>
     /
     <span class="pre">
      bf16x2
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      .f32
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .v2
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .add
     </span>
     ,
     <span class="pre">
      .min
     </span>
     ,
     <span class="pre">
      .max
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .add
     </span>
     ,
     <span class="pre">
      .min
     </span>
     ,
     <span class="pre">
      .max
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .add
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .v4
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .add
     </span>
     ,
     <span class="pre">
      .min
     </span>
     ,
     <span class="pre">
      .max
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .add
     </span>
     ,
     <span class="pre">
      .min
     </span>
     ,
     <span class="pre">
      .max
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .add
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .v8
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .add
     </span>
     ,
     <span class="pre">
      .min
     </span>
     ,
     <span class="pre">
      .max
     </span>
    </p>
   </td>
   <td>
    <p>
     Not supported
    </p>
   </td>
   <td>
    <p>
     Not Supported
    </p>
   </td>
  </tr>
 </table>
 <p>
  Two atomic operations {
  <span class="pre">
   atom
  </span>
  or
  <span class="pre">
   red
  </span>
  } are performed atomically with respect to each other only
if each operation specifies a scope that includes the other. When this condition is not met, each
operation observes the other operation being performed as if it were split into a read followed by a
dependent write.
 </p>
 <p>
  <span class="pre">
   red
  </span>
  instruction on packed type or vector type, accesses adjacent scalar elements in memory. In
such case, the atomicity is guaranteed separately for each of the individual scalar elements; the
entire
  <span class="pre">
   red
  </span>
  is not guaranteed to be atomic as a single access.
 </p>
 <p>
  For
  <span class="pre">
   sm_6x
  </span>
  and earlier architectures,
  <span class="pre">
   red
  </span>
  operations on
  <span class="pre">
   .shared
  </span>
  state space do not
guarantee atomicity with respect to normal store instructions to the same address. It is the
programmerâs responsibility to guarantee correctness of programs that use shared memory reduction
instructions, e.g., by inserting barriers between normal stores and reduction operations to a common
address, or by using
  <span class="pre">
   atom.exch
  </span>
  to store to locations accessed by other reduction operations.
 </p>
 <p>
  Supported addressing modes for operand
  <span class="pre">
   a
  </span>
  and alignment requirements are described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#addresses-as-operands">
   Addresses
as Operands
  </a>
 </p>
 <p>
  The bit-size operations are
  <span class="pre">
   .and
  </span>
  ,
  <span class="pre">
   .or
  </span>
  , and
  <span class="pre">
   .xor
  </span>
  .
 </p>
 <p>
  The integer operations are
  <span class="pre">
   .add
  </span>
  ,
  <span class="pre">
   .inc
  </span>
  ,
  <span class="pre">
   .dec
  </span>
  ,
  <span class="pre">
   .min
  </span>
  ,
  <span class="pre">
   .max
  </span>
  . The
  <span class="pre">
   .inc
  </span>
  and
  <span class="pre">
   .dec
  </span>
  operations return a result in the range
  <span class="pre">
   [0..b]
  </span>
  .
 </p>
 <p>
  The floating-point operation
  <span class="pre">
   .add
  </span>
  operation rounds to nearest even. Current implementation of
  <span class="pre">
   red.add.f32
  </span>
  on global memory flushes subnormal inputs and results to sign-preserving zero;
whereas
  <span class="pre">
   red.add.f32
  </span>
  on shared memory supports subnormal inputs and results and doesnât flush
them to zero.
 </p>
 <p>
  <span class="pre">
   red.add.f16
  </span>
  ,
  <span class="pre">
   red.add.f16x2
  </span>
  ,
  <span class="pre">
   red.add.bf16
  </span>
  and
  <span class="pre">
   red.add.bf16x2
  </span>
  operation requires the
  <span class="pre">
   .noftz
  </span>
  qualifier; it preserves subnormal inputs and results, and does not flush them to zero.
 </p>
 <p>
  When the optional argument
  <span class="pre">
   cache-policy
  </span>
  is specified, the qualifier
  <span class="pre">
   .level::cache_hint
  </span>
  is
required. The 64-bit operand
  <span class="pre">
   cache-policy
  </span>
  specifies the cache eviction policy that may be used
during the memory access.
 </p>
 <p>
  The qualifier
  <span class="pre">
   .level::cache_hint
  </span>
  is only supported for
  <span class="pre">
   .global
  </span>
  state space and for generic
addressing where the address points to the
  <span class="pre">
   .global
  </span>
  state space.
 </p>
 <p>
  <span class="pre">
   cache-policy
  </span>
  is a hint to the cache subsystem and may not always be respected. It is treated as
a performance hint only, and does not change the memory consistency behavior of the program.
 </p>
 <p>
  Semantics
 </p>
 <pre>*a = operation(*a, b);

where
    inc(r, s) = (r &gt;= s) ? 0 : r+1;
    dec(r, s) = (r==0 || r &gt; s)  ? s : r-1;
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.2.
 </p>
 <p>
  <span class="pre">
   red.add.f32
  </span>
  and
  <span class="pre">
   red.shared.add.u64
  </span>
  introduced in PTX ISA 2.0.
 </p>
 <p>
  64-bit
  <span class="pre">
   red.{and,or,xor,min,max}
  </span>
  introduced in PTX ISA 3.1.
 </p>
 <p>
  <span class="pre">
   red.add.f64
  </span>
  introduced in PTX ISA 5.0.
 </p>
 <p>
  <span class="pre">
   .scope
  </span>
  qualifier introduced in PTX ISA 5.0.
 </p>
 <p>
  <span class="pre">
   .sem
  </span>
  qualifier introduced in PTX ISA version 6.0.
 </p>
 <p>
  <span class="pre">
   red.add.noftz.f16x2
  </span>
  introduced in PTX ISA 6.2.
 </p>
 <p>
  <span class="pre">
   red.add.noftz.f16
  </span>
  introduced in PTX ISA 6.3.
 </p>
 <p>
  Per-element atomicity of
  <span class="pre">
   red.f16x2
  </span>
  clarified in PTX ISA version 6.3, with retrospective effect
from PTX ISA version 6.2
 </p>
 <p>
  Support for
  <span class="pre">
   .level::cache_hint
  </span>
  qualifier introduced in PTX ISA version 7.4.
 </p>
 <p>
  <span class="pre">
   red.add.noftz.bf16
  </span>
  and
  <span class="pre">
   red.add.noftz.bf16x2
  </span>
  introduced in PTX ISA 7.8.
 </p>
 <p>
  Support for
  <span class="pre">
   .cluster
  </span>
  scope qualifier introduced in PTX ISA version 7.8.
 </p>
 <p>
  Support for
  <span class="pre">
   ::cta
  </span>
  and
  <span class="pre">
   ::cluster
  </span>
  sub-qualifiers introduced in PTX ISA version 7.8.
 </p>
 <p>
  Support for vector types introduced in PTX ISA version 8.1.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   red.global
  </span>
  requires
  <span class="pre">
   sm_11
  </span>
  or higher
 </p>
 <p>
  <span class="pre">
   red.shared
  </span>
  requires
  <span class="pre">
   sm_12
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   red.global.add.u64
  </span>
  requires
  <span class="pre">
   sm_12
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   red.shared.add.u64
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  64-bit
  <span class="pre">
   red.{and,or,xor,min,max}
  </span>
  require
  <span class="pre">
   sm_32
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   red.add.f32
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   red.add.f64
  </span>
  requires
  <span class="pre">
   sm_60
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   .scope
  </span>
  qualifier requires
  <span class="pre">
   sm_60
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   .sem
  </span>
  qualifier requires
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  Use of generic addressing requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   red.add.noftz.f16x2
  </span>
  requires
  <span class="pre">
   sm_60
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   red.add.noftz.f16
  </span>
  requires
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  Support for
  <span class="pre">
   .level::cache_hint
  </span>
  qualifier requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   red.add.noftz.bf16
  </span>
  and
  <span class="pre">
   red.add.noftz.bf16x2
  </span>
  require
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Support for
  <span class="pre">
   .cluster
  </span>
  scope qualifier requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Sub-qualifier
  <span class="pre">
   ::cta
  </span>
  requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Sub-qualifier
  <span class="pre">
   ::cluster
  </span>
  requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Support for vector types requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>red.global.add.s32  [a],1;
red.shared::cluster.max.u32  [x+4],0;
@p  red.global.and.b32  [p],my_val;
red.global.sys.add.u32 [a], 1;
red.global.acquire.sys.add.u32 [gbl], 1;
red.add.noftz.f16x2 [a], b;
red.add.noftz.bf16   [a], hb;
red.add.noftz.bf16x2 [b], bb;
red.global.cluster.relaxed.add.u32 [a], 1;
red.shared::cta.min.u32  [x+4],0;

createpolicy.fractional.L2::evict_last.b64 cache-policy, 0.25;
red.global.and.L2::cache_hint.b32 [a], 1, cache-policy;

red.global.v8.f16.add.noftz  [gbl], {%h0, %h1, %h2, %h3, %h4, %h5, %h6, %h7};
red.global.v8.bf16.min.noftz [gbl], {%h0, %h1, %h2, %h3, %h4, %h5, %h6, %h7};
red.global.v2.f16.add.noftz [gbl], {%h0, %h1};
red.global.v2.bf16.add.noftz [gbl], {%h0, %h1};
red.global.v4.f16x2.max.noftz [gbl], {%h0, %h1, %h2, %h3};
red.global.v4.f32.add  [gbl], {%f0, %f1, %f2, %f3};
red.global.v2.f16x2.max.noftz {%bd0, %bd1}, [g], {%b0, %b1};
red.global.v2.bf16x2.add.noftz {%bd0, %bd1}, [g], {%b0, %b1};
red.global.v2.f32.add  {%f0, %f1}, [g], {%f0, %f1};
</pre>
 <h4>
  <span class="section-number">
   9.7.12.7.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-red-async">
   Parallel Synchronization and Communication Instructions: red.async
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-red-async" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  red.async
 </p>
 <p>
  Asynchronous reduction operation on shared memory.
 </p>
 <p>
  Syntax
 </p>
 <pre>// Increment and Decrement reductions
red.async.relaxed.cluster{.ss}.completion_mechanism.op.type [a], b, [mbar];

.ss   =                 { .shared::cluster };
.op   =                 { .inc, .dec };
.type =                 { .u32 };
.completion_mechanism = { .mbarrier::complete_tx::bytes };


// MIN and MAX reductions
red.async.relaxed.cluster{.ss}.completion_mechanism.op.type [a], b, [mbar];

.ss   = { .shared::cluster };
.op   = { .min, .max };
.type = { .u32, .s32 };
.completion_mechanism = { .mbarrier::complete_tx::bytes };

// Bitwise AND, OR and XOR reductions
red.async.relaxed.cluster{.ss}.completion_mechanism.op.type [a], b, [mbar];

.ss   = { .shared::cluster };
.op   = { .and, .or, .xor };
.type = { .b32 };
.completion_mechanism = { .mbarrier::complete_tx::bytes };

// ADD reductions
red.async.relaxed.cluster{.ss}.completion_mechanism.add.type [a], b, [mbar];

.ss   = { .shared::cluster };
.type = { .u32, .s32, .u64 };
.completion_mechanism = { .mbarrier::complete_tx::bytes };
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   red.async
  </span>
  is a non-blocking instruction which initiates an asynchronous reduction operation
specified by
  <span class="pre">
   .op
  </span>
  , with the operand
  <span class="pre">
   b
  </span>
  and the value at destination shared memory location
specified by operand
  <span class="pre">
   a
  </span>
  .
 </p>
 <p>
  The
  <span class="pre">
   .inc
  </span>
  and
  <span class="pre">
   .dec
  </span>
  operations return a result in the range
  <span class="pre">
   [0..b]
  </span>
  .
 </p>
 <p>
  The modifier
  <span class="pre">
   .completion_mechanism
  </span>
  specifies that upon completion of the asynchronous operation,
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-complete-tx-operation">
   complete-tx
  </a>
  operation, with
  <span class="pre">
   completeCount
  </span>
  argument equal to amount of data stored in bytes, will be
performed on the
  mbarrier object
  specified by the operand
  <span class="pre">
   mbar
  </span>
  .
 </p>
 <p>
  Operand
  <span class="pre">
   a
  </span>
  represents destination address and must be a register or of the form
  <span class="pre">
   register
  </span>
  <span class="pre">
   +
  </span>
  <span class="pre">
   immOff
  </span>
  as described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#addresses-as-operands">
   Addresses as Operands
  </a>
  .
 </p>
 <p>
  The shared memory addresses of destination operand
  <span class="pre">
   a
  </span>
  and the
  mbarrier object
  <span class="pre">
   mbar
  </span>
  , must
meet all of the following conditions:
 </p>
 <ul class="simple">
  <li>
   <p>
    They Belong to the same CTA.
   </p>
  </li>
  <li>
   <p>
    They are different to the CTA of the executing thread but must be within the same cluster.
   </p>
  </li>
 </ul>
 <p>
  Otherwise, the behavior is undefined.
 </p>
 <p>
  The state space of the address
  <span class="pre">
   {.ss}
  </span>
  , if specified, is applicable to both operands
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   mbar
  </span>
  . If not specified, then
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#generic-addressing">
   Generic Addressing
  </a>
  is used for
both
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   mbar
  </span>
  .
 </p>
 <p>
  With
  <span class="pre">
   .shared::cluster
  </span>
  , if the addresses specified do not fall within the address window of
  <span class="pre">
   .shared::cluster
  </span>
  state space, then the behaviour is undefined.
 </p>
 <p>
  The reduce operation in
  <span class="pre">
   red.async
  </span>
  is treated as a relaxed memory operation and the
  complete_tx
  operation on the mbarrier has
  <span class="pre">
   .release
  </span>
  semantics at the .cluster scope as described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory Consistency Model
  </a>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 8.1.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>red.async.relaxed.cluster.shared::cluster.mbarrier::complete_tx::bytes.min.u32 [addr], b, [mbar_addr];
</pre>
 <h4>
  <span class="section-number">
   9.7.12.8.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-vote">
   Parallel Synchronization and Communication Instructions: vote (deprecated)
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-vote-deprecated" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  vote (deprecated)
 </p>
 <p>
  Vote across thread group.
 </p>
 <p>
  Syntax
 </p>
 <pre>vote.mode.pred  d, {!}a;
vote.ballot.b32 d, {!}a;  // 'ballot' form, returns bitmask

.mode = { .all, .any, .uni };
</pre>
 <p>
  Deprecation Note
 </p>
 <p>
  The
  <span class="pre">
   vote
  </span>
  instruction without a
  <span class="pre">
   .sync
  </span>
  qualifier is deprecated in PTX ISA version 6.0.
 </p>
 <ul class="simple">
  <li>
   <p>
    Support for this instruction with
    <span class="pre">
     .target
    </span>
    lower than
    <span class="pre">
     sm_70
    </span>
    may be removed in a future PTX
ISA version.
   </p>
  </li>
 </ul>
 <p>
  Removal Note
 </p>
 <p>
  Support for
  <span class="pre">
   vote
  </span>
  instruction without a
  <span class="pre">
   .sync
  </span>
  qualifier is removed in PTX ISA version 6.4 for
  <span class="pre">
   .target
  </span>
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  Description
 </p>
 <p>
  Performs a reduction of the source predicate across all active threads in a warp. The destination
predicate value is the same across all threads in the warp.
 </p>
 <p>
  The reduction modes are:
 </p>
 <span class="pre">
  .all
 </span>
 <p>
  <span class="pre">
   True
  </span>
  if source predicate is
  <span class="pre">
   True
  </span>
  for all active threads in warp. Negate the source
predicate to compute
  <span class="pre">
   .none
  </span>
  .
 </p>
 <span class="pre">
  .any
 </span>
 <p>
  <span class="pre">
   True
  </span>
  if source predicate is
  <span class="pre">
   True
  </span>
  for some active thread in warp. Negate the source
predicate to compute
  <span class="pre">
   .not_all
  </span>
  .
 </p>
 <span class="pre">
  .uni
 </span>
 <p>
  <span class="pre">
   True
  </span>
  if source predicate has the same value in all active threads in warp. Negating the
source predicate also computes
  <span class="pre">
   .uni
  </span>
  .
 </p>
 <p>
  In the
  ballot
  form,
  <span class="pre">
   vote.ballot.b32
  </span>
  simply copies the predicate from each thread in a warp
into the corresponding bit position of destination register
  <span class="pre">
   d
  </span>
  , where the bit position
corresponds to the threadâs lane id.
 </p>
 <p>
  An inactive thread in warp will contribute a 0 for its entry when participating in
  <span class="pre">
   vote.ballot.b32
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.2.
 </p>
 <p>
  Deprecated in PTX ISA version 6.0 in favor of
  <span class="pre">
   vote.sync
  </span>
  .
 </p>
 <p>
  Not supported in PTX ISA version 6.4 for .target
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   vote
  </span>
  requires
  <span class="pre">
   sm_12
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   vote.ballot.b32
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   vote
  </span>
  is not supported on
  <span class="pre">
   sm_70
  </span>
  or higher starting PTX ISA version 6.4.
 </p>
 <p>
  Release Notes
 </p>
 <p>
  Note that
  <span class="pre">
   vote
  </span>
  applies to threads in a single warp, not across an entire CTA.
 </p>
 <p>
  Examples
 </p>
 <pre>vote.all.pred    p,q;
vote.uni.pred    p,q;
vote.ballot.b32  r1,p;  // get 'ballot' across warp
</pre>
 <h4>
  <span class="section-number">
   9.7.12.9.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-vote-sync">
   Parallel Synchronization and Communication Instructions: vote.sync
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-vote-sync" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  vote.sync
 </p>
 <p>
  Vote across thread group.
 </p>
 <p>
  Syntax
 </p>
 <pre>vote.sync.mode.pred  d, {!}a, membermask;
vote.sync.ballot.b32 d, {!}a, membermask;  // 'ballot' form, returns bitmask

.mode = { .all, .any, .uni };
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   vote.sync
  </span>
  will cause executing thread to wait until all non-exited threads corresponding to
  <span class="pre">
   membermask
  </span>
  have executed
  <span class="pre">
   vote.sync
  </span>
  with the same qualifiers and same
  <span class="pre">
   membermask
  </span>
  value
before resuming execution.
 </p>
 <p>
  Operand
  <span class="pre">
   membermask
  </span>
  specifies a 32-bit integer which is a mask indicating threads participating
in this instruction where the bit position corresponds to threadâs
  <span class="pre">
   laneid
  </span>
  . Operand
  <span class="pre">
   a
  </span>
  is a
predicate register.
 </p>
 <p>
  In the
  mode
  form,
  <span class="pre">
   vote.sync
  </span>
  performs a reduction of the source predicate across all non-exited
threads in
  <span class="pre">
   membermask
  </span>
  . The destination operand
  <span class="pre">
   d
  </span>
  is a predicate register and its value is
the same across all threads in
  <span class="pre">
   membermask
  </span>
  .
 </p>
 <p>
  The reduction modes are:
 </p>
 <span class="pre">
  .all
 </span>
 <p>
  <span class="pre">
   True
  </span>
  if source predicate is
  <span class="pre">
   True
  </span>
  for all non-exited threads in
  <span class="pre">
   membermask
  </span>
  . Negate the
source predicate to compute
  <span class="pre">
   .none
  </span>
  .
 </p>
 <span class="pre">
  .any
 </span>
 <p>
  <span class="pre">
   True
  </span>
  if source predicate is
  <span class="pre">
   True
  </span>
  for some thread in
  <span class="pre">
   membermask
  </span>
  . Negate the source
predicate to compute
  <span class="pre">
   .not_all
  </span>
  .
 </p>
 <span class="pre">
  .uni
 </span>
 <p>
  <span class="pre">
   True
  </span>
  if source predicate has the same value in all non-exited threads in
  <span class="pre">
   membermask
  </span>
  . Negating the source predicate also computes
  <span class="pre">
   .uni
  </span>
  .
 </p>
 <p>
  In the
  ballot
  form, the destination operand
  <span class="pre">
   d
  </span>
  is a
  <span class="pre">
   .b32
  </span>
  register. In this form,
  <span class="pre">
   vote.sync.ballot.b32
  </span>
  simply copies the predicate from each thread in
  <span class="pre">
   membermask
  </span>
  into the
corresponding bit position of destination register
  <span class="pre">
   d
  </span>
  , where the bit position corresponds to the
threadâs lane id.
 </p>
 <p>
  A thread not specified in
  <span class="pre">
   membermask
  </span>
  will contribute a 0 for its entry in
  <span class="pre">
   vote.sync.ballot.b32
  </span>
  .
 </p>
 <p>
  The behavior of
  <span class="pre">
   vote.sync
  </span>
  is undefined if the executing thread is not in the
  <span class="pre">
   membermask
  </span>
  .
 </p>
 <p class="admonition-title">
  Note
 </p>
 <p>
  For .target
  <span class="pre">
   sm_6x
  </span>
  or below, all threads in
  <span class="pre">
   membermask
  </span>
  must execute the same
  <span class="pre">
   vote.sync
  </span>
  instruction in convergence, and only threads belonging to some
  <span class="pre">
   membermask
  </span>
  can be active when
the
  <span class="pre">
   vote.sync
  </span>
  instruction is executed. Otherwise, the behavior is undefined.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 6.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>vote.sync.all.pred    p,q,0xffffffff;
vote.sync.ballot.b32  r1,p,0xffffffff;  // get 'ballot' across warp
</pre>
 <h4>
  <span class="section-number">
   9.7.12.10.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-match-sync">
   Parallel Synchronization and Communication Instructions: match.sync
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-match-sync" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  match.sync
 </p>
 <p>
  Broadcast and compare a value across threads in warp.
 </p>
 <p>
  Syntax
 </p>
 <pre>match.any.sync.type  d, a, membermask;
match.all.sync.type  d[|p], a, membermask;

.type = { .b32, .b64 };
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   match.sync
  </span>
  will cause executing thread to wait until all non-exited threads from
  <span class="pre">
   membermask
  </span>
  have executed
  <span class="pre">
   match.sync
  </span>
  with the same qualifiers and same
  <span class="pre">
   membermask
  </span>
  value before resuming
execution.
 </p>
 <p>
  Operand
  <span class="pre">
   membermask
  </span>
  specifies a 32-bit integer which is a mask indicating threads participating
in this instruction where the bit position corresponds to threadâs laneid.
 </p>
 <p>
  <span class="pre">
   match.sync
  </span>
  performs broadcast and compare of operand
  <span class="pre">
   a
  </span>
  across all non-exited threads in
  <span class="pre">
   membermask
  </span>
  and sets destination
  <span class="pre">
   d
  </span>
  and optional predicate
  <span class="pre">
   p
  </span>
  based on mode.
 </p>
 <p>
  Operand
  <span class="pre">
   a
  </span>
  has instruction type and
  <span class="pre">
   d
  </span>
  has
  <span class="pre">
   .b32
  </span>
  type.
 </p>
 <p>
  Destination
  <span class="pre">
   d
  </span>
  is a 32-bit mask where bit position in mask corresponds to threadâs laneid.
 </p>
 <p>
  The matching operation modes are:
 </p>
 <span class="pre">
  .all
 </span>
 <p>
  <span class="pre">
   d
  </span>
  is set to mask corresponding to non-exited threads in
  <span class="pre">
   membermask
  </span>
  if all non-exited
threads in
  <span class="pre">
   membermask
  </span>
  have same value of operand
  <span class="pre">
   a
  </span>
  ; otherwise
  <span class="pre">
   d
  </span>
  is set
to 0. Optionally predicate
  <span class="pre">
   p
  </span>
  is set to true if all non-exited threads in
  <span class="pre">
   membermask
  </span>
  have
same value of operand
  <span class="pre">
   a
  </span>
  ; otherwise
  <span class="pre">
   p
  </span>
  is set to false. The sink symbol â_â may be used in
place of any one of the destination operands.
 </p>
 <span class="pre">
  .any
 </span>
 <p>
  <span class="pre">
   d
  </span>
  is set to mask of non-exited threads in
  <span class="pre">
   membermask
  </span>
  that have same value of operand
  <span class="pre">
   a
  </span>
  .
 </p>
 <p>
  The behavior of
  <span class="pre">
   match.sync
  </span>
  is undefined if the executing thread is not in the
  <span class="pre">
   membermask
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 6.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  Release Notes
 </p>
 <p>
  Note that
  <span class="pre">
   match.sync
  </span>
  applies to threads in a single warp, not across an entire CTA.
 </p>
 <p>
  Examples
 </p>
 <pre>match.any.sync.b32    d, a, 0xffffffff;
match.all.sync.b64    d|p, a, mask;
</pre>
 <h4>
  <span class="section-number">
   9.7.12.11.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-activemask">
   Parallel Synchronization and Communication Instructions: activemask
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-activemask" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  activemask
 </p>
 <p>
  Queries the active threads within a warp.
 </p>
 <p>
  Syntax
 </p>
 <pre>activemask.b32 d;
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   activemask
  </span>
  queries predicated-on active threads from the executing warp and sets the destination
  <span class="pre">
   d
  </span>
  with 32-bit integer mask where bit position in the mask corresponds to the threadâs
  <span class="pre">
   laneid
  </span>
  .
 </p>
 <p>
  Destination
  <span class="pre">
   d
  </span>
  is a 32-bit destination register.
 </p>
 <p>
  An active thread will contribute 1 for its entry in the result and exited or inactive or
predicated-off thread will contribute 0 for its entry in the result.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 6.2.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>activemask.b32  %r1;
</pre>
 <h4>
  <span class="section-number">
   9.7.12.12.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-redux-sync">
   Parallel Synchronization and Communication Instructions: redux.sync
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-redux-sync" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  redux.sync
 </p>
 <p>
  Perform reduction operation on the data from each predicated active thread in the thread group.
 </p>
 <p>
  Syntax
 </p>
 <pre>redux.sync.op.type dst, src, membermask;
.op   = {.add, .min, .max}
.type = {.u32, .s32}

redux.sync.op.b32 dst, src, membermask;
.op   = {.and, .or, .xor}
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   redux.sync
  </span>
  will cause the executing thread to wait until all non-exited threads corresponding to
  <span class="pre">
   membermask
  </span>
  have executed
  <span class="pre">
   redux.sync
  </span>
  with the same qualifiers and same
  <span class="pre">
   membermask
  </span>
  value
before resuming execution.
 </p>
 <p>
  Operand
  <span class="pre">
   membermask
  </span>
  specifies a 32-bit integer which is a mask indicating threads participating
in this instruction where the bit position corresponds to threadâs
  <span class="pre">
   laneid
  </span>
  .
 </p>
 <p>
  <span class="pre">
   redux.sync
  </span>
  performs a reduction operation
  <span class="pre">
   .op
  </span>
  of the 32 bit source register
  <span class="pre">
   src
  </span>
  across
all non-exited threads in the
  <span class="pre">
   membermask
  </span>
  . The result of the reduction operation is written to
the 32 bit destination register
  <span class="pre">
   dst
  </span>
  .
 </p>
 <p>
  Reduction operation can be one of the bitwise operation in
  <span class="pre">
   .and
  </span>
  ,
  <span class="pre">
   .or
  </span>
  ,
  <span class="pre">
   .xor
  </span>
  or arithmetic
operation in
  <span class="pre">
   .add
  </span>
  ,
  <span class="pre">
   .min
  </span>
  ,
  <span class="pre">
   .max
  </span>
  .
 </p>
 <p>
  For the
  <span class="pre">
   .add
  </span>
  operation result is truncated to 32 bits.
 </p>
 <p>
  The behavior of
  <span class="pre">
   redux.sync
  </span>
  is undefined if the executing thread is not in the
  <span class="pre">
   membermask
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  Release Notes
 </p>
 <p>
  Note that
  <span class="pre">
   redux.sync
  </span>
  applies to threads in a single warp, not across an entire CTA.
 </p>
 <p>
  Examples
 </p>
 <pre>.reg .b32 dst, src, init, mask;
redux.sync.add.s32 dst, src, 0xff;
redux.sync.xor.b32 dst, src, mask;
</pre>
 <h4>
  <span class="section-number">
   9.7.12.13.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-griddepcontrol">
   Parallel Synchronization and Communication Instructions: griddepcontrol
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-griddepcontrol" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  griddepcontrol
 </p>
 <p>
  Control execution of dependent grids.
 </p>
 <p>
  Syntax
 </p>
 <pre>griddepcontrol.action;

.action   = { .launch_dependents, .wait }
</pre>
 <p>
  Description
 </p>
 <p>
  The
  <span class="pre">
   griddepcontrol
  </span>
  instruction allows the dependent grids and prerequisite grids as defined by
the runtime, to control execution in the following way:
 </p>
 <p>
  <span class="pre">
   .launch_dependents
  </span>
  modifier signals that specific dependents the runtime system designated to
react to this instruction can be scheduled as soon as all other CTAs in the grid issue the same
instruction or have completed. The dependent may launch before the completion of the current
grid. There is no guarantee that the dependent will launch before the completion of the current
grid. Repeated invocations of this instruction by threads in the current CTA will have no additional
side effects past that of the first invocation.
 </p>
 <p>
  <span class="pre">
   .wait
  </span>
  modifier causes the executing thread to wait until all prerequisite grids in flight have
completed and all the memory operations from the prerequisite grids are performed and made visible
to the current grid.
 </p>
 <p class="admonition-title">
  Note
 </p>
 <p>
  If the prerequisite grid is using
  <span class="pre">
   griddepcontrol.launch_dependents
  </span>
  , then the dependent grid
must use
  <span class="pre">
   griddepcontrol.wait
  </span>
  to ensure correct functional execution.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.8.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>griddepcontrol.launch_dependents;
griddepcontrol.wait;
</pre>
 <h4>
  <span class="section-number">
   9.7.12.14.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-elect-sync">
   Parallel Synchronization and Communication Instructions: elect.sync
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-elect-sync" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  elect.sync
 </p>
 <p>
  Elect a leader thread from a set of threads.
 </p>
 <p>
  Syntax
 </p>
 <pre>elect.sync d|p, membermask;
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   elect.sync
  </span>
  elects one predicated active leader thread from among a set of threads specified by
  <span class="pre">
   membermask
  </span>
  .
  <span class="pre">
   laneid
  </span>
  of the elected thread is returned in the 32-bit destination operand
  <span class="pre">
   d
  </span>
  . The sink symbol â_â can be used for destination operand
  <span class="pre">
   d
  </span>
  . The predicate destination
  <span class="pre">
   p
  </span>
  is set to
  <span class="pre">
   True
  </span>
  for the leader thread, and
  <span class="pre">
   False
  </span>
  for all other threads.
 </p>
 <p>
  Operand
  <span class="pre">
   membermask
  </span>
  specifies a 32-bit integer indicating the set of threads from which a leader
is to be elected. The behavior is undefined if the executing thread is not in
  <span class="pre">
   membermask
  </span>
  .
 </p>
 <p>
  Election of a leader thread happens deterministically, i.e. the same leader thread is elected for
the same
  <span class="pre">
   membermask
  </span>
  every time.
 </p>
 <p>
  The mandatory
  <span class="pre">
   .sync
  </span>
  qualifier indicates that
  <span class="pre">
   elect
  </span>
  causes the executing thread to wait until
all threads in the
  <span class="pre">
   membermask
  </span>
  execute the
  <span class="pre">
   elect
  </span>
  instruction before resuming execution.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 8.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>elect.sync    %r0|%p0, 0xffffffff;
</pre>
 <h4>
  <span class="section-number">
   9.7.12.15.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier">
   Parallel Synchronization and Communication Instructions: mbarrier
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  <span class="pre">
   mbarrier
  </span>
  is a barrier created in shared memory that supports :
 </p>
 <ul class="simple">
  <li>
   <p>
    Synchronizing any subset of threads within a CTA
   </p>
  </li>
  <li>
   <p>
    One-way synchronization of threads across CTAs of a cluster. As noted in
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-smem">
     mbarrier support with
shared memory
    </a>
    , threads can
perform only
    arrive
    operations but not
    *_wait
    on an mbarrier located in
    <span class="pre">
     shared::cluster
    </span>
    space.
   </p>
  </li>
  <li>
   <p>
    Waiting for completion of asynchronous memory operations initiated by a thread and making them
visible to other threads.
   </p>
  </li>
 </ul>
 <p>
  An
  mbarrier object
  is an opaque object in memory which can be initialized and invalidated using :
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     mbarrier.init
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     mbarrier.inval
    </span>
   </p>
  </li>
 </ul>
 <p>
  Operations supported on
  mbarrier object
  s are :
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     mbarrier.expect_tx
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     mbarrier.complete_tx
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     mbarrier.arrive
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     mbarrier.arrive_drop
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     mbarrier.test_wait
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     mbarrier.try_wait
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     mbarrier.pending_count
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     cp.async.mbarrier.arrive
    </span>
   </p>
  </li>
 </ul>
 <p>
  Performing any
  mbarrier
  operation except
  <span class="pre">
   mbarrier.init
  </span>
  on an uninitialized
  mbarrier object
  results in undefined behavior.
 </p>
 <p>
  Unlike
  <span class="pre">
   bar{.cta}
  </span>
  /
  <span class="pre">
   barrier{.cta}
  </span>
  instructions which can access a limited number of barriers
per CTA,
  mbarrier objects
  are used defined and are only limited by the total shared memory size
available.
 </p>
 <p>
  mbarrier
  operations enable threads to perform useful work after the arrival at the
  mbarrier
  and
before waiting for the
  mbarrier
  to complete.
 </p>
 <h5>
  <span class="section-number">
   9.7.12.15.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-size-alignment">
   Size and alignment of mbarrier object
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#size-and-alignment-of-mbarrier-object" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  An mbarrier object is an opaque object with the following type and alignment requirements :
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Type
    </p>
   </th>
   <th class="head">
    <p>
     Alignment (bytes)
    </p>
   </th>
   <th class="head">
    <p>
     Memory space
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .b64
     </span>
    </p>
   </td>
   <td>
    <p>
     8
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .shared
     </span>
    </p>
   </td>
  </tr>
 </table>
 <h5>
  <span class="section-number">
   9.7.12.15.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-contents">
   Contents of the mbarrier object
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#contents-of-the-mbarrier-object" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  An opaque
  mbarrier object
  keeps track of the following information :
 </p>
 <ul class="simple">
  <li>
   <p>
    Current phase of the
    mbarrier object
   </p>
  </li>
  <li>
   <p>
    Count of pending arrivals for the current phase of the
    mbarrier object
   </p>
  </li>
  <li>
   <p>
    Count of expected arrivals for the next phase of the
    mbarrier object
   </p>
  </li>
  <li>
   <p>
    Count of pending asynchronous memory operations (or transactions) tracked by the current phase of
the
    mbarrier object
    . This is also referred to as
    tx-count
    .
   </p>
  </li>
 </ul>
 <p>
  An
  mbarrier object
  progresses through a sequence of phases where each phase is defined by threads
performing an expected number of
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-arrive-on">
   arrive-on
  </a>
  operations.
 </p>
 <p>
  The valid range of each of the counts is as shown below:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Count name
    </p>
   </th>
   <th class="head">
    <p>
     Minimum value
    </p>
   </th>
   <th class="head">
    <p>
     Maximum value
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     Expected arrival count
    </p>
   </td>
   <td>
    <p>
     1
    </p>
   </td>
   <td>
    <p>
     2
     20
     - 1
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     Pending arrival count
    </p>
   </td>
   <td>
    <p>
     0
    </p>
   </td>
   <td>
    <p>
     2
     20
     - 1
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     tx-count
    </p>
   </td>
   <td>
    <p>
     -(2
     20
     - 1)
    </p>
   </td>
   <td>
    <p>
     2
     20
     - 1
    </p>
   </td>
  </tr>
 </table>
 <h5>
  <span class="section-number">
   9.7.12.15.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-lifecycle">
   Lifecycle of the mbarrier object
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#lifecycle-of-the-mbarrier-object" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  The
  mbarrier object
  must be initialized prior to use.
 </p>
 <p>
  An
  mbarrier object
  is used to synchronize threads and asynchronous memory operations.
 </p>
 <p>
  An
  mbarrier object
  may be used to perform a sequence of such synchronizations.
 </p>
 <p>
  An
  mbarrier object
  must be invalidated to repurpose its memory.
 </p>
 <h5>
  <span class="section-number">
   9.7.12.15.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-phase">
   Phase of the mbarrier object
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#phase-of-the-mbarrier-object" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  The phase of an
  mbarrier object
  is the number of times the
  mbarrier object
  has been used to
synchronize threads and
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async">
   cp.async
  </a>
  operations. In each phase {0, 1, 2, â¦}, threads perform in program order :
 </p>
 <ul class="simple">
  <li>
   <p>
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-arrive-on">
     arrive-on
    </a>
    operations to complete the current phase and
   </p>
  </li>
  <li>
   <p>
    test_wait
    /
    try_wait
    operations to check for the completion of the current phase.
   </p>
  </li>
 </ul>
 <p>
  An
  mbarrier object
  is automatically reinitialized upon completion of the current phase for
immediate use in the next phase. The current phase is incomplete and all prior phases are complete.
 </p>
 <p>
  For each phase of the mbarrier object, at least one
  test_wait
  or
  try_wait
  operation must be
performed which returns
  <span class="pre">
   True
  </span>
  for
  <span class="pre">
   waitComplete
  </span>
  before an
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-arrive-on">
   arrive-on
  </a>
  operation
in the subsequent phase.
 </p>
 <h5>
  <span class="section-number">
   9.7.12.15.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-tracking-async-operations">
   Tracking asynchronous operations by the mbarrier object
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tracking-asynchronous-operations-by-the-mbarrier-object" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  Starting with the Hopper architecture (
  <span class="pre">
   sm_9x
  </span>
  ),
  mbarrier object
  supports a new count, called
  tx-count
  , which is used for tracking the completion of asynchronous memory operations or
transactions.
  tx-count
  tracks the number of asynchronous transactions, in units specified by the
asynchronous memory operation, that are outstanding and yet to be complete.
 </p>
 <p>
  The
  tx-count
  of an
  mbarrier object
  must be set to the total amount of asynchronous memory
operations, in units as specified by the asynchronous operations, to be tracked by the current
phase. Upon completion of each of the asynchronous operations, the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-complete-tx-operation">
   complete-tx
  </a>
  operation will be performed on the
  mbarrier object
  and thus progress the mbarrier towards the
completion of the current phase.
 </p>
 <h6>
  <span class="section-number">
   9.7.12.15.5.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-expect-tx-operation">
   expect-tx operation
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#expect-tx-operation" title="Permalink to this headline">
   ï
  </a>
 </h6>
 <p>
  The
  expect-tx
  operation, with an
  <span class="pre">
   expectCount
  </span>
  argument, increases the
  tx-count
  of an
  mbarrier object
  by the value specified by
  <span class="pre">
   expectCount
  </span>
  . This makes the current phase of the
  mbarrier object
  to expect and track the completion of additional asynchronous transactions.
 </p>
 <h6>
  <span class="section-number">
   9.7.12.15.5.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-complete-tx-operation">
   complete-tx operation
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#complete-tx-operation" title="Permalink to this headline">
   ï
  </a>
 </h6>
 <p>
  The
  complete-tx
  operation, with an
  <span class="pre">
   completeCount
  </span>
  argument, on an
  mbarrier object
  consists of the following:
 </p>
 mbarrier signaling
 <p>
  Signals the completion of asynchronous transactions that were tracked by the current phase. As a
result of this,
  tx-count
  is decremented by
  <span class="pre">
   completeCount
  </span>
  .
 </p>
 mbarrier potentially completing the current phase
 <p>
  If the current phase has been completed then the mbarrier transitions to the next phase. Refer to
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-phase-completion">
   Phase Completion of the mbarrier object
  </a>
  for details on phase completion requirements and phase transition process.
 </p>
 <h5>
  <span class="section-number">
   9.7.12.15.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-phase-completion">
   Phase Completion of the mbarrier object
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#phase-completion-of-the-mbarrier-object" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  The requirements for completion of the current phase are described below. Upon completion of the
current phase, the phase transitions to the subsequent phase as described below.
 </p>
 Current phase completion requirements
 <p>
  An
  mbarrier object
  completes the current phase when all of the following conditions are met:
 </p>
 <ul class="simple">
  <li>
   <p>
    The count of the pending arrivals has reached zero.
   </p>
  </li>
  <li>
   <p>
    The
    tx-count
    has reached zero.
   </p>
  </li>
 </ul>
 Phase transition
 <p>
  When an
  mbarrier
  object completes the current phase, the following actions are performed
atomically:
 </p>
 <ul class="simple">
  <li>
   <p>
    The
    mbarrier object
    transitions to the next phase.
   </p>
  </li>
  <li>
   <p>
    The pending arrival count is reinitialized to the expected arrival count.
   </p>
  </li>
 </ul>
 <h5>
  <span class="section-number">
   9.7.12.15.7.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-arrive-on">
   Arrive-on operation on mbarrier object
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#arrive-on-operation-on-mbarrier-object" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  An
  arrive-on
  operation, with an optional
  count
  argument, on an
  mbarrier object
  consists of the
following 2 steps :
 </p>
 <ul>
  <li>
   <p>
    mbarrier signalling:
   </p>
   <p>
    Signals the arrival of the executing thread OR completion of the
    <span class="pre">
     cp.async
    </span>
    instruction which
signals the arrive-on operation initiated by the executing thread on the
    mbarrier object
    . As a
result of this, the pending arrival count is decremented by
    count
    . If the
    count
    argument is
not specified, then it defaults to 1.
   </p>
  </li>
  <li>
   <p>
    mbarrier potentially completing the current phase:
   </p>
   <p>
    If the current phase has been completed then the mbarrier transitions to the next phase. Refer to
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-phase-completion">
     Phase Completion of the mbarrier object
    </a>
    for details on phase completion requirements and phase transition process.
   </p>
  </li>
 </ul>
 <h5>
  <span class="section-number">
   9.7.12.15.8.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-smem">
   mbarrier support with shared memory
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mbarrier-support-with-shared-memory" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  The following table summarizes the support of various mbarrier operations on
  mbarrier objects
  located at different shared memory locations:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     mbarrier operations
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      .shared::cta
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      .shared::cluster
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      mbarrier.arrive
     </span>
    </p>
   </td>
   <td>
    <p>
     Supported
    </p>
   </td>
   <td>
    <p>
     Supported, cannot return result
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      mbarrier.expect_tx
     </span>
    </p>
   </td>
   <td>
    <p>
     Supported
    </p>
   </td>
   <td>
    <p>
     Supported
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      mbarrier.complete_tx
     </span>
    </p>
   </td>
   <td>
    <p>
     Supported
    </p>
   </td>
   <td>
    <p>
     Supported
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     Other mbarrier operations
    </p>
   </td>
   <td>
    <p>
     Supported
    </p>
   </td>
   <td>
    <p>
     Not supported
    </p>
   </td>
  </tr>
 </table>
 <h5>
  <span class="section-number">
   9.7.12.15.9.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-init">
   Parallel Synchronization and Communication Instructions: mbarrier.init
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-init" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  mbarrier.init
 </p>
 <p>
  Initialize the
  mbarrier object
  .
 </p>
 <p>
  Syntax
 </p>
 <pre>mbarrier.init{.shared{::cta}}.b64 [addr], count;
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   mbarrier.init
  </span>
  initializes the
  mbarrier object
  at the location specified by the address operand
  <span class="pre">
   addr
  </span>
  with the unsigned 32-bit integer
  <span class="pre">
   count
  </span>
  . The value of operand count must be in the range
as specified in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-contents">
   Contents of the mbarrier object
  </a>
  .
 </p>
 <p>
  Initialization of the
  mbarrier object
  involves :
 </p>
 <ul class="simple">
  <li>
   <p>
    Initializing the current phase to 0.
   </p>
  </li>
  <li>
   <p>
    Initializing the expected arrival count to
    <span class="pre">
     count
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Initializing the pending arrival count to
    <span class="pre">
     count
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Initializing the
    tx-count
    to 0.
   </p>
  </li>
 </ul>
 <p>
  If no state space is specified then
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#generic-addressing">
   Generic Addressing
  </a>
  is
used. If the address specified by
  <span class="pre">
   addr
  </span>
  does not fall within the address window of
  <span class="pre">
   .shared::cta
  </span>
  state space then the behavior is undefined.
 </p>
 <p>
  Supported addressing modes for operand
  <span class="pre">
   addr
  </span>
  is as described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#addresses-as-operands">
   Addresses as Operands
  </a>
  . Alignment for operand
  <span class="pre">
   addr
  </span>
  is as described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-size-alignment">
   Size
and alignment of mbarrier object
  </a>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.0.
 </p>
 <p>
  Support for sub-qualifier
  <span class="pre">
   ::cta
  </span>
  on
  <span class="pre">
   .shared
  </span>
  introduced in PTX ISA version 7.8.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>.shared .b64 shMem, shMem2;
.reg    .b64 addr;
.reg    .b32 %r1;

cvta.shared.u64          addr, shMem2;
mbarrier.init.b64        [addr],   %r1;
bar.cta.sync             0;
// ... other mbarrier operations on addr

mbarrier.init.shared::cta.b64 [shMem], 12;
bar.sync                 0;
// ... other mbarrier operations on shMem
</pre>
 <h5>
  <span class="section-number">
   9.7.12.15.10.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-inval">
   Parallel Synchronization and Communication Instructions: mbarrier.inval
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-inval" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  mbarrier.inval
 </p>
 <p>
  Invalidates the
  mbarrier object
  .
 </p>
 <p>
  Syntax
 </p>
 <pre>mbarrier.inval{.shared{::cta}}.b64 [addr];
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   mbarrier.inval
  </span>
  invalidates the
  mbarrier object
  at the location specified by the address
operand
  <span class="pre">
   addr
  </span>
  .
 </p>
 <p>
  An
  mbarrier object
  must be invalidated before using its memory location for any other purpose.
 </p>
 <p>
  Performing any
  mbarrier
  operation except
  <span class="pre">
   mbarrier.init
  </span>
  on an invalidated mbarrier object
results in undefined behaviour.
 </p>
 <p>
  If no state space is specified then
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#generic-addressing">
   Generic Addressing
  </a>
  is
used. If the address specified by
  <span class="pre">
   addr
  </span>
  does not fall within the address window of
  <span class="pre">
   .shared::cta
  </span>
  state space then the behavior is undefined.
 </p>
 <p>
  Supported addressing modes for operand
  <span class="pre">
   addr
  </span>
  is as described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#addresses-as-operands">
   Addresses as Operands
  </a>
  . Alignment for operand
  <span class="pre">
   addr
  </span>
  is as described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-size-alignment">
   Size
and alignment of mbarrier object
  </a>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.0.
 </p>
 <p>
  Support for sub-qualifier
  <span class="pre">
   ::cta
  </span>
  on
  <span class="pre">
   .shared
  </span>
  introduced in PTX ISA version 7.8.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>.shared .b64 shmem;
.reg    .b64 addr;
.reg    .b32 %r1;
.reg    .pred t0;

// Example 1 :
bar.sync                      0;
@t0 mbarrier.init.b64     [addr], %r1;
// ... other mbarrier operations on addr
bar.sync                      0;
@t0 mbarrier.inval.b64    [addr];


// Example 2 :
bar.cta.sync                  0;
mbarrier.init.shared.b64           [shmem], 12;
// ... other mbarrier operations on shmem
bar.cta.sync                  0;
@t0 mbarrier.inval.shared.b64      [shmem];

// shmem can be reused here for unrelated use :
bar.cta.sync                  0;
st.shared.b64                      [shmem], ...;

// shmem can be re-initialized as mbarrier object :
bar.cta.sync                  0;
@t0 mbarrier.init.shared.b64       [shmem], 24;
// ... other mbarrier operations on shmem
bar.cta.sync                  0;
@t0 mbarrier.inval.shared::cta.b64 [shmem];
</pre>
 <h5>
  <span class="section-number">
   9.7.12.15.11.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-expect-tx">
   Parallel Synchronization and Communication Instructions: mbarrier.expect_tx
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-expect-tx" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  mbarrier.expect_tx
 </p>
 <p>
  Perfoms
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-expect-tx-operation">
   expect-tx
  </a>
  operation on the
  mbarrier object
  .
 </p>
 <p>
  Syntax
 </p>
 <pre>mbarrier.expect_tx{.sem}{.scope}{.space}.b64 [addr], txCount;

.sem   = { .relaxed }
.scope = { .cta, .cluster }
.space = { .shared{::cta}, .shared::cluster }
</pre>
 <p>
  Description
 </p>
 <p>
  A thread executing
  <span class="pre">
   mbarrier.expect_tx
  </span>
  performs an
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-expect-tx-operation">
   expect-tx
  </a>
  operation on the
  mbarrier object
  at the location specified by the address operand
  <span class="pre">
   addr
  </span>
  . The
32-bit unsigned integer operand
  <span class="pre">
   txCount
  </span>
  specifies the
  <span class="pre">
   expectCount
  </span>
  argument to the
  expect-tx
  operation.
 </p>
 <p>
  If no state space is specified then
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#generic-addressing">
   Generic Addressing
  </a>
  is
used. If the address specified by
  <span class="pre">
   addr
  </span>
  does not fall within the address window of
  <span class="pre">
   .shared::cta
  </span>
  or
  <span class="pre">
   .shared::cluster
  </span>
  state space then the behavior is undefined.
 </p>
 <p>
  Supported addressing modes for operand
  <span class="pre">
   addr
  </span>
  are as described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#addresses-as-operands">
   Addresses as Operands
  </a>
  . Alignment for operand
  <span class="pre">
   addr
  </span>
  is as described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-size-alignment">
   Size
and alignment of mbarrier object
  </a>
  .
 </p>
 <p>
  This operation does not provide any memory ordering semantics and thus is a
  relaxed
  operation.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 8.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>mbarrier.expect_tx.b64                       [addr], 32;
mbarrier.expect_tx.relaxed.cta.shared.b64    [mbarObj1], 512;
mbarrier.expect_tx.relaxed.cta.shared.b64    [mbarObj2], 512;
</pre>
 <h5>
  <span class="section-number">
   9.7.12.15.12.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-complete-tx">
   Parallel Synchronization and Communication Instructions: mbarrier.complete_tx
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-complete-tx" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  mbarrier.complete_tx
 </p>
 <p>
  Perfoms
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-complete-tx-operation">
   complete-tx
  </a>
  operation on the
  mbarrier object
  .
 </p>
 <p>
  Syntax
 </p>
 <pre>mbarrier.complete_tx{.sem}{.scope}{.space}.b64 [addr], txCount;

.sem   = { .relaxed }
.scope = { .cta, .cluster }
.space = { .shared{::cta}, .shared::cluster }
</pre>
 <p>
  Description
 </p>
 <p>
  A thread executing
  <span class="pre">
   mbarrier.complete_tx
  </span>
  performs a
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-complete-tx-operation">
   complete-tx
  </a>
  operation on the
  mbarrier object
  at the location specified by the address operand
  <span class="pre">
   addr
  </span>
  . The
32-bit unsigned integer operand
  <span class="pre">
   txCount
  </span>
  specifies the
  <span class="pre">
   completeCount
  </span>
  argument to the
  complete-tx
  operation.
 </p>
 <p>
  <span class="pre">
   mbarrier.complete_tx
  </span>
  does not involve any asynchronous memory operations and only simulates the
completion of an asynchronous memory operation and its side effect of signaling to the
  mbarrier
object
  .
 </p>
 <p>
  If no state space is specified then
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#generic-addressing">
   Generic Addressing
  </a>
  is
used. If the address specified by
  <span class="pre">
   addr
  </span>
  does not fall within the address window of
  <span class="pre">
   .shared::cta
  </span>
  or
  <span class="pre">
   .shared::cluster
  </span>
  state space then the behavior is undefined.
 </p>
 <p>
  Supported addressing modes for operand
  <span class="pre">
   addr
  </span>
  are as described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#addresses-as-operands">
   Addresses as Operands
  </a>
  . Alignment for operand
  <span class="pre">
   addr
  </span>
  is as described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-size-alignment">
   Size
and alignment of mbarrier object
  </a>
  .
 </p>
 <p>
  This operation does not provide any memory ordering semantics and thus is a
  relaxed
  operation.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 8.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>mbarrier.complete_tx.b64             [addr],     32;
mbarrier.complete_tx.shared.b64      [mbarObj1], 512;
mbarrier.complete_tx.relaxed.cta.b64 [addr2],    32;
</pre>
 <h5>
  <span class="section-number">
   9.7.12.15.13.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-arrive">
   Parallel Synchronization and Communication Instructions: mbarrier.arrive
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-arrive" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  mbarrier.arrive
 </p>
 <p>
  Performs
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-arrive-on">
   arrive-on operation
  </a>
  on the
  mbarrier object
  .
 </p>
 <p>
  Syntax
 </p>
 <pre>mbarrier.arrive{.sem}{.scope}{.shared{::cta}}.b64           state, [addr]{, count};
mbarrier.arrive{.sem}{.scope}{.shared::cluster}.b64         _, [addr] {,count}
mbarrier.arrive.expect_tx{.sem}{.scope}{.shared{::cta}}.b64 state, [addr], txCount;
mbarrier.arrive.expect_tx{.sem}{.scope}{.shared::cluster}.b64   _, [addr], txCount;
mbarrier.arrive.noComplete{.sem}{.cta}{.shared{::cta}}.b64  state, [addr], count;

.sem   = { .release }
.scope = { .cta, .cluster }
</pre>
 <p>
  Description
 </p>
 <p>
  A thread executing
  <span class="pre">
   mbarrier.arrive
  </span>
  performs an
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-arrive-on">
   arrive-on
  </a>
  operation
on the
  mbarrier object
  at the location specified by the address operand
  <span class="pre">
   addr
  </span>
  . The 32-bit
unsigned integer operand
  <span class="pre">
   count
  </span>
  specifies the
  count
  argument to the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-arrive-on">
   arrive-on
  </a>
  operation.
 </p>
 <p>
  If no state space is specified then
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#generic-addressing">
   Generic Addressing
  </a>
  is
used. If the address specified by
  <span class="pre">
   addr
  </span>
  does not fall within the address window of
  <span class="pre">
   .shared::cta
  </span>
  state space then the behavior is undefined.
 </p>
 <p>
  Supported addressing modes for operand
  <span class="pre">
   addr
  </span>
  is as described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#addresses-as-operands">
   Addresses as Operands
  </a>
  . Alignment for operand
  <span class="pre">
   addr
  </span>
  is as described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-size-alignment">
   Size
and alignment of mbarrier object
  </a>
  .
 </p>
 <p>
  The optional qualifier
  <span class="pre">
   .expect_tx
  </span>
  specifies that an
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-expect-tx-operation">
   expect-tx
  </a>
  operation is performed prior to the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-arrive-on">
   arrive-on
  </a>
  operation. The 32-bit unsigned integer operand
  <span class="pre">
   txCount
  </span>
  specifies the
  expectCount
  argument to
the
  expect-tx
  operation. When both qualifiers
  <span class="pre">
   .arrive
  </span>
  and
  <span class="pre">
   .expect_tx
  </span>
  are specified, then
the count argument of the
  arrive-on
  operation is assumed to be 1.
 </p>
 <p>
  A
  <span class="pre">
   mbarrier.arrive
  </span>
  operation with
  <span class="pre">
   .noComplete
  </span>
  qualifier must not cause the
  <span class="pre">
   mbarrier
  </span>
  to
complete its current phase, otherwise the behavior is undefined.
 </p>
 <p>
  The value of the operand
  <span class="pre">
   count
  </span>
  must be in the range as specified in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-contents">
   Contents of the mbarrier
object
  </a>
  .
 </p>
 <p>
  Note: for
  <span class="pre">
   sm_8x
  </span>
  , when the argument
  <span class="pre">
   count
  </span>
  is specified, the modifier
  <span class="pre">
   .noComplete
  </span>
  is
required.
 </p>
 <p>
  <span class="pre">
   mbarrier.arrive
  </span>
  operation on an
  mbarrier object
  located in
  <span class="pre">
   .shared::cta
  </span>
  returns an opaque
64-bit register capturing the phase of the
  mbarrier object
  prior to the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-arrive-on">
   arrive-on operation
  </a>
  in the
destination operand
  <span class="pre">
   state.
  </span>
  Contents of the
  <span class="pre">
   state
  </span>
  operand are implementation
specific. Optionally, sink symbol
  <span class="pre">
   '_'
  </span>
  can be used for the
  <span class="pre">
   state
  </span>
  argument.
 </p>
 <p>
  <span class="pre">
   mbarrier.arrive
  </span>
  operation on an
  mbarrier object
  located in
  <span class="pre">
   .shared::cluster
  </span>
  but not in
  <span class="pre">
   .shared::cta
  </span>
  cannot return a value. Sink symbol â_â is mandatory for the destination operand for
such cases.
 </p>
 <p>
  The optional
  <span class="pre">
   .sem
  </span>
  qualifier specifies a memory synchronizing effect as described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory
Consistency Model
  </a>
  . If the
  <span class="pre">
   .sem
  </span>
  qualifier is absent,
  <span class="pre">
   .release
  </span>
  is assumed by default.
 </p>
 <p>
  The optional
  <span class="pre">
   .scope
  </span>
  qualifier indicates the set of threads that directly observe the memory
synchronizing effect of this operation, as described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory Consistency Model
  </a>
  . If the
  <span class="pre">
   .scope
  </span>
  qualifier is not specified then it
defaults to
  <span class="pre">
   .cta
  </span>
  . In contrast, the
  <span class="pre">
   .shared::&lt;scope&gt;
  </span>
  indicates the state space where the
mbarrier resides.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.0.
 </p>
 <p>
  Support for sink symbol â_â as the destination operand is introduced in PTX ISA version 7.1.
 </p>
 <p>
  Support for sub-qualifier
  <span class="pre">
   ::cta
  </span>
  on
  <span class="pre">
   .shared
  </span>
  introduced in PTX ISA version 7.8.
 </p>
 <p>
  Support for
  <span class="pre">
   count
  </span>
  argument without the modifier
  <span class="pre">
   .noComplete
  </span>
  introduced in PTX ISA version
7.8.
 </p>
 <p>
  Support for sub-qualifier
  <span class="pre">
   ::cluster
  </span>
  introduced in PTX ISA version 8.0.
 </p>
 <p>
  Support for qualifier
  <span class="pre">
   .expect_tx
  </span>
  is introduced in PTX ISA version 8.0.
 </p>
 <p>
  Support for
  <span class="pre">
   .scope
  </span>
  and
  <span class="pre">
   .sem
  </span>
  qualifiers introduced in PTX ISA version 8.0
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  Support for
  <span class="pre">
   count
  </span>
  argument without the modifier
  <span class="pre">
   .noComplete
  </span>
  requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Qualifier
  <span class="pre">
   .expect_tx
  </span>
  requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Sub-qualifier
  <span class="pre">
   ::cluster
  </span>
  requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Support for
  <span class="pre">
   .cluster
  </span>
  scope requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>.reg .b32 cnt, remoteAddr32, remoteCTAId, addr32;
.reg .b64 %r&lt;3&gt;, addr, remoteAddr64;
.shared .b64 shMem, shMem2;

cvta.shared.u64            addr, shMem2;
mov.b32                    addr32, shMem2;
mapa.shared::cluster.u32   remoteAddr32, addr32, remoteCTAId;
mapa.u64                   remoteAddr64, addr,   remoteCTAId;

cvta.shared.u64          addr, shMem2;

mbarrier.arrive.shared.b64                       %r0, [shMem];
mbarrier.arrive.shared::cta.b64                  %r0, [shMem2];
mbarrier.arrive.release.cta.shared::cluster.b64  _, [remoteAddr32];
mbarrier.arrive.release.cluster.b64              _, [remoteAddr64], cnt;
mbarrier.arrive.expect_tx.release.cluster.b64    _, [remoteAddr64], tx_count;
mbarrier.arrive.noComplete.b64                   %r1, [addr], 2;
mbarrier.arrive.b64                              %r2, [addr], cnt;
</pre>
 <h5>
  <span class="section-number">
   9.7.12.15.14.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-arrive-drop">
   Parallel Synchronization and Communication Instructions: mbarrier.arrive_drop
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-arrive-drop" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  mbarrier.arrive_drop
 </p>
 <p>
  Decrements the expected count of the
  mbarrier object
  and performs
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-arrive-on">
   arrive-on operation
  </a>
  .
 </p>
 <p>
  Syntax
 </p>
 <pre>mbarrier.arrive_drop{.sem}{.scope}{.shared{::cta}}.b64 state,           [addr]{, count};
mbarrier.arrive_drop{.sem}{.scope}{.shared::cluster}.b64           _,   [addr] {,count};
mbarrier.arrive_drop.expect_tx{.shared{::cta}}{.sem}{.scope}.b64 state, [addr], tx_count;
mbarrier.arrive_drop.expect_tx{.shared::cluster}{.sem}{.scope}.b64   _, [addr], tx_count;
mbarrier.arrive_drop.noComplete{.sem}{.cta}{.shared{::cta}}.b64 state,  [addr], count;

.sem   = { .release }
.scope = { .cta, .cluster }
</pre>
 <p>
  Description
 </p>
 <p>
  A thread executing
  <span class="pre">
   mbarrier.arrive_drop
  </span>
  on the
  mbarrier object
  at the location specified by
the address operand
  <span class="pre">
   addr
  </span>
  performs the following steps:
 </p>
 <ul class="simple">
  <li>
   <p>
    Decrements the expected arrival count of the
    mbarrier object
    by the value specified by the
32-bit integer operand
    <span class="pre">
     count
    </span>
    . If
    <span class="pre">
     count
    </span>
    operand is not specified, it defaults to 1.
   </p>
  </li>
  <li>
   <p>
    Performs an
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-arrive-on">
     arrive-on operation
    </a>
    on the
    mbarrier object
    . The operand
    <span class="pre">
     count
    </span>
    specifies the
    count
    argument to the
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-arrive-on">
     arrive-on
operation
    </a>
    .
   </p>
  </li>
 </ul>
 <p>
  The decrement done in the expected arrivals count of the
  mbarrier object
  will be for all the
subsequent phases of the
  mbarrier object
  .
 </p>
 <p>
  If no state space is specified then
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#generic-addressing">
   Generic Addressing
  </a>
  is
used. If the address specified by
  <span class="pre">
   addr
  </span>
  does not fall within the address window of
  <span class="pre">
   .shared::cta
  </span>
  or
  <span class="pre">
   .shared::cluster
  </span>
  state space then the behavior is undefined.
 </p>
 <p>
  Supported addressing modes for operand
  <span class="pre">
   addr
  </span>
  is as described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#addresses-as-operands">
   Addresses as Operands
  </a>
  . Alignment for operand
  <span class="pre">
   addr
  </span>
  is as described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-size-alignment">
   Size
and alignment of mbarrier object
  </a>
  .
 </p>
 <p>
  The optional qualifier
  <span class="pre">
   .expect_tx
  </span>
  specifies that an
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-expect-tx-operation">
   expect-tx
  </a>
  operation is performed prior to the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-arrive-on">
   arrive-on
  </a>
  operation. The 32-bit unsigned integer operand
  <span class="pre">
   txCount
  </span>
  specifies the
  expectCount
  argument to
the
  expect-tx
  operation. When both qualifiers
  <span class="pre">
   .arrive
  </span>
  and
  <span class="pre">
   .expect_tx
  </span>
  are specified, then
the count argument of the
  arrive-on
  operation is assumed to be 1.
 </p>
 <p>
  <span class="pre">
   mbarrier.arrive_drop
  </span>
  operation forms the
  release
  pattern as described in the Memory
Consistency Model and synchronizes with the
  acquire
  patterns.
 </p>
 <p>
  The optional
  <span class="pre">
   .scope
  </span>
  qualifier indicates the set of threads that an
  <span class="pre">
   mbarrier.arrive_drop
  </span>
  instruction can directly synchronize. If the
  <span class="pre">
   .scope
  </span>
  qualifier is not specified then it defaults
to
  <span class="pre">
   .cta
  </span>
  . In contrast, the
  <span class="pre">
   .shared::&lt;scope&gt;
  </span>
  indicates the state space where the mbarrier
resides.
 </p>
 <p>
  A
  <span class="pre">
   mbarrier.arrive_drop
  </span>
  with
  <span class="pre">
   .noComplete
  </span>
  qualifier must not complete the
  <span class="pre">
   mbarrier,
  </span>
  otherwise the behavior is undefined.
 </p>
 <p>
  The value of the operand
  <span class="pre">
   count
  </span>
  must be in the range as specified in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-contents">
   Contents of the mbarrier
object
  </a>
  .
 </p>
 <p>
  Note: for
  <span class="pre">
   sm_8x
  </span>
  , when the argument
  <span class="pre">
   count
  </span>
  is specified, the modifier
  <span class="pre">
   .noComplete
  </span>
  is
required.
 </p>
 <p>
  A thread that wants to either exit or opt out of participating in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-arrive-on">
   arrive-on operation
  </a>
  can use
  <span class="pre">
   mbarrier.arrive_drop
  </span>
  to drop itself from the
  <span class="pre">
   mbarrier
  </span>
  .
 </p>
 <p>
  <span class="pre">
   mbarrier.arrive_drop
  </span>
  operation on an
  mbarrier object
  located in
  <span class="pre">
   .shared::cta
  </span>
  returns an
opaque 64-bit register capturing the phase of the
  mbarrier object
  prior to the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-arrive-on">
   arrive-on
operation
  </a>
  in the destination operand
  <span class="pre">
   state
  </span>
  . Contents of the returned state are implementation
specific. Optionally, sink symbol
  <span class="pre">
   '_'
  </span>
  can be used for the
  <span class="pre">
   state
  </span>
  argument.
 </p>
 <p>
  <span class="pre">
   mbarrier.arrive_drop
  </span>
  operation on an
  mbarrier
  object located in
  <span class="pre">
   .shared::cluster
  </span>
  but not
in
  <span class="pre">
   .shared::cta
  </span>
  cannot return a value. Sink symbol â_â is mandatory for the destination operand
for such cases.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.0.
 </p>
 <p>
  Support for sub-qualifier
  <span class="pre">
   ::cta
  </span>
  on
  <span class="pre">
   .shared
  </span>
  introduced in PTX ISA version 7.8.
 </p>
 <p>
  Support for
  <span class="pre">
   count
  </span>
  argument without the modifier
  <span class="pre">
   .noComplete
  </span>
  introduced in PTX ISA version
7.8.
 </p>
 <p>
  Support for qualifier
  <span class="pre">
   .expect_tx
  </span>
  is introduced in PTX ISA version 8.0.
 </p>
 <p>
  Support for sub-qualifier
  <span class="pre">
   ::cluster
  </span>
  introduced in PTX ISA version 8.0.
 </p>
 <p>
  Support for
  <span class="pre">
   .scope
  </span>
  and
  <span class="pre">
   .sem
  </span>
  qualifiers introduced in PTX ISA version 8.0
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  Support for
  <span class="pre">
   count
  </span>
  argument without the modifier
  <span class="pre">
   .noComplete
  </span>
  requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Qualifier
  <span class="pre">
   .expect_tx
  </span>
  requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Sub-qualifier
  <span class="pre">
   ::cluster
  </span>
  requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Support for
  <span class="pre">
   .cluster
  </span>
  scope requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>.reg .b32 cnt;
.reg .b64 %r1;
.shared .b64 shMem;

// Example 1
@p mbarrier.arrive_drop.shared.b64 _, [shMem];
@p exit;
@p2 mbarrier.arrive_drop.noComplete.shared.b64 _, [shMem], %a;
@p2 exit;
..
@!p mbarrier.arrive.shared.b64   %r1, [shMem];
@!p mbarrier.test_wait.shared.b64  q, [shMem], %r1;

// Example 2
mbarrier.arrive_drop.shared::cluster.b64 _, [addr];
mbarrier.arrive_drop.shared::cta.release.cluster.b64     _, [addr], cnt;

// Example 3
mbarrier.arrive_drop.expect_tx.shared::cta.release.cta.b64 state, [addr], tx_count;
</pre>
 <h5>
  <span class="section-number">
   9.7.12.15.15.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-cp-async-mbarrier-arrive">
   Parallel Synchronization and Communication Instructions: cp.async.mbarrier.arrive
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-cp-async-mbarrier-arrive" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  cp.async.mbarrier.arrive
 </p>
 <p>
  Makes the
  mbarrier object
  track all prior
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async">
   cp.async
  </a>
  operations initiated by the
executing thread.
 </p>
 <p>
  Syntax
 </p>
 <pre>cp.async.mbarrier.arrive{.noinc}{.shared{::cta}}.b64 [addr];
</pre>
 <p>
  Description
 </p>
 <p>
  Causes an
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-arrive-on">
   arrive-on operation
  </a>
  to be
triggered by the system on the
  mbarrier object
  upon the completion of all prior
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async">
   cp.async
  </a>
  operations initiated by the
executing thread. The
  mbarrier object
  is at the location specified by the operand
  <span class="pre">
   addr
  </span>
  . The
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-arrive-on">
   arrive-on operation
  </a>
  is
asynchronous to execution of
  <span class="pre">
   cp.async.mbarrier.arrive
  </span>
  .
 </p>
 <p>
  When
  <span class="pre">
   .noinc
  </span>
  modifier is not specified, the pending count of the mbarrier object is incremented
by 1 prior to the asynchronous
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-arrive-on">
   arrive-on operation
  </a>
  . This
results in a zero-net change for the pending count from the asynchronous
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-arrive-on">
   arrive-on
  </a>
  operation
during the current phase. The pending count of the
  mbarrier object
  after the increment should not
exceed the limit as mentioned in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-contents">
   Contents of the mbarrier object
  </a>
  . Otherwise,
the behavior is undefined.
 </p>
 <p>
  When the
  <span class="pre">
   .noinc
  </span>
  modifier is specified, the increment to the pending count of the
  mbarrier
object
  is not performed. Hence the decrement of the pending count done by the asynchronous
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-arrive-on">
   arrive-on operation
  </a>
  must be
accounted for in the initialization of the
  mbarrier object
  .
 </p>
 <p>
  If no state space is specified then
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#generic-addressing">
   Generic Addressing
  </a>
  is
used. If the address specified by
  <span class="pre">
   addr
  </span>
  does not fall within the address window of
  <span class="pre">
   .shared::cta
  </span>
  state space then the behavior is undefined.
 </p>
 <p>
  Supported addressing modes for operand
  <span class="pre">
   addr
  </span>
  is as described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#addresses-as-operands">
   Addresses as Operands
  </a>
  . Alignment for operand
  <span class="pre">
   addr
  </span>
  is as described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-size-alignment">
   Size
and alignment of mbarrier object
  </a>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.0.
 </p>
 <p>
  Support for sub-qualifier
  <span class="pre">
   ::cta
  </span>
  on
  <span class="pre">
   .shared
  </span>
  introduced in PTX ISA version 7.8.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>// Example 1: no .noinc
mbarrier.init.shared.b64 [shMem], threadCount;
....
cp.async.ca.shared.global [shard1], [gbl1], 4;
cp.async.cg.shared.global [shard2], [gbl2], 16;
....
// Absence of .noinc accounts for arrive-on from completion of prior cp.async operations.
// So mbarrier.init must only account for arrive-on from mbarrier.arrive.
cp.async.mbarrier.arrive.shared.b64 [shMem];
....
mbarrier.arrive.shared.b64 state, [shMem];

waitLoop:
mbarrier.test_wait.shared.b64 p, [shMem], state;
@!p bra waitLoop;



// Example 2: with .noinc

// Tracks arrive-on from mbarrier.arrive and cp.async.mbarrier.arrive.

// All threads participating in the mbarrier perform cp.async
mov.b32 copyOperationCnt, threadCount;

// 3 arrive-on operations will be triggered per-thread
mul.lo.u32 copyArrivalCnt, copyOperationCnt, 3;

add.u32 totalCount, threadCount, copyArrivalCnt;

mbarrier.init.shared.b64 [shMem], totalCount;
....
cp.async.ca.shared.global [shard1], [gbl1], 4;
cp.async.cg.shared.global [shard2], [gbl2], 16;
...
// Presence of .noinc requires mbarrier initalization to have accounted for arrive-on from cp.async
cp.async.mbarrier.arrive.noinc.shared.b64 [shMem]; // 1st instance
....
cp.async.ca.shared.global [shard3], [gbl3], 4;
cp.async.ca.shared.global [shard4], [gbl4], 16;
cp.async.mbarrier.arrive.noinc.shared::cta.b64 [shMem]; // 2nd instance
....
cp.async.ca.shared.global [shard5], [gbl5], 4;
cp.async.cg.shared.global [shard6], [gbl6], 16;
cp.async.mbarrier.arrive.noinc.shared.b64 [shMem]; // 3rd and last instance
....
mbarrier.arrive.shared.b64 state, [shMem];

waitLoop:
mbarrier.test_wait.shared.b64 p, [shMem], state;
@!p bra waitLoop;
</pre>
 <h5>
  <span class="section-number">
   9.7.12.15.16.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-test-wait-try-wait">
   Parallel Synchronization and Communication Instructions: mbarrier.test_wait/mbarrier.try_wait
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-test-wait-mbarrier-try-wait" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  mbarrier.test_wait/mbarrier.try_wait
 </p>
 <p>
  Checks whether the
  mbarrier object
  has completed the phase.
 </p>
 <p>
  Syntax
 </p>
 <pre>mbarrier.test_wait{.sem}{.scope}{.shared{::cta}}.b64        waitComplete, [addr], state;
mbarrier.test_wait.parity{.sem}{.scope}{.shared{::cta}}.b64 waitComplete, [addr], phaseParity;

mbarrier.try_wait{.sem}{.scope}{.shared{::cta}}.b64         waitComplete, [addr], state
                                                               {, suspendTimeHint};

mbarrier.try_wait.parity{.sem}{.scope}{.shared{::cta}}.b64  waitComplete, [addr], phaseParity
                                                               {, suspendTimeHint};

.sem   = { .acquire }
.scope = { .cta, .cluster }
</pre>
 <p>
  Description
 </p>
 <p>
  The
  test_wait
  and
  try_wait
  operations test for the completion of the current or the immediately
preceding phase of an
  mbarrier object
  at the location specified by the operand
  <span class="pre">
   addr
  </span>
  .
 </p>
 <p>
  <span class="pre">
   mbarrier.test_wait
  </span>
  is a non-blocking instruction which tests for the completion of the phase.
 </p>
 <p>
  <span class="pre">
   mbarrier.try_wait
  </span>
  is a potentially blocking instruction which tests for the completion of the
phase. If the phase is not complete, the executing thread may be suspended. Suspended thread resumes
execution when the specified phase completes OR before the phase completes following a
system-dependent time limit. The optional 32-bit unsigned integer operand
  <span class="pre">
   suspendTimeHint
  </span>
  specifies the time limit, in nanoseconds, that may be used for the time limit instead of the
system-dependent limit.
 </p>
 <p>
  <span class="pre">
   mbarrier.test_wait
  </span>
  and
  <span class="pre">
   mbarrier.try_wait
  </span>
  test for completion of the phase :
 </p>
 <ul class="simple">
  <li>
   <p>
    Specified by the operand
    <span class="pre">
     state
    </span>
    , which was returned by an
    <span class="pre">
     mbarrier.arrive
    </span>
    instruction on
the same
    mbarrier object
    during the current or the immediately preceding phase. Or
   </p>
  </li>
  <li>
   <p>
    Indicated by the operand
    <span class="pre">
     phaseParity
    </span>
    , which is the integer parity of either the current phase
or the immediately preceding phase of the
    mbarrier object
    .
   </p>
  </li>
 </ul>
 <p>
  The
  <span class="pre">
   .parity
  </span>
  variant of the instructions test for the completion of the phase indicated by the
operand
  <span class="pre">
   phaseParity
  </span>
  , which is the integer parity of either the current phase or the immediately
preceding phase of the
  mbarrier object
  . An even phase has integer parity 0 and an odd phase has
integer parity of 1. So the valid values of
  <span class="pre">
   phaseParity
  </span>
  operand are 0 and 1.
 </p>
 <p>
  Note: the use of the
  <span class="pre">
   .parity
  </span>
  variants of the instructions requires tracking the phase of an
  mbarrier object
  throughout its lifetime.
 </p>
 <p>
  The
  test_wait
  and
  try_wait
  operations are valid only for :
 </p>
 <ul class="simple">
  <li>
   <p>
    the current incomplete phase, for which
    <span class="pre">
     waitComplete
    </span>
    returns
    <span class="pre">
     False
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    the immediately preceding phase, for which
    <span class="pre">
     waitComplete
    </span>
    returns
    <span class="pre">
     True
    </span>
    .
   </p>
  </li>
 </ul>
 <p>
  If no state space is specified then
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#generic-addressing">
   Generic Addressing
  </a>
  is
used. If the address specified by
  <span class="pre">
   addr
  </span>
  does not fall within the address window of
  <span class="pre">
   .shared::cta
  </span>
  state space then the behavior is undefined.
 </p>
 <p>
  Supported addressing modes for operand
  <span class="pre">
   addr
  </span>
  is as described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#addresses-as-operands">
   Addresses as Operands
  </a>
  . Alignment for operand
  <span class="pre">
   addr
  </span>
  is as described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-size-alignment">
   Size
and alignment of mbarrier object
  </a>
  .
 </p>
 <p>
  When
  <span class="pre">
   mbarrier.test_wait
  </span>
  and
  <span class="pre">
   mbarrier.try_wait
  </span>
  operations return
  <span class="pre">
   True
  </span>
  , they form the
  acquire
  pattern as described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory Consistency Model
  </a>
  .
 </p>
 <p>
  The optional
  <span class="pre">
   .scope
  </span>
  qualifier indicates the set of threads that the
  <span class="pre">
   mbarrier.test_wait
  </span>
  and
  <span class="pre">
   mbarrier.try_wait
  </span>
  instructions can directly synchronize. If the
  <span class="pre">
   .scope
  </span>
  qualifier is not
specified then it defaults to
  <span class="pre">
   .cta
  </span>
  . In contrast, the
  <span class="pre">
   .shared::&lt;scope&gt;
  </span>
  indicates the state
space where the mbarrier resides.
 </p>
 <p>
  The following ordering of memory operations hold for the executing thread when
  <span class="pre">
   mbarrier.test_wait
  </span>
  or
  <span class="pre">
   mbarrier.try_wait
  </span>
  returns
  <span class="pre">
   True
  </span>
  :
 </p>
 <ol class="arabic simple">
  <li>
   <p>
    All memory accesses (except
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async">
     async operations
    </a>
    ) requested prior, in program
order, to
    <span class="pre">
     mbarrier.arrive
    </span>
    during the completed phase by the participating threads of the CTA
are performed and are visible to the executing thread.
   </p>
  </li>
  <li>
   <p>
    All
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async">
     cp.async
    </a>
    operations
requested prior, in program order, to
    <span class="pre">
     cp.async.mbarrier.arrive
    </span>
    during the completed phase by
the participating threads of the CTA are performed and made visible to the executing thread.
   </p>
  </li>
  <li>
   <p>
    All
    <span class="pre">
     cp.async.bulk
    </span>
    asynchronous operations using the same
    mbarrier object
    requested prior,
in program order, to
    <span class="pre">
     mbarrier.arrive
    </span>
    during the completed phase by the participating threads
of the CTA are performed and made visible to the executing thread.
   </p>
  </li>
  <li>
   <p>
    All memory accesses requested after the
    <span class="pre">
     mbarrier.test_wait
    </span>
    or
    <span class="pre">
     mbarrier.try_wait
    </span>
    , in
program order, are not performed and not visible to memory accesses performed prior to
    <span class="pre">
     mbarrier.arrive
    </span>
    , in program order, by other threads participating in the
    <span class="pre">
     mbarrier
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    There is no ordering and visibility guarantee for memory accesses requested by the thread after
    <span class="pre">
     mbarrier.arrive
    </span>
    and prior to
    <span class="pre">
     mbarrier.test_wait
    </span>
    , in program order.
   </p>
  </li>
 </ol>
 <p>
  PTX ISA Notes
 </p>
 <p>
  <span class="pre">
   mbarrier.test_wait
  </span>
  introduced in PTX ISA version 7.0.
 </p>
 <p>
  Modifier
  <span class="pre">
   .parity
  </span>
  is introduced in PTX ISA version 7.1.
 </p>
 <p>
  <span class="pre">
   mbarrier.try_wait
  </span>
  introduced in PTX ISA version 7.8.
 </p>
 <p>
  Support for sub-qualifier
  <span class="pre">
   ::cta
  </span>
  on
  <span class="pre">
   .shared
  </span>
  introduced in PTX ISA version 7.8.
 </p>
 <p>
  Support for
  <span class="pre">
   .scope
  </span>
  and
  <span class="pre">
   .sem
  </span>
  qualifiers introduced in PTX ISA version 8.0
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   mbarrier.test_wait
  </span>
  requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   mbarrier.try_wait
  </span>
  requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Support for
  <span class="pre">
   .cluster
  </span>
  scope requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>// Example 1a, thread synchronization with test_wait:

.reg .b64 %r1;
.shared .b64 shMem;

mbarrier.init.shared.b64 [shMem], N;  // N threads participating in the mbarrier.
...
mbarrier.arrive.shared.b64  %r1, [shMem]; // N threads executing mbarrier.arrive

// computation not requiring mbarrier synchronization...

waitLoop:
mbarrier.test_wait.shared.b64    complete, [shMem], %r1;
@!complete nanosleep.u32 20;
@!complete bra waitLoop;

// Example 1b, thread synchronization with try_wait :

.reg .b64 %r1;
.shared .b64 shMem;

mbarrier.init.shared.b64 [shMem], N;  // N threads participating in the mbarrier.
...
mbarrier.arrive.shared.b64  %r1, [shMem]; // N threads executing mbarrier.arrive

// computation not requiring mbarrier synchronization...

waitLoop:
mbarrier.try_wait.shared.b64    complete, [shMem], %r1;
@!complete bra waitLoop;


// Example 2, thread synchronization using phase parity :

.reg .b32 i, parArg;
.reg .b64 %r1;
.shared .b64 shMem;

mov.b32 i, 0;
mbarrier.init.shared.b64 [shMem], N;  // N threads participating in the mbarrier.
...
loopStart :                           // One phase per loop iteration
    ...
    mbarrier.arrive.shared.b64  %r1, [shMem]; // N threads
    ...
    and.b32 parArg, i, 1;
    waitLoop:
    mbarrier.test_wait.parity.shared.b64  complete, [shMem], parArg;
    @!complete nanosleep.u32 20;
    @!complete bra waitLoop;
    ...
    add.u32 i, i, 1;
    setp.lt.u32 p, i, IterMax;
@p bra loopStart;


// Example 3, Asynchronous copy completion waiting :

.reg .b64 state;
.shared .b64 shMem2;
.shared .b64 shard1, shard2;
.global .b64 gbl1, gbl2;

mbarrier.init.shared.b64 [shMem2], threadCount;
...
cp.async.ca.shared.global [shard1], [gbl1], 4;
cp.async.cg.shared.global [shard2], [gbl2], 16;

// Absence of .noinc accounts for arrive-on from prior cp.async operation
cp.async.mbarrier.arrive.shared.b64 [shMem2];
...
mbarrier.arrive.shared.b64 state, [shMem2];

waitLoop:
mbarrier.test_wait.shared::cta.b64 p, [shMem2], state;
@!p bra waitLoop;

// Example 4, Synchronizing the CTA0 threads with cluster threads
.reg .b64 %r1, addr, remAddr;
.shared .b64 shMem;

cvta.shared.u64          addr, shMem;
mapa.u64                 remAddr, addr, 0;     // CTA0âs shMem instance

// One thread from CTA0 executing the below initialization operation
@p0 mbarrier.init.shared::cta.b64 [shMem], N;  // N = no of cluster threads

barrier.cluster.arrive;
barrier.cluster.wait;

// Entire cluster executing the below arrive operation
mbarrier.arrive.release.cluster.b64              _, [remAddr];

// computation not requiring mbarrier synchronization ...

// Only CTA0 threads executing the below wait operation
waitLoop:
mbarrier.try_wait.parity.acquire.cluser.shared::cta.b64  complete, [shMem], 0;
@!complete bra waitLoop;
</pre>
 <h5>
  <span class="section-number">
   9.7.12.15.17.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-pending-count">
   Parallel Synchronization and Communication Instructions: mbarrier.pending_count
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-pending-count" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  mbarrier.pending_count
 </p>
 <p>
  Query the pending arrival count from the opaque mbarrier state.
 </p>
 <p>
  Syntax
 </p>
 <pre>mbarrier.pending_count.b64 count, state;
</pre>
 <p>
  Description
 </p>
 <p>
  The pending count can be queried from the opaque mbarrier state using
  <span class="pre">
   mbarrier.pending_count
  </span>
  .
 </p>
 <p>
  The
  <span class="pre">
   state
  </span>
  operand is a 64-bit register that must be the result of a prior
  <span class="pre">
   mbarrier.arrive.noComplete
  </span>
  or
  <span class="pre">
   mbarrier.arrive_drop.noComplete
  </span>
  instruction. Otherwise, the
behavior is undefined.
 </p>
 <p>
  The destination register
  <span class="pre">
   count
  </span>
  is a 32-bit unsigned integer representing the pending count of
the
  mbarrier object
  prior to the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-mbarrier-arrive-on">
   arrive-on operation
  </a>
  from
which the
  <span class="pre">
   state
  </span>
  register was obtained.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>.reg .b32 %r1;
.reg .b64 state;
.shared .b64 shMem;

mbarrier.arrive.noComplete.b64 state, [shMem], 1;
mbarrier.pending_count.b64 %r1, state;
</pre>
 <h5>
  <span class="section-number">
   9.7.12.15.18.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-tensormap-cp-fenceproxy">
   Parallel Synchronization and Communication Instructions: tensormap.cp_fenceproxy
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-tensormap-cp-fenceproxy" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  tensormap.cp_fenceproxy
 </p>
 <p>
  A fused copy and fence operation.
 </p>
 <p>
  Syntax
 </p>
 <pre>tensormap.cp_fenceproxy.cp_qualifiers.fence_qualifiers.sync.aligned  [dst], [src], size;

.cp_qualifiers    = { .global.shared::cta }
.fence_qualifiers = { .to_proxy::from_proxy.release.scope }
.to_proxy::from_proxy  = { .tensormap::generic }
.scope            = { .cta, .cluster, .gpu , .sys }
</pre>
 <p>
  Description
 </p>
 <p>
  The
  <span class="pre">
   tensormap.cp_fence
  </span>
  instructions perform the following operations in order :
 </p>
 <ul class="simple">
  <li>
   <p>
    Copies data of size specified by the
    <span class="pre">
     size
    </span>
    argument, in bytes, from the location specified
by the address operand
    <span class="pre">
     src
    </span>
    in shared memory to the location specified by the address operand
    <span class="pre">
     dst
    </span>
    in the global memory, in the generic proxy.
   </p>
  </li>
  <li>
   <p>
    Establishes a
    uni-directional
    proxy release pattern on the ordering from the copy operation
to the subsequent access performed in the tensormap proxy on the address
    <span class="pre">
     dst
    </span>
    .
   </p>
  </li>
 </ul>
 <p>
  The valid value of
  <span class="pre">
   size
  </span>
  operand is 128.
 </p>
 <p>
  The operands
  <span class="pre">
   src
  </span>
  and
  <span class="pre">
   dst
  </span>
  specify non-generic addresses in
  <span class="pre">
   shared::cta
  </span>
  and
  <span class="pre">
   global
  </span>
  state space respectively.
 </p>
 <p>
  The optional
  <span class="pre">
   .scope
  </span>
  qualifier specifies the set of threads that can directly observe the proxy
synchronizing effect of this operation, as described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory Consistency Model
  </a>
  .
 </p>
 <p>
  The mandatory
  <span class="pre">
   .sync
  </span>
  qualifier indicates that
  <span class="pre">
   tensormap.cp_fenceproxy
  </span>
  causes the executing
thread to wait until all threads in the warp execute the same
  <span class="pre">
   tensormap.cp_fenceproxy
  </span>
  instruction before resuming execution.
 </p>
 <p>
  The mandatory
  <span class="pre">
   .aligned
  </span>
  qualifier indicates that all threads in the warp must execute the same
  <span class="pre">
   tensormap.cp_fenceproxy
  </span>
  instruction. In conditionally executed code, an aligned
  <span class="pre">
   tensormap.cp_fenceproxy
  </span>
  instruction should only be used if it is known that all threads in the warp evaluate the condition
identically, otherwise behavior is undefined.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 8.3.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>// Example: manipulate a tensor-map object and then consume it in cp.async.bulk.tensor

.reg .b64 new_addr;
.global .align 128 .b8 gbl[128];
.shared .align 128 .b8 sMem[128];

cp.async.bulk.shared::cluster.global.mbarrier::complete_tx::bytes [sMem], [gMem], 128, [mbar];
...
try_wait_loop:
mbarrier.try_wait.shared.b64 p, [mbar], state;
@!p bra try_wait loop;

tensormap.replace.tile.global_address.shared.b1024.b64   [sMem], new_addr;
tensormap.cp_fenceproxy.global.shared::cta.proxy.tensormap::generic.release.gpu
                                    .sync.aligned        [gbl], [sMem], 128;
fence.proxy.tensormap::generic.acquire.gpu [gbl], 128;
cp.async.bulk.tensor.1d.shared::cluster.global.tile  [addr0], [gbl, {tc0}], [mbar0];
</pre>
 <h3>
  <span class="section-number">
   9.7.13.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-instructions">
   Warp Level Matrix Multiply-Accumulate Instructions
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-multiply-accumulate-instructions" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The matrix multiply and accumulate operation has the following form:
 </p>
 <pre>D = A * B + C
</pre>
 <p>
  where
  <span class="pre">
   D
  </span>
  and
  <span class="pre">
   C
  </span>
  are called accumulators and may refer to the same matrix.
 </p>
 <p>
  PTX provides two ways to perform matrix multiply-and-accumulate computation:
 </p>
 <ul>
  <li>
   <p>
    Using
    <span class="pre">
     wmma
    </span>
    instructions:
   </p>
   <ul>
    <li>
     <p>
      This warp-level computation is performed collectively by all threads in the warp as follows:
     </p>
     <ul class="simple">
      <li>
       <p>
        Load matrices A, B and C from memory into registers using the
        <span class="pre">
         wmma.load
        </span>
        operation. When
the operation completes, the destination registers in each thread hold a fragment of the
loaded matrix.
       </p>
      </li>
      <li>
       <p>
        Perform the matrix multiply and accumulate operation using the
        <span class="pre">
         wmma.mma
        </span>
        operation on the
loaded matrices. When the operation completes, the destination registers in each thread hold
a fragment of the result matrix returned by the
        <span class="pre">
         wmma.mma
        </span>
        operation.
       </p>
      </li>
      <li>
       <p>
        Store result Matrix D back to memory using the
        <span class="pre">
         wmma.store
        </span>
        operation. Alternately, result
matrix D can also be used as argument C for a subsequent
        <span class="pre">
         wmma.mma
        </span>
        operation.
       </p>
      </li>
     </ul>
     <p>
      The
      <span class="pre">
       wmma.load
      </span>
      and
      <span class="pre">
       wmma.store
      </span>
      instructions implicitly handle the organization of matrix
elements when loading the input matrices from memory for the
      <span class="pre">
       wmma.mma
      </span>
      operation and when
storing the result back to memory.
     </p>
    </li>
   </ul>
  </li>
  <li>
   <p>
    Using
    <span class="pre">
     mma
    </span>
    instruction:
   </p>
   <ul class="simple">
    <li>
     <p>
      Similar to
      <span class="pre">
       wmma
      </span>
      ,
      <span class="pre">
       mma
      </span>
      also requires computation to be performed collectively by all
threads in the warp however distribution of matrix elements across different threads in warp
needs to be done explicitly before invoking the
      <span class="pre">
       mma
      </span>
      operation. The
      <span class="pre">
       mma
      </span>
      instruction
supports both dense as well as sparse matrix A. The sparse variant can be used when A is a
structured sparse matrix as described in
      <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-sparse-matrix-storage">
       Sparse matrix storage
      </a>
      .
     </p>
    </li>
   </ul>
  </li>
 </ul>
 <h4>
  <span class="section-number">
   9.7.13.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-shape">
   Matrix Shape
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-shape" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The matrix multiply and accumulate operations support a limited set of shapes for the operand
matrices A, B and C. The shapes of all three matrix operands are collectively described by the tuple
  <span class="pre">
   MxNxK
  </span>
  , where A is an
  <span class="pre">
   MxK
  </span>
  matrix, B is a
  <span class="pre">
   KxN
  </span>
  matrix, while C and D are
  <span class="pre">
   MxN
  </span>
  matrices.
 </p>
 <p>
  The following matrix shapes are supported for the specified types:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Instruction
    </p>
   </th>
   <th class="head">
    <p>
     Sparsity
    </p>
   </th>
   <th class="head">
    <p>
     Multiplicand Data-type
    </p>
   </th>
   <th class="head">
    <p>
     Shape
    </p>
   </th>
   <th class="head">
    <p>
     PTX ISA version
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      wmma
     </span>
    </p>
   </td>
   <td>
    <p>
     Dense
    </p>
   </td>
   <td>
    <p>
     Floating-point -
     <span class="pre">
      .f16
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m16n16k16
     </span>
     ,
     <span class="pre">
      .m8n32k16
     </span>
     ,
and
     <span class="pre">
      .m32n8k16
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 6.0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      wmma
     </span>
    </p>
   </td>
   <td>
    <p>
     Dense
    </p>
   </td>
   <td>
    <p>
     Alternate floating-point format -
     <span class="pre">
      .bf16
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m16n16k16
     </span>
     ,
     <span class="pre">
      .m8n32k16
     </span>
     ,
and
     <span class="pre">
      .m32n8k16
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 7.0
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      wmma
     </span>
    </p>
   </td>
   <td>
    <p>
     Dense
    </p>
   </td>
   <td>
    <p>
     Alternate floating-point format -
     <span class="pre">
      .tf32
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m16n16k8
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 7.0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      wmma
     </span>
    </p>
   </td>
   <td>
    <p>
     Dense
    </p>
   </td>
   <td>
    <p>
     Integer -
     <span class="pre">
      .u8
     </span>
     /
     <span class="pre">
      .s8
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m16n16k16
     </span>
     ,
     <span class="pre">
      .m8n32k16
     </span>
     ,
and
     <span class="pre">
      .m32n8k16
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 6.3
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      wmma
     </span>
    </p>
   </td>
   <td>
    <p>
     Dense
    </p>
   </td>
   <td>
    <p>
     Sub-byte integer -
     <span class="pre">
      .u4
     </span>
     /
     <span class="pre">
      .s4
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m8n8k32
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 6.3
(preview feature)
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      wmma
     </span>
    </p>
   </td>
   <td>
    <p>
     Dense
    </p>
   </td>
   <td>
    <p>
     Single-bit -
     <span class="pre">
      .b1
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m8n8k128
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 6.3
(preview feature)
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td rowspan="2">
    <p>
     <span class="pre">
      mma
     </span>
    </p>
   </td>
   <td rowspan="2">
    <p>
     Dense
    </p>
   </td>
   <td rowspan="2">
    <p>
     Floating-point -
     <span class="pre">
      .f64
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m8n8k4
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 7.0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .m16n8k4
     </span>
     ,
     <span class="pre">
      .m16n8k8
     </span>
     ,
and
     <span class="pre">
      .m16n8k16
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 7.8
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td rowspan="3">
    <p>
     <span class="pre">
      mma
     </span>
    </p>
   </td>
   <td rowspan="3">
    <p>
     Dense
    </p>
   </td>
   <td rowspan="3">
    <p>
     Floating-point -
     <span class="pre">
      .f16
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m8n8k4
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 6.4
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .m16n8k8
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 6.5
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .m16n8k16
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 7.0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      mma
     </span>
    </p>
   </td>
   <td>
    <p>
     Dense
    </p>
   </td>
   <td>
    <p>
     Alternate floating-point format -
     <span class="pre">
      .bf16
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m16n8k8
     </span>
     and
     <span class="pre">
      .m16n8k16
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 7.0
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      mma
     </span>
    </p>
   </td>
   <td>
    <p>
     Dense
    </p>
   </td>
   <td>
    <p>
     Alternate floating-point format -
     <span class="pre">
      .tf32
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m16n8k4
     </span>
     and
     <span class="pre">
      .m16n8k8
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 7.0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td rowspan="2">
    <p>
     <span class="pre">
      mma
     </span>
    </p>
   </td>
   <td rowspan="2">
    <p>
     Dense
    </p>
   </td>
   <td rowspan="2">
    <p>
     Integer -
     <span class="pre">
      .u8
     </span>
     /
     <span class="pre">
      .s8
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m8n8k16
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 6.5
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .m16n8k16
     </span>
     and
     <span class="pre">
      .m16n8k32
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 7.0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td rowspan="2">
    <p>
     <span class="pre">
      mma
     </span>
    </p>
   </td>
   <td rowspan="2">
    <p>
     Dense
    </p>
   </td>
   <td rowspan="2">
    <p>
     Sub-byte integer -
     <span class="pre">
      .u4
     </span>
     /
     <span class="pre">
      .s4
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m8n8k32
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 6.5
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .m16n8k32
     </span>
     and
     <span class="pre">
      .m16n8k64
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 7.0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      mma
     </span>
    </p>
   </td>
   <td>
    <p>
     Dense
    </p>
   </td>
   <td>
    <p>
     Single-bit -
     <span class="pre">
      .b1
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m8n8k128
     </span>
     ,
     <span class="pre">
      .m16n8k128
     </span>
     ,
and
     <span class="pre">
      .m16n8k256
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 7.0
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      mma
     </span>
    </p>
   </td>
   <td>
    <p>
     Dense
    </p>
   </td>
   <td>
    <p>
     Alternate floating-point format -
     <span class="pre">
      .e4m3
     </span>
     /
     <span class="pre">
      .e5m2
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m16n8k32
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 8.4
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      mma
     </span>
    </p>
   </td>
   <td>
    <p>
     Sparse
    </p>
   </td>
   <td>
    <p>
     Floating-point -
     <span class="pre">
      .f16
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m16n8k16
     </span>
     and
     <span class="pre">
      .m16n8k32
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 7.1
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      mma
     </span>
    </p>
   </td>
   <td>
    <p>
     Sparse
    </p>
   </td>
   <td>
    <p>
     Alternate floating-point format -
     <span class="pre">
      .bf16
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m16n8k16
     </span>
     and
     <span class="pre">
      .m16n8k32
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 7.1
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      mma
     </span>
    </p>
   </td>
   <td>
    <p>
     Sparse
    </p>
   </td>
   <td>
    <p>
     Alternate floating-point format -
     <span class="pre">
      .tf32
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m16n8k8
     </span>
     and
     <span class="pre">
      .m16n8k16
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 7.1
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      mma
     </span>
    </p>
   </td>
   <td>
    <p>
     Sparse
    </p>
   </td>
   <td>
    <p>
     Integer -
     <span class="pre">
      .u8
     </span>
     /
     <span class="pre">
      .s8
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m16n8k32
     </span>
     and
     <span class="pre">
      .m16n8k64
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 7.1
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      mma
     </span>
    </p>
   </td>
   <td>
    <p>
     Sparse
    </p>
   </td>
   <td>
    <p>
     Sub-byte integer -
     <span class="pre">
      .u4
     </span>
     /
     <span class="pre">
      .s4
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m16n8k64
     </span>
     and
     <span class="pre">
      .m16n8k128
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 7.1
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      mma
     </span>
    </p>
   </td>
   <td>
    <p>
     Sparse
    </p>
   </td>
   <td>
    <p>
     Alternate floating-point format -
     <span class="pre">
      .e4m3
     </span>
     /
     <span class="pre">
      .e5m2
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m16n8k64
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 8.4
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      mma
     </span>
    </p>
   </td>
   <td>
    <p>
     Sparse
with
ordered
metadata
    </p>
   </td>
   <td>
    <p>
     Floating-point -
     <span class="pre">
      .f16
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m16n8k16
     </span>
     and
     <span class="pre">
      .m16n8k32
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 8.5
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      mma
     </span>
    </p>
   </td>
   <td>
    <p>
     Sparse
with
ordered
metadata
    </p>
   </td>
   <td>
    <p>
     Alternate floating-point format -
     <span class="pre">
      .bf16
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m16n8k16
     </span>
     and
     <span class="pre">
      .m16n8k32
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 8.5
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      mma
     </span>
    </p>
   </td>
   <td>
    <p>
     Sparse
with
ordered
metadata
    </p>
   </td>
   <td>
    <p>
     Alternate floating-point format -
     <span class="pre">
      .tf32
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m16n8k8
     </span>
     and
     <span class="pre">
      .m16n8k16
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 8.5
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      mma
     </span>
    </p>
   </td>
   <td>
    <p>
     Sparse
with
ordered
metadata
    </p>
   </td>
   <td>
    <p>
     Integer -
     <span class="pre">
      .u8
     </span>
     /
     <span class="pre">
      .s8
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m16n8k32
     </span>
     and
     <span class="pre">
      .m16n8k64
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 8.5
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      mma
     </span>
    </p>
   </td>
   <td>
    <p>
     Sparse
with
ordered
metadata
    </p>
   </td>
   <td>
    <p>
     Sub-byte integer -
     <span class="pre">
      .u4
     </span>
     /
     <span class="pre">
      .s4
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m16n8k64
     </span>
     and
     <span class="pre">
      .m16n8k128
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 8.5
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      mma
     </span>
    </p>
   </td>
   <td>
    <p>
     Sparse
with
ordered
metadata
    </p>
   </td>
   <td>
    <p>
     Alternate floating-point format -
     <span class="pre">
      .e4m3
     </span>
     /
     <span class="pre">
      .e5m2
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m16n8k64
     </span>
    </p>
   </td>
   <td>
    <p>
     PTX ISA version 8.5
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   9.7.13.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-data-types">
   Matrix Data-types
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-data-types" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The matrix multiply and accumulate operation is supported separately on integer, floating-point,
sub-byte integer and single bit data-types. All operands must contain the same basic type kind,
i.e., integer or floating-point.
 </p>
 <p>
  For floating-point matrix multiply and accumulate operation, different matrix operands may have
different precision, as described later.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Data-type
    </p>
   </th>
   <th class="head">
    <p>
     Multiplicands (A or B)
    </p>
   </th>
   <th class="head">
    <p>
     Accumulators (C or D)
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     Integer
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .u8
     </span>
     ,
     <span class="pre">
      .s8
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .s32
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     Floating Point
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .f16
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .f16
     </span>
     ,
     <span class="pre">
      .f32
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     Alternate floating Point
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .bf16
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .f32
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     Alternate floating Point
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .tf32
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .f32
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     Alternate floating Point
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .e4m3
     </span>
     or
     <span class="pre">
      .e5m2
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .f32
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     Floating Point
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .f64
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .f64
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     Sub-byte integer
    </p>
   </td>
   <td>
    <p>
     both
     <span class="pre">
      .u4
     </span>
     or both
     <span class="pre">
      .s4
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .s32
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     Single-bit integer
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .b1
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .s32
     </span>
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   9.7.13.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-instructions-wmma">
   Matrix multiply-accumulate operation using wmma instructions
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-multiply-accumulate-operation-using-wmma-instructions" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  This section describes warp level
  <span class="pre">
   wmma.load,
  </span>
  <span class="pre">
   wmma.mma
  </span>
  and
  <span class="pre">
   wmma.store
  </span>
  instructions and the
organization of various matrices invovled in these instruction.
 </p>
 <h5>
  <span class="section-number">
   9.7.13.3.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment">
   Matrix Fragments for WMMA
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-wmma" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  Each thread in the warp holds a fragment of the matrix. The distribution of fragments loaded by the
threads in a warp is unspecified and is target architecture dependent, and hence the identity of the
fragment within the matrix is also unspecified and is target architecture dependent. The fragment
returned by a
  <span class="pre">
   wmma
  </span>
  operation can be used as an operand for another
  <span class="pre">
   wmma
  </span>
  operation if the
shape, layout and element type of the underlying matrix matches. Since fragment layout is
architecture dependent, using the fragment returned by a
  <span class="pre">
   wmma
  </span>
  operation in one function as an
operand for a
  <span class="pre">
   wmma
  </span>
  operation in a different function may not work as expected if the two
functions are linked together but were compiled for different link-compatible SM architectures. Note
passing
  <span class="pre">
   wmma
  </span>
  fragment to a function having
  <span class="pre">
   .weak
  </span>
  linkage is unsafe since at link time
references to such function may get resolved to a function in different compilation module.
 </p>
 <p>
  Each fragment is a vector expression whose contents are determined as follows. The identity of
individual matrix elements in the fragment is unspecified.
 </p>
 Integer fragments
 <p>
  Multiplicands (A or B):
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Data-type
    </p>
   </th>
   <th class="head">
    <p>
     Shape
    </p>
   </th>
   <th class="head">
    <p>
     Matrix
    </p>
   </th>
   <th class="head">
    <p>
     Fragment
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td rowspan="2">
    <p>
     <span class="pre">
      .u8
     </span>
     or
     <span class="pre">
      .s8
     </span>
    </p>
   </td>
   <td rowspan="2">
    <p>
     <span class="pre">
      .m16n16k16
     </span>
    </p>
   </td>
   <td>
    <p>
     A
    </p>
   </td>
   <td>
    <p>
     A vector expression of two
     <span class="pre">
      .b32
     </span>
     registers, with each
register containing four elements from the matrix.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     B
    </p>
   </td>
   <td>
    <p>
     A vector expression of two
     <span class="pre">
      .b32
     </span>
     registers, with each
register containing four elements from the matrix.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td rowspan="2">
    <p>
     <span class="pre">
      .m8n32k16
     </span>
    </p>
   </td>
   <td>
    <p>
     A
    </p>
   </td>
   <td>
    <p>
     A vector expression containing a single
     <span class="pre">
      .b32
     </span>
     register
containing four elements from the matrix.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     B
    </p>
   </td>
   <td>
    <p>
     A vector expression of four
     <span class="pre">
      .b32
     </span>
     registers, with each
register containing four elements from the matrix.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td rowspan="2">
    <p>
     <span class="pre">
      .m32n8k16
     </span>
    </p>
   </td>
   <td>
    <p>
     A
    </p>
   </td>
   <td>
    <p>
     A vector expression of four
     <span class="pre">
      .b32
     </span>
     registers, with each
register containing four elements from the matrix.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     B
    </p>
   </td>
   <td>
    <p>
     A vector expression containing single
     <span class="pre">
      .b32
     </span>
     register,
with each containing four elements from the matrix.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Accumulators (C or D):
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Data-type
    </p>
   </th>
   <th class="head">
    <p>
     Shape
    </p>
   </th>
   <th class="head">
    <p>
     Fragment
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td rowspan="3">
    <p>
     <span class="pre">
      .s32
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m16n16k16
     </span>
    </p>
   </td>
   <td rowspan="3">
    <p>
     A vector expression of eight
     <span class="pre">
      .s32
     </span>
     registers.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .m8n32k16
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .m32n8k16
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Floating point fragments
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Data-type
    </p>
   </th>
   <th class="head">
    <p>
     Matrix
    </p>
   </th>
   <th class="head">
    <p>
     Fragment
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .f16
     </span>
    </p>
   </td>
   <td>
    <p>
     A or B
    </p>
   </td>
   <td>
    <p>
     A vector expression of eight
     <span class="pre">
      .f16x2
     </span>
     registers.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .f16
     </span>
    </p>
   </td>
   <td rowspan="2">
    <p>
     C or D
    </p>
   </td>
   <td>
    <p>
     A vector expression of four
     <span class="pre">
      .f16x2
     </span>
     registers.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .f32
     </span>
    </p>
   </td>
   <td>
    <p>
     A vector expression of eight
     <span class="pre">
      .f32
     </span>
     registers.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Floating point fragments for .bf16 data format
 </p>
 <p>
  Multiplicands (A or B):
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Data-type
    </p>
   </th>
   <th class="head">
    <p>
     Shape
    </p>
   </th>
   <th class="head">
    <p>
     Matrix
    </p>
   </th>
   <th class="head">
    <p>
     Fragment
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td rowspan="6">
    <p>
     <span class="pre">
      .bf16
     </span>
    </p>
   </td>
   <td rowspan="2">
    <p>
     <span class="pre">
      .m16n16k16
     </span>
    </p>
   </td>
   <td>
    <p>
     A
    </p>
   </td>
   <td rowspan="2">
    <p>
     A vector expression of four
     <span class="pre">
      .b32
     </span>
     registers, with each
register containing two elements from the matrix.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     B
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td rowspan="2">
    <p>
     <span class="pre">
      .m8n32k16
     </span>
    </p>
   </td>
   <td>
    <p>
     A
    </p>
   </td>
   <td>
    <p>
     A vector expression containing a two
     <span class="pre">
      .b32
     </span>
     registers,
with containing two elements from the matrix.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     B
    </p>
   </td>
   <td>
    <p>
     A vector expression of eight
     <span class="pre">
      .b32
     </span>
     registers, with
each register containing two elements from the matrix.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td rowspan="2">
    <p>
     <span class="pre">
      .m32n8k16
     </span>
    </p>
   </td>
   <td>
    <p>
     A
    </p>
   </td>
   <td>
    <p>
     A vector expression of eight
     <span class="pre">
      .b32
     </span>
     registers, with
each register containing two elements from the matrix.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     B
    </p>
   </td>
   <td>
    <p>
     A vector expression containing two
     <span class="pre">
      .b32
     </span>
     registers,
with each containing two elements from the matrix.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Accumulators (C or D):
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Data-type
    </p>
   </th>
   <th class="head">
    <p>
     Matrix
    </p>
   </th>
   <th class="head">
    <p>
     Fragment
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .f32
     </span>
    </p>
   </td>
   <td>
    <p>
     C or D
    </p>
   </td>
   <td>
    <p>
     A vector expression containing eight
     <span class="pre">
      .f32
     </span>
     registers.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Floating point fragments for .tf32 data format
 </p>
 <p>
  Multiplicands (A or B):
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Data-type
    </p>
   </th>
   <th class="head">
    <p>
     Shape
    </p>
   </th>
   <th class="head">
    <p>
     Matrix
    </p>
   </th>
   <th class="head">
    <p>
     Fragment
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td rowspan="2">
    <p>
     <span class="pre">
      .tf32
     </span>
    </p>
   </td>
   <td rowspan="2">
    <p>
     <span class="pre">
      .m16n16k8
     </span>
    </p>
   </td>
   <td>
    <p>
     A
    </p>
   </td>
   <td>
    <p>
     A vector expression of four
     <span class="pre">
      .b32
     </span>
     registers.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     B
    </p>
   </td>
   <td>
    <p>
     A vector expression of four
     <span class="pre">
      .b32
     </span>
     registers.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Accumulators (C or D):
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Data-type
    </p>
   </th>
   <th class="head">
    <p>
     Shape
    </p>
   </th>
   <th class="head">
    <p>
     Matrix
    </p>
   </th>
   <th class="head">
    <p>
     Fragment
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .f32
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m16n16k8
     </span>
    </p>
   </td>
   <td>
    <p>
     C or D
    </p>
   </td>
   <td>
    <p>
     A vector expression containing eight
     <span class="pre">
      .f32
     </span>
     registers.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Double precision floating point fragments
 </p>
 <p>
  Multiplicands (A or B):
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Data-type
    </p>
   </th>
   <th class="head">
    <p>
     Shape
    </p>
   </th>
   <th class="head">
    <p>
     Matrix
    </p>
   </th>
   <th class="head">
    <p>
     Fragment
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .f64
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m8n8k4
     </span>
    </p>
   </td>
   <td>
    <p>
     A or B
    </p>
   </td>
   <td>
    <p>
     A vector expression of single
     <span class="pre">
      .f64
     </span>
     register.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Accumulators (C or D):
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Data-type
    </p>
   </th>
   <th class="head">
    <p>
     Shape
    </p>
   </th>
   <th class="head">
    <p>
     Matrix
    </p>
   </th>
   <th class="head">
    <p>
     Fragment
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .f64
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m8n8k4
     </span>
    </p>
   </td>
   <td>
    <p>
     C or D
    </p>
   </td>
   <td>
    <p>
     A vector expression containing single
     <span class="pre">
      .f64
     </span>
     register.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Sub-byte integer and single-bit fragments
 </p>
 <p>
  Multiplicands (A or B):
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Data-type
    </p>
   </th>
   <th class="head">
    <p>
     Shape
    </p>
   </th>
   <th class="head">
    <p>
     Fragment
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .u4
     </span>
     or
     <span class="pre">
      .s4
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m8n8k32
     </span>
    </p>
   </td>
   <td>
    <p>
     A vector expression containing a single
     <span class="pre">
      .b32
     </span>
     register, containing eight elements from the matrix.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .b1
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m8n8k128
     </span>
    </p>
   </td>
   <td>
    <p>
     A vector expression containing a single
     <span class="pre">
      .b32
     </span>
     register, containing 32 elements from the matrix.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Accumulators (C or D):
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Data-type
    </p>
   </th>
   <th class="head">
    <p>
     Shape
    </p>
   </th>
   <th class="head">
    <p>
     Fragment
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td rowspan="2">
    <p>
     <span class="pre">
      .s32
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m8n8k32
     </span>
    </p>
   </td>
   <td>
    <p>
     A vector expression of two
     <span class="pre">
      .s32
     </span>
     registers.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .m8n8k128
     </span>
    </p>
   </td>
   <td>
    <p>
     A vector expression of two
     <span class="pre">
      .s32
     </span>
     registers.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Manipulating fragment contents
 </p>
 <p>
  The contents of a matrix fragment can be manipulated by reading and writing to individual
registers in the fragment, provided the following conditions are satisfied:
 </p>
 <ul class="simple">
  <li>
   <p>
    All matrix element in the fragment are operated on uniformly across threads, using the same
parameters.
   </p>
  </li>
  <li>
   <p>
    The order of the matrix elements is not changed.
   </p>
  </li>
 </ul>
 <p>
  For example, if each register corresponding to a given matrix is multiplied by a uniform constant
value, then the resulting matrix is simply the scaled version of the original matrix.
 </p>
 <p>
  Note that type conversion between
  <span class="pre">
   .f16
  </span>
  and
  <span class="pre">
   .f32
  </span>
  accumulator fragments is not supported in
either direction. The result is undefined even if the order of elements in the fragment remains
unchanged.
 </p>
 <h5>
  <span class="section-number">
   9.7.13.3.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-storage">
   Matrix Storage for WMMA
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-storage-for-wmma" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  Each matrix can be stored in memory with a
  row-major
  or
  column-major
  layout. In a
  row-major
  format, consecutive elements of each row are stored in contiguous memory locations, and the row is
called the
  leading dimension
  of the matrix. In a
  column-major
  format, consecutive elements of
each column are stored in contiguous memory locations and the column is called the
  leading
dimension
  of the matrix.
 </p>
 <p>
  Consecutive instances of the
  leading dimension
  (rows or columns) need not be stored contiguously
in memory. The
  <span class="pre">
   wmma.load
  </span>
  and
  <span class="pre">
   wmma.store
  </span>
  operations accept an optional argument
  <span class="pre">
   stride
  </span>
  that specifies the offset from the beginning of each row (or column) to the next, in terms of matrix
elements (and not bytes). For example, the matrix being accessed by a
  <span class="pre">
   wmma
  </span>
  operation may be a
submatrix from a larger matrix stored in memory. This allows the programmer to compose a
multiply-and-accumulate operation on matrices that are larger than the shapes supported by the
  <span class="pre">
   wmma
  </span>
  operation.
 </p>
 <p>
  Address Alignment:
 </p>
 <p>
  The starting address of each instance of the leading dimension (row or column) must be aligned
with the size of the corresponding fragment in bytes. Note that the starting address is
determined by the base pointer and the optional
  <span class="pre">
   stride
  </span>
  .
 </p>
 <p>
  Consider the following instruction as an example:
 </p>
 <pre>wmma.load.a.sync.aligned.row.m16n16k16.f16 {x0,...,x7}, [p], s;
</pre>
 <ul class="simple">
  <li>
   <p>
    Fragment size in bytes = 32 (eight elements of type
    <span class="pre">
     .f16x2
    </span>
    )
   </p>
  </li>
  <li>
   <p>
    Actual
    <span class="pre">
     stride
    </span>
    in bytes = 2 *
    <span class="pre">
     s
    </span>
    (since
    <span class="pre">
     stride
    </span>
    is specified in terms of
    <span class="pre">
     .f16
    </span>
    elements, not bytes)
   </p>
  </li>
  <li>
   <p>
    For each row of this matrix to be aligned at fragment size the following must be true:
   </p>
   <ol class="arabic simple">
    <li>
     <p>
      <span class="pre">
       p
      </span>
      is a multiple of 32.
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       2*s
      </span>
      is a multiple of 32.
     </p>
    </li>
   </ol>
  </li>
 </ul>
 <p>
  Default value for stride:
 </p>
 <p>
  The default value of the
  <span class="pre">
   stride
  </span>
  is the size of the
  leading dimension
  of the matrix. For
example, for an
  <span class="pre">
   MxK
  </span>
  matrix, the
  <span class="pre">
   stride
  </span>
  is
  <span class="pre">
   K
  </span>
  for a
  row-major
  layout and
  <span class="pre">
   M
  </span>
  for a
  column-major
  layout. In particular, the default strides for the supported matrix shapes are as
follows:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Shape
    </p>
   </th>
   <th class="head">
    <p>
     A (row)
    </p>
   </th>
   <th class="head">
    <p>
     A (column)
    </p>
   </th>
   <th class="head">
    <p>
     B (row)
    </p>
   </th>
   <th class="head">
    <p>
     B (column)
    </p>
   </th>
   <th class="head">
    <p>
     Accumulator (row)
    </p>
   </th>
   <th class="head">
    <p>
     Accumulator (column)
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     16x16x16
    </p>
   </td>
   <td>
    <p>
     16
    </p>
   </td>
   <td>
    <p>
     16
    </p>
   </td>
   <td>
    <p>
     16
    </p>
   </td>
   <td>
    <p>
     16
    </p>
   </td>
   <td>
    <p>
     16
    </p>
   </td>
   <td>
    <p>
     16
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     8x32x16
    </p>
   </td>
   <td>
    <p>
     16
    </p>
   </td>
   <td>
    <p>
     8
    </p>
   </td>
   <td>
    <p>
     32
    </p>
   </td>
   <td>
    <p>
     16
    </p>
   </td>
   <td>
    <p>
     32
    </p>
   </td>
   <td>
    <p>
     8
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     32x8x16
    </p>
   </td>
   <td>
    <p>
     16
    </p>
   </td>
   <td>
    <p>
     32
    </p>
   </td>
   <td>
    <p>
     8
    </p>
   </td>
   <td>
    <p>
     16
    </p>
   </td>
   <td>
    <p>
     8
    </p>
   </td>
   <td>
    <p>
     32
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     8x8x32
    </p>
   </td>
   <td>
    <p>
     32
    </p>
   </td>
   <td>
    <p>
     8
    </p>
   </td>
   <td>
    <p>
     8
    </p>
   </td>
   <td>
    <p>
     32
    </p>
   </td>
   <td>
    <p>
     8
    </p>
   </td>
   <td>
    <p>
     8
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     8x8x128
    </p>
   </td>
   <td>
    <p>
     128
    </p>
   </td>
   <td>
    <p>
     8
    </p>
   </td>
   <td>
    <p>
     8
    </p>
   </td>
   <td>
    <p>
     128
    </p>
   </td>
   <td>
    <p>
     8
    </p>
   </td>
   <td>
    <p>
     8
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     16x16x8
    </p>
   </td>
   <td>
    <p>
     8
    </p>
   </td>
   <td>
    <p>
     16
    </p>
   </td>
   <td>
    <p>
     16
    </p>
   </td>
   <td>
    <p>
     8
    </p>
   </td>
   <td>
    <p>
     16
    </p>
   </td>
   <td>
    <p>
     16
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     8x8x4
    </p>
   </td>
   <td>
    <p>
     4
    </p>
   </td>
   <td>
    <p>
     8
    </p>
   </td>
   <td>
    <p>
     8
    </p>
   </td>
   <td>
    <p>
     4
    </p>
   </td>
   <td>
    <p>
     8
    </p>
   </td>
   <td>
    <p>
     8
    </p>
   </td>
  </tr>
 </table>
 <h5>
  <span class="section-number">
   9.7.13.3.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-instructions-wmma-ld">
   Warp-level Matrix Load Instruction: wmma.load
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-load-instruction-wmma-load" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  wmma.load
 </p>
 <p>
  Collectively load a matrix from memory for WMMA
 </p>
 <p>
  Syntax
 </p>
 <p>
  Floating point format
  <span class="pre">
   .f16
  </span>
  loads:
 </p>
 <pre>wmma.load.a.sync.aligned.layout.shape{.ss}.atype r, [p] {, stride};
wmma.load.b.sync.aligned.layout.shape{.ss}.btype r, [p] {, stride};
wmma.load.c.sync.aligned.layout.shape{.ss}.ctype r, [p] {, stride};

.layout = {.row, .col};
.shape  = {.m16n16k16, .m8n32k16, .m32n8k16};
.ss     = {.global, .shared{::cta}};
.atype  = {.f16, .s8, .u8};
.btype  = {.f16, .s8, .u8};
.ctype  = {.f16, .f32, .s32};
</pre>
 <p>
  Alternate floating point format
  <span class="pre">
   .bf16
  </span>
  loads:
 </p>
 <pre>wmma.load.a.sync.aligned.layout.shape{.ss}.atype r, [p] {, stride}
wmma.load.b.sync.aligned.layout.shape{.ss}.btype r, [p] {, stride}
wmma.load.c.sync.aligned.layout.shape{.ss}.ctype r, [p] {, stride}
.layout = {.row, .col};
.shape  = {.m16n16k16, .m8n32k16, .m32n8k16};
.ss     = {.global, .shared{::cta}};
.atype  = {.bf16 };
.btype  = {.bf16 };
.ctype  = {.f32 };
</pre>
 <p>
  Alternate floating point format
  <span class="pre">
   .tf32
  </span>
  loads:
 </p>
 <pre>wmma.load.a.sync.aligned.layout.shape{.ss}.atype r, [p] {, stride}
wmma.load.b.sync.aligned.layout.shape{.ss}.btype r, [p] {, stride}
wmma.load.c.sync.aligned.layout.shape{.ss}.ctype r, [p] {, stride}
.layout = {.row, .col};
.shape  = {.m16n16k8 };
.ss     = {.global, .shared{::cta}};
.atype  = {.tf32 };
.btype  = {.tf32 };
.ctype  = {.f32 };
</pre>
 <p>
  Double precision Floating point
  <span class="pre">
   .f64
  </span>
  loads:
 </p>
 <pre>wmma.load.a.sync.aligned.layout.shape{.ss}.atype r, [p] {, stride}
wmma.load.b.sync.aligned.layout.shape{.ss}.btype r, [p] {, stride}
wmma.load.c.sync.aligned.layout.shape{.ss}.ctype r, [p] {, stride}
.layout = {.row, .col};
.shape  = {.m8n8k4 };
.ss     = {.global, .shared{::cta}};
.atype  = {.f64 };
.btype  = {.f64 };
.ctype  = {.f64 };
</pre>
 <p>
  Sub-byte loads:
 </p>
 <pre>wmma.load.a.sync.aligned.row.shape{.ss}.atype r, [p] {, stride}
wmma.load.b.sync.aligned.col.shape{.ss}.btype r, [p] {, stride}
wmma.load.c.sync.aligned.layout.shape{.ss}.ctype r, [p] {, stride}
.layout = {.row, .col};
.shape  = {.m8n8k32};
.ss     = {.global, .shared{::cta}};
.atype  = {.s4, .u4};
.btype  = {.s4, .u4};
.ctype  = {.s32};
</pre>
 <p>
  Single-bit loads:
 </p>
 <pre>wmma.load.a.sync.aligned.row.shape{.ss}.atype r, [p] {, stride}
wmma.load.b.sync.aligned.col.shape{.ss}.btype r, [p] {, stride}
wmma.load.c.sync.aligned.layout.shape{.ss}.ctype r, [p] {, stride}
.layout = {.row, .col};
.shape  = {.m8n8k128};
.ss     = {.global, .shared{::cta}};
.atype  = {.b1};
.btype  = {.b1};
.ctype  = {.s32};
</pre>
 <p>
  Description
 </p>
 <p>
  Collectively load a matrix across all threads in a warp from the location indicated by address
operand
  <span class="pre">
   p
  </span>
  in the specified state space into destination register
  <span class="pre">
   r
  </span>
  .
 </p>
 <p>
  If no state space is given, perform the memory accesses using
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#generic-addressing">
   Generic Addressing
  </a>
  .
  <span class="pre">
   wmma.load
  </span>
  operation may be used only with
  <span class="pre">
   .global
  </span>
  and
  <span class="pre">
   .shared
  </span>
  spaces and with generic addressing, where the address points to
  <span class="pre">
   .global
  </span>
  or
  <span class="pre">
   .shared
  </span>
  space.
 </p>
 <p>
  The mutually exclusive qualifiers
  <span class="pre">
   .a
  </span>
  ,
  <span class="pre">
   .b
  </span>
  and
  <span class="pre">
   .c
  </span>
  indicate whether matrix A, B or C is
being loaded respectively for the
  <span class="pre">
   wmma
  </span>
  computation.
 </p>
 <p>
  The destination operand
  <span class="pre">
   r
  </span>
  is a brace-enclosed vector expression that can hold the fragment
returned by the load operation, as described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment">
   Matrix Fragments for WMMA
  </a>
  .
 </p>
 <p>
  The
  <span class="pre">
   .shape
  </span>
  qualifier indicates the dimensions of all the matrix arguments involved in the
intended
  <span class="pre">
   wmma
  </span>
  computation.
 </p>
 <p>
  The
  <span class="pre">
   .layout
  </span>
  qualifier indicates whether the matrix to be loaded is stored in
  row-major
  or
  column-major
  format.
 </p>
 <p>
  <span class="pre">
   stride
  </span>
  is an optional 32-bit integer operand that provides an offset in terms of matrix elements
between the start of consecutive instances of the
  leading dimension
  (rows or columns). The default
value of
  <span class="pre">
   stride
  </span>
  is described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-storage">
   Matrix Storage for WMMA
  </a>
  and must be specified if the actual value is larger than
the default. For example, if the matrix is a sub-matrix of a larger matrix, then the value of stride
is the leading dimension of the larger matrix. Specifying a value lower than the default value
results in undefined behavior.
 </p>
 <p>
  The required alignment for address
  <span class="pre">
   p
  </span>
  and
  <span class="pre">
   stride
  </span>
  is described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-storage">
   Matrix Storage for WMMA
  </a>
  .
 </p>
 <p>
  The mandatory
  <span class="pre">
   .sync
  </span>
  qualifier indicates that
  <span class="pre">
   wmma.load
  </span>
  causes the executing thread to wait
until all threads in the warp execute the same
  <span class="pre">
   wmma.load
  </span>
  instruction before resuming execution.
 </p>
 <p>
  The mandatory
  <span class="pre">
   .aligned
  </span>
  qualifier indicates that all threads in the warp must execute the same
  <span class="pre">
   wmma.load
  </span>
  instruction. In conditionally executed code, a
  <span class="pre">
   wmma.load
  </span>
  instruction should only
be used if it is known that all threads in the warp evaluate the condition identically, otherwise
behavior is undefined.
 </p>
 <p>
  The behavior of
  <span class="pre">
   wmma.load
  </span>
  is undefined if all threads do not use the same qualifiers and the
same values of
  <span class="pre">
   p
  </span>
  and
  <span class="pre">
   stride
  </span>
  , or if any thread in the warp has exited.
 </p>
 <p>
  <span class="pre">
   wmma.load
  </span>
  is treated as a
  weak
  memory operation in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory Consistency Model
  </a>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 6.0.
 </p>
 <p>
  <span class="pre">
   .m8n32k16
  </span>
  and
  <span class="pre">
   .m32n8k16
  </span>
  introduced in PTX ISA version 6.1.
 </p>
 <p>
  Integer, sub-byte integer and single-bit
  <span class="pre">
   wmma
  </span>
  introduced in PTX ISA version 6.3.
 </p>
 <p>
  <span class="pre">
   .m8n8k4
  </span>
  and
  <span class="pre">
   .m16n16k8
  </span>
  on
  <span class="pre">
   wmma
  </span>
  introduced in PTX ISA version 7.0.
 </p>
 <p>
  Double precision and alternate floating point precision
  <span class="pre">
   wmma
  </span>
  introduced in PTX ISA version 7.0.
 </p>
 <p>
  Modifier
  <span class="pre">
   .aligned
  </span>
  is required from PTX ISA version 6.3 onwards, and considered implicit in PTX
ISA versions less than 6.3.
 </p>
 <p>
  Support for
  <span class="pre">
   ::cta
  </span>
  sub-qualifier introduced in PTX ISA version 7.8.
 </p>
 Preview Feature:
 <p>
  Sub-byte
  <span class="pre">
   wmma
  </span>
  and single-bit
  <span class="pre">
   wmma
  </span>
  are preview features in PTX ISA version 6.3. All
details are subject to change with no guarantees of backward compatibility on future PTX ISA
versions or SM architectures.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Floating point
  <span class="pre">
   wmma
  </span>
  requires
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  Integer
  <span class="pre">
   wmma
  </span>
  requires
  <span class="pre">
   sm_72
  </span>
  or higher.
 </p>
 <p>
  Sub-byte and single-bit
  <span class="pre">
   wmma
  </span>
  requires
  <span class="pre">
   sm_75
  </span>
  or higher.
 </p>
 <p>
  Double precision and alternate floating point precision
  <span class="pre">
   wmma
  </span>
  requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>// Load elements from f16 row-major matrix B
.reg .b32 x&lt;8&gt;;

wmma.load.b.sync.aligned.m16n16k16.row.f16 {x0,x1,x2,x3,x4,x5,x,x7}, [ptr];
// Now use {x0, ..., x7} for the actual wmma.mma

// Load elements from f32 column-major matrix C and scale the values:
.reg .b32 x&lt;8&gt;;

wmma.load.c.sync.aligned.m16n16k16.col.f32
                 {x0,x1,x2,x3,x4,x5,x6,x7}, [ptr];

mul.f32 x0, x0, 0.1;
// repeat for all registers x&lt;8&gt;;
...
mul.f32 x7, x7, 0.1;
// Now use {x0, ..., x7} for the actual wmma.mma

// Load elements from integer matrix A:
.reg .b32 x&lt;4&gt;
// destination registers x&lt;4&gt; contain four packed .u8 values each
wmma.load.a.sync.aligned.m32n8k16.row.u8 {x0,x1,x2,x3}, [ptr];

// Load elements from sub-byte integer matrix A:
.reg .b32 x0;
// destination register x0 contains eight packed .s4 values
wmma.load.a.sync.aligned.m8n8k32.row.s4 {x0}, [ptr];

// Load elements from .bf16 matrix A:
.reg .b32 x&lt;4&gt;;
wmma.load.a.sync.aligned.m16n16k16.row.bf16
                {x0,x1,x2,x3}, [ptr];

// Load elements from .tf32 matrix A:
.reg .b32 x&lt;4&gt;;
wmma.load.a.sync.aligned.m16n16k8.row.tf32
                {x0,x1,x2,x3}, [ptr];

// Load elements from .f64 matrix A:
.reg .b32 x&lt;4&gt;;
wmma.load.a.sync.aligned.m8n8k4.row.f64
                {x0}, [ptr];
</pre>
 <h5>
  <span class="section-number">
   9.7.13.3.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-instructions-wmma-st">
   Warp-level Matrix Store Instruction: wmma.store
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-store-instruction-wmma-store" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  wmma.store
 </p>
 <p>
  Collectively store a matrix into memory for WMMA
 </p>
 <p>
  Syntax
 </p>
 <pre>wmma.store.d.sync.aligned.layout.shape{.ss}.type [p], r {, stride};

.layout = {.row, .col};
.shape  = {.m16n16k16, .m8n32k16, .m32n8k16};
.ss     = {.global, .shared{::cta}};
.type   = {.f16, .f32, .s32};

wmma.store.d.sync.aligned.layout.shape{.ss}.type [p], r {, stride}
.layout = {.row, .col};
.shape  = {.m8n8k32, .m8n8k128};
.ss     = {.global, .shared{::cta}};
.type   = {.s32};

wmma.store.d.sync.aligned.layout.shape{.ss}.type [p], r {, stride}
.layout = {.row, .col};
.shape  = {.m16n16k8};
.ss     = {.global, .shared{::cta}};
.type   = {.f32};

wmma.store.d.sync.aligned.layout.shape{.ss}.type [p], r {, stride}
.layout = {.row, .col};
.shape  = {.m8n8k4 };
.ss     = {.global, .shared{::cta}};
.type   = {.f64};
</pre>
 <p>
  Description
 </p>
 <p>
  Collectively store a matrix across all threads in a warp at the location indicated by address
operand
  <span class="pre">
   p
  </span>
  in the specified state space from source register
  <span class="pre">
   r
  </span>
  .
 </p>
 <p>
  If no state space is given, perform the memory accesses using
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#generic-addressing">
   Generic Addressing
  </a>
  .
  <span class="pre">
   wmma.load
  </span>
  operation may be used only with
  <span class="pre">
   .global
  </span>
  and
  <span class="pre">
   .shared
  </span>
  spaces and with generic addressing, where the address points to
  <span class="pre">
   .global
  </span>
  or
  <span class="pre">
   .shared
  </span>
  space.
 </p>
 <p>
  The source operand
  <span class="pre">
   r
  </span>
  is a brace-enclosed vector expression that matches the shape of the
fragment expected by the store operation, as described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment">
   Matrix Fragments for WMMA
  </a>
  .
 </p>
 <p>
  The
  <span class="pre">
   .shape
  </span>
  qualifier indicates the dimensions of all the matrix arguments involved in the
intended
  <span class="pre">
   wmma
  </span>
  computation. It must match the
  <span class="pre">
   .shape
  </span>
  qualifier specified on the
  <span class="pre">
   wmma.mma
  </span>
  instruction that produced the D matrix being stored.
 </p>
 <p>
  The
  <span class="pre">
   .layout
  </span>
  qualifier indicates whether the matrix to be loaded is stored in
  row-major
  or
  column-major
  format.
 </p>
 <p>
  <span class="pre">
   stride
  </span>
  is an optional 32-bit integer operand that provides an offset in terms of matrix elements
between the start of consecutive instances of the
  leading dimension
  (rows or columns). The default
value of
  <span class="pre">
   stride
  </span>
  is described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-storage">
   Matrix Storage for WMMA
  </a>
  and must be specified if the actual value is larger than
the default. For example, if the matrix is a sub-matrix of a larger matrix, then the value of stride
is the leading dimension of the larger matrix. Specifying a value lower than the default value
results in undefined behavior.
 </p>
 <p>
  The required alignment for address
  <span class="pre">
   p
  </span>
  and
  <span class="pre">
   stride
  </span>
  is described in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-storage">
   Matrix Storage for WMMA
  </a>
  .
 </p>
 <p>
  The mandatory
  <span class="pre">
   .sync
  </span>
  qualifier indicates that
  <span class="pre">
   wmma.store
  </span>
  causes the executing thread to wait
until all threads in the warp execute the same
  <span class="pre">
   wmma.store
  </span>
  instruction before resuming execution.
 </p>
 <p>
  The mandatory
  <span class="pre">
   .aligned
  </span>
  qualifier indicates that all threads in the warp must execute the same
  <span class="pre">
   wmma.store
  </span>
  instruction. In conditionally executed code, a
  <span class="pre">
   wmma.store
  </span>
  instruction should only
be used if it is known that all threads in the warp evaluate the condition identically, otherwise
behavior is undefined.
 </p>
 <p>
  The behavior of
  <span class="pre">
   wmma.store
  </span>
  is undefined if all threads do not use the same qualifiers and the
same values of
  <span class="pre">
   p
  </span>
  and
  <span class="pre">
   stride
  </span>
  , or if any thread in the warp has exited.
 </p>
 <p>
  <span class="pre">
   wmma.store
  </span>
  is treated as a
  weak
  memory operation in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory Consistency Model
  </a>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 6.0.
 </p>
 <p>
  <span class="pre">
   .m8n32k16
  </span>
  and
  <span class="pre">
   .m32n8k16
  </span>
  introduced in PTX ISA version 6.1.
 </p>
 <p>
  Integer, sub-byte integer and single-bit
  <span class="pre">
   wmma
  </span>
  introduced in PTX ISA version 6.3.
 </p>
 <p>
  <span class="pre">
   .m16n16k8
  </span>
  introduced in PTX ISA version 7.0.
 </p>
 <p>
  Double precision
  <span class="pre">
   wmma
  </span>
  introduced in PTX ISA version 7.0.
 </p>
 <p>
  Modifier
  <span class="pre">
   .aligned
  </span>
  is required from PTX ISA version 6.3 onwards, and considered implicit in PTX
ISA versions less than 6.3.
 </p>
 <p>
  Support for
  <span class="pre">
   ::cta
  </span>
  sub-qualifier introduced in PTX ISA version 7.8.
 </p>
 Preview Feature:
 <p>
  Sub-byte
  <span class="pre">
   wmma
  </span>
  and single-bit
  <span class="pre">
   wmma
  </span>
  are preview features in PTX ISA version 6.3. All
details are subject to change with no guarantees of backward compatibility on future PTX ISA
versions or SM architectures.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Floating point
  <span class="pre">
   wmma
  </span>
  requires
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  Integer
  <span class="pre">
   wmma
  </span>
  requires
  <span class="pre">
   sm_72
  </span>
  or higher.
 </p>
 <p>
  Sub-byte and single-bit
  <span class="pre">
   wmma
  </span>
  requires
  <span class="pre">
   sm_75
  </span>
  or higher.
 </p>
 <p>
  Double precision
  <span class="pre">
   wmma
  </span>
  and shape
  <span class="pre">
   .m16n16k8
  </span>
  requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>// Storing f32 elements computed by a wmma.mma
.reg .b32 x&lt;8&gt;;

wmma.mma.sync.m16n16k16.row.col.f32.f32
              {d0, d1, d2, d3, d4, d5, d6, d7}, ...;
wmma.store.d.sync.m16n16k16.row.f32
              [ptr], {d0, d1, d2, d3, d4, d5, d6, d7};

// Store s32 accumulator for m16n16k16 shape:
.reg .b32 d&lt;8&gt;;
wmma.store.d.sync.aligned.m16n16k16.row.s32
              [ptr], {d0, d1, d2, d3, d4, d5, d6, d7};

// Store s32 accumulator for m8n8k128 shape:
.reg .b32 d&lt;2&gt;
wmma.store.d.sync.aligned.m8n8k128.row.s32
[ptr], {d0, d1};

// Store f64 accumulator for m8n8k4 shape:
.reg .f64 d&lt;2&gt;;
wmma.store.d.sync.aligned.m8n8k4.row.f64
              [ptr], {d0, d1};
</pre>
 <h5>
  <span class="section-number">
   9.7.13.3.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-instructions-wmma-mma">
   Warp-level Matrix Multiply-and-Accumulate Instruction: wmma.mma
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-multiply-and-accumulate-instruction-wmma-mma" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  wmma.mma
 </p>
 <p>
  Perform a single matrix multiply-and-accumulate operation across a warp
 </p>
 <p>
  Syntax
 </p>
 <pre>// Floating point (.f16 multiplicands) wmma.mma
wmma.mma.sync.aligned.alayout.blayout.shape.dtype.ctype d, a, b, c;

// Integer (.u8/.s8 multiplicands) wmma.mma
wmma.mma.sync.aligned.alayout.blayout.shape.s32.atype.btype.s32{.satfinite} d, a, b, c;

.alayout = {.row, .col};
.blayout = {.row, .col};
.shape  =  {.m16n16k16, .m8n32k16, .m32n8k16};
.dtype   = {.f16, .f32};
.atype   = {.s8, .u8};
.btype   = {.s8, .u8};
.ctype   = {.f16, .f32};
</pre>
 <p>
  Floating point format
  <span class="pre">
   .bf16
  </span>
  <span class="pre">
   wmma.mma
  </span>
  :
 </p>
 <pre>wmma.mma.sync.aligned.alayout.blayout.shape.f32.atype.btype.f32 d, a, b, c;
.alayout = {.row, .col};
.blayout = {.row, .col};
.shape   = {.m16n16k16, .m8n32k16, .m32n8k16};
.atype   = {.bf16 };
.btype   = {.bf16};
</pre>
 <p>
  Floating point format
  <span class="pre">
   .tf32
  </span>
  <span class="pre">
   wmma.mma
  </span>
  :
 </p>
 <pre>wmma.mma.sync.aligned.alayout.blayout.shape.f32.atype.btype.f32 d, a, b, c;
.alayout = {.row, .col};
.blayout = {.row, .col};
.shape   = {.m16n16k8 };
.atype   = {.tf32 };
.btype   = {.tf32};
</pre>
 <p>
  Floating point Double precision
  <span class="pre">
   wmma.mma
  </span>
  :
 </p>
 <pre>wmma.mma.sync.aligned.alayout.blayout.shape{.rnd}.f64.f64.f64.f64 d, a, b, c;
.alayout = {.row, .col};
.blayout = {.row, .col};
.shape   = {.m8n8k4 };
.rnd = { .rn, .rz, .rm, .rp };
</pre>
 <p>
  Sub-byte (
  <span class="pre">
   .u4
  </span>
  /
  <span class="pre">
   .s4
  </span>
  multiplicands)
  <span class="pre">
   wmma.mma
  </span>
  :
 </p>
 <pre>wmma.mma.sync.aligned.row.col.shape.s32.atype.btype.s32{.satfinite} d, a, b, c;
.shape  = {.m8n8k32};
.atype  = {.s4, .u4};
.btype  = {.s4, .u4};
</pre>
 <p>
  Single-bit (
  <span class="pre">
   .b1
  </span>
  multiplicands)
  <span class="pre">
   wmma.mma
  </span>
  :
 </p>
 <pre>wmma.mma.op.popc.sync.aligned.row.col.shape.s32.atype.btype.s32 d, a, b, c;
.shape  = {.m8n8k128};
.atype  = {.b1};
.btype  = {.b1};
.op     = {.xor, .and}
</pre>
 <p>
  Description
 </p>
 <p>
  Perform a warp-level matrix multiply-and-accumulate computation
  <span class="pre">
   D
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   A
  </span>
  <span class="pre">
   *
  </span>
  <span class="pre">
   B
  </span>
  <span class="pre">
   +
  </span>
  <span class="pre">
   C
  </span>
  using matrices A,
B and C loaded in registers
  <span class="pre">
   a
  </span>
  ,
  <span class="pre">
   b
  </span>
  and
  <span class="pre">
   c
  </span>
  respectively, and store the result matrix in
register
  <span class="pre">
   d
  </span>
  . The register arguments
  <span class="pre">
   a
  </span>
  ,
  <span class="pre">
   b
  </span>
  ,
  <span class="pre">
   c
  </span>
  and
  <span class="pre">
   d
  </span>
  hold unspecified fragments of
the corresponding matrices as described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment">
   Matrix Fragments for WMMA
  </a>
 </p>
 <p>
  The qualifiers
  <span class="pre">
   .dtype
  </span>
  ,
  <span class="pre">
   .atype
  </span>
  ,
  <span class="pre">
   .btype
  </span>
  and
  <span class="pre">
   .ctype
  </span>
  indicate the data-type of the
elements in the matrices D, A, B and C respectively.
 </p>
 <p>
  For
  <span class="pre">
   wmma.mma
  </span>
  without explicit
  <span class="pre">
   .atype
  </span>
  and
  <span class="pre">
   .btype
  </span>
  :
  <span class="pre">
   .atype
  </span>
  and
  <span class="pre">
   .btype
  </span>
  are
implicitly set to
  <span class="pre">
   .f16
  </span>
  .
 </p>
 <p>
  For integer
  <span class="pre">
   wmma
  </span>
  ,
  <span class="pre">
   .ctype
  </span>
  and
  <span class="pre">
   .dtype
  </span>
  must be specified as
  <span class="pre">
   .s32
  </span>
  . Also, the values for
  <span class="pre">
   .atype
  </span>
  and
  <span class="pre">
   .btype
  </span>
  must be the same, i.e., either both are
  <span class="pre">
   .s8
  </span>
  or both are
  <span class="pre">
   .u8
  </span>
  .
 </p>
 <p>
  For sub-byte single-bit
  <span class="pre">
   wmma
  </span>
  ,
  <span class="pre">
   .ctype
  </span>
  and
  <span class="pre">
   .dtype
  </span>
  must be specified as
  <span class="pre">
   .s32
  </span>
  . Also, the
values for
  <span class="pre">
   .atype
  </span>
  and
  <span class="pre">
   .btype
  </span>
  must be the same; i.e., either both are
  <span class="pre">
   .s4
  </span>
  , both are
  <span class="pre">
   .u4
  </span>
  , or both are
  <span class="pre">
   .b1
  </span>
  .
 </p>
 <p>
  For single-bit
  <span class="pre">
   wmma
  </span>
  , multiplication is replaced by a sequence of logical operations;
specifically,
  <span class="pre">
   wmma.xor.popc
  </span>
  and
  <span class="pre">
   wmma.and.popc
  </span>
  computes the XOR, AND respectively of a
128-bit row of A with a 128-bit column of B, then counts the number of set bits in the result
(
  <span class="pre">
   popc
  </span>
  ). This result is added to the corresponding element of C and written into D.
 </p>
 <p>
  The qualifiers
  <span class="pre">
   .alayout
  </span>
  and
  <span class="pre">
   .blayout
  </span>
  must match the layout specified on the
  <span class="pre">
   wmma.load
  </span>
  instructions that produce the contents of operands
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  respectively. Similarly, the
qualifiers
  <span class="pre">
   .atype
  </span>
  ,
  <span class="pre">
   .btype
  </span>
  and
  <span class="pre">
   .ctype
  </span>
  must match the corresponding qualifiers on the
  <span class="pre">
   wmma.load
  </span>
  instructions that produce the contents of operands
  <span class="pre">
   a
  </span>
  ,
  <span class="pre">
   b
  </span>
  and
  <span class="pre">
   c
  </span>
  respectively.
 </p>
 <p>
  The
  <span class="pre">
   .shape
  </span>
  qualifier must match the
  <span class="pre">
   .shape
  </span>
  qualifier used on the
  <span class="pre">
   wmma.load
  </span>
  instructions
that produce the contents of all three input operands
  <span class="pre">
   a
  </span>
  ,
  <span class="pre">
   b
  </span>
  and
  <span class="pre">
   c
  </span>
  respectively.
 </p>
 <p>
  The destination operand
  <span class="pre">
   d
  </span>
  is a brace-enclosed vector expression that matches the
  <span class="pre">
   .shape
  </span>
  of
the fragment computed by the
  <span class="pre">
   wmma.mma
  </span>
  instruction.
 </p>
 Saturation at the output:
 <p>
  The optional qualifier
  <span class="pre">
   .satfinite
  </span>
  indicates that the final values in the destination register
are saturated as follows:
 </p>
 <ul class="simple">
  <li>
   <p>
    The output is clamped to the minimum or maximum 32-bit signed integer value. Otherwise, if the
accumulation would overflow, the value wraps.
   </p>
  </li>
 </ul>
 Precision and rounding for
 <span class="pre">
  .f16
 </span>
 floating point operations:
 <p>
  Element-wise multiplication of matrix A and B is performed with at least single precision. When
  <span class="pre">
   .ctype
  </span>
  or
  <span class="pre">
   .dtype
  </span>
  is
  <span class="pre">
   .f32
  </span>
  , accumulation of the intermediate values is performed with
at least single precision. When both
  <span class="pre">
   .ctype
  </span>
  and
  <span class="pre">
   .dtype
  </span>
  are specified as
  <span class="pre">
   .f16
  </span>
  , the
accumulation is performed with at least half precision.
 </p>
 <p>
  The accumulation order, rounding and handling of subnormal inputs is unspecified.
 </p>
 Precision and rounding for
 <span class="pre">
  .bf16
 </span>
 ,
 <span class="pre">
  .tf32
 </span>
 floating point operations:
 <p>
  Element-wise multiplication of matrix A and B is performed with specified precision. Accumulation
of the intermediate values is performed with at least single precision.
 </p>
 <p>
  The accumulation order, rounding and handling of subnormal inputs is unspecified.
 </p>
 <p>
  Rounding modifiers on double precision
  <span class="pre">
   wmma.mma
  </span>
  (default is
  <span class="pre">
   .rn
  </span>
  ):
 </p>
 <span class="pre">
  .rn
 </span>
 <p>
  mantissa LSB rounds to nearest even
 </p>
 <span class="pre">
  .rz
 </span>
 <p>
  mantissa LSB rounds towards zero
 </p>
 <span class="pre">
  .rm
 </span>
 <p>
  mantissa LSB rounds towards negative infinity
 </p>
 <span class="pre">
  .rp
 </span>
 <p>
  mantissa LSB rounds towards positive infinity
 </p>
 <p>
  The mandatory
  <span class="pre">
   .sync
  </span>
  qualifier indicates that
  <span class="pre">
   wmma.mma
  </span>
  causes the executing thread to wait
until all threads in the warp execute the same
  <span class="pre">
   wmma.mma
  </span>
  instruction before resuming execution.
 </p>
 <p>
  The mandatory
  <span class="pre">
   .aligned
  </span>
  qualifier indicates that all threads in the warp must execute the same
  <span class="pre">
   wmma.mma
  </span>
  instruction. In conditionally executed code, a
  <span class="pre">
   wmma.mma
  </span>
  instruction should only be
used if it is known that all threads in the warp evaluate the condition identically, otherwise
behavior is undefined.
 </p>
 <p>
  The behavior of
  <span class="pre">
   wmma.mma
  </span>
  is undefined if all threads in the same warp do not use the same
qualifiers, or if any thread in the warp has exited.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 6.0.
 </p>
 <p>
  <span class="pre">
   .m8n32k16
  </span>
  and
  <span class="pre">
   .m32n8k16
  </span>
  introduced in PTX ISA version 6.1.
 </p>
 <p>
  Integer, sub-byte integer and single-bit
  <span class="pre">
   wmma
  </span>
  introduced in PTX ISA version 6.3.
 </p>
 <p>
  Double precision and alternate floating point precision
  <span class="pre">
   wmma
  </span>
  introduced in PTX ISA version 7.0.
 </p>
 <p>
  Support for
  <span class="pre">
   .and
  </span>
  operation in single-bit
  <span class="pre">
   wmma
  </span>
  introduced in PTX ISA version 7.1.
 </p>
 <p>
  Modifier
  <span class="pre">
   .aligned
  </span>
  is required from PTX ISA version 6.3 onwards, and considered implicit in PTX
ISA versions less than 6.3.
 </p>
 <p>
  Support for
  <span class="pre">
   .satfinite
  </span>
  on floating point
  <span class="pre">
   wmma.mma
  </span>
  is deprecated in PTX ISA version 6.4 and
is removed from PTX ISA version 6.5.
 </p>
 Preview Feature:
 <p>
  Sub-byte
  <span class="pre">
   wmma
  </span>
  and single-bit
  <span class="pre">
   wmma
  </span>
  are preview features in PTX ISA. All details are
subject to change with no guarantees of backward compatibility on future PTX ISA versions or SM
architectures.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Floating point
  <span class="pre">
   wmma
  </span>
  requires
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  Integer
  <span class="pre">
   wmma
  </span>
  requires
  <span class="pre">
   sm_72
  </span>
  or higher.
 </p>
 <p>
  Sub-byte and single-bit
  <span class="pre">
   wmma
  </span>
  requires
  <span class="pre">
   sm_75
  </span>
  or higher.
 </p>
 <p>
  Double precision, alternate floating point precision
  <span class="pre">
   wmma
  </span>
  require
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   .and
  </span>
  operation in single-bit
  <span class="pre">
   wmma
  </span>
  requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>.global .align 32 .f16 A[256], B[256];
.global .align 32 .f32 C[256], D[256];
.reg .b32 a&lt;8&gt; b&lt;8&gt; c&lt;8&gt; d&lt;8&gt;;

wmma.load.a.sync.aligned.m16n16k16.global.row.f16
        {a0, a1, a2, a3, a4, a5, a6, a7}, [A];
wmma.load.b.sync.aligned.m16n16k16.global.col.f16
        {b0, b1, b2, b3, b4, b5, b6, b7}, [B];

wmma.load.c.sync.aligned.m16n16k16.global.row.f32
        {c0, c1, c2, c3, c4, c5, c6, c7}, [C];

wmma.mma.sync.aligned.m16n16k16.row.col.f32.f32
        {d0, d1, d2, d3, d4, d5, d6, d7},
        {a0, a1, a2, a3, a4, a5, a6, a7},
        {b0, b1, b2, b3, b4, b5, b6, b7},
        {c0, c1, c2, c3, c4, c5, c6, c7};

wmma.store.d.sync.aligned.m16n16k16.global.col.f32
        [D], {d0, d1, d2, d3, d4, d5, d6, d7};

// Compute an integer WMMA:
.reg .b32  a, b&lt;4&gt;;
.reg .b32 c&lt;8&gt;, d&lt;8&gt;;
wmma.mma.sync.aligned.m8n32k16.row.col.s32.s8.s8.s32
        {d0, d1, d2, d3, d4, d5, d6, d7},
        {a}, {b0, b1, b2,  b3},
        {c0, c1, c2, c3, c4, c5, c6, c7};

// Compute sub-byte WMMA:
.reg .b32 a, b, c&lt;2&gt; d&lt;2&gt;
wmma.mma.sync.aligned.m8n8k32.row.col.s32.s4.s4.s32
        {d0, d1}, {a}, {b}, {c0, c1};

// Compute single-bit type WMMA:
.reg .b32 a, b, c&lt;2&gt; d&lt;2&gt;
wmma.mma.xor.popc.sync.aligned.m8n8k128.row.col.s32.b1.b1.s32
        {d0, d1}, {a}, {b}, {c0, c1};

// Compute double precision wmma
.reg .f64 a, b, c&lt;2&gt;, d&lt;2&gt;;
wmma.mma.sync.aligned.m8n8k4.row.col.f64.f64.f64.f64
        {d0, d1}, {a}, {b}, {c0, c1};

// Compute alternate floating point precision wmma
.reg .b32 a&lt;2&gt;, b&lt;2&gt;, c&lt;8&gt;, d&lt;8&gt;;
wmma.mma.sync.aligned.m16n16k8.row.col.f32.tf32.tf32.f32
        {d0, d1, d2, d3, d4, d5, d6, d7},
        {a0, a1, a2, a3}, {b0, b1, b2, b3},
        {c0, c1, c2, c3, c4, c5, c6, c7};
</pre>
 <h4>
  <span class="section-number">
   9.7.13.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-instructions-for-mma">
   Matrix multiply-accumulate operation using mma instruction
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-multiply-accumulate-operation-using-mma-instruction" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  This section describes warp-level
  <span class="pre">
   mma
  </span>
  ,
  <span class="pre">
   ldmatrix
  </span>
  ,
  <span class="pre">
   stmatrix
  </span>
  , and
  <span class="pre">
   movmatrix
  </span>
  instructions and the organization of various matrices involved in these instructions.
 </p>
 <h5>
  <span class="section-number">
   9.7.13.4.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-mma-884-f16">
   Matrix Fragments for mma.m8n8k4 with .f16 floating point type
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-mma-m8n8k4-with-f16-floating-point-type" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  A warp executing
  <span class="pre">
   mma.m8n8k4
  </span>
  with .f16 floating point type will compute 4 MMA operations of shape
  <span class="pre">
   .m8n8k4
  </span>
  .
 </p>
 <p>
  Elements of 4 matrices need to be distributed across the threads in a warp. The following table
shows distribution of matrices for MMA operations.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     MMA Computation
    </p>
   </th>
   <th class="head">
    <p>
     Threads participating in MMA computation
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     MMA computation 1
    </p>
   </td>
   <td>
    <p>
     Threads with
     <span class="pre">
      %laneid
     </span>
     0-3 (low group) and 16-19 (high group)
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     MMA computation 2
    </p>
   </td>
   <td>
    <p>
     Threads with
     <span class="pre">
      %laneid
     </span>
     4-7 (low group) and 20-23 (high group)
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     MMA computation 3
    </p>
   </td>
   <td>
    <p>
     Threads with
     <span class="pre">
      %laneid
     </span>
     8-11 (low group) and 24-27 (high group)
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     MMA computation 4
    </p>
   </td>
   <td>
    <p>
     Threads with
     <span class="pre">
      %laneid
     </span>
     12-15 (low group) and 28-31 (high group)
    </p>
   </td>
  </tr>
 </table>
 <p>
  For each of the individual MMA computation shown above, each of the required thread holds a fragment
of the matrix for performing mma operation as follows:
 </p>
 <ul>
  <li>
   <p>
    Multiplicand A:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .atype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .f16
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing two
       <span class="pre">
        .f16x2
       </span>
       registers,
with each register containing two
       <span class="pre">
        .f16
       </span>
       elements from
the matrix A.
      </p>
     </td>
     <td>
      <p>
       a0, a1, a2, a3
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown below:
   </p>
   <ul>
    <li>
     <p>
      Fragment layout for Row Major matrix A is shown in
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-884-a-row-f16">
       <span class="std std-numref">
        Figure 21
       </span>
      </a>
      .
     </p>
     <p>
      <span class="caption-number">
       Figure 21
      </span>
      <span class="caption-text">
       MMA .m8n8k4 fragment layout for row-major matrix A with
       <span class="pre">
        .f16
       </span>
       type
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-884-a-row-f16" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      The row and column of a matrix fragment can be computed as:
     </p>
     <pre><span class="n">row</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span><span class="k">if</span><span class="o">%</span><span class="n">laneid</span><span class="o">&lt;</span><span class="mi">16</span>
<span class="p">(</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="mi">4</span><span class="n">otherwise</span>

<span class="n">col</span><span class="o">=</span><span class="n">i</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,..,</span><span class="mi">3</span><span class="p">}</span>
</pre>
    </li>
    <li>
     <p>
      Fragment layout for Column Major matrix A is shown in
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-884-a-col-f16">
       <span class="std std-numref">
        Figure 22
       </span>
      </a>
      .
     </p>
     <p>
      The layout of the fragments held by different threads is shown below:
     </p>
     <p>
      <span class="caption-number">
       Figure 22
      </span>
      <span class="caption-text">
       MMA .m8n8k4 fragment layout for column-major matrix A with
       <span class="pre">
        .f16
       </span>
       type
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-884-a-col-f16" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      The row and column of a matrix fragment can be computed as:
     </p>
     <pre><span class="n">row</span><span class="o">=</span><span class="n">i</span><span class="o">%</span><span class="mi">4</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,..,</span><span class="mi">3</span><span class="p">}</span><span class="k">if</span><span class="o">%</span><span class="n">laneid</span><span class="o">&lt;</span><span class="mi">16</span>
<span class="p">(</span><span class="n">i</span><span class="o">%</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="mi">4</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,..,</span><span class="mi">3</span><span class="p">}</span><span class="n">otherwise</span>

<span class="n">col</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>
</pre>
    </li>
   </ul>
  </li>
  <li>
   <p>
    Multiplicand B:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .btype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .f16
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing two
       <span class="pre">
        .f16x2
       </span>
       registers, with each
register containing two
       <span class="pre">
        .f16
       </span>
       elements from the matrix B.
      </p>
     </td>
     <td>
      <p>
       b0, b1, b2, b3
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown below:
   </p>
   <ul>
    <li>
     <p>
      Fragment layout for Row Major matrix B is shown in
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-884-b-row-f16">
       <span class="std std-numref">
        Figure 23
       </span>
      </a>
      .
     </p>
     <p>
      <span class="caption-number">
       Figure 23
      </span>
      <span class="caption-text">
       MMA .m8n8k4 fragment layout for row-major matrix B with
       <span class="pre">
        .f16
       </span>
       type
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-884-b-row-f16" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      The row and column of a matrix fragment can be computed as:
     </p>
     <pre><span class="n">row</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">col</span><span class="o">=</span><span class="n">i</span><span class="k">for</span><span class="n">bi</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,..,</span><span class="mi">3</span><span class="p">}</span><span class="k">if</span><span class="o">%</span><span class="n">laneid</span><span class="o">&lt;</span><span class="mi">16</span>
<span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="k">for</span><span class="n">bi</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,..,</span><span class="mi">3</span><span class="p">}</span><span class="n">otherwise</span>
</pre>
    </li>
    <li>
     <p>
      Fragment layout for Column Major matrix B is shown in
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-884-b-col-f16">
       <span class="std std-numref">
        Figure 24
       </span>
      </a>
      .
     </p>
     <p>
      <span class="caption-number">
       Figure 24
      </span>
      <span class="caption-text">
       MMA .m8n8k4 fragment layout for column-major matrix B with
       <span class="pre">
        .f16
       </span>
       type
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-884-b-col-f16" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      The row and column of a matrix fragment can be computed as:
     </p>
     <pre><span class="n">row</span><span class="o">=</span><span class="n">i</span><span class="k">for</span><span class="n">bi</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,..,</span><span class="mi">3</span><span class="p">}</span>

<span class="n">col</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span><span class="k">if</span><span class="o">%</span><span class="n">laneid</span><span class="o">&lt;</span><span class="mi">16</span>
<span class="p">(</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="mi">4</span><span class="n">otherwise</span>
</pre>
    </li>
   </ul>
  </li>
  <li>
   <p>
    Accumulators C (or D):
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .ctype / .dtype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .f16
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing four
       <span class="pre">
        .f16x2
       </span>
       registers, with
each register containing two
       <span class="pre">
        .f16
       </span>
       elements from the matrix
C (or D).
      </p>
     </td>
     <td rowspan="2">
      <p>
       c0, c1, c2, c3, c4, c5, c6, c7
      </p>
     </td>
    </tr>
    <tr class="row-odd">
     <td>
      <p>
       <span class="pre">
        .f32
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression of eight
       <span class="pre">
        .f32
       </span>
       registers.
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown below:
   </p>
   <ul>
    <li>
     <p>
      Fragment layout for accumulator matrix when
      <span class="pre">
       .ctype
      </span>
      is
      <span class="pre">
       .f16
      </span>
      is shown in
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-884-c-f16">
       <span class="std std-numref">
        Figure 25
       </span>
      </a>
      .
     </p>
     <p>
      <span class="caption-number">
       Figure 25
      </span>
      <span class="caption-text">
       MMA .m8n8k4 fragment layout for matrix C/D with
       <span class="pre">
        .ctype
       </span>
       =
       <span class="pre">
        .f16
       </span>
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-884-c-f16" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      The row and column of a matrix fragment can be computed as:
     </p>
     <pre><span class="n">row</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span><span class="k">if</span><span class="o">%</span><span class="n">laneid</span><span class="o">&lt;</span><span class="mi">16</span>
<span class="p">(</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="mi">4</span><span class="n">otherwise</span>

<span class="n">col</span><span class="o">=</span><span class="n">i</span><span class="k">for</span><span class="n">ci</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,..,</span><span class="mi">7</span><span class="p">}</span>
</pre>
    </li>
    <li>
     <p>
      Fragment layout for accumulator matrix when
      <span class="pre">
       .ctype
      </span>
      is
      <span class="pre">
       .f32
      </span>
      is shown in
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-884-c-f32-1">
       <span class="std std-numref">
        Figure 26
       </span>
      </a>
      and
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-884-c-f32-2">
       <span class="std std-numref">
        Figure 27
       </span>
      </a>
      .
     </p>
     <p>
      <span class="caption-number">
       Figure 26
      </span>
      <span class="caption-text">
       MMA .m8n8k4 computation 1 and 2 fragment layout for matrix C/D with
       <span class="pre">
        .ctype
       </span>
       =
       <span class="pre">
        .f32
       </span>
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-884-c-f32-1" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      <span class="caption-number">
       Figure 27
      </span>
      <span class="caption-text">
       MMA .m8n8k4 computation 3 and 4 fragment layout for matrix C/D with
       <span class="pre">
        .ctype
       </span>
       =
       <span class="pre">
        .f32
       </span>
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-884-c-f32-2" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      The row and column of a matrix fragment can be computed as:
     </p>
     <pre><span class="n">row</span><span class="o">=</span><span class="n">X</span><span class="k">if</span><span class="o">%</span><span class="n">laneid</span><span class="o">&lt;</span><span class="mi">16</span>
<span class="n">X</span><span class="o">+</span><span class="mi">4</span><span class="n">otherwise</span>

<span class="n">where</span><span class="n">X</span><span class="o">=</span><span class="p">(</span><span class="o">%</span><span class="n">laneid</span><span class="o">&amp;</span><span class="mb">0b1</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mb">0b10</span><span class="p">)</span><span class="k">for</span><span class="n">ci</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,..,</span><span class="mi">7</span><span class="p">}</span>

<span class="n">col</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mb">0b100</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="o">%</span><span class="n">laneid</span><span class="o">&amp;</span><span class="mb">0b10</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mb">0b1</span><span class="p">)</span><span class="k">for</span><span class="n">ci</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,..,</span><span class="mi">7</span><span class="p">}</span>
</pre>
    </li>
   </ul>
  </li>
 </ul>
 <h5>
  <span class="section-number">
   9.7.13.4.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-mma-884-f64">
   Matrix Fragments for mma.m8n8k4 with .f64 floating point type
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-mma-m8n8k4-with-f64-floating-point-type" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  A warp executing
  <span class="pre">
   mma.m8n8k4
  </span>
  with
  <span class="pre">
   .f64
  </span>
  floating point type will compute an MMA operation of
shape
  <span class="pre">
   .m8n8k4
  </span>
  .
 </p>
 <p>
  Elements of the matrix are distributed across the threads in a warp so each thread of the warp holds
a fragment of the matrix.
 </p>
 <ul>
  <li>
   <p>
    Multiplicand A:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .atype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .f64
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing a single
       <span class="pre">
        .f64
       </span>
       register, containing
single
       <span class="pre">
        .f64
       </span>
       element from the matrix A.
      </p>
     </td>
     <td>
      <p>
       a0
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-884-a-f64">
     <span class="std std-numref">
      Figure 28
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 28
    </span>
    <span class="caption-text">
     MMA .m8n8k4 fragment layout for matrix A  with
     <span class="pre">
      .f64
     </span>
     type
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-884-a-f64" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">row</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>

<span class="n">col</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>
</pre>
  </li>
  <li>
   <p>
    Multiplicand B:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .btype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .f64
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing a single
       <span class="pre">
        .f64
       </span>
       register, containing a single
       <span class="pre">
        .f64
       </span>
       element from the matrix B.
      </p>
     </td>
     <td>
      <p>
       b0
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-884-b-f64">
     <span class="std std-numref">
      Figure 29
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 29
    </span>
    <span class="caption-text">
     MMA .m8n8k4 fragment layout for matrix B  with
     <span class="pre">
      .f64
     </span>
     type
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-884-b-f64" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">row</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">col</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
</pre>
  </li>
  <li>
   <p>
    Accumulators (C or D):
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .ctype / .dtype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .f64
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing of two
       <span class="pre">
        .f64
       </span>
       registers containing two
       <span class="pre">
        .f64
       </span>
       elements from the matrix C.
      </p>
     </td>
     <td>
      <p>
       c0, c1
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-884-c-f64">
     <span class="std std-numref">
      Figure 30
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 30
    </span>
    <span class="caption-text">
     MMA .m8n8k4 fragment layout for accumulator matrix C/D  with
     <span class="pre">
      .f64
     </span>
     type
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-884-c-f64" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span>

<span class="n">col</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x1</span><span class="p">)</span><span class="k">for</span><span class="n">ci</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span>
</pre>
  </li>
 </ul>
 <h5>
  <span class="section-number">
   9.7.13.4.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-mma-8816">
   Matrix Fragments for mma.m8n8k16
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-mma-m8n8k16" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  A warp executing
  <span class="pre">
   mma.m8n8k16
  </span>
  will compute an MMA operation of shape
  <span class="pre">
   .m8n8k16
  </span>
  .
 </p>
 <p>
  Elements of the matrix are distributed across the threads in a warp so each thread of the warp holds
a fragment of the matrix.
 </p>
 <ul>
  <li>
   <p>
    Multiplicand A:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .atype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .s8
       </span>
       /
       <span class="pre">
        .u8
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing a single
       <span class="pre">
        .b32
       </span>
       register, containing
four
       <span class="pre">
        .s8
       </span>
       or
       <span class="pre">
        .u8
       </span>
       elements from the matrix A.
      </p>
     </td>
     <td>
      <p>
       a0, a1, a2, a3
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-8816-a-i8">
     <span class="std std-numref">
      Figure 31
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 31
    </span>
    <span class="caption-text">
     MMA .m8n8k16 fragment layout for matrix A with
     <span class="pre">
      .u8
     </span>
     /
     <span class="pre">
      .s8
     </span>
     type
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-8816-a-i8" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span>

<span class="n">col</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="n">i</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,..,</span><span class="mi">3</span><span class="p">}</span>
</pre>
  </li>
  <li>
   <p>
    Multiplicand B:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .btype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .s8
       </span>
       /
       <span class="pre">
        .u8
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing a single
       <span class="pre">
        .b32
       </span>
       register, containing
four
       <span class="pre">
        .s8
       </span>
       or
       <span class="pre">
        .u8
       </span>
       elements from the matrix B.
      </p>
     </td>
     <td>
      <p>
       b0, b1, b2, b3
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-8816-b-i8">
     <span class="std std-numref">
      Figure 32
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 32
    </span>
    <span class="caption-text">
     MMA .m8n8k16 fragment layout for matrix B with
     <span class="pre">
      .u8
     </span>
     /
     <span class="pre">
      .s8
     </span>
     type
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-8816-b-i8" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="n">i</span><span class="k">for</span><span class="n">bi</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,..,</span><span class="mi">3</span><span class="p">}</span>

<span class="n">col</span><span class="o">=</span><span class="n">groupID</span>
</pre>
  </li>
  <li>
   <p>
    Accumulators (C or D):
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .ctype / .dtype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .s32
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing of two
       <span class="pre">
        .s32
       </span>
       registers.
      </p>
     </td>
     <td>
      <p>
       c0, c1
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-8816-c-i8">
     <span class="std std-numref">
      Figure 33
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 33
    </span>
    <span class="caption-text">
     MMA .m8n8k16 fragment layout for accumulator matrix C/D with
     <span class="pre">
      .s32
     </span>
     type
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-8816-c-i8" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span>

<span class="n">col</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">i</span><span class="k">for</span><span class="n">ci</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span>
</pre>
  </li>
 </ul>
 <h5>
  <span class="section-number">
   9.7.13.4.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-mma-8832">
   Matrix Fragments for mma.m8n8k32
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-mma-m8n8k32" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  A warp executing
  <span class="pre">
   mma.m8n8k32
  </span>
  will compute an MMA operation of shape
  <span class="pre">
   .m8n8k32
  </span>
  .
 </p>
 <p>
  Elements of the matrix are distributed across the threads in a warp so each thread of the warp holds
a fragment of the matrix.
 </p>
 <ul>
  <li>
   <p>
    Multiplicand A:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .atype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .s4
       </span>
       /
       <span class="pre">
        .u4
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing a single
       <span class="pre">
        .b32
       </span>
       register, containing
eight
       <span class="pre">
        .s4
       </span>
       or
       <span class="pre">
        .u4
       </span>
       elements from the matrix A.
      </p>
     </td>
     <td>
      <p>
       a0, a1, a2, a3, a4, a5, a6, a7
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-8832-a-i4">
     <span class="std std-numref">
      Figure 34
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 34
    </span>
    <span class="caption-text">
     MMA .m8n8k32 fragment layout for matrix A with
     <span class="pre">
      .u4
     </span>
     /
     <span class="pre">
      .s4
     </span>
     type
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-8832-a-i4" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span>

<span class="n">col</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span><span class="o">+</span><span class="n">i</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,..,</span><span class="mi">7</span><span class="p">}</span>
</pre>
  </li>
  <li>
   <p>
    Multiplicand B:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .btype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .s4
       </span>
       /
       <span class="pre">
        .u4
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing a single
       <span class="pre">
        .b32
       </span>
       register, containing
eight
       <span class="pre">
        .s4
       </span>
       or
       <span class="pre">
        .u4
       </span>
       elements from the matrix B.
      </p>
     </td>
     <td>
      <p>
       b0, b1, b2, b3, b4, b5, b6, b7
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-8832-b-i4">
     <span class="std std-numref">
      Figure 35
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 35
    </span>
    <span class="caption-text">
     MMA .m8n8k32 fragment layout for matrix B with
     <span class="pre">
      .u4
     </span>
     /
     <span class="pre">
      .s4
     </span>
     type
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-8832-b-i4" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span><span class="o">+</span><span class="n">i</span><span class="k">for</span><span class="n">bi</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,..,</span><span class="mi">7</span><span class="p">}</span>

<span class="n">col</span><span class="o">=</span><span class="n">groupID</span>
</pre>
  </li>
  <li>
   <p>
    Accumulators (C or D):
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .ctype / .dtype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .s32
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression of two
       <span class="pre">
        .s32
       </span>
       registers.
      </p>
     </td>
     <td>
      <p>
       c0, c1
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-8832-c-i4">
     <span class="std std-numref">
      Figure 36
     </span>
    </a>
    :
   </p>
   <p>
    <span class="caption-number">
     Figure 36
    </span>
    <span class="caption-text">
     MMA .m8n8k32 fragment layout for accumulator matrix C/D with
     <span class="pre">
      .s32
     </span>
     type
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-8832-c-i4" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span>
<span class="n">col</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">i</span><span class="k">for</span><span class="n">ci</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span>
</pre>
  </li>
 </ul>
 <h5>
  <span class="section-number">
   9.7.13.4.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-mma-88128">
   Matrix Fragments for mma.m8n8k128
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-mma-m8n8k128" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  A warp executing
  <span class="pre">
   mma.m8n8k128
  </span>
  will compute an MMA operation of shape
  <span class="pre">
   .m8n8k128
  </span>
  .
 </p>
 <p>
  Elements of the matrix are distributed across the threads in a warp so each thread of the warp holds
a fragment of the matrix.
 </p>
 <ul>
  <li>
   <p>
    Multiplicand A:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .atype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .b1
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing a single
       <span class="pre">
        .b32
       </span>
       register, containing thirty
two
       <span class="pre">
        .b1
       </span>
       elements from the matrix A.
      </p>
     </td>
     <td>
      <p>
       a0, a1, â¦ a30, a31
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-88128-a">
     <span class="std std-numref">
      Figure 37
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 37
    </span>
    <span class="caption-text">
     MMA .m8n8k128 fragment layout for matrix A with
     <span class="pre">
      .b1
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-88128-a" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span>

<span class="n">col</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">32</span><span class="p">)</span><span class="o">+</span><span class="n">i</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,..,</span><span class="mi">31</span><span class="p">}</span>
</pre>
  </li>
  <li>
   <p>
    Multiplicand B:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .btype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .b1
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing a single
       <span class="pre">
        .b32
       </span>
       register, containing thirty
two
       <span class="pre">
        .b1
       </span>
       elements from the matrix B.
      </p>
     </td>
     <td>
      <p>
       b0, b1, â¦, b30, b31
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-88128-b">
     <span class="std std-numref">
      Figure 38
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 38
    </span>
    <span class="caption-text">
     MMA .m8n8k128 fragment layout for matrix B with
     <span class="pre">
      .b1
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-88128-b" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">32</span><span class="p">)</span><span class="o">+</span><span class="n">i</span><span class="k">for</span><span class="n">bi</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,..,</span><span class="mi">31</span><span class="p">}</span>

<span class="n">col</span><span class="o">=</span><span class="n">groupID</span>
</pre>
  </li>
  <li>
   <p>
    Accumulators (C or D):
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .ctype / .dtype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .s32
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing two
       <span class="pre">
        .s32
       </span>
       registers, containing two
       <span class="pre">
        .s32
       </span>
       elements from the matrix C (or D).
      </p>
     </td>
     <td>
      <p>
       c0, c1
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-88128-c">
     <span class="std std-numref">
      Figure 39
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 39
    </span>
    <span class="caption-text">
     MMA .m8n8k128 fragment layout for accumulator matrix C/D with
     <span class="pre">
      .s32
     </span>
     type
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-88128-c" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span>

<span class="n">col</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">i</span><span class="k">for</span><span class="n">ci</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span>
</pre>
  </li>
 </ul>
 <h5>
  <span class="section-number">
   9.7.13.4.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-mma-1684">
   Matrix Fragments for mma.m16n8k4
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-mma-m16n8k4" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  A warp executing
  <span class="pre">
   mma.m16n8k4
  </span>
  will compute an MMA operation of shape
  <span class="pre">
   .m16n8k4
  </span>
  .
 </p>
 <p>
  Elements of the matrix are distributed across the threads in a warp so each thread of the warp holds
a fragment of the matrix.
 </p>
 <ul>
  <li>
   <p>
    Multiplicand A:
   </p>
   <ul>
    <li>
     <p>
      <span class="pre">
       .tf32
      </span>
      :
     </p>
     <table class="table-no-stripes docutils align-default">
      <tr class="row-odd">
       <th class="head">
        <p>
         .atype
        </p>
       </th>
       <th class="head">
        <p>
         Fragment
        </p>
       </th>
       <th class="head">
        <p>
         Elements (low to high)
        </p>
       </th>
      </tr>
      <tr class="row-even">
       <td>
        <p>
         <span class="pre">
          .tf32
         </span>
        </p>
       </td>
       <td>
        <p>
         A vector expression containing two
         <span class="pre">
          .b32
         </span>
         registers, containing two
         <span class="pre">
          .tf32
         </span>
         elements from the matrix A.
        </p>
       </td>
       <td>
        <p>
         a0, a1
        </p>
       </td>
      </tr>
     </table>
     <p>
      The layout of the fragments held by different threads is shown in
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-1684-a-tf32">
       <span class="std std-numref">
        Figure 40
       </span>
      </a>
      .
     </p>
     <p>
      <span class="caption-number">
       Figure 40
      </span>
      <span class="caption-text">
       MMA .m16n8k4 fragment layout for matrix A with
       <span class="pre">
        .tf32
       </span>
       type.
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-1684-a-tf32" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      The row and column of a matrix fragment can be computed as:
     </p>
     <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">a0</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="k">for</span><span class="n">a1</span>

<span class="n">col</span><span class="o">=</span><span class="n">threadID_in_group</span>
</pre>
    </li>
    <li>
     <p>
      <span class="pre">
       .f64
      </span>
      :
     </p>
     <table class="table-no-stripes docutils align-default">
      <tr class="row-odd">
       <th class="head">
        <p>
         .atype
        </p>
       </th>
       <th class="head">
        <p>
         Fragment
        </p>
       </th>
       <th class="head">
        <p>
         Elements (low to high)
        </p>
       </th>
      </tr>
      <tr class="row-even">
       <td>
        <p>
         <span class="pre">
          .f64
         </span>
        </p>
       </td>
       <td>
        <p>
         A vector expression containing two
         <span class="pre">
          .f64
         </span>
         registers, containing two
         <span class="pre">
          .f64
         </span>
         elements from the matrix A.
        </p>
       </td>
       <td>
        <p>
         a0, a1
        </p>
       </td>
      </tr>
     </table>
     <p>
      The layout of the fragments held by different threads is shown in
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-1684-a-f64">
       <span class="std std-numref">
        Figure 41
       </span>
      </a>
      .
     </p>
     <p>
      <span class="caption-number">
       Figure 41
      </span>
      <span class="caption-text">
       MMA .m16n8k4 fragment layout for matrix A with
       <span class="pre">
        .f64
       </span>
       type.
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-1684-a-f64" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      The row and column of a matrix fragment can be computed as:
     </p>
     <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">a0</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="k">for</span><span class="n">a1</span>

<span class="n">col</span><span class="o">=</span><span class="n">threadID_in_group</span>
</pre>
    </li>
   </ul>
  </li>
  <li>
   <p>
    Multiplicand B:
   </p>
   <ul>
    <li>
     <p>
      <span class="pre">
       .tf32
      </span>
      :
     </p>
     <table class="table-no-stripes docutils align-default">
      <tr class="row-odd">
       <th class="head">
        <p>
         .btype
        </p>
       </th>
       <th class="head">
        <p>
         Fragment
        </p>
       </th>
       <th class="head">
        <p>
         Elements (low to high)
        </p>
       </th>
      </tr>
      <tr class="row-even">
       <td>
        <p>
         <span class="pre">
          .tf32
         </span>
        </p>
       </td>
       <td>
        <p>
         A vector expression of a single
         <span class="pre">
          .b32
         </span>
         register, containing a single
         <span class="pre">
          .tf32
         </span>
         element from the matrix B.
        </p>
       </td>
       <td>
        <p>
         b0
        </p>
       </td>
      </tr>
     </table>
     <p>
      The layout of the fragments held by different threads is shown in
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-1684-b-tf32">
       <span class="std std-numref">
        Figure 42
       </span>
      </a>
      .
     </p>
     <p>
      <span class="caption-number">
       Figure 42
      </span>
      <span class="caption-text">
       MMA .m16n8k4 fragment layout for matrix B with
       <span class="pre">
        .tf32
       </span>
       type.
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-1684-b-tf32" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      The row and column of a matrix fragment can be computed as:
     </p>
     <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">threadID_in_group</span>

<span class="n">col</span><span class="o">=</span><span class="n">groupID</span>
</pre>
    </li>
    <li>
     <p>
      <span class="pre">
       .f64
      </span>
      :
     </p>
     <table class="table-no-stripes docutils align-default">
      <tr class="row-odd">
       <th class="head">
        <p>
         .btype
        </p>
       </th>
       <th class="head">
        <p>
         Fragment
        </p>
       </th>
       <th class="head">
        <p>
         Elements (low to high)
        </p>
       </th>
      </tr>
      <tr class="row-even">
       <td>
        <p>
         <span class="pre">
          .f64
         </span>
        </p>
       </td>
       <td>
        <p>
         A vector expression of a single
         <span class="pre">
          .f64
         </span>
         register, containing a single
         <span class="pre">
          .f64
         </span>
         element from the matrix B.
        </p>
       </td>
       <td>
        <p>
         b0
        </p>
       </td>
      </tr>
     </table>
     <p>
      The layout of the fragments held by different threads is shown in
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-1684-b-f64">
       <span class="std std-numref">
        Figure 43
       </span>
      </a>
      .
     </p>
     <p>
      <span class="caption-number">
       Figure 43
      </span>
      <span class="caption-text">
       MMA .m16n8k4 fragment layout for matrix B with
       <span class="pre">
        .f64
       </span>
       type.
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-1684-b-f64" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      The row and column of a matrix fragment can be computed as:
     </p>
     <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">threadID_in_group</span>

<span class="n">col</span><span class="o">=</span><span class="n">groupID</span>
</pre>
    </li>
   </ul>
  </li>
  <li>
   <p>
    Accumulators (C or D):
   </p>
   <ul>
    <li>
     <p>
      <span class="pre">
       .tf32
      </span>
      :
     </p>
     <table class="table-no-stripes docutils align-default">
      <tr class="row-odd">
       <th class="head">
        <p>
         .ctype / .dtype
        </p>
       </th>
       <th class="head">
        <p>
         Fragment
        </p>
       </th>
       <th class="head">
        <p>
         Elements (low to high)
        </p>
       </th>
      </tr>
      <tr class="row-even">
       <td>
        <p>
         <span class="pre">
          .f32
         </span>
        </p>
       </td>
       <td>
        <p>
         A vector expression containing four
         <span class="pre">
          .f32
         </span>
         registers, containing four
         <span class="pre">
          .f32
         </span>
         elements from the matrix C (or D).
        </p>
       </td>
       <td>
        <p>
         c0, c1, c2, c3
        </p>
       </td>
      </tr>
     </table>
     <p>
      The layout of the fragments held by different threads is shown in
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-1684-c-f32">
       <span class="std std-numref">
        Figure 44
       </span>
      </a>
      .
     </p>
     <p>
      <span class="caption-number">
       Figure 44
      </span>
      <span class="caption-text">
       MMA .m16n8k4 fragment layout for accumulator matrix C/D with
       <span class="pre">
        .f32
       </span>
       type.
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-1684-c-f32" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      The row and column of a matrix fragment can be computed as:
     </p>
     <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">c0</span><span class="n">and</span><span class="n">c1</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="k">for</span><span class="n">c2</span><span class="n">and</span><span class="n">c3</span>

<span class="n">col</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x1</span><span class="p">)</span><span class="k">for</span><span class="n">ci</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,..,</span><span class="mi">3</span><span class="p">}</span>
</pre>
    </li>
    <li>
     <p>
      <span class="pre">
       .f64
      </span>
      :
     </p>
     <table class="table-no-stripes docutils align-default">
      <tr class="row-odd">
       <th class="head">
        <p>
         .ctype / .dtype
        </p>
       </th>
       <th class="head">
        <p>
         Fragment
        </p>
       </th>
       <th class="head">
        <p>
         Elements (low to high)
        </p>
       </th>
      </tr>
      <tr class="row-even">
       <td>
        <p>
         <span class="pre">
          .f64
         </span>
        </p>
       </td>
       <td>
        <p>
         A vector expression containing four
         <span class="pre">
          .f64
         </span>
         registers, containing four
         <span class="pre">
          .f64
         </span>
         elements from the matrix C (or D).
        </p>
       </td>
       <td>
        <p>
         c0, c1, c2, c3
        </p>
       </td>
      </tr>
     </table>
     <p>
      The layout of the fragments held by different threads is shown in
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-1684-c-f64">
       <span class="std std-numref">
        Figure 45
       </span>
      </a>
      .
     </p>
     <p>
      <span class="caption-number">
       Figure 45
      </span>
      <span class="caption-text">
       MMA .m16n8k4 fragment layout for accumulator matrix C/D with
       <span class="pre">
        .f64
       </span>
       type.
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-1684-c-f64" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      The row and column of a matrix fragment can be computed as:
     </p>
     <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">c0</span><span class="n">and</span><span class="n">c1</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="k">for</span><span class="n">c2</span><span class="n">and</span><span class="n">c3</span>

<span class="n">col</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x1</span><span class="p">)</span><span class="k">for</span><span class="n">ci</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,..,</span><span class="mi">3</span><span class="p">}</span>
</pre>
    </li>
   </ul>
  </li>
 </ul>
 <h5>
  <span class="section-number">
   9.7.13.4.7.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-mma-1688">
   Matrix Fragments for mma.m16n8k8
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-mma-m16n8k8" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  A warp executing
  <span class="pre">
   mma.m16n8k8
  </span>
  will compute an MMA operation of shape
  <span class="pre">
   .m16n8k8
  </span>
  .
 </p>
 <p>
  Elements of the matrix are distributed across the threads in a warp so each thread of the warp holds
a fragment of the matrix.
 </p>
 <ul>
  <li>
   <p>
    Multiplicand A:
   </p>
   <ul>
    <li>
     <p>
      <span class="pre">
       .f16
      </span>
      and
      <span class="pre">
       .bf16
      </span>
      :
     </p>
     <table class="table-no-stripes docutils align-default">
      <tr class="row-odd">
       <th class="head">
        <p>
         .atype
        </p>
       </th>
       <th class="head">
        <p>
         Fragment
        </p>
       </th>
       <th class="head">
        <p>
         Elements (low to high)
        </p>
       </th>
      </tr>
      <tr class="row-even">
       <td>
        <p>
         <span class="pre">
          .f16
         </span>
         /
         <span class="pre">
          .bf16
         </span>
        </p>
       </td>
       <td>
        <p>
         A vector expression containing two
         <span class="pre">
          .f16x2
         </span>
         registers, with each
register containing two
         <span class="pre">
          .f16
         </span>
         /
         <span class="pre">
          .bf16
         </span>
         elements from the
matrix A.
        </p>
       </td>
       <td>
        <p>
         a0, a1, a2, a3
        </p>
       </td>
      </tr>
     </table>
     <p>
      The layout of the fragments held by different threads is shown in
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-1688-a-f16">
       <span class="std std-numref">
        Figure 46
       </span>
      </a>
      .
     </p>
     <p>
      <span class="caption-number">
       Figure 46
      </span>
      <span class="caption-text">
       MMA .m16n8k8 fragment layout for matrix A with
       <span class="pre">
        .f16
       </span>
       /
       <span class="pre">
        .bf16
       </span>
       type.
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-1688-a-f16" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      The row and column of a matrix fragment can be computed as:
     </p>
     <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">a0</span><span class="n">and</span><span class="n">a1</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="k">for</span><span class="n">a2</span><span class="n">and</span><span class="n">a3</span>

<span class="n">col</span><span class="o">=</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x1</span><span class="p">)</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,..,</span><span class="mi">3</span><span class="p">}</span>
</pre>
    </li>
    <li>
     <p>
      <span class="pre">
       .tf32
      </span>
      :
     </p>
     <table class="table-no-stripes docutils align-default">
      <tr class="row-odd">
       <th class="head">
        <p>
         .atype
        </p>
       </th>
       <th class="head">
        <p>
         Fragment
        </p>
       </th>
       <th class="head">
        <p>
         Elements (low to high)
        </p>
       </th>
      </tr>
      <tr class="row-even">
       <td>
        <p>
         <span class="pre">
          .tf32
         </span>
        </p>
       </td>
       <td>
        <p>
         A vector expression containing four
         <span class="pre">
          .b32
         </span>
         registers, containing four
         <span class="pre">
          .tf32
         </span>
         elements from the matrix A.
        </p>
       </td>
       <td>
        <p>
         a0, a1, a2, a3
        </p>
       </td>
      </tr>
     </table>
     <p>
      The layout of the fragments held by different threads is shown in
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-1688-a-tf32">
       <span class="std std-numref">
        Figure 47
       </span>
      </a>
      .
     </p>
     <p>
      <span class="caption-number">
       Figure 47
      </span>
      <span class="caption-text">
       MMA .m16n8k8 fragment layout for matrix A with
       <span class="pre">
        .tf32
       </span>
       type.
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-1688-a-tf32" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      The row and column of a matrix fragment can be computed as:
     </p>
     <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">a0</span><span class="n">and</span><span class="n">a2</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="k">for</span><span class="n">a1</span><span class="n">and</span><span class="n">a3</span>

<span class="n">col</span><span class="o">=</span><span class="n">threadID_in_group</span><span class="k">for</span><span class="n">a0</span><span class="n">and</span><span class="n">a1</span>
<span class="n">threadID_in_group</span><span class="o">+</span><span class="mi">4</span><span class="k">for</span><span class="n">a2</span><span class="n">and</span><span class="n">a3</span>
</pre>
    </li>
    <li>
     <p>
      <span class="pre">
       .f64
      </span>
      :
     </p>
     <table class="table-no-stripes docutils align-default">
      <tr class="row-odd">
       <th class="head">
        <p>
         .atype
        </p>
       </th>
       <th class="head">
        <p>
         Fragment
        </p>
       </th>
       <th class="head">
        <p>
         Elements (low to high)
        </p>
       </th>
      </tr>
      <tr class="row-even">
       <td>
        <p>
         <span class="pre">
          .f64
         </span>
        </p>
       </td>
       <td>
        <p>
         A vector expression containing four
         <span class="pre">
          .f64
         </span>
         registers, containing four
         <span class="pre">
          .f64
         </span>
         elements from the matrix A.
        </p>
       </td>
       <td>
        <p>
         a0, a1, a2, a3
        </p>
       </td>
      </tr>
     </table>
     <p>
      The layout of the fragments held by different threads is shown in
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-1688-a-f64">
       <span class="std std-numref">
        Figure 48
       </span>
      </a>
      .
     </p>
     <p>
      <span class="caption-number">
       Figure 48
      </span>
      <span class="caption-text">
       MMA .m16n8k8 fragment layout for matrix A with
       <span class="pre">
        .f64
       </span>
       type.
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-1688-a-f64" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      The row and column of a matrix fragment can be computed as:
     </p>
     <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">a0</span><span class="n">and</span><span class="n">a2</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="k">for</span><span class="n">a1</span><span class="n">and</span><span class="n">a3</span>

<span class="n">col</span><span class="o">=</span><span class="n">threadID_in_group</span><span class="k">for</span><span class="n">a0</span><span class="n">and</span><span class="n">a1</span>
<span class="n">threadID_in_group</span><span class="o">+</span><span class="mi">4</span><span class="k">for</span><span class="n">a2</span><span class="n">and</span><span class="n">a3</span>
</pre>
    </li>
   </ul>
  </li>
  <li>
   <p>
    Multiplicand B:
   </p>
   <ul>
    <li>
     <p>
      <span class="pre">
       .f16
      </span>
      and
      <span class="pre">
       .bf16
      </span>
      :
     </p>
     <table class="table-no-stripes docutils align-default">
      <tr class="row-odd">
       <th class="head">
        <p>
         .btype
        </p>
       </th>
       <th class="head">
        <p>
         Fragment
        </p>
       </th>
       <th class="head">
        <p>
         Elements (low to high)
        </p>
       </th>
      </tr>
      <tr class="row-even">
       <td>
        <p>
         <span class="pre">
          .f16
         </span>
         /
         <span class="pre">
          .bf16
         </span>
        </p>
       </td>
       <td>
        <p>
         A vector expression containing a single
         <span class="pre">
          .f16x2
         </span>
         register, containing
two
         <span class="pre">
          .f16
         </span>
         /
         <span class="pre">
          .bf16
         </span>
         elements from the matrix B.
        </p>
       </td>
       <td>
        <p>
         b0, b1
        </p>
       </td>
      </tr>
     </table>
     <p>
      The layout of the fragments held by different threads is shown in
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-1688-b-f16">
       <span class="std std-numref">
        Figure 49
       </span>
      </a>
      .
     </p>
     <p>
      <span class="caption-number">
       Figure 49
      </span>
      <span class="caption-text">
       MMA .m16n8k8 fragment layout for matrix B with
       <span class="pre">
        .f16
       </span>
       /
       <span class="pre">
        .bf16
       </span>
       type.
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-1688-b-f16" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      The row and column of a matrix fragment can be computed as:
     </p>
     <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">i</span><span class="k">for</span><span class="n">bi</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span>

<span class="n">col</span><span class="o">=</span><span class="n">groupID</span>
</pre>
    </li>
    <li>
     <p>
      <span class="pre">
       .tf32
      </span>
      :
     </p>
     <table class="table-no-stripes docutils align-default">
      <tr class="row-odd">
       <th class="head">
        <p>
         .btype
        </p>
       </th>
       <th class="head">
        <p>
         Fragment
        </p>
       </th>
       <th class="head">
        <p>
         Elements (low to high)
        </p>
       </th>
      </tr>
      <tr class="row-even">
       <td>
        <p>
         <span class="pre">
          .tf32
         </span>
        </p>
       </td>
       <td>
        <p>
         A vector expression containing two
         <span class="pre">
          .b32
         </span>
         registers, containing two
         <span class="pre">
          .tf32
         </span>
         elements from the matrix B.
        </p>
       </td>
       <td>
        <p>
         b0, b1
        </p>
       </td>
      </tr>
     </table>
     <p>
      The layout of the fragments held by different threads is shown in
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-1688-b-tf32">
       <span class="std std-numref">
        Figure 50
       </span>
      </a>
      .
     </p>
     <p>
      <span class="caption-number">
       Figure 50
      </span>
      <span class="caption-text">
       MMA .m16n8k8 fragment layout for matrix B with
       <span class="pre">
        .tf32
       </span>
       type.
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-1688-b-tf32" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      The row and column of a matrix fragment can be computed as:
     </p>
     <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">threadID_in_group</span><span class="k">for</span><span class="n">b0</span>
<span class="n">threadID_in_group</span><span class="o">+</span><span class="mi">4</span><span class="k">for</span><span class="n">b1</span>

<span class="n">col</span><span class="o">=</span><span class="n">groupID</span>
</pre>
    </li>
    <li>
     <p>
      <span class="pre">
       .f64
      </span>
      :
     </p>
     <table class="table-no-stripes docutils align-default">
      <tr class="row-odd">
       <th class="head">
        <p>
         .btype
        </p>
       </th>
       <th class="head">
        <p>
         Fragment
        </p>
       </th>
       <th class="head">
        <p>
         Elements (low to high)
        </p>
       </th>
      </tr>
      <tr class="row-even">
       <td>
        <p>
         <span class="pre">
          .f64
         </span>
        </p>
       </td>
       <td>
        <p>
         A vector expression containing two
         <span class="pre">
          .f64
         </span>
         registers, containing two
         <span class="pre">
          .f64
         </span>
         elements from the matrix B.
        </p>
       </td>
       <td>
        <p>
         b0, b1
        </p>
       </td>
      </tr>
     </table>
     <p>
      The layout of the fragments held by different threads is shown in
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-1688-b-f64">
       <span class="std std-numref">
        Figure 51
       </span>
      </a>
      .
     </p>
     <p>
      <span class="caption-number">
       Figure 51
      </span>
      <span class="caption-text">
       MMA .m16n8k8 fragment layout for matrix B with
       <span class="pre">
        .f64
       </span>
       type.
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-1688-b-f64" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      The row and column of a matrix fragment can be computed as:
     </p>
     <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">threadID_in_group</span><span class="k">for</span><span class="n">b0</span>
<span class="n">threadID_in_group</span><span class="o">+</span><span class="mi">4</span><span class="k">for</span><span class="n">b1</span>

<span class="n">col</span><span class="o">=</span><span class="n">groupID</span>
</pre>
    </li>
   </ul>
  </li>
  <li>
   <p>
    Accumulators (C or D):
   </p>
   <ul>
    <li>
     <p>
      <span class="pre">
       .f16
      </span>
      ,
      <span class="pre">
       .bf16
      </span>
      and
      <span class="pre">
       .tf32
      </span>
      :
     </p>
     <table class="table-no-stripes docutils align-default">
      <tr class="row-odd">
       <th class="head">
        <p>
         .ctype / .dtype
        </p>
       </th>
       <th class="head">
        <p>
         Fragment
        </p>
       </th>
       <th class="head">
        <p>
         Elements (low to high)
        </p>
       </th>
      </tr>
      <tr class="row-even">
       <td>
        <p>
         <span class="pre">
          .f16
         </span>
        </p>
       </td>
       <td>
        <p>
         A vector expression containing two
         <span class="pre">
          .f16x2
         </span>
         registers, with each
register containing two
         <span class="pre">
          .f16
         </span>
         elements from the matrix C (or D).
        </p>
       </td>
       <td>
        <p>
         c0, c1, c2, c3
        </p>
       </td>
      </tr>
      <tr class="row-odd">
       <td>
        <p>
         <span class="pre">
          .f32
         </span>
        </p>
       </td>
       <td>
        <p>
         A vector expression of four
         <span class="pre">
          .f32
         </span>
         registers.
        </p>
       </td>
      </tr>
     </table>
     <p>
      The layout of the fragments held by different threads is shown in
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-1688-c-f16-f32">
       <span class="std std-numref">
        Figure 52
       </span>
      </a>
      .
     </p>
     <p>
      <span class="caption-number">
       Figure 52
      </span>
      <span class="caption-text">
       MMA .m16n8k8 fragment layout for accumulator matrix C/D with
       <span class="pre">
        .f16x2
       </span>
       /
       <span class="pre">
        .f32
       </span>
       type.
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-1688-c-f16-f32" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      The row and column of a matrix fragment can be computed as:
     </p>
     <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">c0</span><span class="n">and</span><span class="n">c1</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="k">for</span><span class="n">c2</span><span class="n">and</span><span class="n">c3</span>

<span class="n">col</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x1</span><span class="p">)</span><span class="k">for</span><span class="n">ci</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,..,</span><span class="mi">3</span><span class="p">}</span>
</pre>
    </li>
    <li>
     <p>
      <span class="pre">
       .f64
      </span>
      :
     </p>
     <table class="table-no-stripes docutils align-default">
      <tr class="row-odd">
       <th class="head">
        <p>
         .ctype / .dtype
        </p>
       </th>
       <th class="head">
        <p>
         Fragment
        </p>
       </th>
       <th class="head">
        <p>
         Elements (low to high)
        </p>
       </th>
      </tr>
      <tr class="row-even">
       <td>
        <p>
         <span class="pre">
          .f64
         </span>
        </p>
       </td>
       <td>
        <p>
         A vector expression of four
         <span class="pre">
          .f64
         </span>
         registers containing four
         <span class="pre">
          .f64
         </span>
         elements from the matrix C (or D).
        </p>
       </td>
       <td>
        <p>
         c0, c1, c2, c3
        </p>
       </td>
      </tr>
     </table>
     <p>
      The layout of the fragments held by different threads is shown in
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-1688-c-f64">
       <span class="std std-numref">
        Figure 53
       </span>
      </a>
      .
     </p>
     <p>
      <span class="caption-number">
       Figure 53
      </span>
      <span class="caption-text">
       MMA .m16n8k8 fragment layout for accumulator matrix C/D with
       <span class="pre">
        .f64
       </span>
       type.
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-1688-c-f64" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      The row and column of a matrix fragment can be computed as:
     </p>
     <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">c0</span><span class="n">and</span><span class="n">c1</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="k">for</span><span class="n">c2</span><span class="n">and</span><span class="n">c3</span>

<span class="n">col</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x1</span><span class="p">)</span><span class="k">for</span><span class="n">ci</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,..,</span><span class="mi">3</span><span class="p">}</span>
</pre>
    </li>
   </ul>
  </li>
 </ul>
 <h5>
  <span class="section-number">
   9.7.13.4.8.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-mma-16816-float">
   Matrix Fragments for mma.m16n8k16 with floating point type
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-mma-m16n8k16-with-floating-point-type" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  A warp executing
  <span class="pre">
   mma.m16n8k16
  </span>
  floating point types will compute an MMA operation of shape
  <span class="pre">
   .m16n8k16
  </span>
  .
 </p>
 <p>
  Elements of the matrix are distributed across the threads in a warp so each thread of the warp holds
a fragment of the matrix.
 </p>
 <ul>
  <li>
   <p>
    Multiplicand A:
   </p>
   <ul>
    <li>
     <p>
      <span class="pre">
       .f16
      </span>
      and
      <span class="pre">
       .bf16
      </span>
      :
     </p>
     <table class="table-no-stripes docutils align-default">
      <tr class="row-odd">
       <th class="head">
        <p>
         .atype
        </p>
       </th>
       <th class="head">
        <p>
         Fragment
        </p>
       </th>
       <th class="head">
        <p>
         Elements (low to high)
        </p>
       </th>
      </tr>
      <tr class="row-even">
       <td>
        <p>
         <span class="pre">
          .f16
         </span>
         /
         <span class="pre">
          .bf16
         </span>
        </p>
       </td>
       <td>
        <p>
         A vector expression containing four
         <span class="pre">
          .f16x2
         </span>
         registers, with
each register containing two
         <span class="pre">
          .f16
         </span>
         /
         <span class="pre">
          .bf16
         </span>
         elements
from the matrix A.
        </p>
       </td>
       <td>
        <p>
         a0, a1, a2, a3, a4, a5, a6, a7
        </p>
       </td>
      </tr>
     </table>
     <p>
      The layout of the fragments held by different threads is shown in
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16816-a-f16">
       <span class="std std-numref">
        Figure 54
       </span>
      </a>
      .
     </p>
     <p>
      <span class="caption-number">
       Figure 54
      </span>
      <span class="caption-text">
       MMA .m16n8k16 fragment layout for matrix A with
       <span class="pre">
        .f16
       </span>
       /
       <span class="pre">
        .bf16
       </span>
       type.
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16816-a-f16" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      The row and column of a matrix fragment can be computed as:
     </p>
     <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">||</span><span class="mi">4</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">6</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="n">Otherwise</span>

<span class="n">col</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x1</span><span class="p">)</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span>
<span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x1</span><span class="p">)</span><span class="o">+</span><span class="mi">8</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">4</span>
</pre>
    </li>
    <li>
     <p>
      <span class="pre">
       .f64
      </span>
      :
     </p>
     <table class="table-no-stripes docutils align-default">
      <tr class="row-odd">
       <th class="head">
        <p>
         .atype
        </p>
       </th>
       <th class="head">
        <p>
         Fragment
        </p>
       </th>
       <th class="head">
        <p>
         Elements (low to high)
        </p>
       </th>
      </tr>
      <tr class="row-even">
       <td>
        <p>
         <span class="pre">
          .f64
         </span>
        </p>
       </td>
       <td>
        <p>
         A vector expression containing eight
         <span class="pre">
          .f64
         </span>
         registers, with each
register containing one
         <span class="pre">
          .f64
         </span>
         element from the matrix A.
        </p>
       </td>
       <td>
        <p>
         a0, a1, a2, a3, a4, a5, a6, a7
        </p>
       </td>
      </tr>
     </table>
     <p>
      The layout of the fragments held by different threads is shown in
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16816-a-f64">
       <span class="std std-numref">
        Figure 55
       </span>
      </a>
      .
     </p>
     <p>
      <span class="caption-number">
       Figure 55
      </span>
      <span class="caption-text">
       MMA .m16n8k16 fragment layout for matrix A with
       <span class="pre">
        .f64
       </span>
       type.
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16816-a-f64" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      The row and column of a matrix fragment can be computed as:
     </p>
     <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">%</span><span class="mi">2</span><span class="o">=</span><span class="mi">0</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="n">Otherwise</span>

<span class="n">col</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">threadID_in_group</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">%</span><span class="mi">2</span><span class="o">=</span><span class="mi">0</span>
<span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="n">Otherwise</span>
</pre>
    </li>
   </ul>
  </li>
  <li>
   <p>
    Multiplicand B:
   </p>
   <ul>
    <li>
     <p>
      <span class="pre">
       .f16
      </span>
      and
      <span class="pre">
       .bf16
      </span>
      :
     </p>
     <table class="table-no-stripes docutils align-default">
      <tr class="row-odd">
       <th class="head">
        <p>
         .btype
        </p>
       </th>
       <th class="head">
        <p>
         Fragment
        </p>
       </th>
       <th class="head">
        <p>
         Elements (low to high)
        </p>
       </th>
      </tr>
      <tr class="row-even">
       <td>
        <p>
         <span class="pre">
          .f16
         </span>
         /
         <span class="pre">
          .bf16
         </span>
        </p>
       </td>
       <td>
        <p>
         A vector expression containing two
         <span class="pre">
          .f16x2
         </span>
         registers, with
each register containing two
         <span class="pre">
          .f16
         </span>
         /
         <span class="pre">
          .bf16
         </span>
         elements
from the matrix B.
        </p>
       </td>
       <td>
        <p>
         b0, b1, b2, b3
        </p>
       </td>
      </tr>
     </table>
     <p>
      The layout of the fragments held by different threads is shown in
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16816-b-f16">
       <span class="std std-numref">
        Figure 56
       </span>
      </a>
      .
     </p>
     <p>
      <span class="caption-number">
       Figure 56
      </span>
      <span class="caption-text">
       MMA .m16n8k16 fragment layout for matrix B with
       <span class="pre">
        .f16
       </span>
       /
       <span class="pre">
        .bf16
       </span>
       type.
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16816-b-f16" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      where the row and column of a matrix fragment can be computed as:
     </p>
     <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x1</span><span class="p">)</span><span class="k">for</span><span class="n">bi</span><span class="n">where</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">2</span>
<span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x1</span><span class="p">)</span><span class="o">+</span><span class="mi">8</span><span class="k">for</span><span class="n">bi</span><span class="n">where</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">2</span>

<span class="n">col</span><span class="o">=</span><span class="n">groupID</span>
</pre>
    </li>
    <li>
     <p>
      <span class="pre">
       .f64
      </span>
      :
     </p>
     <table class="table-no-stripes docutils align-default">
      <tr class="row-odd">
       <th class="head">
        <p>
         .atype
        </p>
       </th>
       <th class="head">
        <p>
         Fragment
        </p>
       </th>
       <th class="head">
        <p>
         Elements (low to high)
        </p>
       </th>
      </tr>
      <tr class="row-even">
       <td>
        <p>
         <span class="pre">
          .f64
         </span>
        </p>
       </td>
       <td>
        <p>
         A vector expression containing four
         <span class="pre">
          .f64
         </span>
         registers, with each
register containing one
         <span class="pre">
          .f64
         </span>
         element from the matrix B.
        </p>
       </td>
       <td>
        <p>
         b0, b1, b2, b3
        </p>
       </td>
      </tr>
     </table>
     <p>
      The layout of the fragments held by different threads is shown in
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16816-b-f64">
       <span class="std std-numref">
        Figure 57
       </span>
      </a>
      .
     </p>
     <p>
      <span class="caption-number">
       Figure 57
      </span>
      <span class="caption-text">
       MMA .m16n8k16 fragment layout for matrix B with
       <span class="pre">
        .f64
       </span>
       type.
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16816-b-f64" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      The row and column of a matrix fragment can be computed as:
     </p>
     <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">threadID_in_group</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="k">for</span><span class="n">bi</span><span class="n">where</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span>

<span class="n">col</span><span class="o">=</span><span class="n">groupID</span>
</pre>
    </li>
   </ul>
  </li>
  <li>
   <p>
    Accumulators (C or D):
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .ctype / .dtype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .f64
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing four
       <span class="pre">
        .f64
       </span>
       registers containing
       <span class="pre">
        .f64
       </span>
       elements from the matrix C (or D).
      </p>
     </td>
     <td rowspan="3">
      <p>
       c0, c1, c2, c3
      </p>
     </td>
    </tr>
    <tr class="row-odd">
     <td>
      <p>
       <span class="pre">
        .f32
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing four
       <span class="pre">
        .f32
       </span>
       registers containing
four
       <span class="pre">
        .f32
       </span>
       elements from the matrix C (or D).
      </p>
     </td>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .f16
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing two
       <span class="pre">
        .f16x2
       </span>
       registers, with each
register containing two
       <span class="pre">
        .f16
       </span>
       elements from the matrix C (or D).
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16816-c">
     <span class="std std-numref">
      Figure 58
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 58
    </span>
    <span class="caption-text">
     MMA .m16n8k16 fragment layout for accumulator matrix matrix C/D.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16816-c" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">ci</span><span class="n">where</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">2</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="k">for</span><span class="n">ci</span><span class="n">where</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">2</span>

<span class="n">col</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x1</span><span class="p">)</span><span class="k">for</span><span class="n">ci</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,..,</span><span class="mi">3</span><span class="p">}</span>
</pre>
  </li>
 </ul>
 <h5>
  <span class="section-number">
   9.7.13.4.9.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-mma-16816-i8">
   Matrix Fragments for mma.m16n8k16 with integer type
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-mma-m16n8k16-with-integer-type" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  A warp executing
  <span class="pre">
   mma.m16n8k16
  </span>
  with
  <span class="pre">
   .u8
  </span>
  or
  <span class="pre">
   .s8
  </span>
  integer type will compute an MMA operation
of shape
  <span class="pre">
   .m16n8k16
  </span>
  .
 </p>
 <p>
  Elements of the matrix are distributed across the threads in a warp so each thread of the warp holds
a fragment of the matrix.
 </p>
 <ul>
  <li>
   <p>
    Multiplicand A:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .atype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .u8
       </span>
       /
       <span class="pre">
        .s8
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing two
       <span class="pre">
        .b32
       </span>
       registers, with each
register containing four
       <span class="pre">
        .u8
       </span>
       /
       <span class="pre">
        .s8
       </span>
       elements from the
matrix A.
      </p>
     </td>
     <td>
      <p>
       a0, a1, a2, a3, a4, a5, a6, a7
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16816-a-i8">
     <span class="std std-numref">
      Figure 59
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 59
    </span>
    <span class="caption-text">
     MMA .m16n8k16 fragment layout for matrix A with
     <span class="pre">
      .u8
     </span>
     /
     <span class="pre">
      .s8
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16816-a-i8" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">4</span>

<span class="n">col</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x3</span><span class="p">)</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,..,</span><span class="mi">7</span><span class="p">}</span>
</pre>
  </li>
  <li>
   <p>
    Multiplicand B:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .btype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .u8
       </span>
       /
       <span class="pre">
        .s8
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing a single
       <span class="pre">
        .b32
       </span>
       register, containing
four
       <span class="pre">
        .u8
       </span>
       /
       <span class="pre">
        .s8
       </span>
       elements from the matrix B.
      </p>
     </td>
     <td>
      <p>
       b0, b1, b2, b3
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16816-b-i8">
     <span class="std std-numref">
      Figure 60
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 60
    </span>
    <span class="caption-text">
     MMA .m16n8k16 fragment layout for matrix B with
     <span class="pre">
      .u8
     </span>
     /
     <span class="pre">
      .s8
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16816-b-i8" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="n">i</span><span class="k">for</span><span class="n">bi</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,..,</span><span class="mi">3</span><span class="p">}</span>

<span class="n">col</span><span class="o">=</span><span class="n">groupID</span>
</pre>
  </li>
  <li>
   <p>
    Accumulators (C or D):
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .ctype / .dtype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .s32
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing four
       <span class="pre">
        .s32
       </span>
       registers, containing
four
       <span class="pre">
        .s32
       </span>
       elements from the matrix C (or D).
      </p>
     </td>
     <td>
      <p>
       c0, c1, c2, c3
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16816-c-i8">
     <span class="std std-numref">
      Figure 61
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 61
    </span>
    <span class="caption-text">
     MMA .m16n8k16 fragment layout for accumulator matrix C/D with
     <span class="pre">
      .s32
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16816-c-i8" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">ci</span><span class="n">where</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">2</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="k">for</span><span class="n">ci</span><span class="n">where</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">2</span>

<span class="n">col</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x1</span><span class="p">)</span><span class="k">for</span><span class="n">ci</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,..,</span><span class="mi">3</span><span class="p">}</span>
</pre>
  </li>
 </ul>
 <h5>
  <span class="section-number">
   9.7.13.4.10.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-mma-16832">
   Matrix Fragments for mma.m16n8k32
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-mma-m16n8k32" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  A warp executing
  <span class="pre">
   mma.m16n8k32
  </span>
  will compute an MMA operation of shape
  <span class="pre">
   .m16n8k32
  </span>
  .
 </p>
 <p>
  Elements of the matrix are distributed across the threads in a warp so each thread of the warp holds
a fragment of the matrix.
 </p>
 <ul>
  <li>
   <p>
    Multiplicand A:
   </p>
   <ul>
    <li>
     <p>
      <span class="pre">
       .s4
      </span>
      or
      <span class="pre">
       .u4
      </span>
      :
     </p>
     <table class="table-no-stripes docutils align-default">
      <tr class="row-odd">
       <th class="head">
        <p>
         .atype
        </p>
       </th>
       <th class="head">
        <p>
         Fragment
        </p>
       </th>
       <th class="head">
        <p>
         Elements (low to high)
        </p>
       </th>
      </tr>
      <tr class="row-even">
       <td>
        <p>
         <span class="pre">
          .s4
         </span>
         /
         <span class="pre">
          .u4
         </span>
        </p>
       </td>
       <td>
        <p>
         A vector expression containing two
         <span class="pre">
          .b32
         </span>
         registers, with each
register containing eight
         <span class="pre">
          .u4
         </span>
         /
         <span class="pre">
          .s4
         </span>
         elements from the
matrix A.
        </p>
       </td>
       <td>
        <p>
         a0, a1, â¦, a14, a15
        </p>
       </td>
      </tr>
     </table>
     <p>
      The layout of the fragments held by different threads is shown in
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16832-a-i4">
       <span class="std std-numref">
        Figure 62
       </span>
      </a>
      .
     </p>
     <p>
      <span class="caption-number">
       Figure 62
      </span>
      <span class="caption-text">
       MMA .m16n8k32 fragment layout for matrix A with
       <span class="pre">
        .u4
       </span>
       /
       <span class="pre">
        .s4
       </span>
       type.
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16832-a-i4" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      The row and column of a matrix fragment can be computed as:
     </p>
     <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">8</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">8</span>

<span class="n">col</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x7</span><span class="p">)</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,..,</span><span class="mi">15</span><span class="p">}</span>
</pre>
    </li>
    <li>
     <p>
      <span class="pre">
       .s8
      </span>
      or
      <span class="pre">
       .u8
      </span>
      or
      <span class="pre">
       .e4m3
      </span>
      or
      <span class="pre">
       .e5m2
      </span>
      :
     </p>
     <table class="table-no-stripes docutils align-default">
      <tr class="row-odd">
       <th class="head">
        <p>
         .atype
        </p>
       </th>
       <th class="head">
        <p>
         Fragment
        </p>
       </th>
       <th class="head">
        <p>
         Elements (low to high)
        </p>
       </th>
      </tr>
      <tr class="row-even">
       <td>
        <p>
         <span class="pre">
          .s8
         </span>
         /
         <span class="pre">
          .u8
         </span>
        </p>
       </td>
       <td>
        <p>
         A vector expression containing four
         <span class="pre">
          .b32
         </span>
         registers, with each
register containing four
         <span class="pre">
          .s8
         </span>
         /
         <span class="pre">
          .u8
         </span>
         elements from the
matrix A.
        </p>
       </td>
       <td>
        <p>
         a0, a1, .., a14, a15
        </p>
       </td>
      </tr>
      <tr class="row-odd">
       <td>
        <p>
         <span class="pre">
          .e4m3
         </span>
         /
         <span class="pre">
          .e5m2
         </span>
        </p>
       </td>
       <td>
        <p>
         A vector expression containing four
         <span class="pre">
          .b32
         </span>
         registers, with each
register containing four
         <span class="pre">
          .e4m3
         </span>
         /
         <span class="pre">
          .e5m2
         </span>
         elements from
the matrix A.
        </p>
       </td>
       <td>
        <p>
         a0, a1, â¦, a14, a15
        </p>
       </td>
      </tr>
     </table>
     <p>
      The layout of the fragments held by different threads is shown in
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16832-a-i8">
       <span class="std std-numref">
        Figure 63
       </span>
      </a>
      .
     </p>
     <p>
      <span class="caption-number">
       Figure 63
      </span>
      <span class="caption-text">
       MMA .m16n8k32 fragment layout for matrix A with
       <span class="pre">
        .u8
       </span>
       /
       <span class="pre">
        .s8
       </span>
       type.
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16832-a-i8" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      The row and column of a matrix fragment can be computed as:
     </p>
     <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">||</span><span class="mi">8</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">12</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="n">otherwise</span>

<span class="n">col</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x3</span><span class="p">)</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">8</span>
<span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x3</span><span class="p">)</span><span class="o">+</span><span class="mi">16</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">8</span>
</pre>
    </li>
   </ul>
  </li>
  <li>
   <p>
    Multiplicand B:
   </p>
   <ul>
    <li>
     <p>
      <span class="pre">
       .s4
      </span>
      or
      <span class="pre">
       .u4
      </span>
      :
     </p>
     <table class="table-no-stripes docutils align-default">
      <tr class="row-odd">
       <th class="head">
        <p>
         .btype
        </p>
       </th>
       <th class="head">
        <p>
         Fragment
        </p>
       </th>
       <th class="head">
        <p>
         Elements (low to high)
        </p>
       </th>
      </tr>
      <tr class="row-even">
       <td>
        <p>
         <span class="pre">
          .s4
         </span>
         /
         <span class="pre">
          .u4
         </span>
        </p>
       </td>
       <td>
        <p>
         A vector expression containing a single
         <span class="pre">
          .b32
         </span>
         register,
containing eight
         <span class="pre">
          .s4
         </span>
         /
         <span class="pre">
          .u4
         </span>
         elements from the matrix B.
        </p>
       </td>
       <td>
        <p>
         b0, b1, b2, b3, b4, b5, b6, b7
        </p>
       </td>
      </tr>
     </table>
     <p>
      The layout of the fragments held by different threads is shown in
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16832-b-i4">
       <span class="std std-numref">
        Figure 64
       </span>
      </a>
      .
     </p>
     <p>
      <span class="caption-number">
       Figure 64
      </span>
      <span class="caption-text">
       MMA .m16n8k32 fragment layout for matrix B with
       <span class="pre">
        .u4
       </span>
       /
       <span class="pre">
        .s4
       </span>
       type.
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16832-b-i4" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      The row and column of a matrix fragment can be computed as:
     </p>
    </li>
   </ul>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x7</span><span class="p">)</span><span class="k">for</span><span class="n">bi</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,..,</span><span class="mi">7</span><span class="p">}</span>
<span class="n">col</span><span class="o">=</span><span class="n">groupID</span>
</pre>
   <ul>
    <li>
     <p>
      <span class="pre">
       .s8
      </span>
      or
      <span class="pre">
       .u8
      </span>
      or
      <span class="pre">
       .e4m3
      </span>
      or
      <span class="pre">
       .e5m2
      </span>
      :
     </p>
     <table class="table-no-stripes docutils align-default">
      <tr class="row-odd">
       <th class="head">
        <p>
         .btype
        </p>
       </th>
       <th class="head">
        <p>
         Fragment
        </p>
       </th>
       <th class="head">
        <p>
         Elements (low to high)
        </p>
       </th>
      </tr>
      <tr class="row-even">
       <td>
        <p>
         <span class="pre">
          .s8
         </span>
         /
         <span class="pre">
          .u8
         </span>
        </p>
       </td>
       <td>
        <p>
         A vector expression containing two
         <span class="pre">
          .b32
         </span>
         registers, with each
register containing four
         <span class="pre">
          .s8
         </span>
         /
         <span class="pre">
          .u8
         </span>
         elements from the
matrix B.
        </p>
       </td>
       <td>
        <p>
         b0, b1, b2, b3, b4, b5, b6, b7
        </p>
       </td>
      </tr>
      <tr class="row-odd">
       <td>
        <p>
         <span class="pre">
          .e4m3
         </span>
         /
         <span class="pre">
          .e5m2
         </span>
        </p>
       </td>
       <td>
        <p>
         A vector expression containing two
         <span class="pre">
          .b32
         </span>
         registers, with each
register containing four
         <span class="pre">
          .e4m3
         </span>
         /
         <span class="pre">
          .e5m2
         </span>
         elements from the
matrix B.
        </p>
       </td>
       <td>
        <p>
         b0, b1, b2, b3, b4, b5, b6, b7
        </p>
       </td>
      </tr>
     </table>
     <p>
      The layout of the fragments held by different threads is shown in
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16832-b-i8-1">
       <span class="std std-numref">
        Figure 65
       </span>
      </a>
      and
      <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16832-b-i8-2">
       <span class="std std-numref">
        Figure 66
       </span>
      </a>
      .
     </p>
     <p>
      <span class="caption-number">
       Figure 65
      </span>
      <span class="caption-text">
       MMA .m16n8k32 fragment layout for rows 0â15 of matrix B with
       <span class="pre">
        .u8
       </span>
       /
       <span class="pre">
        .s8
       </span>
       type.
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16832-b-i8-1" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      <span class="caption-number">
       Figure 66
      </span>
      <span class="caption-text">
       MMA .m16n8k32 fragment layout for rows 16â31 of matrix B with
       <span class="pre">
        .u8
       </span>
       /
       <span class="pre">
        .s8
       </span>
       type.
      </span>
      <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16832-b-i8-2" title="Permalink to this image">
       ï
      </a>
     </p>
     <p>
      The row and column of a matrix fragment can be computed as:
     </p>
     <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x3</span><span class="p">)</span><span class="k">for</span><span class="n">bi</span><span class="n">where</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span>
<span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x3</span><span class="p">)</span><span class="o">+</span><span class="mi">16</span><span class="k">for</span><span class="n">bi</span><span class="n">where</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">4</span>

<span class="n">col</span><span class="o">=</span><span class="n">groupID</span>
</pre>
    </li>
   </ul>
  </li>
  <li>
   <p>
    Accumulators (C or D):
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .ctype / .dtype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .s32
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing four
       <span class="pre">
        .s32
       </span>
       registers, containing
four
       <span class="pre">
        .s32
       </span>
       elements from the matrix C (or D).
      </p>
     </td>
     <td>
      <p>
       c0, c1, c2, c3
      </p>
     </td>
    </tr>
    <tr class="row-odd">
     <td>
      <p>
       <span class="pre">
        .f32
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing four
       <span class="pre">
        .f32
       </span>
       registers, containing
four
       <span class="pre">
        .f32
       </span>
       elements from the matrix C (or D).
      </p>
     </td>
     <td>
      <p>
       c0, c1, c2, c3
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16832-c">
     <span class="std std-numref">
      Figure 67
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 67
    </span>
    <span class="caption-text">
     MMA .m16n8k32 fragment layout for accumulator matrix C/D with
     <span class="pre">
      .s32
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16832-c" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">ci</span><span class="n">where</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">2</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="k">for</span><span class="n">ci</span><span class="n">where</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">2</span>

<span class="n">col</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x1</span><span class="p">)</span><span class="k">for</span><span class="n">ci</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,..,</span><span class="mi">3</span><span class="p">}</span>
</pre>
  </li>
 </ul>
 <h5>
  <span class="section-number">
   9.7.13.4.11.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-mma-16864">
   Matrix Fragments for mma.m16n8k64
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-mma-m16n8k64" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  A warp executing
  <span class="pre">
   mma.m16n8k64
  </span>
  will compute an MMA operation of shape
  <span class="pre">
   .m16n8k64
  </span>
  .
 </p>
 <p>
  Elements of the matrix are distributed across the threads in a warp so each thread of the warp holds
a fragment of the matrix.
 </p>
 <ul>
  <li>
   <p>
    Multiplicand A:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .atype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .s4
       </span>
       /
       <span class="pre">
        .u4
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing four
       <span class="pre">
        .b32
       </span>
       registers, with each
register containing eight
       <span class="pre">
        .s4
       </span>
       /
       <span class="pre">
        .u4
       </span>
       elements from the
matrix A.
      </p>
     </td>
     <td>
      <p>
       a0, a1, â¦, a30, a31
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16864-a">
     <span class="std std-numref">
      Figure 68
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 68
    </span>
    <span class="caption-text">
     MMA .m16n8k64 fragment layout for matrix A with
     <span class="pre">
      .u4
     </span>
     /
     <span class="pre">
      .s4
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16864-a" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">||</span><span class="mi">16</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">24</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="n">otherwise</span>

<span class="n">col</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x7</span><span class="p">)</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">16</span>
<span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x7</span><span class="p">)</span><span class="o">+</span><span class="mi">32</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">16</span>
</pre>
  </li>
  <li>
   <p>
    Multiplicand B:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .btype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .s4
       </span>
       /
       <span class="pre">
        .u4
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing two
       <span class="pre">
        .b32
       </span>
       registers, with each
register containing eight
       <span class="pre">
        .s4
       </span>
       /
       <span class="pre">
        .u4
       </span>
       elements from the
matrix B.
      </p>
     </td>
     <td>
      <p>
       b0, b1, â¦, b14, b15
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16864-b-1">
     <span class="std std-numref">
      Figure 69
     </span>
    </a>
    and
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16864-b-2">
     <span class="std std-numref">
      Figure 70
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 69
    </span>
    <span class="caption-text">
     MMA .m16n8k64 fragment layout for rows 0â31 of matrix B with
     <span class="pre">
      .u4
     </span>
     /
     <span class="pre">
      .s4
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16864-b-1" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    <span class="caption-number">
     Figure 70
    </span>
    <span class="caption-text">
     MMA .m16n8k64 fragment layout for rows 32â63 of matrix B with
     <span class="pre">
      .u4
     </span>
     /
     <span class="pre">
      .s4
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16864-b-2" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x7</span><span class="p">)</span><span class="k">for</span><span class="n">bi</span><span class="n">where</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">8</span>
<span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x7</span><span class="p">)</span><span class="o">+</span><span class="mi">32</span><span class="k">for</span><span class="n">bi</span><span class="n">where</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">8</span>

<span class="n">col</span><span class="o">=</span><span class="n">groupID</span>
</pre>
  </li>
  <li>
   <p>
    Accumulators (C or D):
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .ctype / .dtype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .s32
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing four
       <span class="pre">
        .s32
       </span>
       registers, containing four
       <span class="pre">
        .s32
       </span>
       elements from the matrix C (or D).
      </p>
     </td>
     <td>
      <p>
       c0, c1, c2, c3
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16864-c">
     <span class="std std-numref">
      Figure 71
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 71
    </span>
    <span class="caption-text">
     MMA .m16n8k64 fragment layout for accumulator matrix C/D with
     <span class="pre">
      .s32
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-16864-c" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">ci</span><span class="n">where</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">2</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="k">for</span><span class="n">ci</span><span class="n">where</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">2</span>

<span class="n">col</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x1</span><span class="p">)</span><span class="k">for</span><span class="n">ci</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,..,</span><span class="mi">3</span><span class="p">}</span>
</pre>
  </li>
 </ul>
 <h5>
  <span class="section-number">
   9.7.13.4.12.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-mma-168128">
   Matrix Fragments for mma.m16n8k128
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-mma-m16n8k128" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  A warp executing
  <span class="pre">
   mma.m16n8k128
  </span>
  will compute an MMA operation of shape
  <span class="pre">
   .m16n8k128
  </span>
  .
 </p>
 <p>
  Elements of the matrix are distributed across the threads in a warp so each thread of the warp holds
a fragment of the matrix.
 </p>
 <ul>
  <li>
   <p>
    Multiplicand A:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .atype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .b1
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing two
       <span class="pre">
        .b32
       </span>
       registers, with each register containing
thirty two
       <span class="pre">
        .b1
       </span>
       elements from the matrix A.
      </p>
     </td>
     <td>
      <p>
       a0, a1, â¦, a62, a63
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-168128-a">
     <span class="std std-numref">
      Figure 72
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 72
    </span>
    <span class="caption-text">
     MMA .m16n8k128 fragment layout for matrix A with
     <span class="pre">
      .b1
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-168128-a" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">32</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">32</span>

<span class="n">col</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">32</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x1F</span><span class="p">)</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="p">...,</span><span class="mi">63</span><span class="p">}</span>
</pre>
  </li>
  <li>
   <p>
    Multiplicand B:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .btype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .b1
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing a single
       <span class="pre">
        .b32
       </span>
       register containing thirty
two
       <span class="pre">
        .b1
       </span>
       elements from the matrix B.
      </p>
     </td>
     <td>
      <p>
       b0, b1, â¦ , b30, b31
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-168128-b">
     <span class="std std-numref">
      Figure 73
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 73
    </span>
    <span class="caption-text">
     MMA .m16n8k128 fragment layout for matrix B with
     <span class="pre">
      .b1
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-168128-b" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">32</span><span class="p">)</span><span class="o">+</span><span class="n">i</span><span class="k">for</span><span class="n">bi</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,...,</span><span class="mi">31</span><span class="p">}</span>
<span class="n">col</span><span class="o">=</span><span class="n">groupID</span>
</pre>
  </li>
  <li>
   <p>
    Accumulators (C or D):
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .ctype / .dtype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .s32
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing four
       <span class="pre">
        .s32
       </span>
       registers, containing
four
       <span class="pre">
        .s32
       </span>
       elements from the matrix C (or D).
      </p>
     </td>
     <td>
      <p>
       c0, c1, c2, c3
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-168128-c">
     <span class="std std-numref">
      Figure 74
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 74
    </span>
    <span class="caption-text">
     MMA .m16n8k128 fragment layout for accumulator matrix C/D with
     <span class="pre">
      .s32
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-168128-c" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">ci</span><span class="n">where</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">2</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="k">for</span><span class="n">ci</span><span class="n">where</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">2</span>

<span class="n">col</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x1</span><span class="p">)</span><span class="k">for</span><span class="n">ci</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span>
</pre>
  </li>
 </ul>
 <h5>
  <span class="section-number">
   9.7.13.4.13.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-mma-168256">
   Matrix Fragments for mma.m16n8k256
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-mma-m16n8k256" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  A warp executing
  <span class="pre">
   mma.m16n8k256
  </span>
  will compute an MMA operation of shape
  <span class="pre">
   .m16n8k256
  </span>
  .
 </p>
 <p>
  Elements of the matrix are distributed across the threads in a warp so each thread of the warp holds
a fragment of the matrix.
 </p>
 <ul>
  <li>
   <p>
    Multiplicand A:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .atype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .b1
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing four
       <span class="pre">
        .b32
       </span>
       registers, with each register
containing thirty two
       <span class="pre">
        .b1
       </span>
       elements from the matrix A.
      </p>
     </td>
     <td>
      <p>
       a0, a1, â¦, a126, a127
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-168256-a">
     <span class="std std-numref">
      Figure 75
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 75
    </span>
    <span class="caption-text">
     MMA .m16n8k256 fragment layout for matrix A with
     <span class="pre">
      .b1
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-168256-a" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">||</span><span class="mi">64</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">96</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="n">otherwise</span>

<span class="n">col</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">32</span><span class="p">)</span><span class="o">+</span><span class="n">i</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">64</span>
<span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">32</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x1F</span><span class="p">)</span><span class="o">+</span><span class="mi">128</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">64</span>
</pre>
  </li>
  <li>
   <p>
    Multiplicand B:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .btype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .b1
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing two
       <span class="pre">
        .b32
       </span>
       registers, with each register
containing thirty two
       <span class="pre">
        .b1
       </span>
       elements from the matrix B.
      </p>
     </td>
     <td>
      <p>
       b0, b1, â¦, b62, b63
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-168256-b-1">
     <span class="std std-numref">
      Figure 76
     </span>
    </a>
    and
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-168256-b-2">
     <span class="std std-numref">
      Figure 77
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 76
    </span>
    <span class="caption-text">
     MMA .m16n8k256 fragment layout for rows 0â127 of matrix B with
     <span class="pre">
      .b1
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-168256-b-1" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    <span class="caption-number">
     Figure 77
    </span>
    <span class="caption-text">
     MMA .m16n8k256 fragment layout for rows 128â255 of matrix B with
     <span class="pre">
      .b1
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-168256-b-2" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">32</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x1F</span><span class="p">)</span><span class="k">for</span><span class="n">bi</span><span class="n">where</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">32</span>
<span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">32</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x1F</span><span class="p">)</span><span class="o">+</span><span class="mi">128</span><span class="k">for</span><span class="n">bi</span><span class="n">where</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">32</span>

<span class="n">col</span><span class="o">=</span><span class="n">groupID</span>
</pre>
  </li>
  <li>
   <p>
    Accumulators (C or D):
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .ctype / .dtype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .s32
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing four
       <span class="pre">
        .s32
       </span>
       registers, containing
four
       <span class="pre">
        .s32
       </span>
       elements from the matrix C (or D).
      </p>
     </td>
     <td>
      <p>
       c0, c1, c2, c3
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-168256-c">
     <span class="std std-numref">
      Figure 78
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 78
    </span>
    <span class="caption-text">
     MMA .m16n8k256 fragment layout for accumulator matrix C/D with
     <span class="pre">
      .s32
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-168256-c" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">ci</span><span class="n">where</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">2</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="k">for</span><span class="n">ci</span><span class="n">where</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">2</span>

<span class="n">col</span><span class="o">=</span><span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x1</span><span class="p">)</span><span class="k">for</span><span class="n">ci</span><span class="n">where</span><span class="n">i</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span>
</pre>
  </li>
 </ul>
 <h5>
  <span class="section-number">
   9.7.13.4.14.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-instructions-mma">
   Multiply-and-Accumulate Instruction: mma
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#multiply-and-accumulate-instruction-mma" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  mma
 </p>
 <p>
  Perform matrix multiply-and-accumulate operation
 </p>
 <p>
  Syntax
 </p>
 <p>
  Half precision floating point type:
 </p>
 <pre>mma.sync.aligned.m8n8k4.alayout.blayout.dtype.f16.f16.ctype  d, a, b, c;
mma.sync.aligned.m16n8k8.row.col.dtype.f16.f16.ctype  d, a, b, c;
mma.sync.aligned.m16n8k16.row.col.dtype.f16.f16.ctype d, a, b, c;

.alayout = {.row, .col};
.blayout = {.row, .col};
.ctype   = {.f16, .f32};
.dtype   = {.f16, .f32};
</pre>
 <p>
  Alternate floating point type :
 </p>
 <pre>mma.sync.aligned.m16n8k4.row.col.f32.tf32.tf32.f32        d, a, b, c;
mma.sync.aligned.m16n8k8.row.col.f32.atype.btype.f32      d, a, b, c;
mma.sync.aligned.m16n8k16.row.col.f32.bf16.bf16.f32       d, a, b, c;
mma.sync.aligned.m16n8k32.row.col.f32.f8type.f8type.f32   d, a, b, c;

.atype  = {.bf16, .tf32};
.btype  = {.bf16, .tf32};
.f8type = {.e4m3, .e5m2};
</pre>
 <p>
  Double precision floating point type:
 </p>
 <pre>mma.sync.aligned.shape.row.col.f64.f64.f64.f64 d, a, b, c;

.shape   = {.m8n84, .m16n8k4, .m16n8k8, .m16n8k16};
</pre>
 <p>
  Integer type:
 </p>
 <pre>mma.sync.aligned.shape.row.col{.satfinite}.s32.atype.btype.s32 d, a, b, c;

.shape   = {.m8n8k16, .m16n8k16, .m16n8k32}
.atype   = {.u8, .s8};
.btype   = {.u8, .s8};

mma.sync.aligned.shape.row.col{.satfinite}.s32.atype.btype.s32 d, a, b, c;

.shape   = {.m8n8k32, .m16n8k32, .m16n8k64}
.atype   = {.u4, .s4};
.btype   = {.u4, .s4};
</pre>
 <p>
  Single bit:
 </p>
 <pre>mma.sync.aligned.shape.row.col.s32.b1.b1.s32.bitOp.popc d, a, b, c;

.bitOp = {.xor, .and}
.shape = {.m8n8k128, .m16n8k128, .m16n8k256}
</pre>
 <p>
  Description
 </p>
 <p>
  Perform a
  <span class="pre">
   MxNxK
  </span>
  matrix multiply and accumulate operation,
  <span class="pre">
   D
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   A*B+C
  </span>
  , where the A matrix is
  <span class="pre">
   MxK
  </span>
  , the B matrix is
  <span class="pre">
   KxN
  </span>
  , and the C and D matrices are
  <span class="pre">
   MxN
  </span>
  .
 </p>
 <p>
  A warp executing
  <span class="pre">
   mma.sync.m8n8k4
  </span>
  instruction computes 4 matrix multiply and accumulate
operations. Rest of the
  <span class="pre">
   mma.sync
  </span>
  operations compute a single matrix mutliply and accumulate
operation per warp.
 </p>
 <p>
  For single-bit
  <span class="pre">
   mma.sync
  </span>
  , multiplication is replaced by a sequence of logical operations;
specifically,
  <span class="pre">
   mma.xor.popc
  </span>
  and
  <span class="pre">
   mma.and.popc
  </span>
  computes the XOR, AND respectively of a k-bit
row of A with a k-bit column of B, then counts the number of set bits in the result (
  <span class="pre">
   popc
  </span>
  ). This
result is added to the corresponding element of C and written into D.
 </p>
 <p>
  Operands
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  represent two multiplicand matrices A and B, while
  <span class="pre">
   c
  </span>
  and
  <span class="pre">
   d
  </span>
  represent the accumulator and destination matrices, distributed across the threads in warp.
 </p>
 <p>
  The registers in each thread hold a fragment of matrix as described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-instructions-for-mma">
   Matrix multiply-accumulate
operation using mma instruction
  </a>
  .
 </p>
 <p>
  The qualifiers
  <span class="pre">
   .dtype
  </span>
  ,
  <span class="pre">
   .atype
  </span>
  ,
  <span class="pre">
   .btype
  </span>
  and
  <span class="pre">
   .ctype
  </span>
  indicate the data-type of the
elements in the matrices D, A, B and C respectively. Specific shapes have type restrictions :
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     .m8n8k4
    </span>
    : When
    <span class="pre">
     .ctype
    </span>
    is
    <span class="pre">
     .f32
    </span>
    ,
    <span class="pre">
     .dtype
    </span>
    must also be
    <span class="pre">
     .f32
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .m16n8k8
    </span>
    :
   </p>
   <ul>
    <li>
     <p>
      <span class="pre">
       .dtype
      </span>
      must be the same as
      <span class="pre">
       .ctype
      </span>
      .
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       .atype
      </span>
      must be the same as
      <span class="pre">
       .btype
      </span>
      .
     </p>
    </li>
   </ul>
  </li>
 </ul>
 <p>
  The qualifiers
  <span class="pre">
   .alayout
  </span>
  and
  <span class="pre">
   .blayout
  </span>
  indicate the row-major or column-major layouts of
matrices A and B respectively.
 </p>
 Precision and rounding :
 <ul>
  <li>
   <p>
    <span class="pre">
     .f16
    </span>
    floating point operations:
   </p>
   <p>
    Element-wise multiplication of matrix A and B is performed with at least single
precision. When
    <span class="pre">
     .ctype
    </span>
    or
    <span class="pre">
     .dtype
    </span>
    is
    <span class="pre">
     .f32
    </span>
    , accumulation of the intermediate values
is performed with at least single precision. When both
    <span class="pre">
     .ctype
    </span>
    and
    <span class="pre">
     .dtype
    </span>
    are specified
as
    <span class="pre">
     .f16
    </span>
    , the accumulation is performed with at least half precision.
   </p>
   <p>
    The accumulation order, rounding and handling of subnormal inputs are unspecified.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .e4m3
    </span>
    and
    <span class="pre">
     .e5m2
    </span>
    floating point operations :
   </p>
   <p>
    Element-wise multiplication of matrix A and B is performed with specified precision. Accumulation
of the intermediate values is performed with at least single precision.
   </p>
   <p>
    The accumulation order, rounding, and handling of subnormal inputs are unspecified.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .bf16
    </span>
    and
    <span class="pre">
     .tf32
    </span>
    floating point operations :
   </p>
   <p>
    Element-wise multiplication of matrix A and B is performed with specified
precision. Accumulation of the intermediate values is performed with at least single
precision.
   </p>
   <p>
    The accumulation order, rounding, and handling of subnormal inputs are unspecified.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .f64
    </span>
    floating point operations :
   </p>
  </li>
 </ul>
 <p>
  Precision of the element-wise multiplication and addition operation is identical to that of
  <span class="pre">
   .f64
  </span>
  precision fused multiply-add. Supported rounding modifiers are :
 </p>
 <ul>
  <li>
   <p>
    <span class="pre">
     .rn
    </span>
    : mantissa LSB rounds to nearest even. This is the default.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .rz
    </span>
    : mantissa LSB rounds towards zero.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .rm
    </span>
    : mantissa LSB rounds towards negative infinity.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .rp
    </span>
    : mantissa LSB rounds towards positive infinity.
   </p>
   <ul>
    <li>
     <p>
      Integer operations :
     </p>
     <p>
      The integer
      <span class="pre">
       mma
      </span>
      operation is performed with
      <span class="pre">
       .s32
      </span>
      accumulators. The
      <span class="pre">
       .satfinite
      </span>
      qualifier indicates that on overflow, the accumulated value is limited to the range
      MIN_INT32
      ..
      MAX_INT32
      (where the bounds are defined as the minimum negative signed 32-bit
integer and the maximum positive signed 32-bit integer respectively).
     </p>
     <p>
      If
      <span class="pre">
       .satfinite
      </span>
      is not specified, the accumulated value is wrapped instead.
     </p>
    </li>
   </ul>
  </li>
 </ul>
 <p>
  The mandatory
  <span class="pre">
   .sync
  </span>
  qualifier indicates that
  <span class="pre">
   mma
  </span>
  instruction causes the executing thread to
wait until all threads in the warp execute the same
  <span class="pre">
   mma
  </span>
  instruction before resuming execution.
 </p>
 <p>
  The mandatory
  <span class="pre">
   .aligned
  </span>
  qualifier indicates that all threads in the warp must execute the same
  <span class="pre">
   mma
  </span>
  instruction. In conditionally executed code, a
  <span class="pre">
   mma
  </span>
  instruction should only be used if it
is known that all threads in the warp evaluate the condition identically, otherwise behavior is
undefined.
 </p>
 <p>
  The behavior of
  <span class="pre">
   mma
  </span>
  instruction is undefined if all threads in the same warp do not use the same
qualifiers, or if any thread in the warp has exited.
 </p>
 <p>
  Notes
 </p>
 <p>
  Programs using double precision floating point
  <span class="pre">
   mma
  </span>
  instruction with shapes
  <span class="pre">
   .m16n8k4
  </span>
  ,
  <span class="pre">
   .m16n8k8
  </span>
  , and
  <span class="pre">
   .m16n8k16
  </span>
  require at least 64 registers for compilation.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 6.4.
 </p>
 <p>
  <span class="pre">
   .f16
  </span>
  floating point type
  <span class="pre">
   mma
  </span>
  operation with
  <span class="pre">
   .m8n8k4
  </span>
  shape introduced in PTX ISA version
6.4.
 </p>
 <p>
  <span class="pre">
   .f16
  </span>
  floating point type
  <span class="pre">
   mma
  </span>
  operation with
  <span class="pre">
   .m16n8k8
  </span>
  shape introduced in PTX ISA version
6.5.
 </p>
 <p>
  <span class="pre">
   .u8/.s8
  </span>
  integer type
  <span class="pre">
   mma
  </span>
  operation with
  <span class="pre">
   .m8n8k16
  </span>
  shape introduced in PTX ISA version
6.5.
 </p>
 <p>
  <span class="pre">
   .u4/.s4
  </span>
  integer type
  <span class="pre">
   mma
  </span>
  operation with
  <span class="pre">
   .m8n8k32
  </span>
  shape introduced in PTX ISA version
6.5.
 </p>
 <p>
  <span class="pre">
   .f64
  </span>
  floating point type
  <span class="pre">
   mma
  </span>
  operation with
  <span class="pre">
   .m8n8k4
  </span>
  shape introduced in PTX ISA version
7.0.
 </p>
 <p>
  <span class="pre">
   .f16
  </span>
  floating point type
  <span class="pre">
   mma
  </span>
  operation with
  <span class="pre">
   .m16n8k16
  </span>
  shape introduced in PTX ISA
version 7.0.
 </p>
 <p>
  <span class="pre">
   .bf16
  </span>
  alternate floating point type
  <span class="pre">
   mma
  </span>
  operation with
  <span class="pre">
   .m16n8k8
  </span>
  and
  <span class="pre">
   .m16n8k16
  </span>
  shapes
introduced in PTX ISA version 7.0.
 </p>
 <p>
  <span class="pre">
   .tf32
  </span>
  alternate floating point type
  <span class="pre">
   mma
  </span>
  operation with
  <span class="pre">
   .m16n8k4
  </span>
  and
  <span class="pre">
   .m16n8k8
  </span>
  shapes
introduced in PTX ISA version 7.0.
 </p>
 <p>
  <span class="pre">
   .u8/.s8
  </span>
  integer type
  <span class="pre">
   mma
  </span>
  operation with
  <span class="pre">
   .m16n8k16
  </span>
  and
  <span class="pre">
   .m16n8k32
  </span>
  shapes introduced in
PTX ISA version 7.0.
 </p>
 <p>
  <span class="pre">
   .u4/.s4
  </span>
  integer type
  <span class="pre">
   mma
  </span>
  operation with
  <span class="pre">
   .m16n8k32
  </span>
  and
  <span class="pre">
   .m16n8k64
  </span>
  shapes introduced in
PTX ISA version 7.0.
 </p>
 <p>
  <span class="pre">
   .b1
  </span>
  single-bit integer type
  <span class="pre">
   mma
  </span>
  operation with
  <span class="pre">
   .m8n8k128
  </span>
  ,
  <span class="pre">
   .m16n8k128
  </span>
  and
  <span class="pre">
   .m16n8k256
  </span>
  shapes introduced in PTX ISA version 7.0.
 </p>
 <p>
  Support for
  <span class="pre">
   .and
  </span>
  operation in single-bit
  <span class="pre">
   mma
  </span>
  introduced in PTX ISA version 7.1.
 </p>
 <p>
  <span class="pre">
   .f64
  </span>
  floating point type
  <span class="pre">
   mma
  </span>
  operation with
  <span class="pre">
   .m16n8k4
  </span>
  ,
  <span class="pre">
   .m16n8k8
  </span>
  , and
  <span class="pre">
   .m16n8k16
  </span>
  shapes introduced in PTX ISA version 7.8.
 </p>
 <p>
  Support for
  <span class="pre">
   .e4m3
  </span>
  and
  <span class="pre">
   .e5m2
  </span>
  alternate floating point type
  <span class="pre">
   mma
  </span>
  operation introduced in
PTX ISA version 8.4.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   .f16
  </span>
  floating point type
  <span class="pre">
   mma
  </span>
  operation with
  <span class="pre">
   .m8n8k4
  </span>
  shape requires
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p class="admonition-title">
  Note
 </p>
 <p>
  <span class="pre">
   mma.sync.m8n8k4
  </span>
  is optimized for target architecture
  <span class="pre">
   sm_70
  </span>
  and may have substantially
reduced performance on other target architectures.
 </p>
 <p>
  <span class="pre">
   .f16
  </span>
  floating point type
  <span class="pre">
   mma
  </span>
  operation with
  <span class="pre">
   .m16n8k8
  </span>
  shape requires
  <span class="pre">
   sm_75
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   .u8/.s8
  </span>
  integer type
  <span class="pre">
   mma
  </span>
  operation with
  <span class="pre">
   .m8n8k16
  </span>
  shape requires
  <span class="pre">
   sm_75
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   .u4/.s4
  </span>
  integer type
  <span class="pre">
   mma
  </span>
  operation with
  <span class="pre">
   .m8n8k32
  </span>
  shape
  <span class="pre">
   sm_75
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   .b1
  </span>
  single-bit integer type
  <span class="pre">
   mma
  </span>
  operation with
  <span class="pre">
   .m8n8k128
  </span>
  shape
  <span class="pre">
   sm_75
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   .f64
  </span>
  floating point type
  <span class="pre">
   mma
  </span>
  operation with
  <span class="pre">
   .m8n8k4
  </span>
  shape requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   .f16
  </span>
  floating point type
  <span class="pre">
   mma
  </span>
  operation with
  <span class="pre">
   .m16n8k16
  </span>
  shape requires
  <span class="pre">
   sm_80
  </span>
  or
higher.
 </p>
 <p>
  <span class="pre">
   .bf16
  </span>
  alternate floating point type
  <span class="pre">
   mma
  </span>
  operation with
  <span class="pre">
   .m16n8k8
  </span>
  and
  <span class="pre">
   .m16n8k16
  </span>
  shapes
requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   .tf32
  </span>
  alternate floating point type
  <span class="pre">
   mma
  </span>
  operation with
  <span class="pre">
   .m16n8k4
  </span>
  and
  <span class="pre">
   .m16n8k8
  </span>
  shapes
requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   .u8/.s8
  </span>
  integer type
  <span class="pre">
   mma
  </span>
  operation with
  <span class="pre">
   .m16n8k16
  </span>
  and
  <span class="pre">
   .m16n8k32
  </span>
  shapes requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   .u4/.s4
  </span>
  integer type
  <span class="pre">
   mma
  </span>
  operation with
  <span class="pre">
   .m16n8k32
  </span>
  and
  <span class="pre">
   .m16n8k64
  </span>
  shapes requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   .b1
  </span>
  single-bit integer type
  <span class="pre">
   mma
  </span>
  operation with
  <span class="pre">
   .m16n8k128
  </span>
  and
  <span class="pre">
   .m16n8k256
  </span>
  shapes
requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   .and
  </span>
  operation in single-bit
  <span class="pre">
   mma
  </span>
  requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   .f64
  </span>
  floating point type
  <span class="pre">
   mma
  </span>
  operation with
  <span class="pre">
   .m16n8k4
  </span>
  ,
  <span class="pre">
   .m16n8k8
  </span>
  , and
  <span class="pre">
   .m16n8k16
  </span>
  shapes require
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   .e4m3
  </span>
  and
  <span class="pre">
   .e5m2
  </span>
  alternate floating point type
  <span class="pre">
   mma
  </span>
  operation requires
  <span class="pre">
   sm_89
  </span>
  or higher.
 </p>
 <p>
  Examples of half precision floating point type
 </p>
 <pre>// f16 elements in C and D matrix
.reg .f16x2 %Ra&lt;2&gt; %Rb&lt;2&gt; %Rc&lt;4&gt; %Rd&lt;4&gt;
mma.sync.aligned.m8n8k4.row.col.f16.f16.f16.f16
{%Rd0, %Rd1, %Rd2, %Rd3},
{%Ra0, %Ra1},
{%Rb0, %Rb1},
{%Rc0, %Rc1, %Rc2, %Rc3};


// f16 elements in C and f32 elements in D
.reg .f16x2 %Ra&lt;2&gt; %Rb&lt;2&gt; %Rc&lt;4&gt;
.reg .f32 %Rd&lt;8&gt;
mma.sync.aligned.m8n8k4.row.col.f32.f16.f16.f16
{%Rd0, %Rd1, %Rd2, %Rd3, %Rd4, %Rd5, %Rd6, %Rd7},
{%Ra0, %Ra1},
{%Rb0, %Rb1},
{%Rc0, %Rc1, %Rc2, %Rc3};

 // f32 elements in C and D
.reg .f16x2 %Ra&lt;2&gt;, %Rb&lt;1&gt;;
.reg .f32 %Rc&lt;4&gt;, %Rd&lt;4&gt;;
mma.sync.aligned.m16n8k8.row.col.f32.f16.f16.f32
  {%Rd0, %Rd1, %Rd2, %Rd3},
  {%Ra0, %Ra1},
  {%Rb0},
  {%Rc0, %Rc1, %Rc2, %Rc3};

.reg .f16x2 %Ra&lt;4&gt;, %Rb&lt;2&gt;, %Rc&lt;2&gt;, %Rd&lt;2&gt;;
mma.sync.aligned.m16n8k16.row.col.f16.f16.f16.f16
  {%Rd0, %Rd1},
  {%Ra0, %Ra1, %Ra2, %Ra3},
  {%Rb0, %Rb1},
  {%Rc0, %Rc1};

.reg .f16 %Ra&lt;4&gt;, %Rb&lt;2&gt;;
.reg .f32 %Rc&lt;2&gt;, %Rd&lt;2&gt;;
mma.sync.aligned.m16n8k16.row.col.f32.f16.f16.f32
  {%Rd0, %Rd1, %Rd2, %Rd3},
  {%Ra0, %Ra1, %Ra2, %Ra3},
  {%Rb0, %Rb1},
  {%Rc0, %Rc1, %Rc2, %Rc3};
</pre>
 <p>
  Examples of alternate floating point type
 </p>
 <pre>.reg .b32 %Ra&lt;2&gt;, %Rb&lt;1&gt;;
.reg .f32 %Rc&lt;4&gt;, %Rd&lt;4&gt;;
mma.sync.aligned.m16n8k4.row.col.f32.tf32.tf32.f32
  {%Rd0, %Rd1, %Rd2, %Rd3},
  {%Ra0, %Ra1},
  {%Rb0},
  {%Rc0, %Rc1, %Rc2, %Rc3};

.reg .f16x2 %Ra&lt;2&gt;, %Rb&lt;1&gt;;
.reg .f32 %Rc&lt;4&gt;, %Rd&lt;4&gt;;
mma.sync.aligned.m16n8k8.row.col.f32.bf16.bf16.f32
  {%Rd0, %Rd1, %Rd2, %Rd3},
  {%Ra0, %Ra1},
  {%Rb0},
  {%Rc0, %Rc1, %Rc2, %Rc3};

.reg .b32 %Ra&lt;2&gt;, %Rb&lt;1&gt;;
.reg .f32 %Rc&lt;4&gt;, %Rd&lt;4&gt;;
mma.sync.aligned.m16n8k8.row.col.f32.tf32.tf32.f32
  {%Rd0, %Rd1, %Rd2, %Rd3},
  {%Ra0, %Ra1, %Rb2, %Rb3},
  {%Rb0, %Rb1},
  {%Rc0, %Rc1, %Rc2, %Rc3};

.reg .f16x2 %Ra&lt;2&gt;, %Rb&lt;1&gt;;
.reg .f32 %Rc&lt;4&gt;, %Rd&lt;4&gt;;
mma.sync.aligned.m16n8k16.row.col.f32.bf16.bf16.f32
  {%Rd0, %Rd1, %Rd2, %Rd3},
  {%Ra0, %Ra1, %Ra2, %Ra3},
  {%Rb0, %Rb1},
  {%Rc0, %Rc1, %Rc2, %Rc3};

.reg .b32 %Ra&lt;4&gt;, %Rb&lt;4&gt;;
.reg .f32 %Rc&lt;4&gt;, %Rd&lt;4&gt;;
mma.sync.aligned.m16n8k32.row.col.f32.e4m3.e5m2.f32
  {%Rd0, %Rd1, %Rd2, %Rd3},
  {%Ra0, %Ra1, %Ra2, %Ra3},
  {%Rb0, %Rb1},
  {%Rc0, %Rc1, %Rc2, %Rc3};
</pre>
 <p>
  Examples of integer type
 </p>
 <pre>.reg .b32 %Ra, %Rb, %Rc&lt;2&gt;, %Rd&lt;2&gt;;

// s8 elements in A and u8 elements in B
mma.sync.aligned.m8n8k16.row.col.satfinite.s32.s8.u8.s32
  {%Rd0, %Rd1},
  {%Ra},
  {%Rb},
  {%Rc0, %Rc1};

// u4 elements in A and B matrix
mma.sync.aligned.m8n8k32.row.col.satfinite.s32.u4.u4.s32
  {%Rd0, %Rd1},
  {%Ra},
  {%Rb},
  {%Rc0, %Rc1};

// s8 elements in A and u8 elements in B
.reg .b32 %Ra&lt;2&gt;, %Rb, %Rc&lt;4&gt;, %Rd&lt;4&gt;;
mma.sync.aligned.m16n8k16.row.col.satfinite.s32.s8.u8.s32
  {%Rd0, %Rd1, %Rd2, %Rd3},
  {%Ra0, %Ra1},
  {%Rb},
  {%Rc0, %Rc1, %Rc2, %Rc3};

// u4 elements in A and s4 elements in B
.reg .b32 %Ra&lt;2&gt;, %Rb, %Rc&lt;4&gt;, %Rd&lt;4&gt;;
mma.sync.aligned.m16n8k32.row.col.satfinite.s32.u4.s4.s32
  {%Rd0, %Rd1, %Rd2, %Rd3},
  {%Ra0, %Ra1},
  {%Rb},
  {%Rc0, %Rc1, %Rc2, %Rc3};

// s8 elements in A and s8 elements in B
.reg .b32 %Ra&lt;4&gt;, %Rb&lt;2&gt;, %Rc&lt;4&gt;, %Rd&lt;4&gt;;
mma.sync.aligned.m16n8k32.row.col.satfinite.s32.s8.s8.s32
  {%Rd0, %Rd1, %Rd2, %Rd3},
  {%Ra0, %Ra1, %Ra2, %Ra3},
  {%Rb0, %Rb1},
  {%Rc0, %Rc1, %Rc2, %Rc3};

// u8 elements in A and u8 elements in B
.reg .b32 %Ra&lt;4&gt;, %Rb&lt;2&gt;, %Rc&lt;4&gt;, %Rd&lt;4&gt;;
mma.sync.aligned.m16n8k64.row.col.satfinite.s32.u4.u4.s32
  {%Rd0, %Rd1, %Rd2, %Rd3},
  {%Ra0, %Ra1, %Ra2, %Ra3},
  {%Rb0, %Rb1 },
  {%Rc0, %Rc1, %Rc2, %Rc3};
</pre>
 <p>
  Examples of single bit type
 </p>
 <pre>// b1 elements in A and B
.reg .b32 %Ra, %Rb, %Rc&lt;2&gt;, %Rd&lt;2&gt;;
mma.sync.aligned.m8n8k128.row.col.s32.b1.b1.s32.and.popc
  {%Rd0, %Rd1},
  {%Ra},
  {%Rb},
  {%Rc0, %Rc1};

// b1 elements in A and B
.reg .b32 %Ra, %Rb, %Rc&lt;2&gt;, %Rd&lt;2&gt;;
mma.sync.aligned.m8n8k128.row.col.s32.b1.b1.s32.xor.popc
  {%Rd0, %Rd1},
  {%Ra},
  {%Rb},
  {%Rc0, %Rc1};

.reg .b32 %Ra&lt;2&gt;, %Rb, %Rc&lt;4&gt;, %Rd&lt;4&gt;;
mma.sync.aligned.m16n8k128.row.col.s32.b1.b1.s32.xor.popc
  {%Rd0, %Rd1, %Rd2, %Rd3},
  {%Ra0, %Ra1},
  {%Rb},
  {%Rc0, %Rc1, %Rc2, %Rc3};

.reg .b32 %Ra&lt;2&gt;, %Rb, %Rc&lt;4&gt;, %Rd&lt;4&gt;;
mma.sync.aligned.m16n8k128.row.col.s32.b1.b1.s32.and.popc
  {%Rd0, %Rd1, %Rd2, %Rd3},
  {%Ra0, %Ra1},
  {%Rb},
  {%Rc0, %Rc1, %Rc2, %Rc3};

.reg .b32 %Ra&lt;4&gt;, %Rb&lt;2&gt;, %Rc&lt;4&gt;, %Rd&lt;4&gt;;
mma.sync.aligned.m16n8k256.row.col.s32.b1.b1.s32.xor.popc
  {%Rd0, %Rd1, %Rd2, %Rd3},
  {%Ra0, %Ra1, %Ra2, %Ra3},
  {%Rb0, %Rb1},
  {%Rc0, %Rc1, %Rc2, %Rc3};

.reg .b32 %Ra&lt;4&gt;, %Rb&lt;2&gt;, %Rc&lt;4&gt;, %Rd&lt;4&gt;;
mma.sync.aligned.m16n8k256.row.col.s32.b1.b1.s32.and.popc
  {%Rd0, %Rd1, %Rd2, %Rd3},
  {%Ra0, %Ra1, %Ra2, %Ra3},
  {%Rb0, %Rb1},
  {%Rc0, %Rc1, %Rc2, %Rc3};
</pre>
 <p>
  Examples of .f64 floating point type
 </p>
 <pre>.reg .f64 %Ra, %Rb, %Rc&lt;2&gt;, %Rd&lt;2&gt;;
mma.sync.aligned.m8n8k4.row.col.f64.f64.f64.f64
  {%Rd0, %Rd1},
  {%Ra},
  {%Rb},
  {%Rc0, %Rc1};

.reg .f64 %Ra&lt;8&gt;, %Rb&lt;4&gt;, %Rc&lt;4&gt;, %Rd&lt;4&gt;;
mma.sync.aligned.m16n8k4.row.col.f64.f64.f64.f64.rn
  {%Rd0, %Rd1, %Rd2, %Rd3},
  {%Ra0, %Ra1},
  {%Rb0},
  {%Rc0, %Rc1, %Rc2, %Rc3};

mma.sync.aligned.m16n8k8.row.col.f64.f64.f64.f64.rn
  {%Rd0, %Rd1, %Rd2, %Rd3},
  {%Ra0, %Ra1, %Ra2, %Ra3},
  {%Rb0, %Rb1},
  {%Rc0, %Rc1, %Rc2, %Rc3};

mma.sync.aligned.m16n8k16.row.col.f64.f64.f64.f64.rn
  {%Rd0, %Rd1, %Rd2, %Rd3},
  {%Ra0, %Ra1, %Ra2, %Ra3, %Ra4, %Ra5, %Ra6, %Ra7},
  {%Rb0, %Rb1, %Rb2, %Rb3},
  {%Rc0, %Rc1, %Rc2, %Rc3};
</pre>
 <h5>
  <span class="section-number">
   9.7.13.4.15.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-instructions-ldmatrix">
   Warp-level matrix load instruction: ldmatrix
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-load-instruction-ldmatrix" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  ldmatrix
 </p>
 <p>
  Collectively load one or more matrices from shared memory for
  <span class="pre">
   mma
  </span>
  instruction
 </p>
 <p>
  Syntax
 </p>
 <pre>ldmatrix.sync.aligned.shape.num{.trans}{.ss}.type r, [p];

.shape  = {.m8n8};
.num    = {.x1, .x2, .x4};
.ss     = {.shared{::cta}};
.type   = {.b16};
</pre>
 <p>
  Description
 </p>
 <p>
  Collectively load one or more matrices across all threads in a warp from the location indicated by
the address operand
  <span class="pre">
   p
  </span>
  , from
  <span class="pre">
   .shared
  </span>
  state space into destination register
  <span class="pre">
   r
  </span>
  . If no state
space is provided, generic addressing is used, such that the address in
  <span class="pre">
   p
  </span>
  points into
  <span class="pre">
   .shared
  </span>
  space. If the generic address doesnât fall in
  <span class="pre">
   .shared
  </span>
  state space, then the behavior
is undefined.
 </p>
 <p>
  The
  <span class="pre">
   .shape
  </span>
  qualifier indicates the dimensions of the matrices being loaded. Each matrix element
holds 16-bit data as indicated by the
  <span class="pre">
   .type
  </span>
  qualifier.
 </p>
 <p>
  The values
  <span class="pre">
   .x1
  </span>
  ,
  <span class="pre">
   .x2
  </span>
  and
  <span class="pre">
   .x4
  </span>
  for
  <span class="pre">
   .num
  </span>
  indicate one, two or four matrices
respectively.
 </p>
 <p>
  The mandatory
  <span class="pre">
   .sync
  </span>
  qualifier indicates that
  <span class="pre">
   ldmatrix
  </span>
  causes the executing thread to wait
until all threads in the warp execute the same
  <span class="pre">
   ldmatrix
  </span>
  instruction before resuming execution.
 </p>
 <p>
  The mandatory
  <span class="pre">
   .aligned
  </span>
  qualifier indicates that all threads in the warp must execute the same
  <span class="pre">
   ldmatrix
  </span>
  instruction. In conditionally executed code, an
  <span class="pre">
   ldmatrix
  </span>
  instruction should only be
used if it is known that all threads in the warp evaluate the condition identically, otherwise the
behavior is undefined.
 </p>
 <p>
  The behavior of
  <span class="pre">
   ldmatrix
  </span>
  is undefined if all threads do not use the same qualifiers, or if any
thread in the warp has exited.
 </p>
 <p>
  The destination operand
  <span class="pre">
   r
  </span>
  is a brace-enclosed vector expression consisting of 1, 2, or 4 32-bit
registers as per the value of
  <span class="pre">
   .num
  </span>
  . Each component of the vector expression holds a fragment
from the corresponding matrix.
 </p>
 <p>
  Supported addressing modes for
  <span class="pre">
   p
  </span>
  are described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#addresses-as-operands">
   Addresses as Operands
  </a>
  .
 </p>
 <p>
  Consecutive instances of row need not be stored contiguously in memory. The eight addresses required
for each matrix are provided by eight threads, depending upon the value of
  <span class="pre">
   .num
  </span>
  as shown in the
following table. Each address corresponds to the start of a matrix row. Addresses addr0âaddr7
correspond to the rows of the first matrix, addresses addr8âaddr15 correspond to the rows of the
second matrix, and so on.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      .num
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     Threads 0â7
    </p>
   </th>
   <th class="head">
    <p>
     Threads 8â15
    </p>
   </th>
   <th class="head">
    <p>
     Threads 16â23
    </p>
   </th>
   <th class="head">
    <p>
     Threads 24â31
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .x1
     </span>
    </p>
   </td>
   <td>
    <p>
     addr0âaddr7
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .x2
     </span>
    </p>
   </td>
   <td>
    <p>
     addr0âaddr7
    </p>
   </td>
   <td>
    <p>
     addr8âaddr15
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .x4
     </span>
    </p>
   </td>
   <td>
    <p>
     addr0âaddr7
    </p>
   </td>
   <td>
    <p>
     addr8âaddr15
    </p>
   </td>
   <td>
    <p>
     addr16âaddr23
    </p>
   </td>
   <td>
    <p>
     addr24âaddr31
    </p>
   </td>
  </tr>
 </table>
 <p class="admonition-title">
  Note
 </p>
 <p>
  For .target
  <span class="pre">
   sm_75
  </span>
  or below, all threads must contain valid addresses. Otherwise, the behavior
is undefined. For
  <span class="pre">
   .num
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   .x1
  </span>
  and
  <span class="pre">
   .num
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   .x2
  </span>
  , addresses contained in lower threads can be
copied to higher threads to achieve the expected behavior.
 </p>
 <p>
  When reading 8x8 matrices, a group of four consecutive threads loads 16 bytes. The matrix addresses
must be naturally aligned accordingly.
 </p>
 <p>
  Each thread in a warp loads fragments of a row, with thread 0 receiving the first fragment in its
register
  <span class="pre">
   r
  </span>
  , and so on. A group of four threads loads an entire row of the matrix as shown in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-ldmatrix-fragments">
   <span class="std std-numref">
    Figure 79
   </span>
  </a>
  .
 </p>
 <p>
  <span class="caption-number">
   Figure 79
  </span>
  <span class="caption-text">
   ldmatrix fragment layout
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-ldmatrix-fragments" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  When
  <span class="pre">
   .num
  </span>
  =
  <span class="pre">
   .x2
  </span>
  , the elements of the second matrix are loaded in the next destination
register in each thread as per the layout in above table. Similarly, when
  <span class="pre">
   .num
  </span>
  =
  <span class="pre">
   .x4
  </span>
  ,
elements of the third and fourth matrices are loaded in the subsequent destination registers in each
thread.
 </p>
 <p>
  Optional qualifier
  <span class="pre">
   .trans
  </span>
  indicates that the matrix is loaded in column-major format.
 </p>
 <p>
  The
  <span class="pre">
   ldmatrix
  </span>
  instruction is treated as a weak memory operation in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory Consistency Model
  </a>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 6.5.
 </p>
 <p>
  Support for
  <span class="pre">
   ::cta
  </span>
  sub-qualifier introduced in PTX ISA version 7.8.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_75
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>// Load a single 8x8 matrix using 64-bit addressing
.reg .b64 addr;
.reg .b32 d;
ldmatrix.sync.aligned.m8n8.x1.shared::cta.b16 {d}, [addr];

// Load two 8x8 matrices in column-major format
.reg .b64 addr;
.reg .b32 d&lt;2&gt;;
ldmatrix.sync.aligned.m8n8.x2.trans.shared.b16 {d0, d1}, [addr];

// Load four 8x8 matrices
.reg .b64 addr;
.reg .b32 d&lt;4&gt;;
ldmatrix.sync.aligned.m8n8.x4.b16 {d0, d1, d2, d3}, [addr];
</pre>
 <h5>
  <span class="section-number">
   9.7.13.4.16.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-instructions-stmatrix">
   Warp-level matrix store instruction: stmatrix
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-store-instruction-stmatrix" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  stmatrix
 </p>
 <p>
  Collectively store one or more matrices to shared memory.
 </p>
 <p>
  Syntax
 </p>
 <pre>stmatrix.sync.aligned.shape.num{.trans}{.ss}.type [p], r;

.shape  = {.m8n8};
.num    = {.x1, .x2, .x4};
.ss     = {.shared{::cta}};
.type   = {.b16};
</pre>
 <p>
  Description
 </p>
 <p>
  Collectively store one or more matrices across all threads in a warp to the location indicated by
the address operand
  <span class="pre">
   p
  </span>
  , in
  <span class="pre">
   .shared
  </span>
  state space. If no state space is provided, generic
addressing is used, such that the address in
  <span class="pre">
   p
  </span>
  points into
  <span class="pre">
   .shared
  </span>
  space. If the generic
address doesnât fall in
  <span class="pre">
   .shared
  </span>
  state space, then the behavior is undefined.
 </p>
 <p>
  The
  <span class="pre">
   .shape
  </span>
  qualifier indicates the dimensions of the matrices being loaded. Each matrix element
holds 16-bit data as indicated by the
  <span class="pre">
   .type
  </span>
  qualifier.
 </p>
 <p>
  The values
  <span class="pre">
   .x1
  </span>
  ,
  <span class="pre">
   .x2
  </span>
  and
  <span class="pre">
   .x4
  </span>
  for
  <span class="pre">
   .num
  </span>
  indicate one, two or four matrices
respectively.
 </p>
 <p>
  The mandatory
  <span class="pre">
   .sync
  </span>
  qualifier indicates that
  <span class="pre">
   stmatrix
  </span>
  causes the executing thread to wait
until all threads in the warp execute the same
  <span class="pre">
   stmatrix
  </span>
  instruction before resuming execution.
 </p>
 <p>
  The mandatory
  <span class="pre">
   .aligned
  </span>
  qualifier indicates that all threads in the warp must execute the same
  <span class="pre">
   stmatrix
  </span>
  instruction. In conditionally executed code, an
  <span class="pre">
   stmatrix
  </span>
  instruction should only be
used if it is known that all threads in the warp evaluate the condition identically, otherwise the
behavior is undefined.
 </p>
 <p>
  The behavior of
  <span class="pre">
   stmatrix
  </span>
  is undefined if all threads do not use the same qualifiers, or if any
thread in the warp has exited.
 </p>
 <p>
  The source operand
  <span class="pre">
   r
  </span>
  is a brace-enclosed vector expression consisting of 1, 2, or 4 32-bit
registers as per the value of
  <span class="pre">
   .num
  </span>
  . Each component of the vector expression holds a fragment
from the corresponding matrix.
 </p>
 <p>
  Supported addressing modes for
  <span class="pre">
   p
  </span>
  are described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#addresses-as-operands">
   Addresses as Operands
  </a>
  .
 </p>
 <p>
  Consecutive instances of row need not be stored contiguously in memory. The eight addresses required
for each matrix are provided by eight threads, depending upon the value of
  <span class="pre">
   .num
  </span>
  as shown in the
following table. Each address corresponds to the start of a matrix row. Addresses addr0âaddr7
correspond to the rows of the first matrix, addresses addr8âaddr15 correspond to the rows of the
second matrix, and so on.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      .num
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     Threads 0â7
    </p>
   </th>
   <th class="head">
    <p>
     Threads 8â15
    </p>
   </th>
   <th class="head">
    <p>
     Threads 16â23
    </p>
   </th>
   <th class="head">
    <p>
     Threads 24â31
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .x1
     </span>
    </p>
   </td>
   <td>
    <p>
     addr0âaddr7
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .x2
     </span>
    </p>
   </td>
   <td>
    <p>
     addr0âaddr7
    </p>
   </td>
   <td>
    <p>
     addr8âaddr15
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
   <td>
    <p>
     â
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .x4
     </span>
    </p>
   </td>
   <td>
    <p>
     addr0âaddr7
    </p>
   </td>
   <td>
    <p>
     addr8âaddr15
    </p>
   </td>
   <td>
    <p>
     addr16âaddr23
    </p>
   </td>
   <td>
    <p>
     addr24âaddr31
    </p>
   </td>
  </tr>
 </table>
 <p>
  When storing 8x8 matrices, a group of four consecutive threads stores 16 bytes. The matrix addresses
must be naturally aligned accordingly.
 </p>
 <p>
  Each thread in a warp stores fragments of a row, with thread 0 storing the first fragment from its
register
  <span class="pre">
   r
  </span>
  , and so on. A group of four threads stores an entire row of the matrix as shown in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-stmatrix-fragments">
   <span class="std std-numref">
    Figure 80
   </span>
  </a>
  .
 </p>
 <p>
  <span class="caption-number">
   Figure 80
  </span>
  <span class="caption-text">
   stmatrix fragment layout
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-stmatrix-fragments" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  When
  <span class="pre">
   .num
  </span>
  =
  <span class="pre">
   .x2
  </span>
  , the elements of the second matrix are storedd from the next source register
in each thread as per the layout in above table. Similarly, when
  <span class="pre">
   .num
  </span>
  =
  <span class="pre">
   .x4
  </span>
  , elements of the
third and fourth matrices are stored from the subsequent source registers in each thread.
 </p>
 <p>
  Optional qualifier
  <span class="pre">
   .trans
  </span>
  indicates that the matrix is stored in column-major format.
 </p>
 <p>
  The
  <span class="pre">
   stmatrix
  </span>
  instruction is treated as a weak memory operation in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#memory-consistency-model">
   Memory Consistency Model
  </a>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.8.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>// Store a single 8x8 matrix using 64-bit addressing
.reg .b64 addr;
.reg .b32 r;
stmatrix.sync.aligned.m8n8.x1.shared.b16 [addr], {r};

// Store two 8x8 matrices in column-major format
.reg .b64 addr;
.reg .b32 r&lt;2&gt;;
stmatrix.sync.aligned.m8n8.x2.trans.shared::cta.b16 [addr], {r0, r1};

// Store four 8x8 matrices
.reg .b64 addr;
.reg .b32 r&lt;4&gt;;
stmatrix.sync.aligned.m8n8.x4.b16 [addr], {r0, r1, r2, r3};
</pre>
 <h5>
  <span class="section-number">
   9.7.13.4.17.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-instructions-movmatrix">
   Warp-level matrix transpose instruction: movmatrix
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-transpose-instruction-movmatrix" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  movmatrix
 </p>
 <p>
  Transpose a matrix in registers across the warp.
 </p>
 <p>
  Syntax
 </p>
 <pre>movmatrix.sync.aligned.shape.trans.type d, a;

.shape  = {.m8n8};
.type   = {.b16};
</pre>
 <p>
  Description
 </p>
 <p>
  Move a row-major matrix across all threads in a warp, reading elements from source
  <span class="pre">
   a
  </span>
  , and
writing the transposed elements to destination
  <span class="pre">
   d
  </span>
  .
 </p>
 <p>
  The
  <span class="pre">
   .shape
  </span>
  qualifier indicates the dimensions of the matrix being transposed. Each matrix
element holds 16-bit data as indicated by the
  <span class="pre">
   .type
  </span>
  qualifier.
 </p>
 <p>
  The mandatory
  <span class="pre">
   .sync
  </span>
  qualifier indicates that
  <span class="pre">
   movmatrix
  </span>
  causes the executing thread to wait
until all threads in the warp execute the same
  <span class="pre">
   movmatrix
  </span>
  instruction before resuming execution.
 </p>
 <p>
  The mandatory
  <span class="pre">
   .aligned
  </span>
  qualifier indicates that all threads in the warp must execute the same
  <span class="pre">
   movmatrix
  </span>
  instruction. In conditionally executed code, a
  <span class="pre">
   movmatrix
  </span>
  instruction should only
be used if it is known that all threads in the warp evaluate the condition identically, otherwise
the behavior is undefined.
 </p>
 <p>
  Operands
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   d
  </span>
  are 32-bit registers containing fragments of the input matrix and the
resulting matrix respectively. The mandatory qualifier
  <span class="pre">
   .trans
  </span>
  indicates that the resulting
matrix in
  <span class="pre">
   d
  </span>
  is a transpose of the input matrix specified by
  <span class="pre">
   a
  </span>
  .
 </p>
 <p>
  Each thread in a warp holds a fragment of a row of the input matrix, with thread 0 holding the first
fragment in register
  <span class="pre">
   a
  </span>
  , and so on. A group of four threads holds an entire row of the input
matrix as shown in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-movmatrix-fragments-src">
   <span class="std std-numref">
    Figure 81
   </span>
  </a>
  .
 </p>
 <p>
  <span class="caption-number">
   Figure 81
  </span>
  <span class="caption-text">
   movmatrix source matrix fragment layout
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-movmatrix-fragments-src" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  Each thread in a warp holds a fragment of a column of the result matrix, with thread 0 holding the
first fragment in register
  <span class="pre">
   d
  </span>
  , and so on. A group of four threads holds an entire column of the
result matrix as shown in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-movmatrix-fragments-dst">
   <span class="std std-numref">
    Figure 82
   </span>
  </a>
  .
 </p>
 <p>
  <span class="caption-number">
   Figure 82
  </span>
  <span class="caption-text">
   movmatrix result matrix fragment layout
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#mma-movmatrix-fragments-dst" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.8.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_75
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>.reg .b32 d, a;
movmatrix.sync.aligned.m8n8.trans.b16 d, a;
</pre>
 <h4>
  <span class="section-number">
   9.7.13.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-instructions-for-sparse-mma">
   Matrix multiply-accumulate operation using mma.sp instruction with sparse matrix A
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-multiply-accumulate-operation-using-mma-sp-instruction-with-sparse-matrix-a" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  This section describes warp-level
  <span class="pre">
   mma.sp{::ordered_metadata}
  </span>
  instruction with sparse matrix A.
This variant of the
  <span class="pre">
   mma
  </span>
  operation can be used when A is a structured sparse matrix with 50%
zeros in each row distributed in a shape-specific granularity. For an
  <span class="pre">
   MxNxK
  </span>
  sparse
  <span class="pre">
   mma.sp{::ordered_metadata}
  </span>
  operation, the
  <span class="pre">
   MxK
  </span>
  matrix A is packed into
  <span class="pre">
   MxK/2
  </span>
  elements.
For each K-wide row of matrix A, 50% elements are zeros and the remaining K/2 non-zero elements
are packed in the operand representing matrix A. The mapping of these K/2 elements to the
corresponding K-wide row is provided explicitly as metadata.
 </p>
 <h5>
  <span class="section-number">
   9.7.13.5.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-sparse-matrix-storage">
   Sparse matrix storage
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-matrix-storage" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  Granularity of sparse matrix A is defined as the ratio of the number of non-zero elements in a
sub-chunk of the matrix row to the total number of elements in that sub-chunk where the size of the
sub-chunk is shape-specific. For example, in a
  <span class="pre">
   16x16
  </span>
  matrix A, sparsity is expected to be at 2:4
granularity, i.e. each 4-element vector (i.e. a sub-chunk of 4 consecutive elements) of a matrix row
contains 2 zeros. Index of each non-zero element in a sub-chunk is stored in the metadata
operand. Values
  <span class="pre">
   0b0000
  </span>
  ,
  <span class="pre">
   0b0101
  </span>
  ,
  <span class="pre">
   0b1010
  </span>
  ,
  <span class="pre">
   0b1111
  </span>
  are invalid values for metadata and
will result in undefined behavior. In a group of four consecutive threads, one or more threads store
the metadata for the whole group depending upon the matrix shape. These threads are specified using
an additional
  sparsity selector
  operand.
 </p>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-storage-example">
   <span class="std std-numref">
    Figure 83
   </span>
  </a>
  shows an example of a 16x16 matrix A represented in sparse format and sparsity
selector indicating which thread in a group of four consecutive threads stores the metadata.
 </p>
 <p>
  <span class="caption-number">
   Figure 83
  </span>
  <span class="caption-text">
   Sparse MMA storage example
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-storage-example" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  Granularities for different matrix shapes and data types are described below.
 </p>
 <p>
  Sparse
  <span class="pre">
   mma.sp{::ordered_metadata}
  </span>
  with half-precision and
  <span class="pre">
   .bf16
  </span>
  type
 </p>
 <p>
  For the
  <span class="pre">
   .m16n8k16
  </span>
  and
  <span class="pre">
   .m16n8k32
  </span>
  <span class="pre">
   mma.sp{::ordered_metadata}
  </span>
  operations, matrix A is
structured sparse at a granularity of 2:4. In other words, each chunk of four adjacent elements
in a row of matrix A has two zeros and two non-zero elements. Only the two non-zero elements are
stored in the operand representing matrix A and their positions in the four-wide chunk in matrix
A are indicated by two 2-bit indices in the metadata operand. For
  <span class="pre">
   mma.sp::ordered_metadata
  </span>
  ,
  <span class="pre">
   0b0100
  </span>
  ,
  <span class="pre">
   0b1000
  </span>
  ,
  <span class="pre">
   0b1001
  </span>
  ,
  <span class="pre">
   0b1100
  </span>
  ,
  <span class="pre">
   0b1101
  </span>
  ,
  <span class="pre">
   0b1110
  </span>
  are the meaningful values
of indices; any other values result in an undefined behavior.
 </p>
 <p>
  <span class="caption-number">
   Figure 84
  </span>
  <span class="caption-text">
   Sparse MMA metadata example for
   <span class="pre">
    .f16
   </span>
   /
   <span class="pre">
    .bf16
   </span>
   type.
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#f16-metadata-example" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  The sparsity selector indicates the threads which contribute metadata as listed below:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     m16n8k16
    </span>
    : One thread within a group of four consecutive threads contributes the metadata for
the entire group. This thread is indicated by a value in {0, 1, 2, 3}.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     m16n8k32
    </span>
    : A thread-pair within a group of four consecutive threads contributes the sparsity
metadata. Hence, the sparsity selector must be either 0 (threads T0, T1) or 1 (threads T2, T3);
any other value results in an undefined behavior.
   </p>
  </li>
 </ul>
 <p>
  Sparse
  <span class="pre">
   mma.sp{::ordered_metadata}
  </span>
  with
  <span class="pre">
   .tf32
  </span>
  type
 </p>
 <p>
  When matrix A has
  <span class="pre">
   .tf32
  </span>
  elements, matrix A is structured sparse at a granularity of 1:2. In
other words, each chunk of two adjacent elements in a row of matrix A has one zero and one non-zero
element. Only the non-zero elements are stored in the operand for matrix A and their positions in a
two-wide chunk in matrix A are indicated by the 4-bit index in the metadata.
  <span class="pre">
   0b1110
  </span>
  and
  <span class="pre">
   0b0100
  </span>
  are the only meaningful index values; any other values result in an undefined behavior.
 </p>
 <p>
  <span class="caption-number">
   Figure 85
  </span>
  <span class="caption-text">
   Sparse MMA metadata example for
   <span class="pre">
    .tf32
   </span>
   type.
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tf32-metadata-example" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  The sparsity selector indicates the threads which contribute metadata as listed below:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     m16n8k8
    </span>
    : One thread within a group of four consecutive threads contributes the metadata for
the entire group. This thread is indicated by a value in {0, 1, 2, 3}.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     m16n8k16
    </span>
    : A thread-pair within a group of four consecutive threads contributes the sparsity
metadata. Hence, the sparsity selector must be either 0 (threads T0, T1) or 1 (threads T2, T3);
any other value results in an undefined behavior.
   </p>
  </li>
 </ul>
 <p>
  Sparse
  <span class="pre">
   mma.sp{::ordered_metadata}
  </span>
  with integer type
 </p>
 <p>
  When matrices A and B have
  <span class="pre">
   .u8
  </span>
  /
  <span class="pre">
   .s8
  </span>
  elements, matrix A is structured sparse at a granularity
of 2:4. In other words, each chunk of four adjacent elements in a row of matrix A have two zeroes
and two non-zero elements. Only the two non-zero elements are stored in sparse matrix and their
positions in the four-wide chunk are indicated by two 2-bit indices in the metadata. For
  <span class="pre">
   mma.sp::ordered_metadata
  </span>
  ,
  <span class="pre">
   0b0100
  </span>
  ,
  <span class="pre">
   0b1000
  </span>
  ,
  <span class="pre">
   0b1001
  </span>
  ,
  <span class="pre">
   0b1100
  </span>
  ,
  <span class="pre">
   0b1101
  </span>
  ,
  <span class="pre">
   0b1110
  </span>
  are the meaningful values of indices; any other values result in an undefined behavior.
 </p>
 <p>
  <span class="caption-number">
   Figure 86
  </span>
  <span class="caption-text">
   Sparse MMA metadata example for
   <span class="pre">
    .u8
   </span>
   /
   <span class="pre">
    .s8
   </span>
   type.
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#u8s8-metadata-example" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  when matrices A and B have
  <span class="pre">
   .u4
  </span>
  /
  <span class="pre">
   .s4
  </span>
  elements, matrix A is pair-wise structured sparse at a
granularity of 4:8. In other words, each chunk of eight adjacent elements in a row of matrix A has
four zeroes and four non-zero values. Further, the zero and non-zero values are clustered in
sub-chunks of two elements each within the eight-wide chunk. i.e., each two-wide sub-chunk within
the eight-wide chunk must be all zeroes or all non-zeros. Only the four non-zero values are stored
in sparse matrix and the positions of the two two-wide sub-chunks with non-zero values in the
eight-wide chunk of a row of matrix A are indicated by two 2-bit indices in the metadata. For
  <span class="pre">
   mma.sp::ordered_metadata
  </span>
  ,
  <span class="pre">
   0b0100
  </span>
  ,
  <span class="pre">
   0b1000
  </span>
  ,
  <span class="pre">
   0b1001
  </span>
  ,
  <span class="pre">
   0b1100
  </span>
  ,
  <span class="pre">
   0b1101
  </span>
  ,
  <span class="pre">
   0b1110
  </span>
  are the meaningful values of indices; any other values result in an undefined behavior.
 </p>
 <p>
  <span class="caption-number">
   Figure 87
  </span>
  <span class="caption-text">
   Sparse MMA metadata example for
   <span class="pre">
    .u4
   </span>
   /
   <span class="pre">
    .s4
   </span>
   type.
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#u4s4-metadata-example" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  The sparsity selector indicates the threads which contribute metadata as listed below:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     m16n8k32
    </span>
    with
    <span class="pre">
     .u8
    </span>
    /
    <span class="pre">
     .s8
    </span>
    type and
    <span class="pre">
     m16n8k64
    </span>
    with
    <span class="pre">
     .u4
    </span>
    /
    <span class="pre">
     .s4
    </span>
    type: A thread-pair
within a group of four consecutive threads contributes the sparsity metadata. Hence, the sparsity
selector must be either 0 (threads T0, T1) or 1 (threads T2, T3); any other value results in an
undefined behavior.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     m16n8k64
    </span>
    with
    <span class="pre">
     .u8
    </span>
    /
    <span class="pre">
     .s8
    </span>
    type and
    <span class="pre">
     m16n8k128
    </span>
    with
    <span class="pre">
     .u4
    </span>
    /
    <span class="pre">
     .s4
    </span>
    type: All threads
within a group of four consecutive threads contribute the sparsity metadata. Hence, the sparsity
selector in this case must be 0. Any other value of sparsity selector results in an undefined
behavior.
   </p>
  </li>
 </ul>
 <p>
  Sparse
  <span class="pre">
   mma.sp{::ordered_metadata}
  </span>
  with
  <span class="pre">
   .e4m3
  </span>
  /
  <span class="pre">
   .e5m2
  </span>
  type
 </p>
 <p>
  When matrices A and B have
  <span class="pre">
   .e4m3
  </span>
  /
  <span class="pre">
   .e5m2
  </span>
  elements, matrix A is structured sparse at a granularity
of 2:4. In other words, each chunk of four adjacent elements in a row of matrix A have two zeroes and
two non-zero elements. Only the two non-zero elements are stored in sparse matrix and their positions
in the four-wide chunk are indicated by two 2-bit indices in the metadata.
  <span class="pre">
   0b0100
  </span>
  ,
  <span class="pre">
   0b1000
  </span>
  ,
  <span class="pre">
   0b1001
  </span>
  ,
  <span class="pre">
   0b1100
  </span>
  ,
  <span class="pre">
   0b1101
  </span>
  ,
  <span class="pre">
   0b1110
  </span>
  are the meaningful values of indices; any other values
result in an undefined behavior.
 </p>
 <p>
  <span class="caption-number">
   Figure 88
  </span>
  <span class="caption-text">
   Sparse MMA metadata example for
   <span class="pre">
    .e4m3
   </span>
   /
   <span class="pre">
    .e5m2
   </span>
   type.
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#fp8-metadata-example" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  The sparsity selector indicates the threads which contribute metadata as listed below:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     m16n8k64
    </span>
    : All threads within a group of four consecutive threads contribute the sparsity metadata.
Hence, the sparsity selector in this case must be 0. Any other value of sparsity selector results in
an undefined behavior.
   </p>
  </li>
 </ul>
 <h5>
  <span class="section-number">
   9.7.13.5.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragments-for-sparse-mma">
   Matrix fragments for multiply-accumulate operation with sparse matrix A
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-multiply-accumulate-operation-with-sparse-matrix-a" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  In this section we describe how the contents of thread registers are associated with fragments of
various matrices and the sparsity metadata. The following conventions are used throughout this
section:
 </p>
 <ul class="simple">
  <li>
   <p>
    For matrix A, only the layout of a fragment is described in terms of register vector sizes and
their association with the matrix data.
   </p>
  </li>
  <li>
   <p>
    For matrix B, when the combination of matrix dimension and the supported data type is not already
covered in
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-instructions-for-mma">
     Matrix multiply-accumulate operation using mma instruction
    </a>
    , a pictorial representation of matrix
fragments is provided.
   </p>
  </li>
  <li>
   <p>
    For matrices C and D, since the matrix dimension - data type combination is the same for all
supported shapes, and is already covered in
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-instructions-for-mma">
     Matrix multiply-accumulate operation using mma
instruction
    </a>
    , the pictorial representations
of matrix fragments are not included in this section.
   </p>
  </li>
  <li>
   <p>
    For the metadata operand, pictorial representations of the association between indices of the
elements of matrix A and the contents of the metadata operand are included.
    <span class="pre">
     Tk:
    </span>
    <span class="pre">
     [m..n]
    </span>
    present
in cell
    <span class="pre">
     [x][y..z]
    </span>
    indicates that bits
    <span class="pre">
     m
    </span>
    through
    <span class="pre">
     n
    </span>
    (with
    <span class="pre">
     m
    </span>
    being higher) in the
metadata operand of thread with
    <span class="pre">
     %laneid=k
    </span>
    contains the indices of the non-zero elements from
the chunk
    <span class="pre">
     [x][y]..[x][z]
    </span>
    of matrix A.
   </p>
  </li>
 </ul>
 <h6>
  <span class="section-number">
   9.7.13.5.2.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-sparse-mma-16816-f16bf16">
   Matrix Fragments for sparse mma.m16n8k16 with .f16 and .bf16 types
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-sparse-mma-m16n8k16-with-f16-and-bf16-types" title="Permalink to this headline">
   ï
  </a>
 </h6>
 <p>
  A warp executing sparse
  <span class="pre">
   mma.m16n8k16
  </span>
  with
  <span class="pre">
   .f16
  </span>
  /
  <span class="pre">
   .bf16
  </span>
  floating point type will compute
an MMA operation of shape
  <span class="pre">
   .m16n8k16
  </span>
  .
 </p>
 <p>
  Elements of the matrix are distributed across the threads in a warp so each thread of the warp holds
a fragment of the matrix.
 </p>
 <ul>
  <li>
   <p>
    Multiplicand A:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .atype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .f16
       </span>
       /
       <span class="pre">
        .bf16
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing two
       <span class="pre">
        .b32
       </span>
       registers,
with each register containing two non-zero
       <span class="pre">
        .f16
       </span>
       /
       <span class="pre">
        .bf16
       </span>
       elements out of 4 consecutive elements from
matrix A.
      </p>
     </td>
     <td>
      <p>
       Mapping of the non-zero elements is as
described in
       <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-sparse-matrix-storage">
        Sparse matrix storage
       </a>
       .
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-16816-f16-bf16-a">
     <span class="std std-numref">
      Figure 89
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 89
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k16 fragment layout for matrix A with
     <span class="pre">
      .f16
     </span>
     /
     <span class="pre">
      .bf16
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-16816-f16-bf16-a" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">a0</span><span class="n">and</span><span class="n">a1</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="k">for</span><span class="n">a2</span><span class="n">and</span><span class="n">a3</span>

<span class="n">col</span><span class="o">=</span><span class="p">[</span><span class="n">firstcol</span><span class="p">...</span><span class="n">lastcol</span><span class="p">]</span><span class="c1">// As per the mapping of non-zero elements</span>
<span class="c1">// as described in Sparse matrix storage</span>

<span class="n">Where</span>
<span class="n">firstcol</span><span class="o">=</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">4</span>
<span class="n">lastcol</span><span class="o">=</span><span class="n">firstcol</span><span class="o">+</span><span class="mi">3</span>
</pre>
  </li>
  <li>
   <p>
    Matrix fragments for multiplicand B and accumulators C and D are the same as in case of
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-mma-16816-float">
     Matrix
Fragments for mma.m16n8k16 with floating point type
    </a>
    for
    <span class="pre">
     .f16
    </span>
    /
    <span class="pre">
     .b16
    </span>
    formats.
   </p>
  </li>
  <li>
   <p>
    Metadata: A
    <span class="pre">
     .b32
    </span>
    register containing 16 2-bit vectors each storing the index of a non-zero
element of a 4-wide chunk of matrix A as shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-metadata-16816-f16bf16">
     <span class="std std-numref">
      Figure 90
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 90
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k16 metadata layout for
     <span class="pre">
      .f16
     </span>
     /
     <span class="pre">
      .bf16
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-metadata-16816-f16bf16" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
 </ul>
 <h6>
  <span class="section-number">
   9.7.13.5.2.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-sparse-mma-16832-f16bf16">
   Matrix Fragments for sparse mma.m16n8k32 with .f16 and .bf16 types
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-sparse-mma-m16n8k32-with-f16-and-bf16-types" title="Permalink to this headline">
   ï
  </a>
 </h6>
 <p>
  A warp executing sparse
  <span class="pre">
   mma.m16n8k32
  </span>
  with
  <span class="pre">
   .f16
  </span>
  /
  <span class="pre">
   .bf16
  </span>
  floating point type will compute
an MMA operation of shape
  <span class="pre">
   .m16n8k32
  </span>
  .
 </p>
 <p>
  Elements of the matrix are distributed across the threads in a warp so each thread of the warp holds
a fragment of the matrix.
 </p>
 <ul>
  <li>
   <p>
    Multiplicand A:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .atype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .f16
       </span>
       /
       <span class="pre">
        .bf16
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing four
       <span class="pre">
        .b32
       </span>
       registers,
with each register containing two non-zero
       <span class="pre">
        .f16
       </span>
       /
       <span class="pre">
        .bf16
       </span>
       elements out of 4 consecutive elements from
matrix A.
      </p>
     </td>
     <td>
      <p>
       Mapping of the non-zero elements is as
described in
       <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-sparse-matrix-storage">
        Sparse matrix storage
       </a>
       .
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-16832-f16-bf16-a">
     <span class="std std-numref">
      Figure 91
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 91
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k32 fragment layout for matrix A with
     <span class="pre">
      .f16
     </span>
     /
     <span class="pre">
      .bf16
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-16832-f16-bf16-a" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">||</span><span class="mi">4</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">6</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="n">Otherwise</span>

<span class="n">col</span><span class="o">=</span><span class="p">[</span><span class="n">firstcol</span><span class="p">...</span><span class="n">lastcol</span><span class="p">]</span><span class="c1">// As per the mapping of non-zero elements</span>
<span class="c1">// as described in Sparse matrix storage</span>

<span class="n">Where</span>
<span class="n">firstcol</span><span class="o">=</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">4</span><span class="n">For</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span>
<span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="mi">16</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">4</span>
<span class="n">lastcol</span><span class="o">=</span><span class="n">firstcol</span><span class="o">+</span><span class="mi">3</span>
</pre>
  </li>
  <li>
   <p>
    Multiplicand B:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .atype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .f16
       </span>
       /
       <span class="pre">
        .bf16
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing four
       <span class="pre">
        .b32
       </span>
       registers, each
containing two
       <span class="pre">
        .f16
       </span>
       /
       <span class="pre">
        .bf16
       </span>
       elements from matrix B.
      </p>
     </td>
     <td>
      <p>
       b0, b1, b2, b3
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-16832-f16bf16-b">
     <span class="std std-numref">
      Figure 92
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 92
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k32 fragment layout for matrix B with
     <span class="pre">
      .f16
     </span>
     /
     <span class="pre">
      .bf16
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-16832-f16bf16-b" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
  <li>
   <p>
    Matrix fragments for accumulators C and D are the same as in case of
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-mma-16816-float">
     Matrix Fragments for
mma.m16n8k16 with floating point type
    </a>
    for
    <span class="pre">
     .f16
    </span>
    /
    <span class="pre">
     .b16
    </span>
    formats.
   </p>
  </li>
  <li>
   <p>
    Metadata: A
    <span class="pre">
     .b32
    </span>
    register containing 16 2-bit vectors with each pair of 2-bit vectors storing
the indices of two non-zero element from a 4-wide chunk of matrix A as shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-metadata-16832-f16bf16">
     <span class="std std-numref">
      Figure 93
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 93
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k32 metadata layout for
     <span class="pre">
      .f16
     </span>
     /
     <span class="pre">
      .bf16
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-metadata-16832-f16bf16" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
 </ul>
 <h6>
  <span class="section-number">
   9.7.13.5.2.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-sparse-mma-16816-tf32">
   Matrix Fragments for sparse mma.m16n8k16 with .tf32 floating point type
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-sparse-mma-m16n8k16-with-tf32-floating-point-type" title="Permalink to this headline">
   ï
  </a>
 </h6>
 <p>
  A warp executing sparse
  <span class="pre">
   mma.m16n8k16
  </span>
  with
  <span class="pre">
   .tf32
  </span>
  floating point type will compute an MMA
operation of shape
  <span class="pre">
   .m16n8k16
  </span>
  .
 </p>
 <p>
  Elements of the matrix are distributed across the threads in a warp so each thread of the warp holds
a fragment of the matrix.
 </p>
 <ul>
  <li>
   <p>
    Multiplicand A:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .atype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .tf32
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing four
       <span class="pre">
        .b32
       </span>
       registers, with each
register containing one non-zero
       <span class="pre">
        .tf32
       </span>
       element out of 2
consecutive elements from matrix A.
      </p>
     </td>
     <td>
      <p>
       Mapping of the non-zero elements is
as described in
       <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-sparse-matrix-storage">
        Sparse matrix storage
       </a>
       .
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-16816-tf32-a">
     <span class="std std-numref">
      Figure 94
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 94
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k16 fragment layout for matrix A with
     <span class="pre">
      .tf32
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-16816-tf32-a" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">a0</span><span class="n">and</span><span class="n">a2</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="k">for</span><span class="n">a1</span><span class="n">and</span><span class="n">a3</span>

<span class="n">col</span><span class="o">=</span><span class="p">[</span><span class="n">firstcol</span><span class="p">...</span><span class="n">lastcol</span><span class="p">]</span><span class="c1">// As per the mapping of non-zero elements</span>
<span class="c1">// as described in Sparse matrix storage</span>

<span class="n">Where</span>
<span class="n">firstcol</span><span class="o">=</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">2</span><span class="k">for</span><span class="n">a0</span><span class="n">and</span><span class="n">a1</span>
<span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">8</span><span class="k">for</span><span class="n">a2</span><span class="n">and</span><span class="n">a3</span>
<span class="n">lastcol</span><span class="o">=</span><span class="n">firstcol</span><span class="o">+</span><span class="mi">1</span>
</pre>
  </li>
  <li>
   <p>
    Multiplicand B:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .atype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .tf32
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing four
       <span class="pre">
        .b32
       </span>
       registers, each
containing four
       <span class="pre">
        .tf32
       </span>
       elements from matrix B.
      </p>
     </td>
     <td>
      <p>
       b0, b1, b2, b3
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-16816-tf32-b">
     <span class="std std-numref">
      Figure 95
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 95
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k16 fragment layout for matrix B with
     <span class="pre">
      .tf32
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-16816-tf32-b" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
  <li>
   <p>
    Matrix fragments for accumulators C and D are the same as in case of
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-mma-16816-float">
     Matrix Fragments for
mma.m16n8k16 with floating point type
    </a>
    .
   </p>
  </li>
  <li>
   <p>
    Metadata: A
    <span class="pre">
     .b32
    </span>
    register containing 8 4-bit vectors each storing the index of a non-zero
element of a 2-wide chunk of matrix A as shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-metadata-16816-tf32">
     <span class="std std-numref">
      Figure 96
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 96
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k16 metadata layout for
     <span class="pre">
      .tf32
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-metadata-16816-tf32" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
 </ul>
 <h6>
  <span class="section-number">
   9.7.13.5.2.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-sparse-mma-1688-tf32">
   Matrix Fragments for sparse mma.m16n8k8 with .tf32 floating point type
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-sparse-mma-m16n8k8-with-tf32-floating-point-type" title="Permalink to this headline">
   ï
  </a>
 </h6>
 <p>
  A warp executing sparse
  <span class="pre">
   mma.m16n8k8
  </span>
  with
  <span class="pre">
   .tf32
  </span>
  floating point type will compute an MMA
operation of shape
  <span class="pre">
   .m16n8k8
  </span>
  .
 </p>
 <p>
  Elements of the matrix are distributed across the threads in a warp so each thread of the warp holds
a fragment of the matrix.
 </p>
 <ul>
  <li>
   <p>
    Multiplicand A:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .atype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .tf32
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing two
       <span class="pre">
        .b32
       </span>
       registers, each
containing one non-zero
       <span class="pre">
        .tf32
       </span>
       element out of 2
consecutive elements from matrix A.
      </p>
     </td>
     <td>
      <p>
       Mapping of the non-zero elements is
as described in
       <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-sparse-matrix-storage">
        Sparse matrix storage
       </a>
       .
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-1688-tf32">
     <span class="std std-numref">
      Figure 97
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 97
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k8 fragment layout for matrix A with
     <span class="pre">
      .tf32
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-1688-tf32" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    The row and column of a matrix fragment can be computed as:
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">a0</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="k">for</span><span class="n">a1</span>

<span class="n">col</span><span class="o">=</span><span class="p">[</span><span class="n">firstcol</span><span class="p">...</span><span class="n">lastcol</span><span class="p">]</span><span class="c1">// As per the mapping of non-zero elements</span>
<span class="c1">// as described in Sparse matrix storage</span>

<span class="n">Where</span>
<span class="n">firstcol</span><span class="o">=</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">2</span>
<span class="n">lastcol</span><span class="o">=</span><span class="n">firstcol</span><span class="o">+</span><span class="mi">1</span>
</pre>
  </li>
  <li>
   <p>
    Matrix fragments for multiplicand B and accumulators C and D are the same as in case of
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-mma-1688">
     Matrix
Fragments for mma.m16n8k8
    </a>
    for
    <span class="pre">
     .tf32
    </span>
    format.
   </p>
  </li>
  <li>
   <p>
    Metadata: A
    <span class="pre">
     .b32
    </span>
    register containing 8 4-bit vectors each storing the index of a non-zero
element of a 2-wide chunk of matrix A as shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-metadata-1688-tf32">
     <span class="std std-numref">
      Figure 98
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 98
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k8 metadata layout for
     <span class="pre">
      .tf32
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-metadata-1688-tf32" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
 </ul>
 <h6>
  <span class="section-number">
   9.7.13.5.2.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-sparse-mma-16832-u8s8">
   Matrix Fragments for sparse mma.m16n8k32 with .u8/.s8 integer type
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-sparse-mma-m16n8k32-with-u8-s8-integer-type" title="Permalink to this headline">
   ï
  </a>
 </h6>
 <p>
  A warp executing sparse
  <span class="pre">
   mma.m16n8k32
  </span>
  with
  <span class="pre">
   .u8
  </span>
  /
  <span class="pre">
   .s8
  </span>
  integer type will compute an MMA
operation of shape
  <span class="pre">
   .m16n8k32
  </span>
  .
 </p>
 <p>
  Elements of the matrix are distributed across the threads in a warp so each thread of the warp holds
a fragment of the matrix.
 </p>
 <ul>
  <li>
   <p>
    Multiplicand A:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .atype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .u8
       </span>
       /
       <span class="pre">
        .s8
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing two
       <span class="pre">
        .b32
       </span>
       registers, with each
register containing four non-zero
       <span class="pre">
        .u8
       </span>
       /
       <span class="pre">
        .s8
       </span>
       elements out
of 8 consecutive elements from matrix A.
      </p>
     </td>
     <td>
      <p>
       Mapping of the non-zero elements is
as described in
       <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-sparse-matrix-storage">
        Sparse matrix storage
       </a>
       .
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-16832-u8s8-a">
     <span class="std std-numref">
      Figure 99
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 99
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k32 fragment layout for matrix A with
     <span class="pre">
      .u8
     </span>
     /
     <span class="pre">
      .s8
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-16832-u8s8-a" title="Permalink to this image">
     ï
    </a>
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="n">Otherwise</span>

<span class="n">col</span><span class="o">=</span><span class="p">[</span><span class="n">firstcol</span><span class="p">...</span><span class="n">lastcol</span><span class="p">]</span><span class="c1">// As per the mapping of non-zero elements</span>
<span class="c1">// as described in Sparse matrix storage</span>

<span class="n">Where</span>
<span class="n">firstcol</span><span class="o">=</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">8</span>
<span class="n">lastcol</span><span class="o">=</span><span class="n">firstcol</span><span class="o">+</span><span class="mi">7</span>
</pre>
  </li>
  <li>
   <p>
    Matrix fragments for multiplicand B and accumulators C and D are the same as in case of
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-mma-16832">
     Matrix
Fragments for mma.m16n8k32
    </a>
    .
   </p>
  </li>
  <li>
   <p>
    Metadata: A
    <span class="pre">
     .b32
    </span>
    register containing 16 2-bit vectors with each pair of 2-bit vectors storing
the indices of two non-zero elements from a 4-wide chunk of matrix A as shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-metadata-16832-u8s8">
     <span class="std std-numref">
      Figure 100
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 100
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k32 metadata layout for
     <span class="pre">
      .u8
     </span>
     /
     <span class="pre">
      .s8
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-metadata-16832-u8s8" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
 </ul>
 <h6>
  <span class="section-number">
   9.7.13.5.2.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-sparse-mma-16864-u8s8-fp8">
   Matrix Fragments for sparse mma.m16n8k64 with .u8/.s8/.e4m3/.e5m2 type
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-sparse-mma-m16n8k64-with-u8-s8-e4m3-e5m2-type" title="Permalink to this headline">
   ï
  </a>
 </h6>
 <p>
  A warp executing sparse
  <span class="pre">
   mma.m16n8k64
  </span>
  with
  <span class="pre">
   .u8
  </span>
  /
  <span class="pre">
   .s8
  </span>
  /
  <span class="pre">
   .e4m3
  </span>
  /
  <span class="pre">
   .e5m2
  </span>
  type will compute an MMA
operation of shape
  <span class="pre">
   .m16n8k64
  </span>
  .
 </p>
 <p>
  Elements of the matrix are distributed across the threads in a warp so each thread of the warp holds
a fragment of the matrix.
 </p>
 <ul>
  <li>
   <p>
    Multiplicand A:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .atype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .u8
       </span>
       /
       <span class="pre">
        .s8
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing four
       <span class="pre">
        .b32
       </span>
       registers, with each
register containing four non-zero
       <span class="pre">
        .u8
       </span>
       /
       <span class="pre">
        .s8
       </span>
       elements out
of 8 consecutive elements from matrix A.
      </p>
     </td>
     <td rowspan="2">
      <p>
       Mapping of the non-zero elements is
as described in
       <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-sparse-matrix-storage">
        Sparse matrix storage
       </a>
       .
      </p>
     </td>
    </tr>
    <tr class="row-odd">
     <td>
      <p>
       <span class="pre">
        .e4m3
       </span>
       /
       <span class="pre">
        .e5m2
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing four
       <span class="pre">
        .b32
       </span>
       registers, with each
register containing four non-zero
       <span class="pre">
        .e4m3
       </span>
       /
       <span class="pre">
        .e5m2
       </span>
       elements
out of 8 consecutive elements from matrix A.
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-16864-u8s8-a-first32col">
     <span class="std std-numref">
      Figure 101
     </span>
    </a>
    and
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-16864-u8s8-a-last32col">
     <span class="std std-numref">
      Figure 102
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 101
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k64 fragment layout for columns 0â31 of matrix A with
     <span class="pre">
      .u8
     </span>
     /
     <span class="pre">
      .s8
     </span>
     /
     <span class="pre">
      .e4m3
     </span>
     /
     <span class="pre">
      .e5m2
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-16864-u8s8-a-first32col" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    <span class="caption-number">
     Figure 102
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k64 fragment layout for columns 32â63 of matrix A with
     <span class="pre">
      .u8
     </span>
     /
     <span class="pre">
      .s8
     </span>
     /
     <span class="pre">
      .e4m3
     </span>
     /
     <span class="pre">
      .e5m2
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-16864-u8s8-a-last32col" title="Permalink to this image">
     ï
    </a>
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">||</span><span class="mi">8</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">12</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="n">Otherwise</span>

<span class="n">col</span><span class="o">=</span><span class="p">[</span><span class="n">firstcol</span><span class="p">...</span><span class="n">lastcol</span><span class="p">]</span><span class="c1">// As per the mapping of non-zero elements</span>
<span class="c1">// as described in Sparse matrix storage</span>

<span class="n">Where</span>
<span class="n">firstcol</span><span class="o">=</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">8</span><span class="n">For</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">8</span>
<span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span><span class="o">+</span><span class="mi">32</span><span class="n">For</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">8</span>
<span class="n">lastcol</span><span class="o">=</span><span class="n">firstcol</span><span class="o">+</span><span class="mi">7</span>
</pre>
  </li>
  <li>
   <p>
    Multiplicand B:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .btype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .u8
       </span>
       /
       <span class="pre">
        .s8
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing four
       <span class="pre">
        .b32
       </span>
       registers,
each containing four
       <span class="pre">
        .u8
       </span>
       /
       <span class="pre">
        .s8
       </span>
       elements from
matrix B.
      </p>
     </td>
     <td rowspan="2">
      <p>
       b0, b1, b2, b3, â¦, b15
      </p>
     </td>
    </tr>
    <tr class="row-odd">
     <td>
      <p>
       <span class="pre">
        .e4m3
       </span>
       /
       <span class="pre">
        .e5m2
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing four
       <span class="pre">
        .b32
       </span>
       registers,
each containing four
       <span class="pre">
        .e4m3
       </span>
       /
       <span class="pre">
        .e5m2
       </span>
       elements from
matrix B.
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-16864-u8s8-b1">
     <span class="std std-numref">
      Figure 103
     </span>
    </a>
    ,
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-16864-u8s8-b2">
     <span class="std std-numref">
      Figure 104
     </span>
    </a>
    ,
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-16864-u8s8-b3">
     <span class="std std-numref">
      Figure 105
     </span>
    </a>
    and
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-16864-u8s8-b4">
     <span class="std std-numref">
      Figure 106
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 103
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k64 fragment layout for rows 0â15 of matrix B with
     <span class="pre">
      .u8
     </span>
     /
     <span class="pre">
      .s8
     </span>
     /
     <span class="pre">
      .e4m3
     </span>
     /
     <span class="pre">
      .e5m2
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-16864-u8s8-b1" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    <span class="caption-number">
     Figure 104
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k64 fragment layout for rows 16â31 of matrix B with
     <span class="pre">
      .u8
     </span>
     /
     <span class="pre">
      .s8
     </span>
     /
     <span class="pre">
      .e4m3
     </span>
     /
     <span class="pre">
      .e5m2
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-16864-u8s8-b2" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    <span class="caption-number">
     Figure 105
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k64 fragment layout for rows 32â47 of matrix B with
     <span class="pre">
      .u8
     </span>
     /
     <span class="pre">
      .s8
     </span>
     /
     <span class="pre">
      .e4m3
     </span>
     /
     <span class="pre">
      .e5m2
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-16864-u8s8-b3" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    <span class="caption-number">
     Figure 106
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k64 fragment layout for rows 48â63 of matrix B with
     <span class="pre">
      .u8
     </span>
     /
     <span class="pre">
      .s8
     </span>
     /
     <span class="pre">
      .e4m3
     </span>
     /
     <span class="pre">
      .e5m2
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-16864-u8s8-b4" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
  <li>
   <p>
    Matrix fragments for accumulators C and D are the same as in case of
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-mma-16816-i8">
     Matrix Fragments for
mma.m16n8k16 with integer type
    </a>
    .
   </p>
  </li>
  <li>
   <p>
    Metadata: A
    <span class="pre">
     .b32
    </span>
    register containing 16 2-bit vectors with each pair of 2-bit vectors storing
the indices of two non-zero elements from a 4-wide chunk of matrix A as shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-metadata-16864-u8s8-first32col">
     <span class="std std-numref">
      Figure 107
     </span>
    </a>
    and
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-metadata-16864-u8s8-last32col">
     <span class="std std-numref">
      Figure 108
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 107
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k64 metadata layout for columns 0â31 for
     <span class="pre">
      .u8
     </span>
     /
     <span class="pre">
      .s8
     </span>
     /
     <span class="pre">
      .e4m3
     </span>
     /
     <span class="pre">
      .e5m2
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-metadata-16864-u8s8-first32col" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    <span class="caption-number">
     Figure 108
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k64 metadata layout for columns 32â63 for
     <span class="pre">
      .u8
     </span>
     /
     <span class="pre">
      .s8
     </span>
     /
     <span class="pre">
      .e4m3
     </span>
     /
     <span class="pre">
      .e5m2
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-metadata-16864-u8s8-last32col" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
 </ul>
 <h6>
  <span class="section-number">
   9.7.13.5.2.7.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-sparse-mma-16864-u4s4">
   Matrix Fragments for sparse mma.m16n8k64 with .u4/.s4 integer type
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-sparse-mma-m16n8k64-with-u4-s4-integer-type" title="Permalink to this headline">
   ï
  </a>
 </h6>
 <p>
  A warp executing sparse
  <span class="pre">
   mma.m16n8k64
  </span>
  with
  <span class="pre">
   .u4
  </span>
  /
  <span class="pre">
   .s4
  </span>
  integer type will compute an MMA
operation of shape
  <span class="pre">
   .m16n8k64
  </span>
  .
 </p>
 <p>
  Elements of the matrix are distributed across the threads in a warp so each thread of the warp holds
a fragment of the matrix.
 </p>
 <ul>
  <li>
   <p>
    Multiplicand A:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .atype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .u4
       </span>
       /
       <span class="pre">
        .s4
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing two
       <span class="pre">
        .b32
       </span>
       registers, with each
register containing eight non-zero
       <span class="pre">
        .u4
       </span>
       /
       <span class="pre">
        .s4
       </span>
       elements
out of 16 consecutive elements from matrix A.
      </p>
     </td>
     <td>
      <p>
       Mapping of the non-zero elements is
as described in
       <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-sparse-matrix-storage">
        Sparse matrix storage
       </a>
       .
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-16864-u4s4-a">
     <span class="std std-numref">
      Figure 109
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 109
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k64 fragment layout for matrix A with
     <span class="pre">
      .u4
     </span>
     /
     <span class="pre">
      .s4
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-16864-u4s4-a" title="Permalink to this image">
     ï
    </a>
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">8</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="n">Otherwise</span>

<span class="n">col</span><span class="o">=</span><span class="p">[</span><span class="n">firstcol</span><span class="p">...</span><span class="n">lastcol</span><span class="p">]</span><span class="c1">// As per the mapping of non-zero elements</span>
<span class="c1">// as described in Sparse matrix storage</span>

<span class="n">Where</span>
<span class="n">firstcol</span><span class="o">=</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">16</span>
<span class="n">lastcol</span><span class="o">=</span><span class="n">firstcol</span><span class="o">+</span><span class="mi">15</span>
</pre>
  </li>
  <li>
   <p>
    Matrix fragments for multiplicand B and accumulators C and D are the same as in case of
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-mma-16864">
     Matrix
Fragments for mma.m16n8k64
    </a>
    .
   </p>
  </li>
  <li>
   <p>
    Metadata: A
    <span class="pre">
     .b32
    </span>
    register containing 16 2-bit vectors with each pair of 2-bit vectors storing
the indices of four non-zero elements from a 8-wide chunk of matrix A as shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-metadata-16864-u4s4">
     <span class="std std-numref">
      Figure 110
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 110
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k64 metadata layout for
     <span class="pre">
      .u4
     </span>
     /
     <span class="pre">
      .s4
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-metadata-16864-u4s4" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
 </ul>
 <h6>
  <span class="section-number">
   9.7.13.5.2.8.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-sparse-mma-168128-u4s4">
   Matrix Fragments for sparse mma.m16n8k128 with .u4/.s4 integer type
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-sparse-mma-m16n8k128-with-u4-s4-integer-type" title="Permalink to this headline">
   ï
  </a>
 </h6>
 <p>
  A warp executing sparse
  <span class="pre">
   mma.m16n8k128
  </span>
  with
  <span class="pre">
   .u4
  </span>
  /
  <span class="pre">
   .s4
  </span>
  integer type will compute an MMA
operation of shape
  <span class="pre">
   .m16n8k128
  </span>
  .
 </p>
 <p>
  Elements of the matrix are distributed across the threads in a warp so each thread of the warp holds
a fragment of the matrix.
 </p>
 <ul>
  <li>
   <p>
    Multiplicand A:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .atype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .u4
       </span>
       /
       <span class="pre">
        .s4
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing four
       <span class="pre">
        .b32
       </span>
       registers, with each
register containing eight non-zero
       <span class="pre">
        .u4
       </span>
       /
       <span class="pre">
        .s4
       </span>
       elements out
of 16 consecutive elements from matrix A.
      </p>
     </td>
     <td>
      <p>
       Mapping of the non-zero elements is
as described in
       <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-sparse-matrix-storage">
        Sparse matrix storage
       </a>
       .
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-168128-u4s4-a-first64col">
     <span class="std std-numref">
      Figure 111
     </span>
    </a>
    and
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-168128-u4s4-a-last64col">
     <span class="std std-numref">
      Figure 112
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 111
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k128 fragment layout for columns 0â63 of matrix A with
     <span class="pre">
      .u4
     </span>
     /
     <span class="pre">
      .s4
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-168128-u4s4-a-first64col" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    <span class="caption-number">
     Figure 112
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k128 fragment layout for columns 64â127 of matrix A with
     <span class="pre">
      .u4
     </span>
     /
     <span class="pre">
      .s4
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-168128-u4s4-a-last64col" title="Permalink to this image">
     ï
    </a>
   </p>
   <pre><span class="n">groupID</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">&gt;&gt;</span><span class="mi">2</span>
<span class="n">threadID_in_group</span><span class="o">=</span><span class="o">%</span><span class="n">laneid</span><span class="o">%</span><span class="mi">4</span>

<span class="n">row</span><span class="o">=</span><span class="n">groupID</span><span class="k">for</span><span class="n">ai</span><span class="n">where</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">||</span><span class="mi">16</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">24</span>
<span class="n">groupID</span><span class="o">+</span><span class="mi">8</span><span class="n">Otherwise</span>

<span class="n">col</span><span class="o">=</span><span class="p">[</span><span class="n">firstcol</span><span class="p">...</span><span class="n">lastcol</span><span class="p">]</span><span class="c1">// As per the mapping of non-zero elements</span>
<span class="c1">// as described in Sparse matrix storage</span>

<span class="n">Where</span>
<span class="n">firstcol</span><span class="o">=</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">16</span><span class="n">For</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">16</span>
<span class="p">(</span><span class="n">threadID_in_group</span><span class="o">*</span><span class="mi">16</span><span class="p">)</span><span class="o">+</span><span class="mi">64</span><span class="n">For</span><span class="n">ai</span><span class="n">where</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">16</span>
<span class="n">lastcol</span><span class="o">=</span><span class="n">firstcol</span><span class="o">+</span><span class="mi">15</span>
</pre>
  </li>
  <li>
   <p>
    Multiplicand B:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .atype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .u4
       </span>
       /
       <span class="pre">
        .s4
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing four
       <span class="pre">
        .b32
       </span>
       registers, each containing
eight
       <span class="pre">
        .u4
       </span>
       /
       <span class="pre">
        .s4
       </span>
       elements from matrix B.
      </p>
     </td>
     <td>
      <p>
       b0, b1, b2, b3, â¦, b31
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-168128-u4s4-b1">
     <span class="std std-numref">
      Figure 113
     </span>
    </a>
    ,
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-168128-u4s4-b2">
     <span class="std std-numref">
      Figure 114
     </span>
    </a>
    ,
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-168128-u4s4-b3">
     <span class="std std-numref">
      Figure 115
     </span>
    </a>
    ,
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-168128-u4s4-b4">
     <span class="std std-numref">
      Figure 116
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 113
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k128 fragment layout for rows 0â31 of matrix B with
     <span class="pre">
      .u4
     </span>
     /
     <span class="pre">
      .s4
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-168128-u4s4-b1" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    <span class="caption-number">
     Figure 114
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k128 fragment layout for rows 31â63 of matrix B with
     <span class="pre">
      .u4
     </span>
     /
     <span class="pre">
      .s4
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-168128-u4s4-b2" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    <span class="caption-number">
     Figure 115
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k128 fragment layout for rows 64â95 of matrix B with
     <span class="pre">
      .u4
     </span>
     /
     <span class="pre">
      .s4
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-168128-u4s4-b3" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    <span class="caption-number">
     Figure 116
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k128 fragment layout for rows 96â127 of matrix B with
     <span class="pre">
      .u4
     </span>
     /
     <span class="pre">
      .s4
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-168128-u4s4-b4" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
  <li>
   <p>
    Matrix fragments for accumulators C and D are the same as in case of
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-mma-16864">
     Matrix Fragments for
mma.m16n8k64
    </a>
    .
   </p>
  </li>
  <li>
   <p>
    Metadata: A
    <span class="pre">
     .b32
    </span>
    register containing 16 2-bit vectors with each pair of 2-bit vectors storing
the indices of four non-zero elements from a 8-wide chunk of matrix A as shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-metadata-168128-u4s4-first64col">
     <span class="std std-numref">
      Figure 117
     </span>
    </a>
    and
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-metadata-168128-u4s4-last64col">
     <span class="std std-numref">
      Figure 118
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 117
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k128 metadata layout for  columns 0â63 for
     <span class="pre">
      .u4
     </span>
     /
     <span class="pre">
      .s4
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-metadata-168128-u4s4-first64col" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    <span class="caption-number">
     Figure 118
    </span>
    <span class="caption-text">
     Sparse MMA .m16n8k128 metadata layout for  columns 64â127 for
     <span class="pre">
      .u4
     </span>
     /
     <span class="pre">
      .s4
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-metadata-168128-u4s4-last64col" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
 </ul>
 <h5>
  <span class="section-number">
   9.7.13.5.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-instructions-sparse-mma">
   Multiply-and-Accumulate Instruction: mma.sp/mma.sp::ordered_metadata
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#multiply-and-accumulate-instruction-mma-sp-mma-sp-ordered-metadata" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  mma.sp/mma.sp::ordered_metadata
 </p>
 <p>
  Perform matrix multiply-and-accumulate operation with sparse matrix A
 </p>
 <p>
  Syntax
 </p>
 <p>
  Half precision floating point type:
 </p>
 <pre>mma.spvariant.sync.aligned.m16n8k16.row.col.dtype.f16.f16.ctype  d, a, b, c, e, f;
mma.spvariant.sync.aligned.m16n8k32.row.col.dtype.f16.f16.ctype  d, a, b, c, e, f;

.ctype     = {.f16, .f32};
.dtype     = {.f16, .f32};
.spvariant = {.sp, .sp::ordered_metadata};
</pre>
 <p>
  Alternate floating point type :
 </p>
 <pre>mma.spvariant.sync.aligned.m16n8k16.row.col.f32.bf16.bf16.f32     d, a, b, c, e, f;
mma.spvariant.sync.aligned.m16n8k32.row.col.f32.bf16.bf16.f32     d, a, b, c, e, f;
mma.spvariant.sync.aligned.m16n8k8.row.col.f32.tf32.tf32.f32      d, a, b, c, e, f;
mma.spvariant.sync.aligned.m16n8k16.row.col.f32.tf32.tf32.f32     d, a, b, c, e, f;
mma.spvariant.sync.aligned.m16n8k64.row.col.f32.f8type.f8type.f32 d, a, b, c, e, f;

.f8type    = {.e4m3, .e5m2};
.spvariant = {.sp, .sp::ordered_metadata};
</pre>
 <p>
  Integer type:
 </p>
 <pre>mma.spvariant.sync.aligned.shape.row.col{.satfinite}.s32.atype.btype.s32 d, a, b, c, e, f;

.shape     = {.m16n8k32, .m16n8k64}
.atype     = {.u8, .s8};
.btype     = {.u8, .s8};
.spvariant = {.sp, .sp::ordered_metadata};

mma.spvariant.sync.aligned.shape.row.col{.satfinite}.s32.atype.btype.s32 d, a, b, c, e, f;

.shape     = {.m16n8k64, .m16n8k128}
.atype     = {.u4, .s4};
.btype     = {.u4, .s4};
.spvariant = {.sp, .sp::ordered_metadata};
</pre>
 <p>
  Description
 </p>
 <p>
  Perform a
  <span class="pre">
   MxNxK
  </span>
  matrix multiply and accumulate operation,
  <span class="pre">
   D
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   A*B+C
  </span>
  , where the A matrix is
  <span class="pre">
   MxK
  </span>
  , the B matrix is
  <span class="pre">
   KxN
  </span>
  , and the C and D matrices are
  <span class="pre">
   MxN
  </span>
  .
 </p>
 <p>
  A warp executing
  <span class="pre">
   mma.sp.sync/mma.sp::ordered_metadata.sync
  </span>
  instruction compute a single matrix
mutliply and accumulate operation.
 </p>
 <p>
  Operands
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  represent two multiplicand matrices A and B, while
  <span class="pre">
   c
  </span>
  and
  <span class="pre">
   d
  </span>
  represent the accumulator and destination matrices, distributed across the threads in warp. Matrix A
is structured sparse as described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-sparse-matrix-storage">
   Sparse matrix storage
  </a>
  Operands
  <span class="pre">
   e
  </span>
  and
  <span class="pre">
   f
  </span>
  represent sparsity
metadata and sparsity selector respectively. Operand
  <span class="pre">
   e
  </span>
  is a 32-bit integer and operand
  <span class="pre">
   f
  </span>
  is
a 32-bit integer constant with values in the range 0..3
 </p>
 <p>
  Instruction
  <span class="pre">
   mma.sp::ordered_metadata
  </span>
  requires the indices in the sparsity metadata to be sorted
in an increasing order starting from LSB, otherwise behavior is undefined.
 </p>
 <p>
  The registers in each thread hold a fragment of matrix as described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragments-for-sparse-mma">
   Matrix fragments for
multiply-accumulate operation with sparse matrix A
  </a>
  .
 </p>
 <p>
  The qualifiers
  <span class="pre">
   .dtype
  </span>
  ,
  <span class="pre">
   .atype
  </span>
  ,
  <span class="pre">
   .btype
  </span>
  and
  <span class="pre">
   .ctype
  </span>
  indicate the data-type of the
elements in the matrices D, A, B and C respectively. In case of shapes
  <span class="pre">
   .m16n8k16
  </span>
  and
  <span class="pre">
   .m16n8k32
  </span>
  ,
  <span class="pre">
   .dtype
  </span>
  must be the same as
  <span class="pre">
   .ctype
  </span>
 </p>
 Precision and rounding :
 <ul>
  <li>
   <p>
    <span class="pre">
     .f16
    </span>
    floating point operations :
   </p>
   <p>
    Element-wise multiplication of matrix A and B is performed with at least single
precision. When
    <span class="pre">
     .ctype
    </span>
    or
    <span class="pre">
     .dtype
    </span>
    is
    <span class="pre">
     .f32
    </span>
    , accumulation of the intermediate values
is performed with at least single precision. When both
    <span class="pre">
     .ctype
    </span>
    and
    <span class="pre">
     .dtype
    </span>
    are specified
as
    <span class="pre">
     .f16
    </span>
    , the accumulation is performed with at least half precision.
   </p>
   <p>
    The accumulation order, rounding and handling of subnormal inputs are unspecified.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .e4m3
    </span>
    and
    <span class="pre">
     .e5m2
    </span>
    floating point operations :
   </p>
   <p>
    Element-wise multiplication of matrix A and B is performed with specified precision. Accumulation
of the intermediate values is performed with at least single precision.
   </p>
   <p>
    The accumulation order, rounding, and handling of subnormal inputs are unspecified.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .bf16
    </span>
    and
    <span class="pre">
     .tf32
    </span>
    floating point operations :
   </p>
   <p>
    Element-wise multiplication of matrix A and B is performed with specified
precision. Accumulation of the intermediate values is performed with at least single
precision.
   </p>
   <p>
    The accumulation order, rounding, and handling of subnormal inputs are unspecified.
   </p>
  </li>
  <li>
   <p>
    Integer operations :
   </p>
   <p>
    The integer
    <span class="pre">
     mma.sp/mma.sp::ordered_metadata
    </span>
    operation is performed with
    <span class="pre">
     .s32
    </span>
    accumulators.
The
    <span class="pre">
     .satfinite
    </span>
    qualifier indicates that on overflow, the accumulated value is limited to the range
    MIN_INT32
    ..
    MAX_INT32
    (where the bounds are defined as the minimum negative signed 32-bit
integer and the maximum positive signed 32-bit integer respectively).
   </p>
   <p>
    If
    <span class="pre">
     .satfinite
    </span>
    is not specified, the accumulated value is wrapped instead.
   </p>
  </li>
 </ul>
 <p>
  The mandatory
  <span class="pre">
   .sync
  </span>
  qualifier indicates that
  <span class="pre">
   mma.sp/mma.sp::ordered_metadata
  </span>
  instruction causes
the executing thread to wait until all threads in the warp execute the same
  <span class="pre">
   mma.sp/mma.sp::ordered_metadata
  </span>
  instruction before resuming execution.
 </p>
 <p>
  The mandatory
  <span class="pre">
   .aligned
  </span>
  qualifier indicates that all threads in the warp must execute the same
  <span class="pre">
   mma.sp/mma.sp::ordered_metadata
  </span>
  instruction. In conditionally executed code, a
  <span class="pre">
   mma.sp/mma.sp::ordered_metadata
  </span>
  instruction should only be used if it is known that all threads in the warp evaluate the condition identically,
otherwise behavior is undefined.
 </p>
 <p>
  The behavior of
  <span class="pre">
   mma.sp/mma.sp::ordered_metadata
  </span>
  instruction is undefined if all threads in the same warp
do not use the same qualifiers, or if any thread in the warp has exited.
 </p>
 <p>
  Notes
 </p>
 <p>
  <span class="pre">
   mma.sp
  </span>
  instruction may have substantially reduced performance on some target architectures.
Hence, it is advised to use
  <span class="pre">
   mma.sp::ordered_metadata
  </span>
  instruction.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.1.
 </p>
 <p>
  Support for
  <span class="pre">
   .e4m3
  </span>
  and
  <span class="pre">
   .e5m2
  </span>
  alternate floating point type
  <span class="pre">
   mma
  </span>
  operation introduced in
PTX ISA version 8.4.
 </p>
 <p>
  <span class="pre">
   mma.sp::ordered_metadata
  </span>
  introduced in PTX ISA version 8.5.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   .e4m3
  </span>
  and
  <span class="pre">
   .e5m2
  </span>
  alternate floating point type
  <span class="pre">
   mma
  </span>
  operation requires
  <span class="pre">
   sm_89
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   mma.sp::ordered_metadata
  </span>
  requires
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  Examples of half precision floating point type
 </p>
 <pre>// f16 elements in C and D matrix
.reg .f16x2 %Ra&lt;2&gt; %Rb&lt;2&gt; %Rc&lt;2&gt; %Rd&lt;2&gt;
.reg .b32 %Re;
mma.sp.sync.aligned.m16n8k16.row.col.f16.f16.f16.f16
  {%Rd0, %Rd1},
  {%Ra0, %Ra1},
  {%Rb0, %Rb1},
  {%Rc0, %Rc1}, %Re, 0x1;

.reg .f16x2 %Ra&lt;2&gt; %Rb&lt;2&gt; %Rc&lt;2&gt; %Rd&lt;2&gt;
.reg .b32 %Re;

mma.sp::ordered_metadata.sync.aligned.m16n8k16.row.col.f16.f16.f16.f16
  {%Rd0, %Rd1},
  {%Ra0, %Ra1},
  {%Rb0, %Rb1},
  {%Rc0, %Rc1}, %Re, 0x1;
</pre>
 <p>
  Examples of alternate floating point type
 </p>
 <pre>.reg .b32 %Ra&lt;2&gt;, %Rb&lt;2&gt;;
.reg .f32 %Rc&lt;4&gt;, %Rd&lt;4&gt;;
.reg .b32 %Re;
mma.sp.sync.aligned.m16n8k8.row.col.f32.tf32.tf32.f32
  {%Rd0, %Rd1, %Rd2, %Rd3},
  {%Ra0, %Ra1},
  {%Rb0, %Rb1},
  {%Rc0, %Rc1, %Rc2, %Rc3}, %Re, 0x1;

.reg .b32 %Ra&lt;2&gt;, %Rb&lt;2&gt;;
.reg .f32 %Rc&lt;4&gt;, %Rd&lt;4&gt;;
.reg .b32 %Re;
mma.sp.sync.aligned.m16n8k16.row.col.f32.bf16.bf16.f32
  {%Rd0, %Rd1, %Rd2, %Rd3},
  {%Ra0, %Ra1},
  {%Rb0, %Rb1},
  {%Rc0, %Rc1, %Rc2, %Rc3}, %Re, 0x1;

.reg .b32 %Ra&lt;4&gt;, %Rb&lt;4&gt;;
.reg .f32 %Rc&lt;4&gt;, %Rd&lt;4&gt;;
.reg .b32 %Re;
mma.sp.sync.aligned.m16n8k32.row.col.f32.bf16.bf16.f32
  {%Rd0, %Rd1, %Rd2, %Rd3},
  {%Ra0, %Ra1, %Ra2, %Ra3},
  {%Rb0, %Rb1, %Rb2, %Rb3},
  {%Rc0, %Rc1, %Rc2, %Rc3}, %Re, 0x1;

.reg .b32 %Ra&lt;4&gt;, %Rb&lt;4&gt;;
.reg .f32 %Rc&lt;4&gt;, %Rd&lt;4&gt;;
.reg .b32 %Re;
mma.sp.sync.aligned.m16n8k64.row.col.f32.e5m2.e4m3.f32
  {%Rd0, %Rd1, %Rd2, %Rd3},
  {%Ra0, %Ra1, %Ra2, %Ra3},
  {%Rb0, %Rb1, %Rb2, %Rb3},
  {%Rc0, %Rc1, %Rc2, %Rc3}, %Re, 0;

.reg .b32 %Ra&lt;2&gt;, %Rb&lt;2&gt;;
.reg .f32 %Rc&lt;4&gt;, %Rd&lt;4&gt;;
.reg .b32 %Re;
mma.sp::ordered_metadata.sync.aligned.m16n8k16.row.col.f32.bf16.bf16.f32
  {%Rd0, %Rd1, %Rd2, %Rd3},
  {%Ra0, %Ra1},
  {%Rb0, %Rb1},
  {%Rc0, %Rc1, %Rc2, %Rc3}, %Re, 0x1;
</pre>
 <p>
  Examples of integer type
 </p>
 <pre>.reg .b32 %Ra&lt;4&gt;, %Rb&lt;4&gt;, %Rc&lt;4&gt;, %Rd&lt;4&gt;;
.reg .u32 %Re;

// u8 elements in A and B matrix
mma.sp.sync.aligned.m16n8k32.row.col.satfinite.s32.u8.u8.s32
  {%Rd0, %Rd1, %Rd2, %Rd3},
  {%Ra0, %Ra1},
  {%Rb0, %Rb1},
  {%Rc0, %Rc1, %Rc2, %Rc3}, %Re, 0x1;

// s8 elements in A and B matrix
mma.sp.sync.aligned.m16n8k64.row.col.satfinite.s32.s8.s8.s32
  {%Rd0, %Rd1, %Rd2, %Rd3},
  {%Ra0, %Ra1, %Ra2, %Ra3},
  {%Rb0, %Rb1, %Rb2, %Rb3},
  {%Rc0, %Rc1, %Rc2, %Rc3}, %Re, 0x0;

// s8 elements in A and B matrix with ordered metadata
mma.sp::ordered_metadata.sync.aligned.m16n8k64.row.col.satfinite.s32.s8.s8.s32
  {%Rd0, %Rd1, %Rd2, %Rd3},
  {%Ra0, %Ra1, %Ra2, %Ra3},
  {%Rb0, %Rb1, %Rb2, %Rb3},
  {%Rc0, %Rc1, %Rc2, %Rc3}, %Re, 0x0;

// u4 elements in A and B matrix
mma.sp.sync.aligned.m16n8k64.row.col.s32.s4.s4.s32
  {%Rd0, %Rd1, %Rd2, %Rd3},
  {%Ra0, %Ra1},
  {%Rb0, %Rb1},
  {%Rc0, %Rc1, %Rc2, %Rc3}, %Re, 0x1;

// u4 elements in A and B matrix
mma.sp.sync.aligned.m16n8k128.row.col.satfinite.s32.u4.u4.s32
  {%Rd0, %Rd1, %Rd2, %Rd3},
  {%Ra0, %Ra1, %Ra2, %Ra3},
  {%Rb0, %Rb1, %Rb2, %Rb3},
  {%Rc0, %Rc1, %Rc2, %Rc3}, %Re, 0x0;
</pre>
 <h3>
  <span class="section-number">
   9.7.14.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-instructions">
   Asynchronous Warpgroup Level Matrix Multiply-Accumulate Instructions
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-multiply-accumulate-instructions" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The warpgroup level matrix multiply and accumulate operation has either of the following forms,
where matrix
  <span class="pre">
   D
  </span>
  is called accumulator:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     D
    </span>
    <span class="pre">
     =
    </span>
    <span class="pre">
     A
    </span>
    <span class="pre">
     *
    </span>
    <span class="pre">
     B
    </span>
    <span class="pre">
     +
    </span>
    <span class="pre">
     D
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     D
    </span>
    <span class="pre">
     =
    </span>
    <span class="pre">
     A
    </span>
    <span class="pre">
     *
    </span>
    <span class="pre">
     B
    </span>
    , where the input from accumulator D is disabled.
   </p>
  </li>
 </ul>
 <p>
  The
  <span class="pre">
   wgmma
  </span>
  instructions perform warpgroup level matrix multiply-and-accumulate operation by
having all threads in a warpgroup collectively perform the following actions:
 </p>
 <ol class="arabic simple">
  <li>
   <p>
    Load matrices A, B and D into registers or into shared memory.
   </p>
  </li>
  <li>
   <p>
    Perform the following
    <span class="pre">
     fence
    </span>
    operations:
   </p>
   <ul class="simple">
    <li>
     <p>
      <span class="pre">
       wgmma.fence
      </span>
      operations to indicate that the register/shared-memory across the warpgroup
have been written into.
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       fence.proxy.async
      </span>
      operation to make the generic proxy operations visible to the async
proxy.
     </p>
    </li>
   </ul>
  </li>
  <li>
   <p>
    Issue the asynchronous matrix multiply and accumulate operations using the
    <span class="pre">
     wgmma.mma_async
    </span>
    operation on the input matrices. The
    <span class="pre">
     wgmma.mma_async
    </span>
    operation is performed in the async
proxy.
   </p>
  </li>
  <li>
   <p>
    Create a wgmma-group and commit all the prior outstanding
    <span class="pre">
     wgmma.mma_async
    </span>
    operations into the
group, by using
    <span class="pre">
     wgmma.commit_group
    </span>
    operation.
   </p>
  </li>
  <li>
   <p>
    Wait for the completion of the required wgmma-group.
   </p>
  </li>
  <li>
   <p>
    Once the wgmma-group completes, all the
    <span class="pre">
     wgmma.mma_async
    </span>
    operations have been performed and
completed.
   </p>
  </li>
 </ol>
 <h4>
  <span class="section-number">
   9.7.14.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-instructions-warpgroup">
   Warpgroup
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warpgroup" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  A warpgroup is a set of four contiguous warps such that the
  warp-rank
  of the first warp is a
multiple of 4.
 </p>
 <p>
  warp-rank of a warp is defined as:
 </p>
 <pre>(%tid.x + %tid.y * %ntid.x  + %tid.z * %ntid.x * %ntid.y) / 32
</pre>
 <h4>
  <span class="section-number">
   9.7.14.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shape">
   Matrix Shape
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shape" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The matrix multiply and accumulate operations support a limited set of shapes for the operand
matrices A, B and D. The shapes of all three matrix operands are collectively described by the tuple
  <span class="pre">
   MxNxK
  </span>
  , where A is an
  <span class="pre">
   MxK
  </span>
  matrix, B is a
  <span class="pre">
   KxN
  </span>
  matrix, while D is a
  <span class="pre">
   MxN
  </span>
  matrix.
 </p>
 <p>
  The following matrix shapes are supported for the specified types for the
  <span class="pre">
   wgmma.mma_async
  </span>
  operation:
 </p>
 <table class="table-no-stripes longtable docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Multiplicand Data type
    </p>
   </th>
   <th class="head">
    <p>
     Sparsity
    </p>
   </th>
   <th class="head">
    <p>
     Shape
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     Floating-point -
     <span class="pre">
      .f16
     </span>
    </p>
   </td>
   <td rowspan="2">
    <p>
     Dense
    </p>
   </td>
   <td rowspan="3">
    <p>
     <span class="pre">
      .m64n8k16
     </span>
     ,
     <span class="pre">
      .m64n16k16
     </span>
     ,
     <span class="pre">
      .m64n24k16
     </span>
     ,
     <span class="pre">
      .m64n32k16
     </span>
     ,
     <span class="pre">
      .m64n40k16
     </span>
     ,
     <span class="pre">
      .m64n48k16
     </span>
     ,
     <span class="pre">
      .m64n56k16
     </span>
     ,
     <span class="pre">
      .m64n64k16
     </span>
     ,
     <span class="pre">
      .m64n72k16
     </span>
     ,
     <span class="pre">
      .m64n80k16
     </span>
     ,
     <span class="pre">
      .m64n88k16
     </span>
     ,
     <span class="pre">
      .m64n96k16
     </span>
     ,
     <span class="pre">
      .m64n104k16
     </span>
     ,
     <span class="pre">
      .m64n112k16
     </span>
     ,
     <span class="pre">
      .m64n120k16
     </span>
     ,
     <span class="pre">
      .m64n128k16
     </span>
     ,
     <span class="pre">
      .m64n136k16
     </span>
     ,
     <span class="pre">
      .m64n144k16
     </span>
     ,
     <span class="pre">
      .m64n152k16
     </span>
     ,
     <span class="pre">
      .m64n160k16
     </span>
     ,
     <span class="pre">
      .m64n168k16
     </span>
     ,
     <span class="pre">
      .m64n176k16
     </span>
     ,
     <span class="pre">
      .m64n184k16
     </span>
     ,
     <span class="pre">
      .m64n192k16
     </span>
     ,
     <span class="pre">
      .m64n200k16
     </span>
     ,
     <span class="pre">
      .m64n208k16
     </span>
     ,
     <span class="pre">
      .m64n216k16
     </span>
     ,
     <span class="pre">
      .m64n224k16
     </span>
     ,
     <span class="pre">
      .m64n232k16
     </span>
     ,
     <span class="pre">
      .m64n240k16
     </span>
     ,
     <span class="pre">
      .m64n248k16
     </span>
     ,
     <span class="pre">
      .m64n256k16
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     Alternate floating-point
format -
     <span class="pre">
      .bf16
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     Alternate floating-point
format -
     <span class="pre">
      .tf32
     </span>
    </p>
   </td>
   <td>
    <p>
     Sparse
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     Alternate floating-point
format -
     <span class="pre">
      .tf32
     </span>
    </p>
   </td>
   <td>
    <p>
     Dense
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m64n8k8
     </span>
     ,
     <span class="pre">
      .m64n16k8
     </span>
     ,
     <span class="pre">
      .m64n24k8
     </span>
     ,
     <span class="pre">
      .m64n32k8
     </span>
     ,
     <span class="pre">
      .m64n40k8
     </span>
     ,
     <span class="pre">
      .m64n48k8
     </span>
     ,
     <span class="pre">
      .m64n56k8
     </span>
     ,
     <span class="pre">
      .m64n64k8
     </span>
     ,
     <span class="pre">
      .m64n72k8
     </span>
     ,
     <span class="pre">
      .m64n80k8
     </span>
     ,
     <span class="pre">
      .m64n88k8
     </span>
     ,
     <span class="pre">
      .m64n96k8
     </span>
     ,
     <span class="pre">
      .m64n104k8
     </span>
     ,
     <span class="pre">
      .m64n112k8
     </span>
     ,
     <span class="pre">
      .m64n120k8
     </span>
     ,
     <span class="pre">
      .m64n128k8
     </span>
     ,
     <span class="pre">
      .m64n136k8
     </span>
     ,
     <span class="pre">
      .m64n144k8
     </span>
     ,
     <span class="pre">
      .m64n152k8
     </span>
     ,
     <span class="pre">
      .m64n160k8
     </span>
     ,
     <span class="pre">
      .m64n168k8
     </span>
     ,
     <span class="pre">
      .m64n176k8
     </span>
     ,
     <span class="pre">
      .m64n184k8
     </span>
     ,
     <span class="pre">
      .m64n192k8
     </span>
     ,
     <span class="pre">
      .m64n200k8
     </span>
     ,
     <span class="pre">
      .m64n208k8
     </span>
     ,
     <span class="pre">
      .m64n216k8
     </span>
     ,
     <span class="pre">
      .m64n224k8
     </span>
     ,
     <span class="pre">
      .m64n232k8
     </span>
     ,
     <span class="pre">
      .m64n240k8
     </span>
     ,
     <span class="pre">
      .m64n248k8
     </span>
     ,
     <span class="pre">
      .m64n256k8
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     Alternate floating-point
format -
     <span class="pre">
      .e4m3
     </span>
     /
     <span class="pre">
      .e5m2
     </span>
    </p>
   </td>
   <td>
    <p>
     Dense
    </p>
   </td>
   <td rowspan="3">
    <p>
     <span class="pre">
      .m64n8k32
     </span>
     ,
     <span class="pre">
      .m64n16k32
     </span>
     ,
     <span class="pre">
      .m64n24k32
     </span>
     ,
     <span class="pre">
      .m64n32k32
     </span>
     ,
     <span class="pre">
      .m64n40k32
     </span>
     ,
     <span class="pre">
      .m64n48k32
     </span>
     ,
     <span class="pre">
      .m64n56k32
     </span>
     ,
     <span class="pre">
      .m64n64k32
     </span>
     ,
     <span class="pre">
      .m64n72k32
     </span>
     ,
     <span class="pre">
      .m64n80k32
     </span>
     ,
     <span class="pre">
      .m64n88k32
     </span>
     ,
     <span class="pre">
      .m64n96k32
     </span>
     ,
     <span class="pre">
      .m64n104k32
     </span>
     ,
     <span class="pre">
      .m64n112k32
     </span>
     ,
     <span class="pre">
      .m64n120k32
     </span>
     ,
     <span class="pre">
      .m64n128k32
     </span>
     ,
     <span class="pre">
      .m64n136k32
     </span>
     ,
     <span class="pre">
      .m64n144k32
     </span>
     ,
     <span class="pre">
      .m64n152k32
     </span>
     ,
     <span class="pre">
      .m64n160k32
     </span>
     ,
     <span class="pre">
      .m64n168k32
     </span>
     ,
     <span class="pre">
      .m64n176k32
     </span>
     ,
     <span class="pre">
      .m64n184k32
     </span>
     ,
     <span class="pre">
      .m64n192k32
     </span>
     ,
     <span class="pre">
      .m64n200k32
     </span>
     ,
     <span class="pre">
      .m64n208k32
     </span>
     ,
     <span class="pre">
      .m64n216k32
     </span>
     ,
     <span class="pre">
      .m64n224k32
     </span>
     ,
     <span class="pre">
      .m64n232k32
     </span>
     ,
     <span class="pre">
      .m64n240k32
     </span>
     ,
     <span class="pre">
      .m64n248k32
     </span>
     ,
     <span class="pre">
      .m64n256k32
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     Floating point -
     <span class="pre">
      .f16
     </span>
    </p>
   </td>
   <td rowspan="2">
    <p>
     Sparse
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     Altername floating-point
format -
     <span class="pre">
      .bf16
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     Integer -
     <span class="pre">
      .u8
     </span>
     /
     <span class="pre">
      .s8
     </span>
    </p>
   </td>
   <td>
    <p>
     Dense
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m64n8k32
     </span>
     ,
     <span class="pre">
      .m64n16k32
     </span>
     ,
     <span class="pre">
      .m64n24k32
     </span>
     ,
     <span class="pre">
      .m64n32k32
     </span>
     ,
     <span class="pre">
      .m64n48k32
     </span>
     ,
     <span class="pre">
      .m64n64k32
     </span>
     ,
     <span class="pre">
      .m64n80k32
     </span>
     ,
     <span class="pre">
      .m64n96k32
     </span>
     ,
     <span class="pre">
      .m64n112k32
     </span>
     ,
     <span class="pre">
      .m64n128k32
     </span>
     ,
     <span class="pre">
      .m64n144k32
     </span>
     ,
     <span class="pre">
      .m64n160k32
     </span>
     ,
     <span class="pre">
      .m64n176k32
     </span>
     ,
     <span class="pre">
      .m64n192k32
     </span>
     ,
     <span class="pre">
      .m64n208k32
     </span>
     ,
     <span class="pre">
      .m64n224k32
     </span>
     ,
     <span class="pre">
      .m64n240k32
     </span>
     ,
     <span class="pre">
      .m64n256k32
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     Alternate floating-point
format -
     <span class="pre">
      .e4m3
     </span>
     /
     <span class="pre">
      .e5m2
     </span>
    </p>
   </td>
   <td>
    <p>
     Sparse
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m64n8k64
     </span>
     ,
     <span class="pre">
      .m64n16k64
     </span>
     ,
     <span class="pre">
      .m64n24k64
     </span>
     ,
     <span class="pre">
      .m64n32k64
     </span>
     ,
     <span class="pre">
      .m64n40k64
     </span>
     ,
     <span class="pre">
      .m64n48k64
     </span>
     ,
     <span class="pre">
      .m64n56k64
     </span>
     ,
     <span class="pre">
      .m64n64k64
     </span>
     ,
     <span class="pre">
      .m64n72k64
     </span>
     ,
     <span class="pre">
      .m64n80k64
     </span>
     ,
     <span class="pre">
      .m64n88k64
     </span>
     ,
     <span class="pre">
      .m64n96k64
     </span>
     ,
     <span class="pre">
      .m64n104k64
     </span>
     ,
     <span class="pre">
      .m64n112k64
     </span>
     ,
     <span class="pre">
      .m64n120k64
     </span>
     ,
     <span class="pre">
      .m64n128k64
     </span>
     ,
     <span class="pre">
      .m64n136k64
     </span>
     ,
     <span class="pre">
      .m64n144k64
     </span>
     ,
     <span class="pre">
      .m64n152k64
     </span>
     ,
     <span class="pre">
      .m64n160k64
     </span>
     ,
     <span class="pre">
      .m64n168k64
     </span>
     ,
     <span class="pre">
      .m64n176k64
     </span>
     ,
     <span class="pre">
      .m64n184k64
     </span>
     ,
     <span class="pre">
      .m64n192k64
     </span>
     ,
     <span class="pre">
      .m64n200k64
     </span>
     ,
     <span class="pre">
      .m64n208k64
     </span>
     ,
     <span class="pre">
      .m64n216k64
     </span>
     ,
     <span class="pre">
      .m64n224k64
     </span>
     ,
     <span class="pre">
      .m64n232k64
     </span>
     ,
     <span class="pre">
      .m64n240k64
     </span>
     ,
     <span class="pre">
      .m64n248k64
     </span>
     ,
     <span class="pre">
      .m64n256k64
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     Integer -
     <span class="pre">
      .u8
     </span>
     /
     <span class="pre">
      .s8
     </span>
    </p>
   </td>
   <td>
    <p>
     Sparse
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m64n8k64
     </span>
     ,
     <span class="pre">
      .m64n16k64
     </span>
     ,
     <span class="pre">
      .m64n24k64
     </span>
     ,
     <span class="pre">
      .m64n32k64
     </span>
     ,
     <span class="pre">
      .m64n48k64
     </span>
     ,
     <span class="pre">
      .m64n64k64
     </span>
     ,
     <span class="pre">
      .m64n80k64
     </span>
     ,
     <span class="pre">
      .m64n96k64
     </span>
     ,
     <span class="pre">
      .m64n112k64
     </span>
     ,
     <span class="pre">
      .m64n128k64
     </span>
     ,
     <span class="pre">
      .m64n144k64
     </span>
     ,
     <span class="pre">
      .m64n160k64
     </span>
     ,
     <span class="pre">
      .m64n176k64
     </span>
     ,
     <span class="pre">
      .m64n192k64
     </span>
     ,
     <span class="pre">
      .m64n208k64
     </span>
     ,
     <span class="pre">
      .m64n224k64
     </span>
     ,
     <span class="pre">
      .m64n240k64
     </span>
     ,
     <span class="pre">
      .m64n256k64
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     Single-bit -
     <span class="pre">
      .b1
     </span>
    </p>
   </td>
   <td>
    <p>
     Dense
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .m64n8k256
     </span>
     ,
     <span class="pre">
      .m64n16k256
     </span>
     ,
     <span class="pre">
      .m64n24k256
     </span>
     ,
     <span class="pre">
      .m64n32k256
     </span>
     ,
     <span class="pre">
      .m64n48k256
     </span>
     ,
     <span class="pre">
      .m64n64k256
     </span>
     ,
     <span class="pre">
      .m64n80k256
     </span>
     ,
     <span class="pre">
      .m64n96k256
     </span>
     ,
     <span class="pre">
      .m64n112k256
     </span>
     ,
     <span class="pre">
      .m64n128k256
     </span>
     ,
     <span class="pre">
      .m64n144k256
     </span>
     ,
     <span class="pre">
      .m64n160k256
     </span>
     ,
     <span class="pre">
      .m64n176k256
     </span>
     ,
     <span class="pre">
      .m64n192k256
     </span>
     ,
     <span class="pre">
      .m64n208k256
     </span>
     ,
     <span class="pre">
      .m64n224k256
     </span>
     ,
     <span class="pre">
      .m64n240k256
     </span>
     ,
     <span class="pre">
      .m64n256k256
     </span>
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   9.7.14.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-data-types">
   Matrix Data-types
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-data-types" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The matrix multiply and accumulate operation is supported separately on integer, floating-point,
sub-byte integer and single bit data-types. All operands must contain the same basic type kind,
i.e., integer or floating-point.
 </p>
 <p>
  For floating-point matrix multiply and accumulate operation, different matrix operands may have
different precision, as described later.
 </p>
 <p>
  For integer matrix multiply and accumulate operation, both multiplicand matrices (A and B) must have
elements of the same data-type, e.g. both signed integer or both unsigned integer.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Data-type
    </p>
   </th>
   <th class="head">
    <p>
     Multiplicands (A or B)
    </p>
   </th>
   <th class="head">
    <p>
     Accumulator (D)
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     Integer
    </p>
   </td>
   <td>
    <p>
     both
     <span class="pre">
      .u8
     </span>
     or both
     <span class="pre">
      .s8
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .s32
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     Floating Point
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .f16
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .f16
     </span>
     ,
     <span class="pre">
      .f32
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     Alternate floating Point
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .bf16
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .f32
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     Alternate floating Point
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .tf32
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .f32
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     Alternate floating Point
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .e4m3
     </span>
     ,
     <span class="pre">
      .e5m2
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .f16
     </span>
     ,
     <span class="pre">
      .f32
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     Single-bit integer
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .b1
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .s32
     </span>
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   9.7.14.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-async-proxy">
   Async Proxy
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-async-proxy" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The
  <span class="pre">
   wgmma.mma_async
  </span>
  operations are performed in the asynchronous proxy (or async proxy).
 </p>
 <p>
  Accessing the same memory location across multiple proxies needs a cross-proxy fence. For the async
proxy,
  <span class="pre">
   fence.proxy.async
  </span>
  should be used to synchronize memory between generic proxy and the
async proxy.
 </p>
 <p>
  The completion of a
  <span class="pre">
   wgmma.mma_async
  </span>
  operation is followed by an implicit generic-async proxy
fence. So the result of the asynchronous operation is made visible to the generic proxy as soon as
its completion is observed.
  <span class="pre">
   wgmma.commit_group
  </span>
  and
  <span class="pre">
   wgmma.wait_group
  </span>
  operations must be used
to wait for the completion of the
  <span class="pre">
   wgmma.mma_async
  </span>
  instructions.
 </p>
 <h4>
  <span class="section-number">
   9.7.14.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-operation-wgmma-mma-async">
   Asynchronous Warpgroup Level Matrix Multiply-Accumulate Operation using wgmma.mma_async instruction
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-multiply-accumulate-operation-using-wgmma-mma-async-instruction" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  This section describes warpgroup level
  <span class="pre">
   wgmma.mma_async
  </span>
  instruction and the organization of
various matrices involved in this instruction.
 </p>
 <h5>
  <span class="section-number">
   9.7.14.5.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-fragment">
   Register Fragments and Shared Memory Matrix Layouts
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#register-fragments-and-shared-memory-matrix-layouts" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  The input matrix A of the warpgroup wide MMA operations can be either in registers or in the shared
memory. The input matrix B of the warpgroup wide MMA operations must be in the shared memory. This
section describes the layouts of register fragments and shared memory expected by the warpgroup MMA
instructions.
 </p>
 <p>
  When the matrices are in shared memory, their starting addresses must be aligned to 16 bytes.
 </p>
 <h6>
  <span class="section-number">
   9.7.14.5.1.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-register-fragment">
   Register Fragments
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#register-fragments" title="Permalink to this headline">
   ï
  </a>
 </h6>
 <p>
  This section describes the organization of various matrices located in register operands of the
  <span class="pre">
   wgmma.mma_async
  </span>
  instruction.
 </p>
 <span class="section-number">
  9.7.14.5.1.1.1.
 </span>
 <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-register-fragment-wgmma-64n16">
  Matrix Fragments for wgmma.mma_async.m64nNk16
 </a>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-wgmma-mma-async-m64nnk16" title="Permalink to this headline">
  ï
 </a>
 <p>
  A warpgroup executing
  <span class="pre">
   wgmma.mma_async.m64nNk16
  </span>
  will compute an MMA operation of shape
  <span class="pre">
   .m64nNk16
  </span>
  where N is a valid
  <span class="pre">
   n
  </span>
  dimension as listed in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shape">
   Matrix Shape
  </a>
  .
 </p>
 <p>
  Elements of the matrix are distributed across the threads in a warpgroup so each thread of the
warpgroup holds a fragment of the matrix.
 </p>
 <ul>
  <li>
   <p>
    Multiplicand A in registers:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .atype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .f16
       </span>
       /
       <span class="pre">
        .bf16
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing four
       <span class="pre">
        .f16x2
       </span>
       registers, with each
register containing two
       <span class="pre">
        .f16
       </span>
       /
       <span class="pre">
        .bf16
       </span>
       elements from matrix A.
      </p>
     </td>
     <td>
      <p>
       a0, a1, a2, a3, a4, a5, a6, a7
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n16-a">
     <span class="std std-numref">
      Figure 119
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 119
    </span>
    <span class="caption-text">
     WGMMA .m64nNk16 register fragment layout for matrix A.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n16-a" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
  <li>
   <p>
    Accumulator D:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .dtype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .f16
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing N/4 number of
       <span class="pre">
        .f16x2
       </span>
       registers, with each register containing two
       <span class="pre">
        .f16
       </span>
       elements from matrix D.
      </p>
     </td>
     <td rowspan="2">
      <p>
       d0, d1, d2, d3, â¦, dX, dY, dZ, dW
      </p>
      <p>
       where
       <span class="pre">
        X
       </span>
       <span class="pre">
        =
       </span>
       <span class="pre">
        N/2
       </span>
       Â
       <span class="pre">
        -
       </span>
       Â
       <span class="pre">
        4
       </span>
      </p>
      <p>
       <span class="pre">
        Y
       </span>
       <span class="pre">
        =
       </span>
       <span class="pre">
        N/2
       </span>
       Â
       <span class="pre">
        -
       </span>
       Â
       <span class="pre">
        3
       </span>
      </p>
      <p>
       <span class="pre">
        Z
       </span>
       <span class="pre">
        =
       </span>
       <span class="pre">
        N/2
       </span>
       Â
       <span class="pre">
        -
       </span>
       Â
       <span class="pre">
        2
       </span>
      </p>
      <p>
       <span class="pre">
        W
       </span>
       <span class="pre">
        =
       </span>
       <span class="pre">
        N/2
       </span>
       Â
       <span class="pre">
        -
       </span>
       Â
       <span class="pre">
        1
       </span>
      </p>
      <p>
       <span class="pre">
        N
       </span>
       <span class="pre">
        =
       </span>
       <span class="pre">
        8*i
       </span>
       <span class="pre">
        where
       </span>
       <span class="pre">
        i
       </span>
       <span class="pre">
        =
       </span>
       <span class="pre">
        {1,
       </span>
       <span class="pre">
        2,
       </span>
       <span class="pre">
        ...
       </span>
       <span class="pre">
        ,
       </span>
       <span class="pre">
        32}
       </span>
      </p>
     </td>
    </tr>
    <tr class="row-odd">
     <td>
      <p>
       <span class="pre">
        .f32
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing N/2 number of
       <span class="pre">
        .f32
       </span>
       registers.
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n16-d">
     <span class="std std-numref">
      Figure 120
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 120
    </span>
    <span class="caption-text">
     WGMMA .m64nNk16 register fragment layout for accumulator matrix D.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n16-d" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
 </ul>
 <span class="section-number">
  9.7.14.5.1.1.2.
 </span>
 <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-register-fragment-wgmma-64n8">
  Matrix Fragments for wgmma.mma_async.m64nNk8
 </a>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-wgmma-mma-async-m64nnk8" title="Permalink to this headline">
  ï
 </a>
 <p>
  A warpgroup executing
  <span class="pre">
   wgmma.mma_async.m64nNk8
  </span>
  will compute an MMA operation of shape
  <span class="pre">
   .m64nNk8
  </span>
  where N is a valid
  <span class="pre">
   n
  </span>
  dimension as listed in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shape">
   Matrix Shape
  </a>
  .
 </p>
 <p>
  Elements of the matrix are distributed across the threads in a warpgroup so each thread of the
warpgroup holds a fragment of the matrix.
 </p>
 <ul>
  <li>
   <p>
    Multiplicand A in registers:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .atype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .tf32
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing four
       <span class="pre">
        .b32
       </span>
       registers containing
four
       <span class="pre">
        .tf32
       </span>
       elements from matrix A.
      </p>
     </td>
     <td>
      <p>
       a0, a1, a2, a3
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n8-a">
     <span class="std std-numref">
      Figure 121
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 121
    </span>
    <span class="caption-text">
     WGMMA .m64nNk8 register fragment layout for matrix A.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n8-a" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
  <li>
   <p>
    Accumulator D:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .dtype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .f32
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing N/2 number of
       <span class="pre">
        .f32
       </span>
       registers.
      </p>
     </td>
     <td>
      <p>
       d0, d1, d2, d3, â¦, dX, dY, dZ, dW
      </p>
      <p>
       where
       <span class="pre">
        X
       </span>
       <span class="pre">
        =
       </span>
       <span class="pre">
        N/2
       </span>
       Â
       <span class="pre">
        -
       </span>
       Â
       <span class="pre">
        4
       </span>
      </p>
      <p>
       <span class="pre">
        Y
       </span>
       <span class="pre">
        =
       </span>
       <span class="pre">
        N/2
       </span>
       Â
       <span class="pre">
        -
       </span>
       Â
       <span class="pre">
        3
       </span>
      </p>
      <p>
       <span class="pre">
        Z
       </span>
       <span class="pre">
        =
       </span>
       <span class="pre">
        N/2
       </span>
       Â
       <span class="pre">
        -
       </span>
       Â
       <span class="pre">
        2
       </span>
      </p>
      <p>
       <span class="pre">
        W
       </span>
       <span class="pre">
        =
       </span>
       <span class="pre">
        N/2
       </span>
       Â
       <span class="pre">
        -
       </span>
       Â
       <span class="pre">
        1
       </span>
      </p>
      <p>
       <span class="pre">
        N
       </span>
       <span class="pre">
        =
       </span>
       <span class="pre">
        8*i
       </span>
       <span class="pre">
        where
       </span>
       <span class="pre">
        i
       </span>
       <span class="pre">
        =
       </span>
       <span class="pre">
        {1,
       </span>
       <span class="pre">
        2,
       </span>
       <span class="pre">
        ...
       </span>
       <span class="pre">
        ,
       </span>
       <span class="pre">
        32}
       </span>
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n8-d">
     <span class="std std-numref">
      Figure 122
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 122
    </span>
    <span class="caption-text">
     WGMMA .m64nNk8 register fragment layout for accumulator matrix D.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n8-d" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
 </ul>
 <span class="section-number">
  9.7.14.5.1.1.3.
 </span>
 <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-register-fragment-wgmma-64n32">
  Matrix Fragments for wgmma.mma_async.m64nNk32
 </a>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-wgmma-mma-async-m64nnk32" title="Permalink to this headline">
  ï
 </a>
 <p>
  A warpgroup executing
  <span class="pre">
   wgmma.mma_async.m64nNk32
  </span>
  will compute an MMA operation of shape
  <span class="pre">
   .m64nNk32
  </span>
  where N is a valid
  <span class="pre">
   n
  </span>
  dimension as listed in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shape">
   Matrix Shape
  </a>
  .
 </p>
 <p>
  Elements of the matrix are distributed across the threads in a warpgroup so each thread of the
warpgroup holds a fragment of the matrix.
 </p>
 <ul>
  <li>
   <p>
    Multiplicand A in registers:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .atype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .s8
       </span>
       /
       <span class="pre">
        .u8
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing four
       <span class="pre">
        .b32
       </span>
       registers, with each
register containing four
       <span class="pre">
        .u8
       </span>
       /
       <span class="pre">
        .s8
       </span>
       elements from matrix A.
      </p>
     </td>
     <td rowspan="2">
      <p>
       a0, a1, a2, a3, â¦ , a14, a15
      </p>
     </td>
    </tr>
    <tr class="row-odd">
     <td>
      <p>
       <span class="pre">
        .e4m3
       </span>
       /
       <span class="pre">
        .e5m2
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing four
       <span class="pre">
        .b32
       </span>
       registers, with each
register containing four
       <span class="pre">
        .e4m3
       </span>
       /
       <span class="pre">
        .e5m2
       </span>
       elements from
matrix A.
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n32-a">
     <span class="std std-numref">
      Figure 123
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 123
    </span>
    <span class="caption-text">
     WGMMA .m64nNk32 register fragment layout for matrix A.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n32-a" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
  <li>
   <p>
    Accumulator D:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .dtype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
     <th class="head">
      <p>
       Miscellaneous Information
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .s32
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing
N/2 number of
       <span class="pre">
        .s32
       </span>
       registers.
      </p>
     </td>
     <td rowspan="3">
      <p>
       d0, d1, d2, d3, â¦, dX, dY, dZ, dW
      </p>
      <p>
       where
       <span class="pre">
        X
       </span>
       <span class="pre">
        =
       </span>
       <span class="pre">
        N/2
       </span>
       Â
       <span class="pre">
        -
       </span>
       Â
       <span class="pre">
        4
       </span>
      </p>
      <p>
       <span class="pre">
        Y
       </span>
       <span class="pre">
        =
       </span>
       <span class="pre">
        N/2
       </span>
       Â
       <span class="pre">
        -
       </span>
       Â
       <span class="pre">
        3
       </span>
      </p>
      <p>
       <span class="pre">
        Z
       </span>
       <span class="pre">
        =
       </span>
       <span class="pre">
        N/2
       </span>
       Â
       <span class="pre">
        -
       </span>
       Â
       <span class="pre">
        2
       </span>
      </p>
      <p>
       <span class="pre">
        W
       </span>
       <span class="pre">
        =
       </span>
       <span class="pre">
        N/2
       </span>
       Â
       <span class="pre">
        -
       </span>
       Â
       <span class="pre">
        1
       </span>
      </p>
      <p>
       <span class="pre">
        N
       </span>
       depends on .dtype, as
described in the next column.
      </p>
     </td>
     <td>
      <p>
       <span class="pre">
        N
       </span>
       <span class="pre">
        =
       </span>
       <span class="pre">
        8*i
       </span>
       <span class="pre">
        where
       </span>
       <span class="pre">
        i
       </span>
       <span class="pre">
        =
       </span>
       <span class="pre">
        {1,
       </span>
       <span class="pre">
        2,
       </span>
       <span class="pre">
        3,
       </span>
       <span class="pre">
        4}
       </span>
      </p>
      <p>
       <span class="pre">
        =
       </span>
       <span class="pre">
        16*i
       </span>
       <span class="pre">
        where
       </span>
       <span class="pre">
        i
       </span>
       <span class="pre">
        =
       </span>
       <span class="pre">
        {3,
       </span>
       <span class="pre">
        4,
       </span>
       <span class="pre">
        ...,
       </span>
       <span class="pre">
        15,
       </span>
       <span class="pre">
        16}
       </span>
      </p>
     </td>
    </tr>
    <tr class="row-odd">
     <td>
      <p>
       <span class="pre">
        .f32
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing
N/2 number of
       <span class="pre">
        .f32
       </span>
       registers.
      </p>
     </td>
     <td rowspan="2">
      <p>
       <span class="pre">
        N
       </span>
       <span class="pre">
        =
       </span>
       <span class="pre">
        8*i
       </span>
       <span class="pre">
        where
       </span>
       <span class="pre">
        i
       </span>
       <span class="pre">
        =
       </span>
       <span class="pre">
        {1,
       </span>
       <span class="pre">
        2,
       </span>
       <span class="pre">
        ...
       </span>
       <span class="pre">
        ,
       </span>
       <span class="pre">
        32}
       </span>
      </p>
     </td>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .f16
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing
N/4 number of
       <span class="pre">
        .f16x2
       </span>
       registers, with each register
containing two
       <span class="pre">
        .f16
       </span>
       elements from matrix D.
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n32-d">
     <span class="std std-numref">
      Figure 124
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 124
    </span>
    <span class="caption-text">
     WGMMA .m64nNk32 register fragment layout for accumulator matrix D.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n32-d" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
 </ul>
 <span class="section-number">
  9.7.14.5.1.1.4.
 </span>
 <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-register-fragment-wgmma-64n256">
  Matrix Fragments for wgmma.mma_async.m64nNk256
 </a>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-wgmma-mma-async-m64nnk256" title="Permalink to this headline">
  ï
 </a>
 <p>
  A warpgroup executing
  <span class="pre">
   wgmma.mma_async.m64nNk256
  </span>
  will compute an MMA operation of shape
  <span class="pre">
   .m64nNk256
  </span>
  where N is a valid
  <span class="pre">
   n
  </span>
  dimension as listed in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shape">
   Matrix Shape
  </a>
  .
 </p>
 <p>
  Elements of the matrix are distributed across the threads in a warpgroup so each thread of the
warpgroup holds a fragment of the matrix.
 </p>
 <ul>
  <li>
   <p>
    Multiplicand A in registers:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .atype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .b1
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing four
       <span class="pre">
        .b32
       </span>
       registers, with each
register containing thirty two
       <span class="pre">
        .b1
       </span>
       element from matrix A.
      </p>
     </td>
     <td>
      <p>
       a0, a1, a2, â¦, a127
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n256-a">
     <span class="std std-numref">
      Figure 125
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 125
    </span>
    <span class="caption-text">
     WGMMA .m64nNk256 register fragment layout for matrix A.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n256-a" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
  <li>
   <p>
    Accumulator D:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .dtype
      </p>
     </th>
     <th class="head">
      <p>
       Fragment
      </p>
     </th>
     <th class="head">
      <p>
       Elements (low to high)
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <p>
       <span class="pre">
        .s32
       </span>
      </p>
     </td>
     <td>
      <p>
       A vector expression containing N/2 number of
       <span class="pre">
        .s32
       </span>
       registers.
      </p>
     </td>
     <td>
      <p>
       d0, d1, d2, d3, â¦, dX, dY, dZ, dW
      </p>
      <p>
       where
       <span class="pre">
        X
       </span>
       <span class="pre">
        =
       </span>
       <span class="pre">
        N/2
       </span>
       Â
       <span class="pre">
        -
       </span>
       Â
       <span class="pre">
        4
       </span>
      </p>
      <p>
       <span class="pre">
        Y
       </span>
       <span class="pre">
        =
       </span>
       <span class="pre">
        N/2
       </span>
       Â
       <span class="pre">
        -
       </span>
       Â
       <span class="pre">
        3
       </span>
      </p>
      <p>
       <span class="pre">
        Z
       </span>
       <span class="pre">
        =
       </span>
       <span class="pre">
        N/2
       </span>
       Â
       <span class="pre">
        -
       </span>
       Â
       <span class="pre">
        2
       </span>
      </p>
      <p>
       <span class="pre">
        W
       </span>
       <span class="pre">
        =
       </span>
       <span class="pre">
        N/2
       </span>
       Â
       <span class="pre">
        -
       </span>
       Â
       <span class="pre">
        1
       </span>
      </p>
      <p>
       <span class="pre">
        N
       </span>
       <span class="pre">
        =
       </span>
       <span class="pre">
        8*i
       </span>
       <span class="pre">
        where
       </span>
       <span class="pre">
        i
       </span>
       <span class="pre">
        =
       </span>
       <span class="pre">
        {1,
       </span>
       <span class="pre">
        2,
       </span>
       <span class="pre">
        3,
       </span>
       <span class="pre">
        4}
       </span>
      </p>
      <p>
       <span class="pre">
        =
       </span>
       <span class="pre">
        16*i
       </span>
       <span class="pre">
        where
       </span>
       <span class="pre">
        i
       </span>
       <span class="pre">
        =
       </span>
       <span class="pre">
        {3,
       </span>
       <span class="pre">
        4,
       </span>
       <span class="pre">
        ...,
       </span>
       <span class="pre">
        15,
       </span>
       <span class="pre">
        16}
       </span>
      </p>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n256-d">
     <span class="std std-numref">
      Figure 126
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 126
    </span>
    <span class="caption-text">
     WGMMA .m64nNk256 register fragment layout for accumulator matrix D.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n256-d" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
 </ul>
 <h6>
  <span class="section-number">
   9.7.14.5.1.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shared-memory-layout">
   Shared Memory Matrix Layout
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#shared-memory-matrix-layout" title="Permalink to this headline">
   ï
  </a>
 </h6>
 <p>
  Matrices in shared memory are organized into a number of smaller matrices called core matrices. Each
core matrix has 8 rows or columns and the size of each row is 16 bytes. The core matrices occupy
contiguous space in shared memory.
 </p>
 <p>
  Matrix A is made up of 8x2 core matrices and Matrix B is made up of 2x(N/8) core matrices. This
section describes the layout of the core matrices for each shape.
 </p>
 <span class="section-number">
  9.7.14.5.1.2.1.
 </span>
 <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shared-memory-layout-wgmma-64n16">
  Shared Memory Layout for wgmma.mma_async.m64nNk16
 </a>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#shared-memory-layout-for-wgmma-mma-async-m64nnk16" title="Permalink to this headline">
  ï
 </a>
 <p>
  Core matrices of A and B are as follows:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Core matrix
    </p>
   </th>
   <th class="head">
    <p>
     Matrix description
    </p>
   </th>
   <th class="head">
    <p>
     Matrix size
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     Each row is made up of eight
     <span class="pre">
      .f16
     </span>
     /
     <span class="pre">
      .bf16
     </span>
     elements.
    </p>
   </td>
   <td>
    <p>
     8x8
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      B
     </span>
    </p>
   </td>
   <td>
    <p>
     Each column is made up of eight
     <span class="pre">
      .f16
     </span>
     /
     <span class="pre">
      .bf16
     </span>
     elements.
    </p>
   </td>
   <td>
    <p>
     8x8
    </p>
   </td>
  </tr>
 </table>
 <p>
  Matrices A and B consist of core matrices as shown in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n16-core-matrices-ab">
   <span class="std std-numref">
    Figure 127
   </span>
  </a>
  .
Each colored cell represents a core matrix.
 </p>
 <p>
  <span class="caption-number">
   Figure 127
  </span>
  <span class="caption-text">
   WGMMA .m64nNk16 core matrices for A and B
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n16-core-matrices-ab" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  Layout of core matrices of A is shown in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n16-core-matrices-a">
   <span class="std std-numref">
    Figure 128
   </span>
  </a>
  . Each numbered
cell represents an individual element of the core matrix.
 </p>
 <p>
  <span class="caption-number">
   Figure 128
  </span>
  <span class="caption-text">
   WGMMA .m64nNk16 core matrix layout for A
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n16-core-matrices-a" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  Layout of core matrices of B is shown in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n16-core-matrices-b">
   <span class="std std-numref">
    Figure 129
   </span>
  </a>
  . Each numbered cell
represents an individual element of the core matrix.
 </p>
 <p>
  <span class="caption-number">
   Figure 129
  </span>
  <span class="caption-text">
   WGMMA .m64nNk16 core matrix layout for B
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n16-core-matrices-b" title="Permalink to this image">
   ï
  </a>
 </p>
 <span class="section-number">
  9.7.14.5.1.2.2.
 </span>
 <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shared-memory-layout-wgmma-64n8">
  Shared Memory Layout for wgmma.mma_async.m64nNk8
 </a>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#shared-memory-layout-for-wgmma-mma-async-m64nnk8" title="Permalink to this headline">
  ï
 </a>
 <p>
  Core matrices of A and B are as follows:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Core matrix
    </p>
   </th>
   <th class="head">
    <p>
     Matrix description
    </p>
   </th>
   <th class="head">
    <p>
     Matrix size
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     Each row is made up of four
     <span class="pre">
      .tf32
     </span>
     elements.
    </p>
   </td>
   <td>
    <p>
     8x4
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      B
     </span>
    </p>
   </td>
   <td>
    <p>
     Each row is made up of four
     <span class="pre">
      .tf32
     </span>
     elements.
    </p>
   </td>
   <td>
    <p>
     4x8
    </p>
   </td>
  </tr>
 </table>
 <p>
  Matrices A and B consist of core matrices as shown in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n8-core-matrices-ab">
   <span class="std std-numref">
    Figure 130
   </span>
  </a>
  . Each
colored cell represents a core matrix.
 </p>
 <p>
  <span class="caption-number">
   Figure 130
  </span>
  <span class="caption-text">
   WGMMA .m64nNk8 core matrices for A and B
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n8-core-matrices-ab" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  Layout of core matrices of A is shown in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n8-core-matrices-a">
   <span class="std std-numref">
    Figure 131
   </span>
  </a>
  . Each numbered cell
represents an individual element of the core matrix.
 </p>
 <p>
  <span class="caption-number">
   Figure 131
  </span>
  <span class="caption-text">
   WGMMA .m64nNk8 core matrix layout for A
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n8-core-matrices-a" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  Layout of core matrices of B is shown in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n8-core-matrices-b">
   <span class="std std-numref">
    Figure 132
   </span>
  </a>
  . Each numbered cell
represents an individual element of the core matrix.
 </p>
 <p>
  <span class="caption-number">
   Figure 132
  </span>
  <span class="caption-text">
   WGMMA .m64nNk8 core matrix layout for B
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n8-core-matrices-b" title="Permalink to this image">
   ï
  </a>
 </p>
 <span class="section-number">
  9.7.14.5.1.2.3.
 </span>
 <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shared-memory-layout-wgmma-64n32">
  Shared Memory Layout for wgmma.mma_async.m64nNk32
 </a>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#shared-memory-layout-for-wgmma-mma-async-m64nnk32" title="Permalink to this headline">
  ï
 </a>
 <p>
  Core matrices of A and B are as follows:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     .atype/ .btype
    </p>
   </th>
   <th class="head">
    <p>
     Core matrix
    </p>
   </th>
   <th class="head">
    <p>
     Matrix description
    </p>
   </th>
   <th class="head">
    <p>
     Matrix size
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .s8
     </span>
     /
     <span class="pre">
      .u8
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     Each row is made up of sixteen
     <span class="pre">
      .s8
     </span>
     /
     <span class="pre">
      .u8
     </span>
     elements.
    </p>
   </td>
   <td>
    <p>
     8x4
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .e4m3
     </span>
     /
     <span class="pre">
      .e5m2
     </span>
    </p>
   </td>
   <td>
    <p>
     Each row is made up of sixteen
     <span class="pre">
      .e4m3
     </span>
     /
     <span class="pre">
      .e5m2
     </span>
     elements.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .s8
     </span>
     /
     <span class="pre">
      .u8
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      B
     </span>
    </p>
   </td>
   <td>
    <p>
     Each column is made up of sixteen
     <span class="pre">
      .s8
     </span>
     /
     <span class="pre">
      .u8
     </span>
     elements.
    </p>
   </td>
   <td>
    <p>
     4x8
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .e4m3
     </span>
     /
     <span class="pre">
      .e5m2
     </span>
    </p>
   </td>
   <td>
    <p>
     Each column is made up of sixteen
     <span class="pre">
      .e4m3
     </span>
     /
     <span class="pre">
      .e5m2
     </span>
     elements.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Matrices A and B consist of core matrices as shown in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n32-core-matrices-ab">
   <span class="std std-numref">
    Figure 133
   </span>
  </a>
  . Each
colored cell represents a core matrix.
 </p>
 <p>
  <span class="caption-number">
   Figure 133
  </span>
  <span class="caption-text">
   WGMMA .m64nNk32 core matrices for A and B
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n32-core-matrices-ab" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  Layout of core matrices of A is shown in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n32-core-matrices-a">
   <span class="std std-numref">
    Figure 134
   </span>
  </a>
  . Each numbered cell
represents an individual element of the core matrix.
 </p>
 <p>
  <span class="caption-number">
   Figure 134
  </span>
  <span class="caption-text">
   WGMMA .m64nNk32 core matrix layout for A
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n32-core-matrices-a" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  Layout of core matrices of B is shown in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n32-core-matrices-b">
   <span class="std std-numref">
    Figure 135
   </span>
  </a>
  . Each numbered cell
represents an individual element of the core matrix.
 </p>
 <p>
  <span class="caption-number">
   Figure 135
  </span>
  <span class="caption-text">
   WGMMA .m64nNk32 core matrix layout for B
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n32-core-matrices-b" title="Permalink to this image">
   ï
  </a>
 </p>
 <span class="section-number">
  9.7.14.5.1.2.4.
 </span>
 <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shared-memory-layout-wgmma-64n256">
  Shared Memory Layout for wgmma.mma_async.m64nNk256
 </a>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#shared-memory-layout-for-wgmma-mma-async-m64nnk256" title="Permalink to this headline">
  ï
 </a>
 <p>
  Core matrices of A and B are as follows:
 </p>
 <table class="table-no-table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Core matrix
    </p>
   </th>
   <th class="head">
    <p>
     Matrix description
    </p>
   </th>
   <th class="head">
    <p>
     Matrix size
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     Each row is made up of 256
     <span class="pre">
      .b1
     </span>
     elements.
    </p>
   </td>
   <td>
    <p>
     8x128
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      B
     </span>
    </p>
   </td>
   <td>
    <p>
     Each column is made up of 256
     <span class="pre">
      .b1
     </span>
     elements.
    </p>
   </td>
   <td>
    <p>
     128x8
    </p>
   </td>
  </tr>
 </table>
 <p>
  Matrices A and B consist of core matrices as shown in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n256-core-matrices-ab">
   <span class="std std-numref">
    Figure 136
   </span>
  </a>
  . Each
colored cell represents a core matrix.
 </p>
 <p>
  <span class="caption-number">
   Figure 136
  </span>
  <span class="caption-text">
   WGMMA .m64nNk256 core matrices for A and B
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n256-core-matrices-ab" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  Layout of core matrices of A is shown in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n256-core-matrices-a">
   <span class="std std-numref">
    Figure 137
   </span>
  </a>
  . Each numbered cell
represents an individual element of the core matrix.
 </p>
 <p>
  <span class="caption-number">
   Figure 137
  </span>
  <span class="caption-text">
   WGMMA .m64nNk256 core matrix layout for A
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n256-core-matrices-a" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  Layout of core matrices of B is shown in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n256-core-matrices-b">
   <span class="std std-numref">
    Figure 138
   </span>
  </a>
  . Each numbered cell
represents an individual element of the core matrix.
 </p>
 <p>
  <span class="caption-number">
   Figure 138
  </span>
  <span class="caption-text">
   WGMMA .m64nNk256 core matrix layout for B
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-64n256-core-matrices-b" title="Permalink to this image">
   ï
  </a>
 </p>
 <span class="section-number">
  9.7.14.5.1.2.5.
 </span>
 <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shared-memory-layout-strides">
  Strides
 </a>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#strides" title="Permalink to this headline">
  ï
 </a>
 <p>
  Leading dimension byte offset
  of matrix A or B is the distance, in bytes, between two adjacent
core matrices in the K dimension.
 </p>
 <p>
  Stride dimension byte offset
  of matrix A or B is the distance, in bytes, between two adjacent core
matrices in the M or N dimension.
 </p>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-stride-and-leading-dim-offset-a">
   <span class="std std-numref">
    Figure 139
   </span>
  </a>
  and
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-stride-and-leading-dim-offset-b">
   <span class="std std-numref">
    Figure 140
   </span>
  </a>
  show the leading dimension byte offset and the stride dimension byte offsets for A and B matrices.
 </p>
 <ul>
  <li>
   <p>
    Matrix A:
   </p>
   <p>
    <span class="caption-number">
     Figure 139
    </span>
    <span class="caption-text">
     WGMMA stride and leading dimension byte offset for matrix A
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-stride-and-leading-dim-offset-a" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
  <li>
   <p>
    Matrix B:
   </p>
   <p>
    <span class="caption-number">
     Figure 140
    </span>
    <span class="caption-text">
     WGMMA stride and leading dimension byte offset for matrix B
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-stride-and-leading-dim-offset-b" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
 </ul>
 <p>
  Leading dimension byte offset and stride dimension byte offset must be specified in the matrix
descriptor as described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shared-memory-layout-matrix-descriptor">
   Matrix Descriptor Format
  </a>
  .
 </p>
 <span class="section-number">
  9.7.14.5.1.2.6.
 </span>
 <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shared-memory-layout-swizzling-modes">
  Swizzling Modes
 </a>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shared-memory-layout-swizzling-modes" title="Permalink to this headline">
  ï
 </a>
 <p>
  The core matrices can be swizzled in the shared memory by specifying one of the following swizzling
modes:
 </p>
 <ol class="arabic">
  <li>
   <p>
    No swizzling: All the elements of the entire core matrix are adjacent to each other and there is
no swizzling.
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-core-matrices-no-swizzling">
     <span class="std std-numref">
      Figure 141
     </span>
    </a>
    illustrates this:
   </p>
   <p>
    <span class="caption-number">
     Figure 141
    </span>
    <span class="caption-text">
     WGMMA core matrices with no swizzling
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-core-matrices-no-swizzling" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
  <li>
   <p>
    32-Byte swizzling: A group of two adjacent core matrices are swizzled as shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-core-matrices-32-byte-swizzling">
     <span class="std std-numref">
      Figure 142
     </span>
    </a>
    . The
swizzling pattern repeats for the remaining core matrices.
   </p>
   <p>
    <span class="caption-number">
     Figure 142
    </span>
    <span class="caption-text">
     WGMMA core matrices with 32-byte swizzling
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-core-matrices-32-byte-swizzling" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
  <li>
   <p>
    64-Byte swizzling: A group of four adjacent core matrices are swizzled as shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-core-matrices-64-byte-swizzling">
     <span class="std std-numref">
      Figure 143
     </span>
    </a>
    . The
swizzling pattern repeats for the remaining core matrices.
   </p>
   <p>
    <span class="caption-number">
     Figure 143
    </span>
    <span class="caption-text">
     WGMMA core matrices with 64-byte swizzling
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-core-matrices-64-byte-swizzling" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
  <li>
   <p>
    128-Byte swizzling: A group of eight adjacent core matrices are swizzled as shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-core-matrices-128-byte-swizzling">
     <span class="std std-numref">
      Figure 144
     </span>
    </a>
    . The
swizzling pattern repeats for the remaining core matrices.
   </p>
   <p>
    <span class="caption-number">
     Figure 144
    </span>
    <span class="caption-text">
     WGMMA core matrices with 128-byte swizzling
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#wgmma-core-matrices-128-byte-swizzling" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
 </ol>
 <span class="section-number">
  9.7.14.5.1.2.7.
 </span>
 <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shared-memory-layout-matrix-descriptor">
  Matrix Descriptor Format
 </a>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-descriptor-format" title="Permalink to this headline">
  ï
 </a>
 <p>
  Matrix descriptor specifies the properties of the matrix in shared memory that is a multiplicand in
the matrix multiply and accumulate operation. It is a 64-bit value contained in a register with the
following layout:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Bit-field
    </p>
   </th>
   <th class="head">
    <p>
     Size in bits
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     13â0
    </p>
   </td>
   <td>
    <p>
     14
    </p>
   </td>
   <td>
    <p>
     matrix-descriptor-encode(Matrix start address)
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     29â16
    </p>
   </td>
   <td>
    <p>
     14
    </p>
   </td>
   <td>
    <p>
     matrix-descriptor-encode(Leading dimension byte offset)
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     45â32
    </p>
   </td>
   <td>
    <p>
     14
    </p>
   </td>
   <td>
    <p>
     matrix-descriptor-encode(Stride dimension byte offset)
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     51â49
    </p>
   </td>
   <td>
    <p>
     3
    </p>
   </td>
   <td>
    <p>
     Matrix base offset. This is valid for all swizzling modes except the no-swizzle mode.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     63â62
    </p>
   </td>
   <td>
    <p>
     2
    </p>
   </td>
   <td>
    <p>
     Specifies the swizzling mode to be used:
    </p>
    <ul class="simple">
     <li>
      <p>
       0: No swizzle
      </p>
     </li>
     <li>
      <p>
       1: 128-Byte swizzle
      </p>
     </li>
     <li>
      <p>
       2: 64-Byte swizzle
      </p>
     </li>
     <li>
      <p>
       3: 32-Byte swizzle
      </p>
     </li>
    </ul>
   </td>
  </tr>
 </table>
 <p>
  where
 </p>
 <pre>matrix-descriptor-encode(x) = (x &amp; 0x3FFFF) &gt;&gt; 0x4
</pre>
 <p>
  The value of base offset is 0 when the repeating pattern of the specified swizzling mode starts as
per the below table:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Swizzling mode
    </p>
   </th>
   <th class="head">
    <p>
     Starting address of the repeating pattern
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     128-Byte swizzle
    </p>
   </td>
   <td>
    <p>
     1024-Byte boundary
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     64-Byte swizzle
    </p>
   </td>
   <td>
    <p>
     512-Byte boundary
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     32-Byte swizzle
    </p>
   </td>
   <td>
    <p>
     256-Byte boundary
    </p>
   </td>
  </tr>
 </table>
 <p>
  Otherwise, the base offset must be a non-zero value, computed using the following formula:
 </p>
 <pre>base offset = (pattern start addr &gt;&gt; 0x7) &amp; 0x7
</pre>
 <h5>
  <span class="section-number">
   9.7.14.5.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-instructions-wgmma-mma">
   Asynchronous Multiply-and-Accumulate Instruction: wgmma.mma_async
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-multiply-and-accumulate-instruction-wgmma-mma-async" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  wgmma.mma_async
 </p>
 <p>
  Perform matrix multiply-and-accumulate operation across warpgroup
 </p>
 <p>
  Syntax
 </p>
 <p>
  Half precision floating point type:
 </p>
 <pre>wgmma.mma_async.sync.aligned.shape.dtype.f16.f16  d, a-desc, b-desc, scale-d, imm-scale-a, imme-scale-b, imm-trans-a, imm-trans-b;

wgmma.mma_async.sync.aligned.shape.dtype.f16.f16  d, a, b-desc, scale-d, imm-scale-a, imme-scale-b, imm-trans-b;

.shape   = {.m64n8k16, .m64n16k16, .m64n24k16, .m64n32k16,
            .m64n40k16, .m64n48k16, .m64n56k16, .m64n64k16,
            .m64n72k16, .m64n80k16, .m64n88k16, .m64n96k16,
            .m64n104k16, .m64n112k16, .m64n120k16, .m64n128k16,
            .m64n136k16, .m64n144k16, .m64n152k16, .m64n160k16,
            .m64n168k16, .m648176k16, .m64n184k16, .m64n192k16,
            .m64n200k16, .m64n208k16, .m64n216k16, .m64n224k16,
            .m64n232k16, .m64n240k16, .m64n248k16, .m64n256k16};
.dtype   = {.f16, .f32};
</pre>
 <p>
  Alternate floating point type :
 </p>
 <pre>.bf16 floating point type:

wgmma.mma_async.sync.aligned.shape.dtype.bf16.bf16  d, a-desc, b-desc, scale-d, imm-scale-a, imme-scale-b, imm-trans-a, imm-trans-b;

wgmma.mma_async.sync.aligned.shape.dtype.bf16.bf16  d, a, b-desc, scale-d, imm-scale-a, imme-scale-b, imm-trans-b;

.shape   = {.m64n8k16, .m64n16k16, .m64n24k16, .m64n32k16,
            .m64n40k16, .m64n48k16, .m64n56k16, .m64n64k16,
            .m64n72k16, .m64n80k16, .m64n88k16, .m64n96k16,
            .m64n104k16, .m64n112k16, .m64n120k16, .m64n128k16,
            .m64n136k16, .m64n144k16, .m64n152k16, .m64n160k16,
            .m64n168k16, .m648176k16, .m64n184k16, .m64n192k16,
            .m64n200k16, .m64n208k16, .m64n216k16, .m64n224k16,
            .m64n232k16, .m64n240k16, .m64n248k16, .m64n256k16};
.dtype  = {.f32};

.tf32 floating point type:

wgmma.mma_async.sync.aligned.shape.dtype.tf32.tf32  d, a-desc, b-desc, scale-d, imm-scale-a, imme-scale-b;

wgmma.mma_async.sync.aligned.shape.dtype.tf32.tf32  d, a, b-desc, scale-d, imm-scale-a, imme-scale-b;

.shape   = {.m64n8k8, .m64n16k8, .m64n24k8, .m64n32k8,
            .m64n40k8, .m64n48k8, .m64n56k8, .m64n64k8,
            .m64n72k8, .m64n80k8, .m64n88k8, .m64n96k8,
            .m64n104k8, .m64n112k8, .m64n120k8, .m64n128k8,
            .m64n136k8, .m64n144k8, .m64n152k8, .m64n160k8,
            .m64n168k8, .m648176k8, .m64n184k8, .m64n192k8,
            .m64n200k8, .m64n208k8, .m64n216k8, .m64n224k8,
            .m64n232k8, .m64n240k8, .m64n248k8, .m64n256k8};
.dtype  = {.f32};

FP8 floating point type

wgmma.mma_async.sync.aligned.shape.dtype.atype.btype  d, a-desc, b-desc, scale-d, imm-scale-a, imme-scale-b;

wgmma.mma_async.sync.aligned.shape.dtype.atype.btype  d, a, b-desc, scale-d, imm-scale-a, imme-scale-b;

.shape   = {.m64n8k32, .m64n16k32, .m64n24k32, .m64n32k32,
            .m64n40k32, .m64n48k32, .m64n56k32, .m64n64k32,
            .m64n72k32, .m64n80k32, .m64n88k32, .m64n96k32,
            .m64n104k32, .m64n112k32, .m64n120k32, .m64n128k32,
            .m64n136k32, .m64n144k32, .m64n152k32, .m64n160k32,
            .m64n168k32, .m648176k32, .m64n184k32, .m64n192k32,
            .m64n200k32, .m64n208k32, .m64n216k32, .m64n224k32,
            .m64n232k32, .m64n240k32, .m64n248k32, .m64n256k32};
.atype  = {.e4m3, .e5m2};
.btype  = {.e4m3, .e5m2};
.dtype  = {.f16, .f32};
</pre>
 <p>
  Integer type:
 </p>
 <pre>wgmma.mma_async.sync.aligned.shape{.satfinite}.s32.atype.btype  d, a-desc, b-desc, scale-d;

wgmma.mma_async.sync.aligned.shape{.satfinite}.s32.atype.btype  d, a, b-desc, scale-d;

.shape   = {.m64n8k32, .m64n16k32, .m64n24k32, .m64n32k32,
            .m64n48k32, .m64n64k32, .m64n80k32, .m64n96k32,
            .m64n112k32, .m64n128k32, .m64n144k32, .m64n160k32,
            .m648176k32, .m64n192k32, .m64n208k32, .m64n224k32};
.atype  = {.s8, .u8};
.btype  = {.s8, .u8};
</pre>
 <p>
  Single bit:
 </p>
 <pre>wgmma.mma_async.sync.aligned.shape.s32.b1.b1.op.popc  d, a-desc, b-desc, scale-d;

wgmma.mma_async.sync.aligned.shape.s32.b1.b1.op.popc  d, a, b-desc, scale-d;

.shape   = {.m64n8k256, .m64n16k256, .m64n24k256, .m64n32k256,
            .m64n48k256, .m64n64k256, .m64n80k256, .m64n96k256,
            .m64n112k256, .m64n128k256, .m64n144k256, .m64n160k256,
            .m64n176k256, .m64n192k256, .m64n208k256, .m64n224k256,
            .m64n240k256, .m64n256k256};
.op  = {.and};
</pre>
 <p>
  Description
 </p>
 <p>
  Instruction
  <span class="pre">
   wgmma.mma_async
  </span>
  issues a
  <span class="pre">
   MxNxK
  </span>
  matrix multiply and accumulate operation,
  <span class="pre">
   D
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   A*B+D
  </span>
  , where the A matrix is
  <span class="pre">
   MxK
  </span>
  , the B matrix is
  <span class="pre">
   KxN
  </span>
  , and the D matrix is
  <span class="pre">
   MxN
  </span>
  .
 </p>
 <p>
  The operation of the form
  <span class="pre">
   D
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   A*B
  </span>
  is issued when the input predicate argument
  <span class="pre">
   scale-d
  </span>
  is
false.
 </p>
 <p>
  <span class="pre">
   wgmma.fence
  </span>
  instruction must be used to fence the register accesses of
  <span class="pre">
   wgmma.mma_async
  </span>
  instruction from their prior accesses. Otherwise, the behavior is undefined.
 </p>
 <p>
  <span class="pre">
   wgmma.commit_group
  </span>
  and
  <span class="pre">
   wgmma.wait_group
  </span>
  operations must be used to wait for the completion
of the asynchronous matrix multiply and accumulate operations before the results are accessed.
 </p>
 <p>
  Register operand
  <span class="pre">
   d
  </span>
  represents the accumulator matrix as well as the destination matrix,
distributed across the participating threads. Register operand
  <span class="pre">
   a
  </span>
  represents the multiplicand
matrix A in register distributed across the participating threads. The 64-bit register operands
  <span class="pre">
   a-desc
  </span>
  and
  <span class="pre">
   b-desc
  </span>
  are the matrix descriptors which represent the multiplicand matrices A and
B in shared memory respectively. The contents of a matrix descriptor must be same across all the warps
in the warpgroup. The format of the matrix descriptor is described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shared-memory-layout-matrix-descriptor">
   Matrix Descriptor Format
  </a>
  .
 </p>
 <p>
  Matrices A and B are stored in row-major and column-major format respectively. For certain floating
point variants, the input matrices A and B can be transposed by specifying the value 1 for the
immediate integer arguments
  <span class="pre">
   imm-trans-a
  </span>
  and
  <span class="pre">
   imm-trans-b
  </span>
  respectively. A value of 0 can be
used to avoid the transpose operation. The valid values of
  <span class="pre">
   imm-trans-a
  </span>
  and
  <span class="pre">
   imm-trans-b
  </span>
  are 0
and 1. The transpose operation is only supported for the
  <span class="pre">
   wgmma.mma_async
  </span>
  variants with
  <span class="pre">
   .f16
  </span>
  /
  <span class="pre">
   .bf16
  </span>
  types on matrices accessed from shared memory using matrix descriptors.
 </p>
 <p>
  For the floating point variants of the
  <span class="pre">
   wgmma.mma_async
  </span>
  operation, each element of the input
matrices A and B can be negated by specifying the value -1 for operands
  <span class="pre">
   imm-scale-a
  </span>
  and
  <span class="pre">
   imm-scale-b
  </span>
  respectively. A value of 1 can be used to avoid the negate operation. The valid
values of
  <span class="pre">
   imm-scale-a
  </span>
  and
  <span class="pre">
   imm-scale-b
  </span>
  are -1 and 1.
 </p>
 <p>
  The qualifiers
  <span class="pre">
   .dtype
  </span>
  ,
  <span class="pre">
   .atype
  </span>
  and
  <span class="pre">
   .btype
  </span>
  indicate the data type of the elements in
matrices D, A and B respectively.
  <span class="pre">
   .atype
  </span>
  and
  <span class="pre">
   .btype
  </span>
  must be the same for all floating point
  <span class="pre">
   wgmma.mma_async
  </span>
  variants except for the FP8 floating point variants. The sizes of individual
data elements of matrices A and B in alternate floating point variants of the
  <span class="pre">
   wgmma.mma_async
  </span>
  operation are as follows:
 </p>
 <ul class="simple">
  <li>
   <p>
    Matrices A and B have 8-bit data elements when
    <span class="pre">
     .atype
    </span>
    /
    <span class="pre">
     .btype
    </span>
    is
    <span class="pre">
     .e4m3
    </span>
    /
    <span class="pre">
     .e5m2
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Matrices A and B have 16-bit data elements when
    <span class="pre">
     .atype
    </span>
    /
    <span class="pre">
     .btype
    </span>
    is
    <span class="pre">
     .bf16
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Matrices A and B have 32-bit data elements when
    <span class="pre">
     .atype
    </span>
    /
    <span class="pre">
     .btype
    </span>
    is
    <span class="pre">
     .tf32
    </span>
    .
   </p>
  </li>
 </ul>
 <p>
  Precision and rounding:
 </p>
 <ul>
  <li>
   <p>
    Floating point operations:
   </p>
   <p>
    Element-wise multiplication of matrix A and B is performed with at least single precision. When
    <span class="pre">
     .dtype
    </span>
    is
    <span class="pre">
     .f32
    </span>
    , accumulation of the intermediate values is performed with at least single
precision. When
    <span class="pre">
     .dtype
    </span>
    is
    <span class="pre">
     .f16
    </span>
    , the accumulation is performed with at least half
precision.
   </p>
   <p>
    The accumulation order, rounding and handling of subnormal inputs are unspecified.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .bf16
    </span>
    and
    <span class="pre">
     .tf32
    </span>
    floating point operations:
   </p>
   <p>
    Element-wise multiplication of matrix A and B is performed with specified
precision.
    <span class="pre">
     wgmma.mma_async
    </span>
    operation involving type
    <span class="pre">
     .tf32
    </span>
    will truncate lower 13 bits of
the 32-bit input data before multiplication is issued. Accumulation of the intermediate values is
performed with at least single precision.
   </p>
   <p>
    The accumulation order, rounding, and handling of subnormal inputs are unspecified.
   </p>
  </li>
  <li>
   <p>
    Integer operations:
   </p>
   <p>
    The integer
    <span class="pre">
     wgmma.mma_async
    </span>
    operation is performed with
    <span class="pre">
     .s32
    </span>
    accumulators. The
    <span class="pre">
     .satfinite
    </span>
    qualifier indicates that on overflow, the accumulated value is limited to the
range
    MIN_INT32
    ..
    MAX_INT32
    (where the bounds are defined as the minimum negative signed
32-bit integer and the maximum positive signed 32-bit integer respectively).
   </p>
   <p>
    If
    <span class="pre">
     .satfinite
    </span>
    is not specified, the accumulated value is wrapped instead.
   </p>
  </li>
 </ul>
 <p>
  The mandatory
  <span class="pre">
   .sync
  </span>
  qualifier indicates that
  <span class="pre">
   wgmma.mma_async
  </span>
  instruction causes the
executing thread to wait until all threads in the warp execute the same
  <span class="pre">
   wgmma.mma_async
  </span>
  instruction before resuming execution.
 </p>
 <p>
  The mandatory
  <span class="pre">
   .aligned
  </span>
  qualifier indicates that all threads in the warpgroup must execute the
same
  <span class="pre">
   wgmma.mma_async
  </span>
  instruction. In conditionally executed code, a
  <span class="pre">
   wgmma.mma_async
  </span>
  instruction should only be used if it is known that all threads in the warpgroup evaluate the
condition identically, otherwise behavior is undefined.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 8.0.
 </p>
 <p>
  Support for
  <span class="pre">
   .u8.s8
  </span>
  and
  <span class="pre">
   .s8.u8
  </span>
  as .atype.btype introduced in PTX ISA version 8.4.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90a
  </span>
  .
 </p>
 <p>
  Examples of half precision floating point type
 </p>
 <pre>.reg .f16x2 f16a&lt;40&gt;, f16d&lt;40&gt;;
.reg .f32   f32d&lt;40&gt;;
.reg .b64   descA, descB;
.reg .pred  scaleD;
wgmma.mma_async.sync.aligned.m64n8k16.f32.f16.f16
  {f32d0, f32d1, f32d2, f32d3},
  {f16a0, f16a1, f16a2, f16a3},
  descB,
  1, -1, -1, 1;

wgmma.mma_async.sync.aligned.m64n72k16.f16.f16.f16
  {f16d0, f16d1,  f16d2,  f16d3,  f16d4,  f16d5,  f16d6,  f16d7,  f16d8,
   f16d9, f16d10, f16d11, f16d12, f16d13, f16d14, f16d15, f16d16, f16d17},
  descA,
  descB,
  scaleD, -1, 1, 1, 0;
</pre>
 <p>
  Examples of alternate floating point type
 </p>
 <pre>.reg .f32   f32d&lt;40&gt;;
.reg .b32   bf16a&lt;40&gt;
.reg .b64   descA, descB;

wgmma.mma_async.sync.aligned.m64n120k16.f32.bf16.bf16
  {f32d0, f32d1, f32d2, f32d3, f32d4, f32d5, f32d6, f32d7, f32d8, f32d9,
   f32d10, f32d11, f32d12, f32d13, f32d14, f32d15, f32d16, f32d17, f32d18, f32d19,
   f32d20, f32d21, f32d22, f32d23, f32d24, f32d25, f32d26, f32d27, f32d28, f32d29,
   f32d30, f32d31, f32d32, f32d33, f32d34, f32d35, f32d36, f32d37, f32d38, f32d39,
   f32d40, f32d41, f32d42, f32d43, f32d44, f32d45, f32d46, f32d47, f32d48, f32d49,
   f32d50, f32d51, f32d52, f32d53, f32d54, f32d55, f32d56, f32d57, f32d58, f32d59},
  {bf16a0, bf16a1, bf16a2, bf16a3},
  descB,
  scaleD, -1, -1, 0;

.reg .f32   f32d&lt;40&gt;;
.reg .b64   descA, descB;

wgmma.mma_async.sync.aligned.m64n16k8.f32.tf32.tf32
  {f32d0, f32d1, f32d2, f32d3, f32d4, f32d5, f32d6, f32d7},
  descA,
  descB,
  0, -1, -1;

.reg .b32 f16d&lt;8&gt;, f16a&lt;8&gt;;
.reg .f32 f32d&lt;8&gt;;
.reg .b64   descA, descB;

wgmma.mma_async.sync.aligned.m64n8k32.f16.e4m3.e5m2
  {f16d0, f16d1},
  descA,
  descB,
  scaleD, -1, 1;

wgmma.mma_async.sync.aligned.m64n8k32.f32.e5m2.e4m3
  {f32d0, f32d1, f32d2, f32d3},
  {f16a0, f16a1, f16a2, f16a3},
  descB,
  1, -1, -1;
</pre>
 <p>
  Examples of integer type
 </p>
 <pre>.reg .s32 s32d&lt;8&gt;, s32a&lt;8&gt;;
.reg .u32 u32a&lt;8&gt;;
.reg .pred scaleD;
.reg .b64   descA, descB;

wgmma.mma_async.sync.aligned.m64n8k32.s32.s8.s8.satfinite
  {s32d0, s32d1, s32d2, s32d3},
  {s32a0, s32a1, s32a2, s32a3},
  descB,
  1;

wgmma.mma_async.sync.aligned.m64n8k32.s32.u8.u8
  {s32d0, s32d1, s32d2, s32d3},
  descA,
  descB,
  scaleD;

wgmma.mma_async.sync.aligned.m64n8k32.s32.s8.u8.satfinite
  {s32d0, s32d1, s32d2, s32d3},
  {s32a0, s32a1, s32a2, s32a3},
  descB,
  scaleD;

wgmma.mma_async.sync.aligned.m64n8k32.s32.u8.s8
  {s32d0, s32d1, s32d2, s32d3},
  descA,
  descB,
  scaleD;
</pre>
 <p>
  Examples of single bit type
 </p>
 <pre>.reg .s32 s32d&lt;4&gt;;
.reg .b32 b32a&lt;4&gt;;
.reg .pred scaleD;
.reg .b64   descA, descB;


wgmma.mma_async.sync.aligned.m64n8k256.s32.b1.b1.and.popc
  {s32d0, s32d1, s32d2, s32d3},
  {b32a0, b32a1, b32a2, b32a3},
  descB,
  scaleD;
</pre>
 <h4>
  <span class="section-number">
   9.7.14.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-instructions-for-sparse-wgmma">
   Asynchronous Warpgroup Level Multiply-and-Accumulate Operation using wgmma.mma_async.sp instruction
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-multiply-and-accumulate-operation-using-wgmma-mma-async-sp-instruction" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  This section describes warp-level
  <span class="pre">
   wgmma.mma_async.sp
  </span>
  instruction with sparse matrix A. This
variant of the
  <span class="pre">
   wgmma.mma_async
  </span>
  operation can be used when A is a structured sparse matrix with
50% zeros in each row distributed in a shape-specific granularity. For an
  <span class="pre">
   MxNxK
  </span>
  sparse
  <span class="pre">
   wgmma.mma_async.sp
  </span>
  operation, the
  <span class="pre">
   MxK
  </span>
  matrix A is packed into
  <span class="pre">
   MxK/2
  </span>
  elements. For each
K-wide row of matrix A, 50% elements are zeros and the remaining
  <span class="pre">
   K/2
  </span>
  non-zero elements are
packed in the operand representing matrix A. The mapping of these
  <span class="pre">
   K/2
  </span>
  elements to the
corresponding K-wide row is provided explicitly as metadata.
 </p>
 <h5>
  <span class="section-number">
   9.7.14.6.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-sparse-matrix-storage">
   Sparse matrix storage
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-sparse-matrix-storage" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  Granularity of sparse matrix A is defined as the ratio of the number of non-zero elements in a
sub-chunk of the matrix row to the total number of elements in that sub-chunk where the size of the
sub-chunk is shape-specific. For example, in a
  <span class="pre">
   64x32
  </span>
  matrix A used in floating point
  <span class="pre">
   wgmma.mma_async
  </span>
  operations, sparsity is expected to be at 2:4 granularity, i.e. each 4-element
vector (i.e. a sub-chunk of 4 consecutive elements) of a matrix row contains 2 zeros. Index of each
non-zero element in a sub-chunk is stored in the metadata operand. Values
  <span class="pre">
   0b0000
  </span>
  ,
  <span class="pre">
   0b0101
  </span>
  ,
  <span class="pre">
   0b1010
  </span>
  ,
  <span class="pre">
   0b1111
  </span>
  are invalid values for metadata and will result in undefined behavior. In a
group of four consecutive threads, one or more threads store the metadata for the whole group
depending upon the matrix shape. These threads are specified using an additional sparsity selector operand.
 </p>
 <p>
  Matrix A and its corresponding input operand to the sparse wgmma is similar to the diagram shown in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-mma-storage-example">
   <span class="std std-numref">
    Figure 83
   </span>
  </a>
  , with an appropriate matrix size.
 </p>
 <p>
  Granularities for different matrix shapes and data types are described below.
 </p>
 <p>
  Sparse
  <span class="pre">
   wgmma.mma_async.sp
  </span>
  with half-precision and
  <span class="pre">
   .bf16
  </span>
  type
 </p>
 <p>
  For
  <span class="pre">
   .f16
  </span>
  and
  <span class="pre">
   .bf16
  </span>
  types, for all supported
  <span class="pre">
   64xNx32
  </span>
  shapes, matrix A is structured
sparse at a granularity of 2:4. In other words, each chunk of four adjacent elements in a row of
matrix A have two zeroes and two non-zero elements. Only the two non-zero elements are stored in
matrix A and their positions in the four-wide chunk in Matrix A are indicated by two 2-bits indices
in the metadata operand.
 </p>
 <p>
  <span class="caption-number">
   Figure 145
  </span>
  <span class="caption-text">
   Sparse WGMMA metadata example for
   <span class="pre">
    .f16
   </span>
   /
   <span class="pre">
    .bf16
   </span>
   type.
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#f16-metadata-example-wgmma" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  The sparsity selector indicates a thread-pair within a group of four consecutive threads which
contributes the sparsity metadata. Hence, the sparsity selector must be either 0 (threads T0, T1) or
1 (threads T2, T3); any other value results in an undefined behavior.
 </p>
 <p>
  Sparse
  <span class="pre">
   wgmma.mma_async.sp
  </span>
  with
  <span class="pre">
   .tf32
  </span>
  type
 </p>
 <p>
  For
  <span class="pre">
   .tf32
  </span>
  type, for all supported
  <span class="pre">
   64xNx16
  </span>
  shapes, matrix A is structured sparse at a
granularity of 1:2. In other words, each chunk of two adjacent elements in a row of matrix A have
one zero and one non-zero element. Only the non-zero element is stored in operand for matrix A and
the 4-bit index in the metadata indicates the position of the non-zero element in the two-wide
chunk. 0b1110 and 0b0100 are the only meaningful values of the index, the remaining values result in
an undefined behavior.
 </p>
 <p>
  <span class="caption-number">
   Figure 146
  </span>
  <span class="caption-text">
   Sparse WGMMA metadata example for
   <span class="pre">
    .tf32
   </span>
   type.
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tf32-metadata-example-wgmma" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  The sparsity selector indicates a thread-pair within a group of four consecutive threads which
contributes the sparsity metadata. Hence, the sparsity selector must be either 0 (threads T0, T1) or
1 (threads T2, T3); any other value results in an undefined behavior.
 </p>
 <p>
  Sparse
  <span class="pre">
   wgmma.mma_async.sp
  </span>
  with
  <span class="pre">
   .e4m3
  </span>
  and
  <span class="pre">
   .e5m2
  </span>
  floating point type
 </p>
 <p>
  For
  <span class="pre">
   .e4m3
  </span>
  and
  <span class="pre">
   .e5m2
  </span>
  types, for all supported
  <span class="pre">
   64xNx64
  </span>
  shapes, matrix A is structured
sparse at a granularity of 2:4. In other words, each chunk of four adjacent elements in a row of
matrix A have two zeroes and two non-zero elements. Only the two non-zero elements are stored in
matrix A and their positions in the four-wide chunk in Matrix A are indicated by two 2-bits indices
in the metadata operand.
 </p>
 <p>
  <span class="caption-number">
   Figure 147
  </span>
  <span class="caption-text">
   Sparse WGMMA metadata example for
   <span class="pre">
    .e4m3
   </span>
   /
   <span class="pre">
    .e5m2
   </span>
   type.
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#e4m3-e5m2-metadata-example-wgmma" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  All threads contribute the sparsity metadata and the sparsity selector must be 0; any other value
results in an undefined behavior.
 </p>
 <p>
  Sparse
  <span class="pre">
   wgmma.mma_async.sp
  </span>
  with integer type
 </p>
 <p>
  For the integer type, for all supported
  <span class="pre">
   64xNx64
  </span>
  shapes, matrix A is structured sparse at a
granularity of 2:4. In other words, each chunk of four adjacent elements in a row of matrix A have
two zeroes and two non-zero elements. Only the two non-zero elements are stored in matrix A and two
2-bit indices in the metadata indicate the position of these two non-zero elements in the four-wide
chunk.
 </p>
 <p>
  <span class="caption-number">
   Figure 148
  </span>
  <span class="caption-text">
   Sparse WGMMA metadata example for
   <span class="pre">
    .u8
   </span>
   /
   <span class="pre">
    .s8
   </span>
   type.
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#u8s8-metadata-example-wgmma" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  All threads contribute the sparsity metadata and the sparsity selector must be 0; any other value
results in an undefined behavior.
 </p>
 <h5>
  <span class="section-number">
   9.7.14.6.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-fragments-for-sparse-wgmma">
   Matrix fragments for warpgroup-level multiply-accumulate operation with sparse matrix A
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-warpgroup-level-multiply-accumulate-operation-with-sparse-matrix-a" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  In this section we describe how the contents of thread registers are associated with fragments of A
matrix and the sparsity metadata.
 </p>
 <p>
  Each warp in the warpgroup provides sparsity information for 16 rows of matrix A. The following
table shows the assignment of warps to rows of matrix A:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Warp
    </p>
   </th>
   <th class="head">
    <p>
     Sparsity information for rows of matrix A
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      %warpid
     </span>
     % 4 = 3
    </p>
   </td>
   <td>
    <p>
     48-63
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      %warpid
     </span>
     % 4 = 2
    </p>
   </td>
   <td>
    <p>
     32-47
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      %warpid
     </span>
     % 4 = 1
    </p>
   </td>
   <td>
    <p>
     16-31
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      %warpid
     </span>
     % 4 = 0
    </p>
   </td>
   <td>
    <p>
     0-15
    </p>
   </td>
  </tr>
 </table>
 <p>
  The following conventions are used throughout this section:
 </p>
 <ul class="simple">
  <li>
   <p>
    For matrix A, only the layout of a fragment is described in terms of register vector sizes and
their association with the matrix data.
   </p>
  </li>
  <li>
   <p>
    For matrix D, since the matrix dimension - data type combination is the same for all supported
shapes, and is already covered in
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-operation-wgmma-mma-async">
     Matrix multiply-accumulate operation using wgmma instruction
    </a>
    , the pictorial
representations of matrix fragments are not included in this section.
   </p>
  </li>
  <li>
   <p>
    For the metadata operand, pictorial representations of the association between indices of the
elements of matrix A and the contents of the metadata operand are included.
    <span class="pre">
     Tk:
    </span>
    <span class="pre">
     [m..n]
    </span>
    present
in cell
    <span class="pre">
     [x][y..z]
    </span>
    indicates that bits
    <span class="pre">
     m
    </span>
    through
    <span class="pre">
     n
    </span>
    (with
    <span class="pre">
     m
    </span>
    being higher) in the
metadata operand of thread with
    <span class="pre">
     %laneid=k
    </span>
    contains the indices of the non-zero elements from
the chunk
    <span class="pre">
     [x][y]..[x][z]
    </span>
    of matrix A.
   </p>
  </li>
 </ul>
 <h6>
  <span class="section-number">
   9.7.14.6.2.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-fragment-sparse-wgmma-64N32">
   Matrix Fragments for sparse wgmma.mma_async.m64nNk32
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-sparse-wgmma-mma-async-m64nnk32" title="Permalink to this headline">
   ï
  </a>
 </h6>
 <p>
  A warpgroup executing sparse
  <span class="pre">
   wgmma.mma_async.m64nNk32
  </span>
  will compute an MMA operation of shape
  <span class="pre">
   .m64nNk32
  </span>
  where N is a valid n dimension as listed in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shape">
   Matrix shape
  </a>
  .
 </p>
 <p>
  Elements of the matrix are distributed across the threads in a warpgroup so each thread of the
warpgroup holds a fragment of the matrix.
 </p>
 <ul>
  <li>
   <p>
    Multiplicand A, from shared memory is documented in
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shared-memory-layout-wgmma-64n32">
     Shared Memory Layout for
wgmma.mma_async.m64nNk32
    </a>
    .
   </p>
  </li>
  <li>
   <p>
    Multiplicand A, from registers:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .atype
      </p>
     </th>
     <th class="head">
      <p>
       Fragments
      </p>
     </th>
     <th class="head">
      <p>
       Elements
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <span class="pre">
       .f16
      </span>
      /
      <span class="pre">
       .bf16
      </span>
     </td>
     <td>
      A vector expression containing four
      <span class="pre">
       .b32
      </span>
      registers, with each register containing two
      non-zero
      <span class="pre">
       .f16
      </span>
      /
      <span class="pre">
       .bf16
      </span>
      elements out of 4
      consecutive elements from matrix A.
     </td>
     <td>
      Non-zero elements:
      a0, a1, a2, a3, a4, a5, a6, a7
      Mapping of the non-zero
      elements is as described in
      <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-sparse-matrix-storage">
       Sparse matrix storage
      </a>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-64n32-f16-bf16-a">
     <span class="std std-numref">
      Figure 149
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 149
    </span>
    <span class="caption-text">
     Sparse WGMMA .m64nNk32 fragment layout for matrix A with
     <span class="pre">
      .f16
     </span>
     /
     <span class="pre">
      .bf16
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-64n32-f16-bf16-a" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
  <li>
   <p>
    Accumulator D:
   </p>
   <p>
    Matrix fragments for accumulator D are the same as in case of
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-register-fragment-wgmma-64n32">
     Matrix Fragments for wgmma.m64nNk32
with floating point type
    </a>
    for the same
    <span class="pre">
     .dtype
    </span>
    format.
   </p>
  </li>
  <li>
   <p>
    Multiplicand B:
   </p>
   <p>
    Shared memory layout for Matrix B is documented in
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shared-memory-layout-wgmma-64n32">
     Shared Memory Layout for
wgmma.mma_async.m64nNk32
    </a>
    .
   </p>
  </li>
  <li>
   <p>
    Metadata operand is a
    <span class="pre">
     .b32
    </span>
    register containing 16 2-bit vectors each storing the index of a
non-zero element of a 4-wide chunk of matrix A.
   </p>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-metadata-64n32-f16bf16">
     <span class="std std-numref">
      Figure 150
     </span>
    </a>
    shows the mapping of the metadata bits to the elements
of matrix A for a warp. In this figure, variable
    <span class="pre">
     i
    </span>
    represents the value of the sparsity
selector operand.
   </p>
   <p>
    <span class="caption-number">
     Figure 150
    </span>
    <span class="caption-text">
     Sparse WGMMA .m64nNk32 metadata layout for
     <span class="pre">
      .f16
     </span>
     /
     <span class="pre">
      .bf16
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-metadata-64n32-f16bf16" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
 </ul>
 <h6>
  <span class="section-number">
   9.7.14.6.2.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-fragment-sparse-wgmma-64N16">
   Matrix Fragments for sparse wgmma.mma_async.m64nNk16
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-sparse-wgmma-mma-async-m64nnk16" title="Permalink to this headline">
   ï
  </a>
 </h6>
 <p>
  A warpgroup executing sparse
  <span class="pre">
   wgmma.mma_async.m64nNk16
  </span>
  will compute an MMA operation of shape
  <span class="pre">
   .m64nNk16
  </span>
  where N is a valid n dimension as listed in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shape">
   Matrix shape
  </a>
  .
 </p>
 <p>
  Elements of the matrix are distributed across the threads in a warpgroup so each thread of the
warpgroup holds a fragment of the matrix.
 </p>
 <ul>
  <li>
   <p>
    Multiplicand A, from shared memory is documented in
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shared-memory-layout-wgmma-64n16">
     Shared Memory Layout for
wgmma.mma_async.m64nNk16
    </a>
    .
   </p>
  </li>
  <li>
   <p>
    Multiplicand A, from registers:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .atype
      </p>
     </th>
     <th class="head">
      <p>
       Fragments
      </p>
     </th>
     <th class="head">
      <p>
       Elements
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <span class="pre">
       .tf32
      </span>
     </td>
     <td>
      A vector expression containing four
      <span class="pre">
       .b32
      </span>
      registers, containing four non-zero
      <span class="pre">
       .tf32
      </span>
      elements out of eight consecutive elements
      from matrix A.
     </td>
     <td>
      Non-zero elements:
      a0, a1, a2, a3
      Mapping of the non-zero
      elements is as described in
      <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-sparse-matrix-storage">
       Sparse matrix storage
      </a>
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-64n16-tf32-a">
     <span class="std std-numref">
      Figure 151
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 151
    </span>
    <span class="caption-text">
     Sparse WGMMA .m64nNk16 fragment layout for matrix A with
     <span class="pre">
      .tf32
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-64n16-tf32-a" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
  <li>
   <p>
    Accumulator D:
   </p>
   <p>
    Matrix fragments for accumulator D are the same as in case of
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-register-fragment-wgmma-64n8">
     Matrix Fragments for wgmma.m64nNk8
with floating point type
    </a>
    for the same
    <span class="pre">
     .dtype
    </span>
    format.
   </p>
  </li>
  <li>
   <p>
    Multiplicand B:
   </p>
   <p>
    Shared memory layout for Matrix B is documented in
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shared-memory-layout-wgmma-64n16">
     Shared Memory Layout for
wgmma.mma_async.m64nNk16
    </a>
    .
   </p>
  </li>
  <li>
   <p>
    Metadata operand is a
    <span class="pre">
     .b32
    </span>
    register containing eight 4-bit vectors each storing the index of a
non-zero element of a 2-wide chunk of matrix A.
   </p>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-metadata-64n16-tf32">
     <span class="std std-numref">
      Figure 152
     </span>
    </a>
    shows the mapping of the metadata bits to the elements
of matrix A for a warp. In this figure, variable
    <span class="pre">
     i
    </span>
    represents the value of the sparsity
selector operand.
   </p>
   <p>
    <span class="caption-number">
     Figure 152
    </span>
    <span class="caption-text">
     Sparse WGMMA .m64nNk16 metadata layout for
     <span class="pre">
      .tf32
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-metadata-64n16-tf32" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
 </ul>
 <h6>
  <span class="section-number">
   9.7.14.6.2.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-fragment-sparse-wgmma-64N64">
   Matrix Fragments for sparse wgmma.mma_async.m64nNk64
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#matrix-fragments-for-sparse-wgmma-mma-async-m64nnk64" title="Permalink to this headline">
   ï
  </a>
 </h6>
 <p>
  A warpgroup executing sparse
  <span class="pre">
   wgmma.mma_async.m64nNk64
  </span>
  will compute an MMA operation of shape
  <span class="pre">
   .m64nNk64
  </span>
  where N is a valid n dimension as listed in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shape">
   Matrix shape
  </a>
  .
 </p>
 <p>
  Elements of the matrix are distributed across the threads in a warpgroup so each thread of the
warpgroup holds a fragment of the matrix.
 </p>
 <ul>
  <li>
   <p>
    Multiplicand A, from shared memory is documented in
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shared-memory-layout-wgmma-64n64">
     Shared Memory Layout for
wgmma.mma_async.m64nNk64
    </a>
    .
   </p>
  </li>
  <li>
   <p>
    Multiplicand A, from registers:
   </p>
   <table class="table-no-stripes docutils align-default">
    <tr class="row-odd">
     <th class="head">
      <p>
       .atype
      </p>
     </th>
     <th class="head">
      <p>
       Fragments
      </p>
     </th>
     <th class="head">
      <p>
       Elements
      </p>
     </th>
    </tr>
    <tr class="row-even">
     <td>
      <span class="pre">
       .e4m3
      </span>
      /
      <span class="pre">
       .e5m2
      </span>
     </td>
     <td>
      A vector expression containing four
      <span class="pre">
       .b32
      </span>
      registers, with each register containing four
      non-zero
      <span class="pre">
       .e4m3
      </span>
      /
      <span class="pre">
       .e5m2
      </span>
      elements out of
      eight consecutive elements from matrix A.
     </td>
     <td rowspan="2">
      Non-zero elements:
      a0, a1, a2, â¦ , a15
      Mapping of the non-zero
      elements is as described in
      <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-sparse-matrix-storage">
       Sparse matrix storage
      </a>
     </td>
    </tr>
    <tr class="row-odd">
     <td>
      <span class="pre">
       .s8
      </span>
      /
      <span class="pre">
       .u8
      </span>
     </td>
     <td>
      A vector expression containing four
      <span class="pre">
       .b32
      </span>
      registers, with each register containing four
      non-zero
      <span class="pre">
       .s8
      </span>
      /
      <span class="pre">
       .u8
      </span>
      elements out of
      eight consecutive elements from matrix A.
     </td>
    </tr>
   </table>
   <p>
    The layout of the fragments held by different threads is shown in
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-64n64-e4m3-e5m2-s8-u8-a">
     <span class="std std-numref">
      Figure 153
     </span>
    </a>
    .
   </p>
   <p>
    <span class="caption-number">
     Figure 153
    </span>
    <span class="caption-text">
     Sparse WGMMA .m64nNk64 fragment layout for matrix A with
     <span class="pre">
      .e4m3
     </span>
     /
     <span class="pre">
      .e5m2
     </span>
     /
     <span class="pre">
      .s8
     </span>
     /
     <span class="pre">
      .u8
     </span>
     type.
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-64n64-e4m3-e5m2-s8-u8-a" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
  <li>
   <p>
    Accumulator D:
   </p>
   <p>
    Matrix fragments for accumulator D are the same as in case of
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-register-fragment-wgmma-64n32">
     Matrix Fragments for wgmma.m64nNk32
with floating point type
    </a>
    for the same
    <span class="pre">
     .dtype
    </span>
    format.
   </p>
  </li>
  <li>
   <p>
    Multiplicand B:
   </p>
   <p>
    Shared memory layout for Matrix B is documented in
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shared-memory-layout-wgmma-64n64">
     Shared Memory Layout for
wgmma.mma_async.m64nNk64
    </a>
    .
   </p>
  </li>
  <li>
   <p>
    Metadata operand is a
    <span class="pre">
     .b32
    </span>
    register containing 16 4-bit vectors each storing the indices of
two non-zero elements of a 4-wide chunk of matrix A.
   </p>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-metadata-64n64-e4m3-e5m2-s8-u8-first32col">
     <span class="std std-numref">
      Figure 154
     </span>
    </a>
    shows the mapping of the metadata
bits to the elements of columns 0â31 of matrix A.
   </p>
   <p>
    <span class="caption-number">
     Figure 154
    </span>
    <span class="caption-text">
     Sparse WGMMA .m64nNk64 metadata layout for
     <span class="pre">
      .e4m3
     </span>
     /
     <span class="pre">
      .e5m2
     </span>
     /
     <span class="pre">
      .s8
     </span>
     /
     <span class="pre">
      .u8
     </span>
     type for columns 0â31
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-metadata-64n64-e4m3-e5m2-s8-u8-first32col" title="Permalink to this image">
     ï
    </a>
   </p>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-metadata-64n64-e4m3-e5m2-s8-u8-last32col">
     <span class="std std-numref">
      Figure 155
     </span>
    </a>
    shows the mapping of the metadata
bits to the elements of columns 32â63 of matrix A.
   </p>
   <p>
    <span class="caption-number">
     Figure 155
    </span>
    <span class="caption-text">
     Sparse WGMMA .m64nNk64 metadata layout for
     <span class="pre">
      .e4m3
     </span>
     /
     <span class="pre">
      .e5m2
     </span>
     /
     <span class="pre">
      .s8
     </span>
     /
     <span class="pre">
      .u8
     </span>
     type for columns 32â63
    </span>
    <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-metadata-64n64-e4m3-e5m2-s8-u8-last32col" title="Permalink to this image">
     ï
    </a>
   </p>
  </li>
 </ul>
 <h5>
  <span class="section-number">
   9.7.14.6.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-shared-memory-layout-for-sparse-wgmma">
   Shared Memory Matrix Layout
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-shared-memory-layout-for-sparse-wgmma" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  Matrices in shared memory are organized into a number of smaller matrices called core matrices. Each
core matrix has 8 rows or columns and the size of each row is 16 bytes. The core matrices occupy
contiguous space in shared memory.
 </p>
 <p>
  Matrix A is made up of 8x2 packed core matrices and Matrix B is made up of 4x (N/8) core
matrices. This section describes the layout of the core matrices for each shape.
 </p>
 <h6>
  <span class="section-number">
   9.7.14.6.3.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shared-memory-layout-wgmma-sp-64n32">
   Shared Memory Layout for wgmma.mma_async.sp.m64nNk32
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#shared-memory-layout-for-wgmma-mma-async-sp-m64nnk32" title="Permalink to this headline">
   ï
  </a>
 </h6>
 <p>
  Core matrices of A and B are as follows:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Core matrix
    </p>
   </th>
   <th class="head">
    <p>
     Matrix Description
    </p>
   </th>
   <th class="head">
    <p>
     Matrix size
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     A
    </p>
   </td>
   <td>
    <p>
     Each row is made up of sixteen
     <span class="pre">
      .f16
     </span>
     /
     <span class="pre">
      .bf16
     </span>
     elements,
with two non-zero elements out of four consecutive elements.
    </p>
   </td>
   <td>
    <p>
     8x16
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     B
    </p>
   </td>
   <td>
    <p>
     Each column is made up of eight
     <span class="pre">
      .f16
     </span>
     /
     <span class="pre">
      .bf16
     </span>
     elements.
    </p>
   </td>
   <td>
    <p>
     8x8
    </p>
   </td>
  </tr>
 </table>
 <p>
  Matrices A and B consist of core matrices as shown in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-64n32-core-matrices-ab">
   <span class="std std-numref">
    Figure 156
   </span>
  </a>
  .
Each colored cell represents a core matrix.
 </p>
 <p>
  <span class="caption-number">
   Figure 156
  </span>
  <span class="caption-text">
   Sparse WGMMA .m64nNk32 core matrices for A and B
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-64n32-core-matrices-ab" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  Layout of core matrices of A is shown in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-64n32-core-matrices-a">
   <span class="std std-numref">
    Figure 157
   </span>
  </a>
  .
 </p>
 <p>
  <span class="caption-number">
   Figure 157
  </span>
  <span class="caption-text">
   Sparse WGMMA .m64nNk32 core matrix layout for A
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-64n32-core-matrices-a" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  Layout of core matrices of B is shown in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-64n32-core-matrices-b">
   <span class="std std-numref">
    Figure 158
   </span>
  </a>
  .
 </p>
 <p>
  <span class="caption-number">
   Figure 158
  </span>
  <span class="caption-text">
   Sparse WGMMA .m64nNk32 core matrix layout for B
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-64n32-core-matrices-b" title="Permalink to this image">
   ï
  </a>
 </p>
 <h6>
  <span class="section-number">
   9.7.14.6.3.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shared-memory-layout-wgmma-sp-64n16">
   Shared Memory Layout for wgmma.mma_async.sp.m64nNk16
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#shared-memory-layout-for-wgmma-mma-async-sp-m64nnk16" title="Permalink to this headline">
   ï
  </a>
 </h6>
 <p>
  Core matrices of A and B are as follows:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Core matrix
    </p>
   </th>
   <th class="head">
    <p>
     Matrix Description
    </p>
   </th>
   <th class="head">
    <p>
     Matrix size
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     A
    </p>
   </td>
   <td>
    <p>
     Each row is made up of eight
     <span class="pre">
      .tf32
     </span>
     elements
with a non-zero element out of two consecutive elements.
    </p>
   </td>
   <td>
    <p>
     8x8
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     B
    </p>
   </td>
   <td>
    <p>
     Each column is made up of four
     <span class="pre">
      .tf32
     </span>
     elements.
    </p>
   </td>
   <td>
    <p>
     4x8
    </p>
   </td>
  </tr>
 </table>
 <p>
  Matrices A and B consist of core matrices as shown in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-64n16-core-matrices-ab">
   <span class="std std-numref">
    Figure 159
   </span>
  </a>
  .
Each colored cell represents a core matrix.
 </p>
 <p>
  <span class="caption-number">
   Figure 159
  </span>
  <span class="caption-text">
   Sparse WGMMA .m64nNk16 core matrices for A and B
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-64n16-core-matrices-ab" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  Layout of core matrices of A is shown in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-64n16-core-matrices-a">
   <span class="std std-numref">
    Figure 160
   </span>
  </a>
  .
 </p>
 <p>
  <span class="caption-number">
   Figure 160
  </span>
  <span class="caption-text">
   Sparse WGMMA .m64nNk16 core matrix layout for A
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-64n16-core-matrices-a" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  Layout of core matrices of B is shown in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-64n16-core-matrices-b">
   <span class="std std-numref">
    Figure 161
   </span>
  </a>
  .
 </p>
 <p>
  <span class="caption-number">
   Figure 161
  </span>
  <span class="caption-text">
   Sparse WGMMA .m64nNk16 core matrix layout for B
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-64n16-core-matrices-b" title="Permalink to this image">
   ï
  </a>
 </p>
 <h6>
  <span class="section-number">
   9.7.14.6.3.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shared-memory-layout-wgmma-sp-64n64">
   Shared Memory Layout for wgmma.mma_async.sp.m64nNk64
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#shared-memory-layout-for-wgmma-mma-async-sp-m64nnk64" title="Permalink to this headline">
   ï
  </a>
 </h6>
 <p>
  Core matrices of A and B are as follows:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Core matrix
    </p>
   </th>
   <th class="head">
    <p>
     Matrix Description
    </p>
   </th>
   <th class="head">
    <p>
     Matrix size
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     A
    </p>
   </td>
   <td>
    <p>
     Each row is made up of thirty-two
     <span class="pre">
      .e4m3
     </span>
     /
     <span class="pre">
      .e5m2
     </span>
     elements,
with two non-zero elements out of four consecutive elements.
    </p>
   </td>
   <td>
    <p>
     8x32
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     B
    </p>
   </td>
   <td>
    <p>
     Each column is made up of eight
     <span class="pre">
      .f16
     </span>
     /
     <span class="pre">
      .bf16
     </span>
     elements.
    </p>
   </td>
   <td>
    <p>
     16x8
    </p>
   </td>
  </tr>
 </table>
 <p>
  Matrices A and B consist of core matrices as shown in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-64n64-core-matrices-ab">
   <span class="std std-numref">
    Figure 162
   </span>
  </a>
  .
Each colored cell represents a core matrix.
 </p>
 <p>
  <span class="caption-number">
   Figure 162
  </span>
  <span class="caption-text">
   Sparse WGMMA .m64nNk64 core matrices for A and B
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-64n64-core-matrices-ab" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  Layout of core matrices of A is shown in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-64n64-core-matrices-a">
   <span class="std std-numref">
    Figure 163
   </span>
  </a>
  .
 </p>
 <p>
  <span class="caption-number">
   Figure 163
  </span>
  <span class="caption-text">
   Sparse WGMMA .m64nNk64 core matrix layout for A
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-64n64-core-matrices-a" title="Permalink to this image">
   ï
  </a>
 </p>
 <p>
  Layout of core matrices of B is shown in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-64n64-core-matrices-b">
   <span class="std std-numref">
    Figure 164
   </span>
  </a>
  .
 </p>
 <p>
  <span class="caption-number">
   Figure 164
  </span>
  <span class="caption-text">
   Sparse WGMMA .m64nNk64 core matrix layout for B
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#sparse-wgmma-64n64-core-matrices-b" title="Permalink to this image">
   ï
  </a>
 </p>
 <h5>
  <span class="section-number">
   9.7.14.6.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-instructions-wgmma-mma-sp">
   Asynchronous Multiply-and-Accumulate Instruction: wgmma.mma_async.sp
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-multiply-and-accumulate-instruction-wgmma-mma-async-sp" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  wgmma.mma_async.sp
 </p>
 <p>
  Perform matrix multiply-and-accumulate operation with sparse matrix A across warpgroup
 </p>
 <p>
  Syntax
 </p>
 <p>
  Half precision floating point type:
 </p>
 <pre>wgmma.mma_async.sp.sync.aligned.shape.dtype.f16.f16  d, a-desc, b-desc, sp-meta, sp-sel, scale-d, imm-scale-a, imm-scale-b, imm-trans-a, imm-trans-b;

wgmma.mma_async.sp.sync.aligned.shape.dtype.f16.f16  d, a, b-desc, sp-meta, sp-sel, scale-d, imm-scale-a, imm-scale-b, imm-trans-b;

.shape   = {.m64n8k32, .m64n16k32, .m64n24k32, .m64n32k32,
            .m64n40k32, .m64n48k32, .m64n56k32, .m64n64k32,
            .m64n72k32, .m64n80k32, .m64n88k32, .m64n96k32,
            .m64n104k32, .m64n112k32, .m64n120k32, .m64n128k32,
            .m64n136k32, .m64n144k32, .m64n152k32, .m64n160k32,
            .m64n168k32, .m648176k32, .m64n184k32, .m64n192k32,
            .m64n200k32, .m64n208k32, .m64n216k32, .m64n224k32,
            .m64n232k32, .m64n240k32, .m64n248k32, .m64n256k32};
.dtype   = {.f16, .f32};
</pre>
 <p>
  Alternate floating point type :
 </p>
 <pre>.bf16 floating point type:

wgmma.mma_async.sp.sync.aligned.shape.dtype.bf16.bf16  d, a-desc, b-desc, sp-meta, sp-sel, scale-d, imm-scale-a, imm-scale-b, imm-trans-a, imm-trans-b;

wgmma.mma_async.sp.sync.aligned.shape.dtype.bf16.bf16  d, a, b-desc, sp-meta, sp-sel, scale-d, imm-scale-a, imme-scale-b, imm-trans-b;

.shape   = {.m64n8k32, .m64n16k32, .m64n24k32, .m64n32k32,
            .m64n40k32, .m64n48k32, .m64n56k32, .m64n64k32,
            .m64n72k32, .m64n80k32, .m64n88k32, .m64n96k32,
            .m64n104k32, .m64n112k32, .m64n120k32, .m64n128k32,
            .m64n136k32, .m64n144k32, .m64n152k32, .m64n160k32,
            .m64n168k32, .m648176k32, .m64n184k32, .m64n192k32,
            .m64n200k32, .m64n208k32, .m64n216k32, .m64n224k32,
            .m64n232k32, .m64n240k32, .m64n248k32, .m64n256k32};
.dtype  = {.f32};

.tf32 floating point type:

wgmma.mma_async.sp.sync.aligned.shape.dtype.tf32.tf32  d, a-desc, b-desc, sp-meta, sp-sel, scale-d, imm-scale-a, imm-scale-b;

wgmma.mma_async.sp.sync.aligned.shape.dtype.tf32.tf32  d, a, b-desc, sp-meta, sp-sel, scale-d, imm-scale-a, imm-scale-b;

.shape   = {.m64n8k16, .m64n16k16, .m64n24k16, .m64n32k16,
            .m64n40k16, .m64n48k16, .m64n56k16, .m64n64k16,
            .m64n72k16, .m64n80k16, .m64n88k16, .m64n96k16,
            .m64n104k16, .m64n112k16, .m64n120k16, .m64n128k16,
            .m64n136k16, .m64n144k16, .m64n152k16, .m64n160k16,
            .m64n168k16, .m648176k16, .m64n184k16, .m64n192k16,
            .m64n200k16, .m64n208k16, .m64n216k16, .m64n224k16,
            .m64n232k16, .m64n240k16, .m64n248k16, .m64n256k16};
.dtype  = {.f32};

FP8 floating point type

wgmma.mma_async.sp.sync.aligned.shape.dtype.atype.btype  d, a-desc, b-desc, sp-meta, sp-sel, scale-d, imm-scale-a, imm-scale-b;

wgmma.mma_async.sp.sync.aligned.shape.dtype.atype.btype  d, a, b-desc, sp-meta, sp-sel, scale-d, imm-scale-a, imm-scale-b;

.shape   = {.m64n8k64, .m64n16k64, .m64n24k64, .m64n32k64,
            .m64n40k64, .m64n48k64, .m64n56k64, .m64n64k64,
            .m64n72k64, .m64n80k64, .m64n88k64, .m64n96k64,
            .m64n104k64, .m64n112k64, .m64n120k64, .m64n128k64,
            .m64n136k64, .m64n144k64, .m64n152k64, .m64n160k64,
            .m64n168k64, .m648176k64, .m64n184k64, .m64n192k64,
            .m64n200k64, .m64n208k64, .m64n216k64, .m64n224k64,
            .m64n232k64, .m64n240k64, .m64n248k64, .m64n256k64};
.atype  = {.e4m3, .e5m2};
.btype  = {.e4m3, .e5m2};
.dtype  = {.f16, .f32};
</pre>
 <p>
  Integer type:
 </p>
 <pre>wgmma.mma_async.sp.sync.aligned.shape{.satfinite}.s32.atype.btype  d, a-desc, b-desc, sp-meta, sp-sel, scale-d;

wgmma.mma_async.sp.sync.aligned.shape{.satfinite}.s32.atype.btype  d, a, b-desc, sp-meta, sp-sel, scale-d;

.shape   = {.m64n8k64, .m64n16k64, .m64n24k64, .m64n32k64,
            .m64n48k64, .m64n64k64, .m64n80k64, .m64n96k64,
            .m64n112k64, .m64n128k64, .m64n144k64, .m64n160k64,
            .m648176k64, .m64n192k64, .m64n208k64, .m64n224k64,
            .m64n240k64, .m64n256k64};
.atype  = {.s8, .u8};
.btype  = {.s8, .u8};
</pre>
 <p>
  Description
 </p>
 <p>
  Instruction
  <span class="pre">
   wgmma.mma_async
  </span>
  issues a
  <span class="pre">
   MxNxK
  </span>
  matrix multiply and accumulate operation,
  <span class="pre">
   D
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   A*B+D
  </span>
  , where the A matrix is
  <span class="pre">
   MxK
  </span>
  , the B matrix is
  <span class="pre">
   KxN
  </span>
  , and the D matrix is
  <span class="pre">
   MxN
  </span>
  .
 </p>
 <p>
  The matrix A is stored in the packed format Mx(K/2) as described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-sparse-matrix-storage">
   Matrix multiply-accumulate
operation using wgmma.mma_async.sp instruction with sparse matrix A
  </a>
  .
 </p>
 <p>
  The operation of the form
  <span class="pre">
   D
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   A*B
  </span>
  is issued when the input predicate argument
  <span class="pre">
   scale-d
  </span>
  is
false.
 </p>
 <p>
  <span class="pre">
   wgmma.fence
  </span>
  instruction must be used to fence the register accesses of
  <span class="pre">
   wgmma.mma_async
  </span>
  instruction from their prior accesses. Otherwise, the behavior is undefined.
 </p>
 <p>
  <span class="pre">
   wgmma.commit_group
  </span>
  and
  <span class="pre">
   wgmma.wait_group
  </span>
  operations must be used to wait for the completion
of the asynchronous matrix multiply and accumulate operations before the results are accessed.
 </p>
 <p>
  Register operand
  <span class="pre">
   d
  </span>
  represents the accumulator matrix as well as the destination matrix,
distributed across the participating threads. Register operand
  <span class="pre">
   a
  </span>
  represents the multiplicand
matrix A in register distributed across the participating threads. The 64-bit register operands
  <span class="pre">
   a-desc
  </span>
  and
  <span class="pre">
   b-desc
  </span>
  are the matrix descriptors which represent the multiplicand matrices A and
B in shared memory respectively. The contents of a matrix descriptor must be same across all the
warps in the warpgroup. The format of the matrix descriptor is described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-shared-memory-layout-matrix-descriptor">
   Matrix Descriptor Format
  </a>
  . Matrix A is
structured sparse as described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-sparse-matrix-storage">
   Sparse matrix storage
  </a>
  .  Operands
  <span class="pre">
   sp-meta
  </span>
  and
  <span class="pre">
   sp-sel
  </span>
  represent sparsity metadata and sparsity selector respectively. Operand
  <span class="pre">
   sp-meta
  </span>
  is a 32-bit
integer and operand
  <span class="pre">
   sp-sel
  </span>
  is a 32-bit integer constant with values in the range 0..3.
 </p>
 <p>
  The valid values of
  <span class="pre">
   sp-meta
  </span>
  and
  <span class="pre">
   sp-sel
  </span>
  for each shape is specified in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-sparse-matrix-storage">
   Matrix
multiply-accumulate operation using wgmma.mma_async.sp instruction with sparse matrix A
  </a>
  and are summarized here :
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Matrix shape
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      .atype
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     Valid values of
     <span class="pre">
      sp-meta
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     Valid values of
     <span class="pre">
      sp-sel
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .m64nNk16
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .tf32
     </span>
    </p>
   </td>
   <td>
    <p>
     0b1110 , 0b0100
    </p>
   </td>
   <td>
    <p>
     0 (threads T0, T1) or 1 (threads T2, T3)
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      .m64nNk32
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .f16
     </span>
     /
     <span class="pre">
      .bf16
     </span>
    </p>
   </td>
   <td>
    <p>
     0b00, 0b01, 0b10, 0b11
    </p>
   </td>
   <td>
    <p>
     0 (threads T0, T1) or 1 (threads T2, T3)
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      .m64nNk64
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      .e4m3
     </span>
     /
     <span class="pre">
      .e5m2
     </span>
     /
     <span class="pre">
      .s8
     </span>
     /
     <span class="pre">
      .u8
     </span>
    </p>
   </td>
   <td>
    <p>
     0b00, 0b01, 0b10, 0b11
    </p>
   </td>
   <td>
    <p>
     0 (all threads contribute)
    </p>
   </td>
  </tr>
 </table>
 <p>
  Matrices A and B are stored in row-major and column-major format respectively. For certain floating
point variants, the input matrices A and B can be transposed by specifying the value 1 for the
immediate integer arguments
  <span class="pre">
   imm-trans-a
  </span>
  and
  <span class="pre">
   imm-trans-b
  </span>
  respectively. A value of 0 can be
used to avoid the transpose operation. The valid values of
  <span class="pre">
   imm-trans-a
  </span>
  and
  <span class="pre">
   imm-trans-b
  </span>
  are 0
and 1. The transpose operation is only supported for the
  <span class="pre">
   wgmma.mma_async
  </span>
  variants with
  <span class="pre">
   .f16
  </span>
  /
  <span class="pre">
   .bf16
  </span>
  types on matrices accessed from shared memory using matrix descriptors.
 </p>
 <p>
  For the floating point variants of the
  <span class="pre">
   wgmma.mma_async
  </span>
  operation, each element of the input
matrices A and B can be negated by specifying the value -1 for operands
  <span class="pre">
   imm-scale-a
  </span>
  and
  <span class="pre">
   imm-scale-b
  </span>
  respectively. A value of 1 can be used to avoid the negate operation. The valid
values of
  <span class="pre">
   imm-scale-a
  </span>
  and
  <span class="pre">
   imm-scale-b
  </span>
  are -1 and 1.
 </p>
 <p>
  The qualifiers
  <span class="pre">
   .dtype
  </span>
  ,
  <span class="pre">
   .atype
  </span>
  and
  <span class="pre">
   .btype
  </span>
  indicate the data type of the elements in
matrices D, A and B respectively.
  <span class="pre">
   .atype
  </span>
  and
  <span class="pre">
   .btype
  </span>
  must be the same for all floating point
  <span class="pre">
   wgmma.mma_async
  </span>
  variants except for the FP8 floating point variants. The sizes of individual
data elements of matrices A and B in alternate floating point variants of the
  <span class="pre">
   wgmma.mma_async
  </span>
  operation are as follows:
 </p>
 <ul class="simple">
  <li>
   <p>
    Matrices A and B have 8-bit data elements when
    <span class="pre">
     .atype
    </span>
    /
    <span class="pre">
     .btype
    </span>
    is
    <span class="pre">
     .e4m3
    </span>
    /
    <span class="pre">
     .e5m2
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Matrices A and B have 16-bit data elements when
    <span class="pre">
     .atype
    </span>
    /
    <span class="pre">
     .btype
    </span>
    is
    <span class="pre">
     .bf16
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Matrices A and B have 32-bit data elements when
    <span class="pre">
     .atype
    </span>
    /
    <span class="pre">
     .btype
    </span>
    is
    <span class="pre">
     .tf32
    </span>
    .
   </p>
  </li>
 </ul>
 <p>
  Precision and rounding:
 </p>
 <ul>
  <li>
   <p>
    Floating point operations:
   </p>
   <p>
    Element-wise multiplication of matrix A and B is performed with at least single precision. When
    <span class="pre">
     .dtype
    </span>
    is
    <span class="pre">
     .f32
    </span>
    , accumulation of the intermediate values is performed with at least single
precision. When
    <span class="pre">
     .dtype
    </span>
    is
    <span class="pre">
     .f16
    </span>
    , the accumulation is performed with at least half
precision.
   </p>
   <p>
    The accumulation order, rounding and handling of subnormal inputs are unspecified.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .bf16
    </span>
    and
    <span class="pre">
     .tf32
    </span>
    floating point operations:
   </p>
   <p>
    Element-wise multiplication of matrix A and B is performed with specified
precision.
    <span class="pre">
     wgmma.mma_async
    </span>
    operation involving type
    <span class="pre">
     .tf32
    </span>
    will truncate lower 13 bits of
the 32-bit input data before multiplication is issued. Accumulation of the intermediate values is
performed with at least single precision.
   </p>
   <p>
    The accumulation order, rounding, and handling of subnormal inputs are unspecified.
   </p>
  </li>
  <li>
   <p>
    Integer operations:
   </p>
   <p>
    The integer
    <span class="pre">
     wgmma.mma_async
    </span>
    operation is performed with
    <span class="pre">
     .s32
    </span>
    accumulators. The
    <span class="pre">
     .satfinite
    </span>
    qualifier indicates that on overflow, the accumulated value is limited to the
range
    MIN_INT32
    ..
    MAX_INT32
    (where the bounds are defined as the minimum negative signed
32-bit integer and the maximum positive signed 32-bit integer respectively).
   </p>
   <p>
    If
    <span class="pre">
     .satfinite
    </span>
    is not specified, the accumulated value is wrapped instead.
   </p>
  </li>
 </ul>
 <p>
  The mandatory
  <span class="pre">
   .sync
  </span>
  qualifier indicates that
  <span class="pre">
   wgmma.mma_async
  </span>
  instruction causes the
executing thread to wait until all threads in the warp execute the same
  <span class="pre">
   wgmma.mma_async
  </span>
  instruction before resuming execution.
 </p>
 <p>
  The mandatory
  <span class="pre">
   .aligned
  </span>
  qualifier indicates that all threads in the warpgroup must execute the
same
  <span class="pre">
   wgmma.mma_async
  </span>
  instruction. In conditionally executed code, a
  <span class="pre">
   wgmma.mma_async
  </span>
  instruction should only be used if it is known that all threads in the warpgroup evaluate the
condition identically, otherwise behavior is undefined.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 8.2.
 </p>
 <p>
  Support for
  <span class="pre">
   .u8.s8
  </span>
  and
  <span class="pre">
   .s8.u8
  </span>
  as .atype.btype introduced in PTX ISA version 8.4.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90a
  </span>
  .
 </p>
 <p>
  Examples of integer type
 </p>
 <pre>wgmma.fence.sync.aligned;
wgmma.mma_async.sp.sync.aligned.m64n8k64.s32.u8.u8  {s32d0, s32d1, s32d2, s32d3},
                                                    descA, descB, spMeta, 0, scaleD;
wgmma.mma_async.sp.sync.aligned.m64n8k64.s32.s8.u8  {s32d0, s32d1, s32d2, s32d3},
                                                    descA, descB, spMeta, 0, scaleD;
wgmma.commit_group.sync.aligned;
wgmma.wait_group.sync.aligned 0;
</pre>
 <h4>
  <span class="section-number">
   9.7.14.7.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-wgmma-proxy-operations">
   Asynchronous wgmma Proxy Operations
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-wgmma-proxy-operations" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  This section describes warpgroup level
  <span class="pre">
   wgmma.fence
  </span>
  ,
  <span class="pre">
   wgmma.commit_group
  </span>
  and
  <span class="pre">
   wgmma.wait_group
  </span>
  instructions.
 </p>
 <h5>
  <span class="section-number">
   9.7.14.7.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-instructions-wgmma-fence">
   Asynchronous Multiply-and-Accumulate Instruction: wgmma.fence
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-multiply-and-accumulate-instruction-wgmma-fence" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  wgmma.fence
 </p>
 <p>
  Enforce an ordering of register accesses between
  <span class="pre">
   wgmma.mma_async
  </span>
  and other operations.
 </p>
 <p>
  Syntax
 </p>
 <pre>wgmma.fence.sync.aligned;
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   wgmma.fence
  </span>
  instruction establishes an ordering between prior accesses to any warpgroup
registers and subsequent accesses to the same registers by a
  <span class="pre">
   wgmma.mma_async
  </span>
  instruction. Only
the accumulator register and the input registers containing the fragments of matrix A require this
ordering.
 </p>
 <p>
  The
  <span class="pre">
   wgmma.fence
  </span>
  instruction must be issued by all warps of the warpgroup at the following
locations:
 </p>
 <ul class="simple">
  <li>
   <p>
    Before the first
    <span class="pre">
     wgmma.mma_async
    </span>
    operation in a warpgroup.
   </p>
  </li>
  <li>
   <p>
    Between a register access by a thread in the warpgroup and any
    <span class="pre">
     wgmma.mma_async
    </span>
    instruction
that accesses the same registers, either as accumulator or input register containing fragments of
matrix A, except when these are accumulator register accesses across multiple
    <span class="pre">
     wgmma.mma_async
    </span>
    instructions of the same shape. In the latter case, an ordering guarantee is provided by default.
   </p>
  </li>
 </ul>
 <p>
  Otherwise, the behavior is undefined.
 </p>
 <p>
  An async proxy fence must be used to establish an ordering between prior writes to shared memory
matrices and subsequent reads of the same matrices in a
  <span class="pre">
   wgmma.mma_async
  </span>
  instruction.
 </p>
 <p>
  The mandatory
  <span class="pre">
   .sync
  </span>
  qualifier indicates that
  <span class="pre">
   wgmma.fence
  </span>
  instruction causes the executing
thread to wait until all threads in the warp execute the same
  <span class="pre">
   wgmma.fence
  </span>
  instruction before
resuming execution.
 </p>
 <p>
  The mandatory
  <span class="pre">
   .aligned
  </span>
  qualifier indicates that all threads in the warpgroup must execute the
same
  <span class="pre">
   wgmma.fence
  </span>
  instruction. In conditionally executed code, an
  <span class="pre">
   wgmma.fence
  </span>
  instruction
should only be used if it is known that all threads in the warpgroup evaluate the condition
identically, otherwise the behavior is undefined.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 8.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90a
  </span>
  .
 </p>
 <p>
  Examples
 </p>
 <pre>// Example 1, first use example:
wgmma.fence.sync.aligned;    // Establishes an ordering w.r.t. prior accesses to the registers s32d&lt;0-3&gt;
wgmma.mma_async.sync.aligned.m64n8k32.s32.u8.u8  {s32d0, s32d1, s32d2, s32d3},
                                                  descA, descB, scaleD;
wgmma.commit_group.sync.aligned;
wgmma.wait_group.sync.aligned 0;

// Example 2, use-case with the input value updated in between:
wgmma.fence.sync.aligned;
wgmma.mma_async.sync.aligned.m64n8k32.s32.u8.u8  {s32d0, s32d1, s32d2, s32d3},
                                                  descA, descB, scaleD;
...
mov.b32 s32d0, new_val;
wgmma.fence.sync.aligned;
wgmma.mma_async.sync.aligned.m64n8k32.s32.u8.u8  {s32d4, s32d5, s32d6, s32d7},
                                                 {s32d0, s32d1, s32d2, s32d3},
                                                  descB, scaleD;
wgmma.commit_group.sync.aligned;
wgmma.wait_group.sync.aligned 0;
</pre>
 <h5>
  <span class="section-number">
   9.7.14.7.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-instructions-wgmma-commit-group">
   Asynchronous Multiply-and-Accumulate Instruction: wgmma.commit_group
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-multiply-and-accumulate-instruction-wgmma-commit-group" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  wgmma.commit_group
 </p>
 <p>
  Commits all prior uncommitted
  <span class="pre">
   wgmma.mma_async
  </span>
  operations into a
  wgmma-group
  .
 </p>
 <p>
  Syntax
 </p>
 <pre>wgmma.commit_group.sync.aligned;
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   wgmma.commit_group
  </span>
  instruction creates a new wgmma-group per warpgroup and batches all prior
  <span class="pre">
   wgmma.mma_async
  </span>
  instructions initiated by the executing warp but not committed to any
wgmma-group into the new wgmma-group. If there are no uncommitted
  <span class="pre">
   wgmma.mma_async
  </span>
  instructions
then
  <span class="pre">
   wgmma.commit_group
  </span>
  results in an empty wgmma-group.
 </p>
 <p>
  An executing thread can wait for the completion of all
  <span class="pre">
   wgmma.mma_async
  </span>
  operations in a
wgmma-group by using
  <span class="pre">
   wgmma.wait_group
  </span>
  .
 </p>
 <p>
  The mandatory
  <span class="pre">
   .sync
  </span>
  qualifier indicates that
  <span class="pre">
   wgmma.commit_group
  </span>
  instruction causes the
executing thread to wait until all threads in the warp execute the same
  <span class="pre">
   wgmma.commit_group
  </span>
  instruction before resuming execution.
 </p>
 <p>
  The mandatory
  <span class="pre">
   .aligned
  </span>
  qualifier indicates that all threads in the warpgroup must execute the
same
  <span class="pre">
   wgmma.commit_group
  </span>
  instruction. In conditionally executed code, an
  <span class="pre">
   wgmma.commit_group
  </span>
  instruction should only be used if it is known that all threads in the warpgroup evaluate the
condition identically, otherwise the behavior is undefined.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 8.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90a
  </span>
  .
 </p>
 <p>
  Examples
 </p>
 <pre>wgmma.commit_group.sync.aligned;
</pre>
 <h5>
  <span class="section-number">
   9.7.14.7.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-instructions-wgmma-wait-group">
   Asynchronous Multiply-and-Accumulate Instruction: wgmma.wait_group
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-multiply-and-accumulate-instruction-wgmma-wait-group" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  wgmma.wait_group
 </p>
 <p>
  Signal the completion of a preceding warpgroup operation.
 </p>
 <p>
  Syntax
 </p>
 <pre>wgmma.wait_group.sync.aligned N;
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   wgmma.wait_group
  </span>
  instruction will cause the executing thread to wait until only N or fewer of
the most recent wgmma-groups are pending and all the prior wgmma-groups committed by the executing
threads are complete. For example, when N is 0, the executing thread waits on all the prior
wgmma-groups to complete. Operand N is an integer constant.
 </p>
 <p>
  Accessing the accumulator register or the input register containing the fragments of matrix A of a
  <span class="pre">
   wgmma.mma_async
  </span>
  instruction without first performing a
  <span class="pre">
   wgmma.wait_group
  </span>
  instruction that
waits on a
  wgmma-group
  including that
  <span class="pre">
   wgmma.mma_async
  </span>
  instruction is undefined behavior.
 </p>
 <p>
  The mandatory
  <span class="pre">
   .sync
  </span>
  qualifier indicates that
  <span class="pre">
   wgmma.wait_group
  </span>
  instruction causes the
executing thread to wait until all threads in the warp execute the same
  <span class="pre">
   wgmma.wait_group
  </span>
  instruction before resuming execution.
 </p>
 <p>
  The mandatory
  <span class="pre">
   .aligned
  </span>
  qualifier indicates that all threads in the warpgroup must execute the
same
  <span class="pre">
   wgmma.wait_group
  </span>
  instruction. In conditionally executed code, an
  <span class="pre">
   wgmma.wait_group
  </span>
  instruction should only be used if it is known that all threads in the warpgroup evaluate the
condition identically, otherwise the behavior is undefined.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 8.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90a
  </span>
  .
 </p>
 <p>
  Examples
 </p>
 <pre>wgmma.fence.sync.aligned;

wgmma.mma_async.sync.aligned.m64n8k32.s32.u8.u8  {s32d0, s32d1, s32d2, s32d3},
                                                  descA, descB, scaleD;
wgmma.commit_group.sync.aligned;

wgmma.mma_async.sync.aligned.m64n8k16.f32.f16.f16 {f32d0, f32d1, f32d2, f32d3},
                                                  {f16a0, f16a1, f16a2, f16a3},
                                                   descB, 1, -1, -1, 1;
wgmma.commit_group.sync.aligned;

wgmma.wait_group.sync.aligned 0;
</pre>
 <h3>
  <span class="section-number">
   9.7.15.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#stack-manipulation-instructions">
   Stack Manipulation Instructions
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#stack-manipulation-instructions" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The stack manipulation instructions can be used to dynamically allocate and deallocate memory on the
stack frame of the current function.
 </p>
 <p>
  The stack manipulation instrucitons are:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     stacksave
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     stackrestore
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     alloca
    </span>
   </p>
  </li>
 </ul>
 <h4>
  <span class="section-number">
   9.7.15.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#stack-manipulation-instructions-stacksave">
   Stack Manipulation Instructions: stacksave
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#stack-manipulation-instructions-stacksave" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  stacksave
 </p>
 <p>
  Save the value of stack pointer into a register.
 </p>
 <p>
  Syntax
 </p>
 <pre>stacksave.type  d;

.type = { .u32, .u64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Copies the current value of stack pointer into the destination register
  <span class="pre">
   d
  </span>
  . Pointer returned by
  <span class="pre">
   stacksave
  </span>
  can be used in a subsequent
  <span class="pre">
   stackrestore
  </span>
  instruction to restore the stack
pointer. If
  <span class="pre">
   d
  </span>
  is modified prior to use in
  <span class="pre">
   stackrestore
  </span>
  instruction, it may corrupt data in
the stack.
 </p>
 <p>
  Destination operand
  <span class="pre">
   d
  </span>
  has the same type as the instruction type.
 </p>
 <p>
  Semantics
 </p>
 <pre>d = stackptr;
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.3.
 </p>
 Preview Feature:
 <p>
  <span class="pre">
   stacksave
  </span>
  is a preview feature in PTX ISA version 7.3. All details are subject to change with
no guarantees of backward compatibility on future PTX ISA versions or SM architectures.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   stacksave
  </span>
  requires
  <span class="pre">
   sm_52
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>.reg .u32 rd;
stacksave.u32 rd;

.reg .u64 rd1;
stacksave.u64 rd1;
</pre>
 <h4>
  <span class="section-number">
   9.7.15.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#stack-manipulation-instructions-stackrestore">
   Stack Manipulation Instructions: stackrestore
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#stack-manipulation-instructions-stackrestore" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  stackrestore
 </p>
 <p>
  Update the stack pointer with a new value.
 </p>
 <p>
  Syntax
 </p>
 <pre>stackrestore.type  a;

.type = { .u32, .u64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Sets the current stack pointer to source register
  <span class="pre">
   a
  </span>
  .
 </p>
 <p>
  When
  <span class="pre">
   stackrestore
  </span>
  is used with operand
  <span class="pre">
   a
  </span>
  written by a prior
  <span class="pre">
   stacksave
  </span>
  instruction, it
will effectively restore the state of stack as it was before
  <span class="pre">
   stacksave
  </span>
  was executed. Note that
if
  <span class="pre">
   stackrestore
  </span>
  is used with an arbitrary value of
  <span class="pre">
   a
  </span>
  , it may cause corruption of stack
pointer. This implies that the correct use of this feature requires that
  <span class="pre">
   stackrestore.type
  </span>
  <span class="pre">
   a
  </span>
  is
used after
  <span class="pre">
   stacksave.type
  </span>
  <span class="pre">
   a
  </span>
  without redefining the value of
  <span class="pre">
   a
  </span>
  between them.
 </p>
 <p>
  Operand
  <span class="pre">
   a
  </span>
  has the same type as the instruction type.
 </p>
 <p>
  Semantics
 </p>
 <pre>stackptr = a;
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.3.
 </p>
 Preview Feature:
 <p>
  <span class="pre">
   stackrestore
  </span>
  is a preview feature in PTX ISA version 7.3. All details are subject to change
with no guarantees of backward compatibility on future PTX ISA versions or SM architectures.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   stackrestore
  </span>
  requires
  <span class="pre">
   sm_52
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>.reg .u32 ra;
stacksave.u32 ra;
// Code that may modify stack pointer
...
stackrestore.u32 ra;
</pre>
 <h4>
  <span class="section-number">
   9.7.15.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#stack-manipulation-instructions-alloca">
   Stack Manipulation Instructions: alloca
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#stack-manipulation-instructions-alloca" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  alloca
 </p>
 <p>
  Dynamically allocate memory on stack.
 </p>
 <p>
  Syntax
 </p>
 <pre>alloca.type  ptr, size{, immAlign};

.type = { .u32, .u64 };
</pre>
 <p>
  Description
 </p>
 <p>
  The
  <span class="pre">
   alloca
  </span>
  instruction dynamically allocates memory on the stack frame of the current function
and updates the stack pointer accordingly. The returned pointer
  <span class="pre">
   ptr
  </span>
  points to local memory and
can be used in the address operand of
  <span class="pre">
   ld.local
  </span>
  and
  <span class="pre">
   st.local
  </span>
  instructions.
 </p>
 <p>
  If sufficient memory is unavailable for allocation on the stack, then execution of
  <span class="pre">
   alloca
  </span>
  may
result in stack overflow. In such cases, attempting to access the allocated memory with
  <span class="pre">
   ptr
  </span>
  will
result in undefined program behavior.
 </p>
 <p>
  The memory allocated by
  <span class="pre">
   alloca
  </span>
  is deallocated in the following ways:
 </p>
 <ul class="simple">
  <li>
   <p>
    It is automatically deallocated when the function exits.
   </p>
  </li>
  <li>
   <p>
    It can be explicitly deallocated using
    <span class="pre">
     stacksave
    </span>
    and
    <span class="pre">
     stackrestore
    </span>
    instructions:
    <span class="pre">
     stacksave
    </span>
    can be used to save the value of stack pointer before executing
    <span class="pre">
     alloca
    </span>
    , and
    <span class="pre">
     stackrestore
    </span>
    can be used after
    <span class="pre">
     alloca
    </span>
    to restore stack pointer to the original value which
was previously saved with
    <span class="pre">
     stacksave
    </span>
    . Note that accessing deallocated memory after executing
    <span class="pre">
     stackrestore
    </span>
    results in undefined behavior.
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   size
  </span>
  is an unsigned value which specifies the amount of memory in number of bytes to be
allocated on stack.
  <span class="pre">
   size
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   0
  </span>
  may not lead to a valid memory allocation.
 </p>
 <p>
  Both
  <span class="pre">
   ptr
  </span>
  and
  <span class="pre">
   size
  </span>
  have the same type as the instruction type.
 </p>
 <p>
  <span class="pre">
   immAlign
  </span>
  is a 32-bit value which specifies the alignment requirement in number of bytes for the
memory allocated by
  <span class="pre">
   alloca
  </span>
  . It is an integer constant, must be a power of 2 and must not exceed
2^23.
  <span class="pre">
   immAlign
  </span>
  is an optional argument with default value being 8 which is the minimum
guaranteed alignment.
 </p>
 <p>
  Semantics
 </p>
 <pre>alloca.type ptr, size, immAlign:

a = max(immAlign, frame_align); // frame_align is the minimum guaranteed alignment

// Allocate size bytes of stack memory with alignment a and update the stack pointer.
// Since the stack grows down, the updated stack pointer contains a lower address.
stackptr = alloc_stack_mem(size, a);

// Return the new value of stack pointer as ptr. Since ptr is the lowest address of the memory
// allocated by alloca, the memory can be accessed using ptr up to (ptr + size of allocated memory).
stacksave ptr;
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.3.
 </p>
 Preview Feature:
 <p>
  <span class="pre">
   alloca
  </span>
  is a preview feature in PTX ISA version 7.3. All details are subject to change with no
guarantees of backward compatibility on future PTX ISA versions or SM architectures.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   alloca
  </span>
  requires
  <span class="pre">
   sm_52
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>.reg .u32 ra, stackptr, ptr, size;

stacksave.u32 stackptr;     // Save the current stack pointer
alloca ptr, size, 8;        // Allocate stack memory
st.local.u32 [ptr], ra;     // Use the allocated stack memory
stackrestore.u32 stackptr;  // Deallocate memory by restoring the stack pointer
</pre>
 <h3>
  <span class="section-number">
   9.7.16.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#video-instructions">
   Video Instructions
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#video-instructions" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  All video instructions operate on 32-bit register operands. However, the video instructions may be
classified as either scalar or SIMD based on whether their core operation applies to one or multiple
values.
 </p>
 <p>
  The video instructions are:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     vadd
    </span>
    ,
    <span class="pre">
     vadd2
    </span>
    ,
    <span class="pre">
     vadd4
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     vsub
    </span>
    ,
    <span class="pre">
     vsub2
    </span>
    ,
    <span class="pre">
     vsub4
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     vmad
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     vavrg2
    </span>
    ,
    <span class="pre">
     vavrg4
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     vabsdiff
    </span>
    ,
    <span class="pre">
     vabsdiff2
    </span>
    ,
    <span class="pre">
     vabsdiff4
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     vmin
    </span>
    ,
    <span class="pre">
     vmin2
    </span>
    ,
    <span class="pre">
     vmin4
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     vmax
    </span>
    ,
    <span class="pre">
     vmax2
    </span>
    ,
    <span class="pre">
     vmax4
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     vshl
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     vshr
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     vset
    </span>
    ,
    <span class="pre">
     vset2
    </span>
    ,
    <span class="pre">
     vset4
    </span>
   </p>
  </li>
 </ul>
 <h4>
  <span class="section-number">
   9.7.16.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#scalar-video-instructions">
   Scalar Video Instructions
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#scalar-video-instructions" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  All scalar video instructions operate on 32-bit register operands. The scalar video instructions
are:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     vadd
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     vsub
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     vabsdiff
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     vmin
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     vmax
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     vshl
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     vshr
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     vmad
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     vset
    </span>
   </p>
  </li>
 </ul>
 <p>
  The scalar video instructions execute the following stages:
 </p>
 <ol class="arabic simple">
  <li>
   <p>
    Extract and sign- or zero-extend byte, half-word, or word values from its source operands, to
produce signed 33-bit input values.
   </p>
  </li>
  <li>
   <p>
    Perform a scalar arithmetic operation to produce a signed 34-bit result.
   </p>
  </li>
  <li>
   <p>
    Optionally clamp the result to the range of the destination type.
   </p>
  </li>
  <li>
   <p>
    Optionally perform one of the following:
   </p>
   <ul class="simple">
    <li>
     <p>
      apply a second operation to the intermediate result and a third operand, or
     </p>
    </li>
    <li>
     <p>
      truncate the intermediate result to a byte or half-word value and merge into a specified
position in the third operand to produce the final result.
     </p>
    </li>
   </ul>
  </li>
 </ol>
 <p>
  The general format of scalar video instructions is as follows:
 </p>
 <pre>// 32-bit scalar operation, with optional secondary operation
vop.dtype.atype.btype{.sat}        d, a{.asel}, b{.bsel};
vop.dtype.atype.btype{.sat}.secop  d, a{.asel}, b{.bsel}, c;

// 32-bit scalar operation, with optional data merge
vop.dtype.atype.btype{.sat}   d.dsel, a{.asel}, b{.bsel}, c;


.dtype = .atype = .btype = { .u32, .s32 };
.dsel  = .asel  = .bsel  = { .b0, .b1, .b2, .b3, .h0, .h1 };
.secop = { .add, .min, .max };
</pre>
 <p>
  The source and destination operands are all 32-bit registers. The type of each operand (
  <span class="pre">
   .u32
  </span>
  or
  <span class="pre">
   .s32
  </span>
  ) is specified in the instruction type; all combinations of
  <span class="pre">
   dtype
  </span>
  ,
  <span class="pre">
   atype
  </span>
  , and
  <span class="pre">
   btype
  </span>
  are valid. Using the
  <span class="pre">
   atype/btype
  </span>
  and
  <span class="pre">
   asel/bsel
  </span>
  specifiers, the input values are
extracted and sign- or zero-extended internally to
  <span class="pre">
   .s33
  </span>
  values. The primary operation is then
performed to produce an
  <span class="pre">
   .s34
  </span>
  intermediate result. The sign of the intermediate result depends on
dtype.
 </p>
 <p>
  The intermediate result is optionally clamped to the range of the destination type (signed or
unsigned), taking into account the subword destination size in the case of optional data merging.
 </p>
 <pre>.s33 optSaturate( .s34 tmp, Bool sat, Bool sign, Modifier dsel ) {
    if ( !sat )  return tmp;

    switch ( dsel ) {
        case .b0, .b1, .b2, .b3:
            if ( sign )  return CLAMP( tmp, S8_MAX, S8_MIN );
            else         return CLAMP( tmp, U8_MAX, U8_MIN );
        case .h0, .h1:
            if ( sign )  return CLAMP( tmp, S16_MAX, S16_MIN );
            else         return CLAMP( tmp, U16_MAX, U16_MIN );
        default:
            if ( sign )  return CLAMP( tmp, S32_MAX, S32_MIN );
            else         return CLAMP( tmp, U32_MAX, U32_MIN );
    }
}
</pre>
 <p>
  This intermediate result is then optionally combined with the third source operand using a secondary
arithmetic operation or subword data merge, as shown in the following pseudocode. The sign of the
third operand is based on
  <span class="pre">
   dtype
  </span>
  .
 </p>
 <pre>.s33 optSecOp(Modifier secop, .s33 tmp, .s33 c) {
    switch ( secop ) {
        .add:     return tmp + c;
        .min:     return MIN(tmp, c);
        .max      return MAX(tmp, c);
        default:  return tmp;
    }
}
</pre>
 <pre>.s33 optMerge( Modifier dsel, .s33 tmp, .s33 c ) {
    switch ( dsel ) {
        case .h0:  return ((tmp &amp; 0xffff)        | (0xffff0000 &amp; c);
        case .h1:  return ((tmp &amp; 0xffff) &lt;&lt; 16) | (0x0000ffff &amp; c);
        case .b0:  return ((tmp &amp; 0xff)          | (0xffffff00 &amp; c);
        case .b1:  return ((tmp &amp; 0xff) &lt;&lt;  8)   | (0xffff00ff &amp; c);
        case .b2:  return ((tmp &amp; 0xff) &lt;&lt; 16)   | (0xff00ffff &amp; c);
        case .b3:  return ((tmp &amp; 0xff) &lt;&lt; 24)   | (0x00ffffff &amp; c);
        default:   return tmp;
    }
}
</pre>
 <p>
  The lower 32-bits are then written to the destination operand.
 </p>
 <h5>
  <span class="section-number">
   9.7.16.1.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#scalar-video-instructions-vadd-vsub-vabsdiff-vmin-vmax">
   Scalar Video Instructions: vadd, vsub, vabsdiff, vmin, vmax
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#scalar-video-instructions-vadd-vsub-vabsdiff-vmin-vmax" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  vadd, vsub
 </p>
 <p>
  Integer byte/half-word/word addition/subtraction.
 </p>
 <p>
  vabsdiff
 </p>
 <p>
  Integer byte/half-word/word absolute value of difference.
 </p>
 <p>
  vmin, vmax
 </p>
 <p>
  Integer byte/half-word/word minimum/maximum.
 </p>
 <p>
  Syntax
 </p>
 <pre>// 32-bit scalar operation, with optional secondary operation
vop.dtype.atype.btype{.sat}       d, a{.asel}, b{.bsel};
vop.dtype.atype.btype{.sat}.op2   d, a{.asel}, b{.bsel}, c;

// 32-bit scalar operation, with optional data merge
vop.dtype.atype.btype{.sat}  d.dsel, a{.asel}, b{.bsel}, c;

 vop   = { vadd, vsub, vabsdiff, vmin, vmax };
.dtype = .atype = .btype = { .u32, .s32 };
.dsel  = .asel  = .bsel  = { .b0, .b1, .b2, .b3, .h0, .h1 };
.op2   = { .add, .min, .max };
</pre>
 <p>
  Description
 </p>
 <p>
  Perform scalar arithmetic operation with optional saturate, and optional secondary arithmetic operation or subword data merge.
 </p>
 <p>
  Semantics
 </p>
 <pre>// extract byte/half-word/word and sign- or zero-extend
// based on source operand type
ta = partSelectSignExtend( a, atype, asel );
tb = partSelectSignExtend( b, btype, bsel );

switch ( vop ) {
    case vadd:     tmp = ta + tb;
    case vsub:     tmp = ta - tb;
    case vabsdiff: tmp = | ta - tb |;
    case vmin:     tmp = MIN( ta, tb );
    case vmax:     tmp = MAX( ta, tb );
}
// saturate, taking into account destination type and merge operations
tmp = optSaturate( tmp, sat, isSigned(dtype), dsel );
d = optSecondaryOp( op2, tmp, c );  // optional secondary operation
d = optMerge( dsel, tmp, c );       // optional merge with c operand
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   vadd
  </span>
  ,
  <span class="pre">
   vsub
  </span>
  ,
  <span class="pre">
   vabsdiff
  </span>
  ,
  <span class="pre">
   vmin
  </span>
  ,
  <span class="pre">
   vmax
  </span>
  require
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>vadd.s32.u32.s32.sat      r1, r2.b0, r3.h0;
vsub.s32.s32.u32.sat      r1, r2.h1, r3.h1;
vabsdiff.s32.s32.s32.sat  r1.h0, r2.b0, r3.b2, c;
vmin.s32.s32.s32.sat.add  r1, r2, r3, c;
</pre>
 <h5>
  <span class="section-number">
   9.7.16.1.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#scalar-video-instructions-vshl-vshr">
   Scalar Video Instructions: vshl, vshr
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#scalar-video-instructions-vshl-vshr" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  vshl, vshr
 </p>
 <p>
  Integer byte/half-word/word left/right shift.
 </p>
 <p>
  Syntax
 </p>
 <pre>// 32-bit scalar operation, with optional secondary operation
vop.dtype.atype.u32{.sat}.mode       d, a{.asel}, b{.bsel};
vop.dtype.atype.u32{.sat}.mode.op2   d, a{.asel}, b{.bsel}, c;

// 32-bit scalar operation, with optional data merge
vop.dtype.atype.u32{.sat}.mode  d.dsel, a{.asel}, b{.bsel}, c;

 vop   = { vshl, vshr };
.dtype = .atype = { .u32, .s32 };
.mode  = { .clamp, .wrap };
.dsel  = .asel  = .bsel  = { .b0, .b1, .b2, .b3, .h0, .h1 };
.op2   = { .add, .min, .max };
</pre>
 <p>
  Description
 </p>
 <span class="pre">
  vshl
 </span>
 <p>
  Shift
  <span class="pre">
   a
  </span>
  left by unsigned amount in
  <span class="pre">
   b
  </span>
  with optional saturate, and optional secondary
arithmetic operation or subword data merge. Left shift fills with zero.
 </p>
 <span class="pre">
  vshr
 </span>
 <p>
  Shift
  <span class="pre">
   a
  </span>
  right by unsigned amount in
  <span class="pre">
   b
  </span>
  with optional saturate, and optional secondary
arithmetic operation or subword data merge. Signed shift fills with the sign bit, unsigned shift
fills with zero.
 </p>
 <p>
  Semantics
 </p>
 <pre>// extract byte/half-word/word and sign- or zero-extend
// based on source operand type
ta = partSelectSignExtend( a,atype, asel );
tb = partSelectSignExtend( b, .u32, bsel );
if ( mode == .clamp  &amp;&amp; tb &gt; 32 )  tb = 32;
if ( mode == .wrap )                       tb = tb &amp; 0x1f;
switch ( vop ){
   case vshl:  tmp = ta &lt;&lt; tb;
   case vshr:  tmp = ta &gt;&gt; tb;
}
// saturate, taking into account destination type and merge operations
tmp = optSaturate( tmp, sat, isSigned(dtype), dsel );
d = optSecondaryOp( op2, tmp, c );  // optional secondary operation
d = optMerge( dsel, tmp, c );       // optional merge with c operand
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   vshl
  </span>
  ,
  <span class="pre">
   vshr
  </span>
  require
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>vshl.s32.u32.u32.clamp  r1, r2, r3;
vshr.u32.u32.u32.wrap   r1, r2, r3.h1;
</pre>
 <h5>
  <span class="section-number">
   9.7.16.1.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#scalar-video-instructions-vmad">
   Scalar Video Instructions: vmad
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#scalar-video-instructions-vmad" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  vmad
 </p>
 <p>
  Integer byte/half-word/word multiply-accumulate.
 </p>
 <p>
  Syntax
 </p>
 <pre>// 32-bit scalar operation
vmad.dtype.atype.btype{.sat}{.scale}     d, {-}a{.asel}, {-}b{.bsel},
                                         {-}c;
vmad.dtype.atype.btype.po{.sat}{.scale}  d, a{.asel}, b{.bsel}, c;

.dtype = .atype = .btype = { .u32, .s32 };
.asel  = .bsel  = { .b0, .b1, .b2, .b3, .h0, .h1 };
.scale = { .shr7, .shr15 };
</pre>
 <p>
  Description
 </p>
 <p>
  Calculate
  <span class="pre">
   (a*b)
  </span>
  <span class="pre">
   +
  </span>
  <span class="pre">
   c
  </span>
  , with optional operand negates,
  plus one
  mode, and scaling.
 </p>
 <p>
  The source operands support optional negation with some restrictions. Although PTX syntax allows
separate negation of the
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  operands, internally this is represented as negation of the
product
  <span class="pre">
   (a*b)
  </span>
  . That is,
  <span class="pre">
   (a*b)
  </span>
  is negated if and only if exactly one of
  <span class="pre">
   a
  </span>
  or
  <span class="pre">
   b
  </span>
  is
negated. PTX allows negation of either
  <span class="pre">
   (a*b)
  </span>
  or
  <span class="pre">
   c
  </span>
  .
 </p>
 <p>
  The plus one mode (
  <span class="pre">
   .po
  </span>
  ) computes
  <span class="pre">
   (a*b)
  </span>
  <span class="pre">
   +
  </span>
  <span class="pre">
   c
  </span>
  <span class="pre">
   +
  </span>
  <span class="pre">
   1
  </span>
  , which is used in computing averages. Source
operands may not be negated in
  <span class="pre">
   .po
  </span>
  mode.
 </p>
 <p>
  The intermediate result of
  <span class="pre">
   (a*b)
  </span>
  is unsigned if atype and btype are unsigned and the product
  <span class="pre">
   (a*b)
  </span>
  is not negated; otherwise, the intermediate result is signed. Input
  <span class="pre">
   c
  </span>
  has the same
sign as the intermediate result.
 </p>
 <p>
  The final result is unsigned if the intermediate result is unsigned and
  <span class="pre">
   c
  </span>
  is not negated.
 </p>
 <p>
  Depending on the sign of the
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  operands, and the operand negates, the following
combinations of operands are supported for VMAD:
 </p>
 <pre> (u32 * u32) + u32  // intermediate unsigned; final unsigned
-(u32 * u32) + s32  // intermediate   signed; final   signed
 (u32 * u32) - u32  // intermediate unsigned; final   signed
 (u32 * s32) + s32  // intermediate   signed; final   signed
-(u32 * s32) + s32  // intermediate   signed; final   signed
 (u32 * s32) - s32  // intermediate   signed; final   signed
 (s32 * u32) + s32  // intermediate   signed; final   signed
-(s32 * u32) + s32  // intermediate   signed; final   signed
 (s32 * u32) - s32  // intermediate   signed; final   signed
 (s32 * s32) + s32  // intermediate   signed; final   signed
-(s32 * s32) + s32  // intermediate   signed; final   signed
 (s32 * s32) - s32  // intermediate   signed; final   signed
</pre>
 <p>
  The intermediate result is optionally scaled via right-shift; this result is sign-extended if the
final result is signed, and zero-extended otherwise.
 </p>
 <p>
  The final result is optionally saturated to the appropriate 32-bit range based on the type (signed
or unsigned) of the final result.
 </p>
 <p>
  Semantics
 </p>
 <pre>// extract byte/half-word/word and sign- or zero-extend
// based on source operand type
ta = partSelectSignExtend( a, atype, asel );
tb = partSelectSignExtend( b, btype, bsel );
signedFinal = isSigned(atype) || isSigned(btype) ||
                                 (a.negate ^ b.negate) || c.negate;
tmp[127:0] = ta * tb;

lsb = 0;
if ( .po )                  {              lsb = 1; } else
if ( a.negate ^ b.negate )  { tmp = ~tmp;  lsb = 1; } else
if ( c.negate )             { c   = ~c;    lsb = 1; }

c128[127:0] = (signedFinal) sext32( c ) : zext ( c );
tmp = tmp + c128 + lsb;
switch( scale ) {
   case .shr7:   result = (tmp &gt;&gt;  7) &amp; 0xffffffffffffffff;
   case .shr15:  result = (tmp &gt;&gt; 15) &amp; 0xffffffffffffffff;
}
if ( .sat ) {
     if (signedFinal) result = CLAMP(result, S32_MAX, S32_MIN);
     else             result = CLAMP(result, U32_MAX, U32_MIN);
}
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   vmad
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>vmad.s32.s32.u32.sat    r0, r1, r2, -r3;
vmad.u32.u32.u32.shr15  r0, r1.h0, r2.h0, r3;
</pre>
 <h5>
  <span class="section-number">
   9.7.16.1.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#scalar-video-instructions-vset">
   Scalar Video Instructions: vset
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#scalar-video-instructions-vset" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  vset
 </p>
 <p>
  Integer byte/half-word/word comparison.
 </p>
 <p>
  Syntax
 </p>
 <pre>// 32-bit scalar operation, with optional secondary operation
vset.atype.btype.cmp       d, a{.asel}, b{.bsel};
vset.atype.btype.cmp.op2   d, a{.asel}, b{.bsel}, c;

// 32-bit scalar operation, with optional data merge
vset.atype.btype.cmp  d.dsel, a{.asel}, b{.bsel}, c;

.atype = .btype = { .u32, .s32 };
.cmp   = { .eq, .ne, .lt, .le, .gt, .ge };
.dsel  = .asel  = .bsel  = { .b0, .b1, .b2, .b3, .h0, .h1 };
.op2   = { .add, .min, .max };
</pre>
 <p>
  Description
 </p>
 <p>
  Compare input values using specified comparison, with optional secondary arithmetic operation or
subword data merge.
 </p>
 <p>
  The intermediate result of the comparison is always unsigned, and therefore destination
  <span class="pre">
   d
  </span>
  and
operand
  <span class="pre">
   c
  </span>
  are also unsigned.
 </p>
 <p>
  Semantics
 </p>
 <pre>// extract byte/half-word/word and sign- or zero-extend
// based on source operand type
ta = partSelectSignExtend( a, atype, asel );
tb = partSelectSignExtend( b, btype, bsel );
tmp = compare( ta, tb, cmp ) ? 1 : 0;
d = optSecondaryOp( op2, tmp, c );    // optional secondary operation
d = optMerge( dsel, tmp, c );         // optional merge with c operand
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   vset
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>vset.s32.u32.lt    r1, r2, r3;
vset.u32.u32.ne    r1, r2, r3.h1;
</pre>
 <h4>
  <span class="section-number">
   9.7.16.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#simd-video-instructions">
   SIMD Video Instructions
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#simd-video-instructions" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  The SIMD video instructions operate on pairs of 16-bit values and quads of 8-bit values.
 </p>
 <p>
  The SIMD video instructions are:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     vadd2
    </span>
    ,
    <span class="pre">
     vadd4
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     vsub2
    </span>
    ,
    <span class="pre">
     vsub4
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     vavrg2
    </span>
    ,
    <span class="pre">
     vavrg4
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     vabsdiff2
    </span>
    ,
    <span class="pre">
     vabsdiff4
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     vmin2
    </span>
    ,
    <span class="pre">
     vmin4
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     vmax2
    </span>
    ,
    <span class="pre">
     vmax4
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     vset2
    </span>
    ,
    <span class="pre">
     vset4
    </span>
   </p>
  </li>
 </ul>
 <p>
  PTX includes SIMD video instructions for operation on pairs of 16-bit values and quads of 8-bit
values. The SIMD video instructions execute the following stages:
 </p>
 <ol class="arabic simple">
  <li>
   <p>
    Form input vectors by extracting and sign- or zero-extending byte or half-word values from the
source operands, to form pairs of signed 17-bit values.
   </p>
  </li>
  <li>
   <p>
    Perform a SIMD arithmetic operation on the input pairs.
   </p>
  </li>
  <li>
   <p>
    Optionally clamp the result to the appropriate signed or unsigned range, as determinted by the
destination type.
   </p>
  </li>
  <li>
   <p>
    Optionally perform one of the following:
   </p>
   <ol class="loweralpha simple">
    <li>
     <p>
      perform a second SIMD merge operation, or
     </p>
    </li>
    <li>
     <p>
      apply a scalar accumulate operation to reduce the intermediate SIMD results to a single
scalar.
     </p>
    </li>
   </ol>
  </li>
 </ol>
 <p>
  The general format of dual half-word SIMD video instructions is as follows:
 </p>
 <pre>// 2-way SIMD operation, with second SIMD merge or accumulate
vop2.dtype.atype.btype{.sat}{.add}  d{.mask}, a{.asel}, b{.bsel}, c;

.dtype = .atype = .btype = { .u32, .s32 };
.mask  = { .h0, .h1, .h10 };
.asel  = .bsel = { .hxy, where x,y are from { 0, 1, 2, 3 } };
</pre>
 <p>
  The general format of quad byte SIMD video instructions is as follows:
 </p>
 <pre>// 4-way SIMD operation, with second SIMD merge or accumulate
vop4.dtype.atype.btype{.sat}{.add}  d{.mask}, a{.asel}, b{.bsel}, c;

.dtype = .atype = .btype = { .u32, .s32 };
.mask  = { .b0,
           .b1, .b10
           .b2, .b20, .b21, .b210,
           .b3, .b30, .b31, .b310, .b32, .b320, .b321, .b3210 };
.asel = .bsel = .bxyzw, where x,y,z,w are from { 0, ..., 7 };
</pre>
 <p>
  The source and destination operands are all 32-bit registers. The type of each operand (
  <span class="pre">
   .u32
  </span>
  or
  <span class="pre">
   .s32
  </span>
  ) is specified in the instruction type; all combinations of
  <span class="pre">
   dtype
  </span>
  ,
  <span class="pre">
   atype
  </span>
  , and
  <span class="pre">
   btype
  </span>
  are valid. Using the
  <span class="pre">
   atype/btype
  </span>
  and
  <span class="pre">
   asel/bsel
  </span>
  specifiers, the input values are
extracted and sign- or zero-extended internally to
  <span class="pre">
   .s33
  </span>
  values. The primary operation is then
performed to produce an
  <span class="pre">
   .s34
  </span>
  intermediate result. The sign of the intermediate result depends on
  <span class="pre">
   dtype
  </span>
  .
 </p>
 <p>
  The intermediate result is optionally clamped to the range of the destination type (signed or
unsigned), taking into account the subword destination size in the case of optional data merging.
 </p>
 <h5>
  <span class="section-number">
   9.7.16.2.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#simd-video-instructions-vadd2-vsub2-vavrg2-vabsdiff2-vmin2-vmax2">
   SIMD Video Instructions: vadd2, vsub2, vavrg2, vabsdiff2, vmin2, vmax2
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#simd-video-instructions-vadd2-vsub2-vavrg2-vabsdiff2-vmin2-vmax2" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  vadd2, vsub2
 </p>
 <p>
  Integer dual half-word SIMD addition/subtraction.
 </p>
 <p>
  vavrg2
 </p>
 <p>
  Integer dual half-word SIMD average.
 </p>
 <p>
  vabsdiff2
 </p>
 <p>
  Integer dual half-word SIMD absolute value of difference.
 </p>
 <p>
  vmin2, vmax2
 </p>
 <p>
  Integer dual half-word SIMD minimum/maximum.
 </p>
 <p>
  Syntax
 </p>
 <pre>// SIMD instruction with secondary SIMD merge operation
vop2.dtype.atype.btype{.sat}  d{.mask}, a{.asel}, b{.bsel}, c;

// SIMD instruction with secondary accumulate operation
vop2.dtype.atype.btype.add  d{.mask}, a{.asel}, b{.bsel}, c;

 vop2  = { vadd2, vsub2, vavrg2, vabsdiff2, vmin2, vmax2 };
.dtype = .atype = .btype = { .u32, .s32 };
.mask  = { .h0, .h1, .h10 };  // defaults to .h10
.asel  = .bsel  = { .hxy, where x,y are from { 0, 1, 2, 3 } };
   .asel defaults to .h10
   .bsel defaults to .h32
</pre>
 <p>
  Description
 </p>
 <p>
  Two-way SIMD parallel arithmetic operation with secondary operation.
 </p>
 <p>
  Elements of each dual half-word source to the operation are selected from any of the four half-words
in the two source operands
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  using the
  <span class="pre">
   asel
  </span>
  and
  <span class="pre">
   bsel
  </span>
  modifiers.
 </p>
 <p>
  The selected half-words are then operated on in parallel.
 </p>
 <p>
  The results are optionally clamped to the appropriate range determined by the destination type
(signed or unsigned). Saturation cannot be used with the secondary accumulate operation.
 </p>
 <p>
  For instructions with a secondary SIMD merge operation:
 </p>
 <ul class="simple">
  <li>
   <p>
    For half-word positions indicated in mask, the selected half-word results are copied into
destination
    <span class="pre">
     d
    </span>
    . For all other positions, the corresponding half-word from source operand
    <span class="pre">
     c
    </span>
    is copied to
    <span class="pre">
     d
    </span>
    .
   </p>
  </li>
 </ul>
 <p>
  For instructions with a secondary accumulate operation:
 </p>
 <ul class="simple">
  <li>
   <p>
    For half-word positions indicated in mask, the selected half-word results are added to operand
    <span class="pre">
     c
    </span>
    , producing a result in
    <span class="pre">
     d
    </span>
    .
   </p>
  </li>
 </ul>
 <p>
  Semantics
 </p>
 <pre>// extract pairs of half-words and sign- or zero-extend
// based on operand type
Va = extractAndSignExt_2( a, b, .asel, .atype );
Vb = extractAndSignExt_2( a, b, .bsel, .btype );
Vc = extractAndSignExt_2( c );

for (i=0; i&lt;2; i++) {
    switch ( vop2 ) {
       case vadd2:             t[i] = Va[i] + Vb[i];
       case vsub2:             t[i] = Va[i] - Vb[i];
       case vavrg2:            if ( ( Va[i] + Vb[i] ) &gt;= 0 ) {
                                   t[i] = ( Va[i] + Vb[i] + 1 ) &gt;&gt; 1;
                               } else {
                                   t[i] = ( Va[i] + Vb[i] ) &gt;&gt; 1;
                               }
       case vabsdiff2:         t[i] = | Va[i] - Vb[i] |;
       case vmin2:             t[i] = MIN( Va[i], Vb[i] );
       case vmax2:             t[i] = MAX( Va[i], Vb[i] );
    }
    if (.sat) {
        if ( .dtype == .s32 )  t[i] = CLAMP( t[i], S16_MAX, S16_MIN );
        else                   t[i] = CLAMP( t[i], U16_MAX, U16_MIN );
    }
}
// secondary accumulate or SIMD merge
mask = extractMaskBits( .mask );
if (.add) {
    d = c;
    for (i=0; i&lt;2; i++) {  d += mask[i] ? t[i] : 0;  }
} else {
    d = 0;
    for (i=0; i&lt;2; i++)  {  d |= mask[i] ? t[i] : Vc[i];  }
}
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 3.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   vadd2
  </span>
  ,
  <span class="pre">
   vsub2
  </span>
  ,
  <span class="pre">
   varvg2
  </span>
  ,
  <span class="pre">
   vabsdiff2
  </span>
  ,
  <span class="pre">
   vmin2
  </span>
  ,
  <span class="pre">
   vmax2
  </span>
  require
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>vadd2.s32.s32.u32.sat  r1, r2, r3, r1;
vsub2.s32.s32.s32.sat  r1.h0, r2.h10, r3.h32, r1;
vmin2.s32.u32.u32.add  r1.h10, r2.h00, r3.h22, r1;
</pre>
 <h5>
  <span class="section-number">
   9.7.16.2.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#simd-video-instructions-vset2">
   SIMD Video Instructions: vset2
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#simd-video-instructions-vset2" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  vset2
 </p>
 <p>
  Integer dual half-word SIMD comparison.
 </p>
 <p>
  Syntax
 </p>
 <pre>// SIMD instruction with secondary SIMD merge operation
vset2.atype.btype.cmp  d{.mask}, a{.asel}, b{.bsel}, c;

// SIMD instruction with secondary accumulate operation
vset2.atype.btype.cmp.add  d{.mask}, a{.asel}, b{.bsel}, c;

.atype = .btype = { .u32, .s32 };
.cmp   = { .eq, .ne, .lt, .le, .gt, .ge };
.mask  = { .h0, .h1, .h10 };  // defaults to .h10
.asel  = .bsel  = { .hxy, where x,y are from { 0, 1, 2, 3 } };
   .asel defaults to .h10
   .bsel defaults to .h32
</pre>
 <p>
  Description
 </p>
 <p>
  Two-way SIMD parallel comparison with secondary operation.
 </p>
 <p>
  Elements of each dual half-word source to the operation are selected from any of the four half-words
in the two source operands
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  using the
  <span class="pre">
   asel
  </span>
  and
  <span class="pre">
   bsel
  </span>
  modifiers.
 </p>
 <p>
  The selected half-words are then compared in parallel.
 </p>
 <p>
  The intermediate result of the comparison is always unsigned, and therefore the half-words of
destination
  <span class="pre">
   d
  </span>
  and operand
  <span class="pre">
   c
  </span>
  are also unsigned.
 </p>
 <p>
  For instructions with a secondary SIMD merge operation:
 </p>
 <ul class="simple">
  <li>
   <p>
    For half-word positions indicated in mask, the selected half-word results are copied into
destination
    <span class="pre">
     d
    </span>
    . For all other positions, the corresponding half-word from source operand
    <span class="pre">
     b
    </span>
    is copied to
    <span class="pre">
     d
    </span>
    .
   </p>
  </li>
 </ul>
 <p>
  For instructions with a secondary accumulate operation:
 </p>
 <ul class="simple">
  <li>
   <p>
    For half-word positions indicated in mask, the selected half-word results are added to operand
    <span class="pre">
     c
    </span>
    , producing
    <span class="pre">
     a
    </span>
    result in
    <span class="pre">
     d
    </span>
    .
   </p>
  </li>
 </ul>
 <p>
  Semantics
 </p>
 <pre>// extract pairs of half-words and sign- or zero-extend
// based on operand type
Va = extractAndSignExt_2( a, b, .asel, .atype );
Vb = extractAndSignExt_2( a, b, .bsel, .btype );
Vc = extractAndSignExt_2( c );
for (i=0; i&lt;2; i++) {
    t[i] = compare( Va[i], Vb[i], .cmp ) ? 1 : 0;
}
// secondary accumulate or SIMD merge
mask = extractMaskBits( .mask );
if (.add) {
    d = c;
    for (i=0; i&lt;2; i++) {  d += mask[i] ? t[i] : 0;  }
} else {
    d = 0;
    for (i=0; i&lt;2; i++)  {  d |= mask[i] ? t[i] : Vc[i];  }
}
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 3.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   vset2
  </span>
  requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>vset2.s32.u32.lt      r1, r2, r3, r0;
vset2.u32.u32.ne.add  r1, r2, r3, r0;
</pre>
 <h5>
  <span class="section-number">
   9.7.16.2.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#simd-video-instructions-vadd4-vsub4-vavrg4-vabsdiff4-vmin4-vmax4">
   SIMD Video Instructions: vadd4, vsub4, vavrg4, vabsdiff4, vmin4, vmax4
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#simd-video-instructions-vadd4-vsub4-vavrg4-vabsdiff4-vmin4-vmax4" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  vadd4, vsub4
 </p>
 <p>
  Integer quad byte SIMD addition/subtraction.
 </p>
 <p>
  vavrg4
 </p>
 <p>
  Integer quad byte SIMD average.
 </p>
 <p>
  vabsdiff4
 </p>
 <p>
  Integer quad byte SIMD absolute value of difference.
 </p>
 <p>
  vmin4, vmax4
 </p>
 <p>
  Integer quad byte SIMD minimum/maximum.
 </p>
 <p>
  Syntax
 </p>
 <pre>// SIMD instruction with secondary SIMD merge operation
vop4.dtype.atype.btype{.sat}  d{.mask}, a{.asel}, b{.bsel}, c;

// SIMD instruction with secondary accumulate operation
vop4.dtype.atype.btype.add  d{.mask}, a{.asel}, b{.bsel}, c;
vop4  = { vadd4, vsub4, vavrg4, vabsdiff4, vmin4, vmax4 };

.dtype = .atype = .btype = { .u32, .s32 };
.mask  = { .b0,
           .b1, .b10
           .b2, .b20, .b21, .b210,
           .b3, .b30, .b31, .b310, .b32, .b320, .b321, .b3210 };
    defaults to .b3210
.asel = .bsel = .bxyzw, where x,y,z,w are from { 0, ..., 7 };
   .asel defaults to .b3210
   .bsel defaults to .b7654
</pre>
 <p>
  Description
 </p>
 <p>
  Four-way SIMD parallel arithmetic operation with secondary operation.
 </p>
 <p>
  Elements of each quad byte source to the operation are selected from any of the eight bytes in the
two source operands
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  using the
  <span class="pre">
   asel
  </span>
  and
  <span class="pre">
   bsel
  </span>
  modifiers.
 </p>
 <p>
  The selected bytes are then operated on in parallel.
 </p>
 <p>
  The results are optionally clamped to the appropriate range determined by the destination type
(signed or unsigned). Saturation cannot be used with the secondary accumulate operation.
 </p>
 <p>
  For instructions with a secondary SIMD merge operation:
 </p>
 <ul class="simple">
  <li>
   <p>
    For byte positions indicated in mask, the selected byte results are copied into destination
    <span class="pre">
     d
    </span>
    . For all other positions, the corresponding byte from source operand
    <span class="pre">
     c
    </span>
    is copied to
    <span class="pre">
     d
    </span>
    .
   </p>
  </li>
 </ul>
 <p>
  For instructions with a secondary accumulate operation:
 </p>
 <ul class="simple">
  <li>
   <p>
    For byte positions indicated in mask, the selected byte results are added to operand
    <span class="pre">
     c
    </span>
    ,
producing a result in
    <span class="pre">
     d
    </span>
    .
   </p>
  </li>
 </ul>
 <p>
  Semantics
 </p>
 <pre>// extract quads of bytes and sign- or zero-extend
// based on operand type
Va = extractAndSignExt_4( a, b, .asel, .atype );
Vb = extractAndSignExt_4( a, b, .bsel, .btype );
Vc = extractAndSignExt_4( c );
for (i=0; i&lt;4; i++) {
    switch ( vop4 ) {
        case vadd4:            t[i] = Va[i] + Vb[i];
        case vsub4:            t[i] = Va[i] - Vb[i];
        case vavrg4:           if ( ( Va[i] + Vb[i] ) &gt;= 0 ) {
                                   t[i] = ( Va[i] + Vb[i] + 1 ) &gt;&gt; 1;
                               } else {
                                   t[i] = ( Va[i] + Vb[i] ) &gt;&gt; 1;
                               }
        case vabsdiff4:        t[i] = | Va[i] - Vb[i] |;
        case vmin4:            t[i] = MIN( Va[i], Vb[i] );
        case vmax4:            t[i] = MAX( Va[i], Vb[i] );
    }
    if (.sat) {
        if ( .dtype == .s32 )  t[i] = CLAMP( t[i], S8_MAX, S8_MIN );
        else                   t[i] = CLAMP( t[i], U8_MAX, U8_MIN );
    }
}
// secondary accumulate or SIMD merge
mask = extractMaskBits( .mask );
if (.add) {
    d = c;
    for (i=0; i&lt;4; i++) {  d += mask[i] ? t[i] : 0;  }
} else {
    d = 0;
    for (i=0; i&lt;4; i++)  {  d |= mask[i] ? t[i] : Vc[i];  }
}
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 3.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   vadd4
  </span>
  ,
  <span class="pre">
   vsub4
  </span>
  ,
  <span class="pre">
   varvg4
  </span>
  ,
  <span class="pre">
   vabsdiff4
  </span>
  ,
  <span class="pre">
   vmin4
  </span>
  ,
  <span class="pre">
   vmax4
  </span>
  require
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>vadd4.s32.s32.u32.sat  r1, r2, r3, r1;
vsub4.s32.s32.s32.sat  r1.b0, r2.b3210, r3.b7654, r1;
vmin4.s32.u32.u32.add  r1.b00, r2.b0000, r3.b2222, r1;
</pre>
 <h5>
  <span class="section-number">
   9.7.16.2.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#simd-video-instructions-vset4">
   SIMD Video Instructions: vset4
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#simd-video-instructions-vset4" title="Permalink to this headline">
   ï
  </a>
 </h5>
 <p>
  vset4
 </p>
 <p>
  Integer quad byte SIMD comparison.
 </p>
 <p>
  Syntax
 </p>
 <pre>// SIMD instruction with secondary SIMD merge operation
vset4.atype.btype.cmp  d{.mask}, a{.asel}, b{.bsel}, c;

// SIMD instruction with secondary accumulate operation
vset4.atype.btype.cmp.add  d{.mask}, a{.asel}, b{.bsel}, c;

.atype = .btype = { .u32, .s32 };
.cmp   = { .eq, .ne, .lt, .le, .gt, .ge };
.mask  = { .b0,
           .b1, .b10
           .b2, .b20, .b21, .b210,
           .b3, .b30, .b31, .b310, .b32, .b320, .b321, .b3210 };
    defaults to .b3210
.asel = .bsel = .bxyzw, where x,y,z,w are from { 0, ..., 7 };
   .asel defaults to .b3210
   .bsel defaults to .b7654
</pre>
 <p>
  Description
 </p>
 <p>
  Four-way SIMD parallel comparison with secondary operation.
 </p>
 <p>
  Elements of each quad byte source to the operation are selected from any of the eight bytes in the
two source operands
  <span class="pre">
   a
  </span>
  and
  <span class="pre">
   b
  </span>
  using the
  <span class="pre">
   asel
  </span>
  and
  <span class="pre">
   bsel
  </span>
  modifiers.
 </p>
 <p>
  The selected bytes are then compared in parallel.
 </p>
 <p>
  The intermediate result of the comparison is always unsigned, and therefore the bytes of destination
  <span class="pre">
   d
  </span>
  and operand
  <span class="pre">
   c
  </span>
  are also unsigned.
 </p>
 <p>
  For instructions with a secondary SIMD merge operation:
 </p>
 <ul class="simple">
  <li>
   <p>
    For byte positions indicated in mask, the selected byte results are copied into destination
    <span class="pre">
     d
    </span>
    . For all other positions, the corresponding byte from source operand
    <span class="pre">
     b
    </span>
    is copied to
    <span class="pre">
     d
    </span>
    .
   </p>
  </li>
 </ul>
 <p>
  For instructions with a secondary accumulate operation:
 </p>
 <ul class="simple">
  <li>
   <p>
    For byte positions indicated in mask, the selected byte results are added to operand
    <span class="pre">
     c
    </span>
    ,
producing a result in
    <span class="pre">
     d
    </span>
    .
   </p>
  </li>
 </ul>
 <p>
  Semantics
 </p>
 <pre>// extract quads of bytes and sign- or zero-extend
// based on operand type
Va = extractAndSignExt_4( a, b, .asel, .atype );
Vb = extractAndSignExt_4( a, b, .bsel, .btype );
Vc = extractAndSignExt_4( c );
for (i=0; i&lt;4; i++) {
    t[i] = compare( Va[i], Vb[i], cmp ) ? 1 : 0;
}
// secondary accumulate or SIMD merge
mask = extractMaskBits( .mask );
if (.add) {
    d = c;
    for (i=0; i&lt;4; i++) {  d += mask[i] ? t[i] : 0;  }
} else {
    d = 0;
    for (i=0; i&lt;4; i++)  {  d |= mask[i] ? t[i] : Vc[i];  }
}
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 3.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   vset4
  </span>
  requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>vset4.s32.u32.lt      r1, r2, r3, r0;
vset4.u32.u32.ne.max  r1, r2, r3, r0;
</pre>
 <h3>
  <span class="section-number">
   9.7.17.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#miscellaneous-instructions">
   Miscellaneous Instructions
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#miscellaneous-instructions" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  The Miscellaneous instructions are:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     brkpt
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     nanosleep
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     pmevent
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     trap
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     setmaxnreg
    </span>
   </p>
  </li>
 </ul>
 <h4>
  <span class="section-number">
   9.7.17.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#miscellaneous-instructions-brkpt">
   Miscellaneous Instructions: brkpt
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#miscellaneous-instructions-brkpt" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  brkpt
 </p>
 <p>
  Breakpoint.
 </p>
 <p>
  Syntax
 </p>
 <pre>brkpt;
</pre>
 <p>
  Description
 </p>
 <p>
  Suspends execution.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   brkpt
  </span>
  requires
  <span class="pre">
   sm_11
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>    brkpt;
@p  brkpt;
</pre>
 <h4>
  <span class="section-number">
   9.7.17.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#miscellaneous-instructions-nanosleep">
   Miscellaneous Instructions: nanosleep
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#miscellaneous-instructions-nanosleep" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  nanosleep
 </p>
 <p>
  Suspend the thread for an approximate delay given in nanoseconds.
 </p>
 <p>
  Syntax
 </p>
 <pre>nanosleep.u32 t;
</pre>
 <p>
  Description
 </p>
 <p>
  Suspends the thread for a sleep duration approximately close to the delay
  <span class="pre">
   t
  </span>
  , specified in
nanoseconds.
  <span class="pre">
   t
  </span>
  may be a register or an immediate value.
 </p>
 <p>
  The sleep duration is approximated, but guaranteed to be in the interval
  <span class="pre">
   [0,
  </span>
  <span class="pre">
   2*t]
  </span>
  . The maximum
sleep duration is 1 millisecond. The implementation may reduce the sleep duration for individual
threads within a warp such that all sleeping threads in the warp wake up together.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  <span class="pre">
   nanosleep
  </span>
  introduced in PTX ISA 6.3.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   nanosleep
  </span>
  requires
  <span class="pre">
   sm_70
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>.reg .b32 r;
.reg .pred p;

nanosleep.u32 r;
nanosleep.u32 42;
@p nanosleep.u32 r;
</pre>
 <h4>
  <span class="section-number">
   9.7.17.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#miscellaneous-instructions-pmevent">
   Miscellaneous Instructions: pmevent
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#miscellaneous-instructions-pmevent" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  pmevent
 </p>
 <p>
  Trigger one or more Performance Monitor events.
 </p>
 <p>
  Syntax
 </p>
 <pre>pmevent       a;    // trigger a single performance monitor event
pmevent.mask  a;    // trigger one or more performance monitor events
</pre>
 <p>
  Description
 </p>
 <p>
  Triggers one or more of a fixed number of performance monitor events, with event index or mask
specified by immediate operand
  <span class="pre">
   a
  </span>
  .
 </p>
 <p>
  <span class="pre">
   pmevent
  </span>
  (without modifier
  <span class="pre">
   .mask
  </span>
  ) triggers a single performance monitor event indexed by
immediate operand
  <span class="pre">
   a
  </span>
  , in the range
  <span class="pre">
   0..15
  </span>
  .
 </p>
 <p>
  <span class="pre">
   pmevent.mask
  </span>
  triggers one or more of the performance monitor events. Each bit in the 16-bit
immediate operand
  <span class="pre">
   a
  </span>
  controls an event.
 </p>
 <p>
  Programmatic performance moniter events may be combined with other hardware events using Boolean
functions to increment one of the four performance counters. The relationship between events and
counters is programmed via API calls from the host.
 </p>
 <p>
  Notes
 </p>
 <p>
  Currently, there are sixteen performance monitor events, numbered 0 through 15.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  <span class="pre">
   pmevent
  </span>
  introduced in PTX ISA version 1.4.
 </p>
 <p>
  <span class="pre">
   pmevent.mask
  </span>
  introduced in PTX ISA version 3.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  pmevent supported on all target architectures.
 </p>
 <p>
  <span class="pre">
   pmevent.mask
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>    pmevent      1;
@p  pmevent      7;
@q  pmevent.mask 0xff;
</pre>
 <h4>
  <span class="section-number">
   9.7.17.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#miscellaneous-instructions-trap">
   Miscellaneous Instructions: trap
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#miscellaneous-instructions-trap" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  trap
 </p>
 <p>
  Perform trap operation.
 </p>
 <p>
  Syntax
 </p>
 <pre>trap;
</pre>
 <p>
  Description
 </p>
 <p>
  Abort execution and generate an interrupt to the host CPU.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>    trap;
@p  trap;
</pre>
 <h4>
  <span class="section-number">
   9.7.17.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#miscellaneous-instructions-setmaxnreg">
   Miscellaneous Instructions: setmaxnreg
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#miscellaneous-instructions-setmaxnreg" title="Permalink to this headline">
   ï
  </a>
 </h4>
 <p>
  setmaxnreg
 </p>
 <p>
  Hint to change the number of registers owned by the warp.
 </p>
 <p>
  Syntax
 </p>
 <pre>setmaxnreg.action.sync.aligned.u32 imm-reg-count;

.action = { .inc, .dec };
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   setmaxnreg
  </span>
  provides a hint to the system to update the maximum number of per-thread registers
owned by the executing warp to the value specified by the
  <span class="pre">
   imm-reg-count
  </span>
  operand.
 </p>
 <p>
  Qualifier
  <span class="pre">
   .dec
  </span>
  is used to release extra registers such that the absolute per-thread maximum
register count is reduced from its current value to
  <span class="pre">
   imm-reg-count
  </span>
  . Qualifier
  <span class="pre">
   .inc
  </span>
  is used to
request additional registers such that the absolute per-thread maximum register count is increased
from its current value to
  <span class="pre">
   imm-reg-count
  </span>
  .
 </p>
 <p>
  A pool of available registers is maintained per-CTA. Register adjustments requested by the
  <span class="pre">
   setmaxnreg
  </span>
  instructions are handled by supplying extra registers from this pool to the
requesting warp or by releasing extra registers from the requesting warp to this pool, depending
upon the value of the
  <span class="pre">
   .action
  </span>
  qualifier.
 </p>
 <p>
  The
  <span class="pre">
   setmaxnreg.inc
  </span>
  instruction blocks the execution until enough registers are available in the
CTAâs register pool. After the instruction
  <span class="pre">
   setmaxnreg.inc
  </span>
  obtains new registers from the CTA
pool, the initial contents of the new registers are undefined. The new registers must be initialized
before they are used.
 </p>
 <p>
  The same
  <span class="pre">
   setmaxnreg
  </span>
  instruction must be executed by all warps in a
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-instructions-warpgroup">
   warpgroup
  </a>
  . After executing a
  <span class="pre">
   setmaxnreg
  </span>
  instruction, all warps in the
  warpgroup
  must synchronize explicitly before
executing subsequent setmaxnreg instructions. If a
  <span class="pre">
   setmaxnreg
  </span>
  instruction is not executed by all
warps in the
  warpgroup
  , then the behavior is undefined.
 </p>
 <p>
  Operand
  <span class="pre">
   imm-reg-count
  </span>
  is an integer constant. The value of
  <span class="pre">
   imm-reg-count
  </span>
  must be in the
range 24 to 256 (both inclusive) and must be a multiple of 8.
 </p>
 <p>
  Changes to the register file of the warp always happen at the tail-end of the register file.
 </p>
 <p>
  The
  <span class="pre">
   setmaxnreg
  </span>
  instruction requires that the kernel has been launched with a valid value of
maximum number of per-thread registers specified via the appropriate compilation via the appropriate
compile-time option or the appropriate performance tuning directive. Otherwise, the
  <span class="pre">
   setmaxnreg
  </span>
  instruction may have no effect.
 </p>
 <p>
  When qualifier
  <span class="pre">
   .dec
  </span>
  is specified, the maximum number of per-thread registers owned by the warp
prior to the execution of
  <span class="pre">
   setmaxnreg
  </span>
  instruction should be greater than or equal to the
  <span class="pre">
   imm-reg-count
  </span>
  . Otherwise, the behaviour is undefined.
 </p>
 <p>
  When qualifier
  <span class="pre">
   .inc
  </span>
  is specified, the maximum number of per-thread registers owned by the warp
prior to the execution of
  <span class="pre">
   setmaxnreg
  </span>
  instruction should be less than or equal to the
  <span class="pre">
   imm-reg-count
  </span>
  . Otherwise, the behaviour is undefined.
 </p>
 <p>
  The mandatory
  <span class="pre">
   .sync
  </span>
  qualifier indicates that
  <span class="pre">
   setmaxnreg
  </span>
  instruction causes the executing
thread to wait until all threads in the warp execute the same
  <span class="pre">
   setmaxnreg
  </span>
  instruction before
resuming execution.
 </p>
 <p>
  The mandatory
  <span class="pre">
   .aligned
  </span>
  qualifier indicates that all threads in the warpgroup must execute the
same
  <span class="pre">
   setmaxnreg
  </span>
  instruction. In conditionally executed code,
  <span class="pre">
   setmaxnreg
  </span>
  instruction should
only be used if it is known that all threads in warpgroup evaluate the condition identically,
otherwise the behavior is undefined.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 8.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90a
  </span>
  .
 </p>
 <p>
  Examples
 </p>
 <pre>setmaxnreg.dec.sync.aligned.u32 64;
setmaxnreg.inc.sync.aligned.u32 192;
</pre>
 <h1>
  <span class="section-number">
   10.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers">
   Special Registers
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <p>
  PTX includes a number of predefined, read-only variables, which are
visible as special registers and accessed through
  <span class="pre">
   mov
  </span>
  or
  <span class="pre">
   cvt
  </span>
  instructions.
 </p>
 <p>
  The special registers are:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     %tid
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     %ntid
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     %laneid
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     %warpid
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     %nwarpid
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     %ctaid
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     %nctaid
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     %smid
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     %nsmid
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     %gridid
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     %is_explicit_cluster
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     %clusterid
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     %nclusterid
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     %cluster_ctaid
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     %cluster_nctaid
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     %cluster_ctarank
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     %cluster_nctarank
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     %lanemask_eq
    </span>
    ,
    <span class="pre">
     %lanemask_le
    </span>
    ,
    <span class="pre">
     %lanemask_lt
    </span>
    ,
    <span class="pre">
     %lanemask_ge
    </span>
    ,
    <span class="pre">
     %lanemask_gt
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     %clock
    </span>
    ,
    <span class="pre">
     %clock_hi
    </span>
    ,
    <span class="pre">
     %clock64
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     %pm0,
    </span>
    <span class="pre">
     ...,
    </span>
    <span class="pre">
     %pm7
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     %pm0_64,
    </span>
    <span class="pre">
     ...,
    </span>
    <span class="pre">
     %pm7_64
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     %envreg0,
    </span>
    <span class="pre">
     ...,
    </span>
    <span class="pre">
     %envreg31
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     %globaltimer
    </span>
    ,
    <span class="pre">
     %globaltimer_lo
    </span>
    ,
    <span class="pre">
     %globaltimer_hi
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     %reserved_smem_offset_begin
    </span>
    ,
    <span class="pre">
     %reserved_smem_offset_end
    </span>
    ,
    <span class="pre">
     %reserved_smem_offset_cap
    </span>
    ,
    <span class="pre">
     %reserved_smem_offset&lt;2&gt;
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     %total_smem_size
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     %aggr_smem_size
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     %dynamic_smem_size
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     %current_graph_exec
    </span>
   </p>
  </li>
 </ul>
 <h2>
  <span class="section-number">
   10.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-tid">
   Special Registers: %tid
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-tid" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %tid
 </p>
 <p>
  Thread identifier within a CTA.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .v4 .u32 %tid;                  // thread id vector
.sreg .u32 %tid.x, %tid.y, %tid.z;    // thread id components
</pre>
 <p>
  Description
 </p>
 <p>
  A predefined, read-only, per-thread special register initialized with the thread identifier within
the CTA. The
  <span class="pre">
   %tid
  </span>
  special register contains a 1D, 2D, or 3D vector to match the CTA shape; the
  <span class="pre">
   %tid
  </span>
  value in unused dimensions is
  <span class="pre">
   0
  </span>
  . The fourth element is unused and always returns
zero. The number of threads in each dimension are specified by the predefined special register
  <span class="pre">
   %ntid
  </span>
  .
 </p>
 <p>
  Every thread in the CTA has a unique
  <span class="pre">
   %tid
  </span>
  .
 </p>
 <p>
  <span class="pre">
   %tid
  </span>
  component values range from
  <span class="pre">
   0
  </span>
  through
  <span class="pre">
   %ntid-1
  </span>
  in each CTA dimension.
 </p>
 <p>
  <span class="pre">
   %tid.y
  </span>
  <span class="pre">
   ==
  </span>
  <span class="pre">
   %tid.z
  </span>
  <span class="pre">
   ==
  </span>
  <span class="pre">
   0
  </span>
  in 1D CTAs.
  <span class="pre">
   %tid.z
  </span>
  <span class="pre">
   ==
  </span>
  <span class="pre">
   0
  </span>
  in 2D CTAs.
 </p>
 <p>
  It is guaranteed that:
 </p>
 <pre>0  &lt;=  %tid.x &lt;  %ntid.x
0  &lt;=  %tid.y &lt;  %ntid.y
0  &lt;=  %tid.z &lt;  %ntid.z
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0 with type
  <span class="pre">
   .v4.u16
  </span>
  .
 </p>
 <p>
  Redefined as type
  <span class="pre">
   .v4.u32
  </span>
  in PTX ISA version 2.0. For compatibility with legacy PTX code, 16-bit
  <span class="pre">
   mov
  </span>
  and
  <span class="pre">
   cvt
  </span>
  instructions may be used to read the lower 16-bits of each component of
  <span class="pre">
   %tid
  </span>
  .
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>mov.u32      %r1,%tid.x;  // move tid.x to %rh

// legacy code accessing 16-bit components of %tid
mov.u16      %rh,%tid.x;
cvt.u32.u16  %r2,%tid.z;  // zero-extend tid.z to %r2
</pre>
 <h2>
  <span class="section-number">
   10.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-ntid">
   Special Registers: %ntid
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-ntid" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %ntid
 </p>
 <p>
  Number of thread IDs per CTA.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .v4 .u32 %ntid;                   // CTA shape vector
.sreg .u32 %ntid.x, %ntid.y, %ntid.z;   // CTA dimensions
</pre>
 <p>
  Description
 </p>
 <p>
  A predefined, read-only special register initialized with the number of thread ids in each CTA
dimension. The
  <span class="pre">
   %ntid
  </span>
  special register contains a 3D CTA shape vector that holds the CTA
dimensions. CTA dimensions are non-zero; the fourth element is unused and always returns zero. The
total number of threads in a CTA is
  <span class="pre">
   (%ntid.x
  </span>
  <span class="pre">
   *
  </span>
  <span class="pre">
   %ntid.y
  </span>
  <span class="pre">
   *
  </span>
  <span class="pre">
   %ntid.z)
  </span>
  .
 </p>
 <pre>%ntid.y == %ntid.z == 1 in 1D CTAs.
%ntid.z ==1 in 2D CTAs.
</pre>
 <p>
  Maximum values of %ntid.{x,y,z} are as follows:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     .target architecture
    </p>
   </th>
   <th class="head">
    <p>
     %ntid.x
    </p>
   </th>
   <th class="head">
    <p>
     %ntid.y
    </p>
   </th>
   <th class="head">
    <p>
     %ntid.z
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      sm_1x
     </span>
    </p>
   </td>
   <td>
    <p>
     512
    </p>
   </td>
   <td>
    <p>
     512
    </p>
   </td>
   <td>
    <p>
     64
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_3x
     </span>
     ,
     <span class="pre">
      sm_5x
     </span>
     ,
     <span class="pre">
      sm_6x
     </span>
     ,
     <span class="pre">
      sm_7x
     </span>
     ,
     <span class="pre">
      sm_8x
     </span>
     ,
     <span class="pre">
      sm_9x
     </span>
    </p>
   </td>
   <td>
    <p>
     1024
    </p>
   </td>
   <td>
    <p>
     1024
    </p>
   </td>
   <td>
    <p>
     64
    </p>
   </td>
  </tr>
 </table>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0 with type
  <span class="pre">
   .v4.u16
  </span>
  .
 </p>
 <p>
  Redefined as type
  <span class="pre">
   .v4.u32
  </span>
  in PTX ISA version 2.0. For compatibility with legacy PTX code, 16-bit
  <span class="pre">
   mov
  </span>
  and
  <span class="pre">
   cvt
  </span>
  instructions may be used to read the lower 16-bits of each component of
  <span class="pre">
   %ntid
  </span>
  .
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>// compute unified thread id for 2D CTA
mov.u32  %r0,%tid.x;
mov.u32  %h1,%tid.y;
mov.u32  %h2,%ntid.x;
mad.u32  %r0,%h1,%h2,%r0;

mov.u16  %rh,%ntid.x;      // legacy code
</pre>
 <h2>
  <span class="section-number">
   10.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-laneid">
   Special Registers: %laneid
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-laneid" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %laneid
 </p>
 <p>
  Lane Identifier.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .u32 %laneid;
</pre>
 <p>
  Description
 </p>
 <p>
  A predefined, read-only special register that returns the threadâs lane within the warp. The lane
identifier ranges from zero to
  <span class="pre">
   WARP_SZ-1
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.3.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>mov.u32  %r, %laneid;
</pre>
 <h2>
  <span class="section-number">
   10.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-warpid">
   Special Registers: %warpid
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-warpid" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %warpid
 </p>
 <p>
  Warp identifier.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .u32 %warpid;
</pre>
 <p>
  Description
 </p>
 <p>
  A predefined, read-only special register that returns the threadâs warp identifier. The warp
identifier provides a unique warp number within a CTA but not across CTAs within a grid. The warp
identifier will be the same for all threads within a single warp.
 </p>
 <p>
  Note that
  <span class="pre">
   %warpid
  </span>
  is volatile and returns the location of a thread at the moment when read, but
its value may change during execution, e.g., due to rescheduling of threads following
preemption. For this reason,
  <span class="pre">
   %ctaid
  </span>
  and
  <span class="pre">
   %tid
  </span>
  should be used to compute a virtual warp index
if such a value is needed in kernel code;
  <span class="pre">
   %warpid
  </span>
  is intended mainly to enable profiling and
diagnostic code to sample and log information such as work place mapping and load distribution.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.3.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>mov.u32  %r, %warpid;
</pre>
 <h2>
  <span class="section-number">
   10.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-nwarpid">
   Special Registers: %nwarpid
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-nwarpid" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %nwarpid
 </p>
 <p>
  Number of warp identifiers.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .u32 %nwarpid;
</pre>
 <p>
  Description
 </p>
 <p>
  A predefined, read-only special register that returns the maximum number of warp identifiers.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   %nwarpid
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>mov.u32  %r, %nwarpid;
</pre>
 <h2>
  <span class="section-number">
   10.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-ctaid">
   Special Registers: %ctaid
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-ctaid" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %ctaid
 </p>
 <p>
  CTA identifier within a grid.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .v4 .u32 %ctaid;                      // CTA id vector
.sreg .u32 %ctaid.x, %ctaid.y, %ctaid.z;    // CTA id components
</pre>
 <p>
  Description
 </p>
 <p>
  A predefined, read-only special register initialized with the CTA identifier within the CTA
grid. The
  <span class="pre">
   %ctaid
  </span>
  special register contains a 1D, 2D, or 3D vector, depending on the shape and
rank of the CTA grid. The fourth element is unused and always returns zero.
 </p>
 <p>
  It is guaranteed that:
 </p>
 <pre>0  &lt;=  %ctaid.x &lt;  %nctaid.x
0  &lt;=  %ctaid.y &lt;  %nctaid.y
0  &lt;=  %ctaid.z &lt;  %nctaid.z
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0 with type
  <span class="pre">
   .v4.u16
  </span>
  .
 </p>
 <p>
  Redefined as type
  <span class="pre">
   .v4.u32
  </span>
  in PTX ISA version 2.0. For compatibility with legacy PTX code, 16-bit
  <span class="pre">
   mov
  </span>
  and
  <span class="pre">
   cvt
  </span>
  instructions may be used to read the lower 16-bits of each component of
  <span class="pre">
   %ctaid
  </span>
  .
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>mov.u32  %r0,%ctaid.x;
mov.u16  %rh,%ctaid.y;   // legacy code
</pre>
 <h2>
  <span class="section-number">
   10.7.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-nctaid">
   Special Registers: %nctaid
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-nctaid" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %nctaid
 </p>
 <p>
  Number of CTA ids per grid.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .v4 .u32 %nctaid                      // Grid shape vector
.sreg .u32 %nctaid.x,%nctaid.y,%nctaid.z;   // Grid dimensions
</pre>
 <p>
  Description
 </p>
 <p>
  A predefined, read-only special register initialized with the number of CTAs in each grid
dimension. The
  <span class="pre">
   %nctaid
  </span>
  special register contains a 3D grid shape vector, with each element
having a value of at least
  <span class="pre">
   1
  </span>
  . The fourth element is unused and always returns zero.
 </p>
 <p>
  Maximum values of %nctaid.{x,y,z} are as follows:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     .target architecture
    </p>
   </th>
   <th class="head">
    <p>
     %nctaid.x
    </p>
   </th>
   <th class="head">
    <p>
     %nctaid.y
    </p>
   </th>
   <th class="head">
    <p>
     %nctaid.z
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      sm_1x
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
    </p>
   </td>
   <td>
    <p>
     65535
    </p>
   </td>
   <td>
    <p>
     65535
    </p>
   </td>
   <td>
    <p>
     65535
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      sm_3x
     </span>
     ,
     <span class="pre">
      sm_5x
     </span>
     ,
     <span class="pre">
      sm_6x
     </span>
     ,
     <span class="pre">
      sm_7x
     </span>
     ,
     <span class="pre">
      sm_8x
     </span>
     ,
     <span class="pre">
      sm_9x
     </span>
    </p>
   </td>
   <td>
    <p>
     2
     31
     -1
    </p>
   </td>
   <td>
    <p>
     65535
    </p>
   </td>
   <td>
    <p>
     65535
    </p>
   </td>
  </tr>
 </table>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0 with type
  <span class="pre">
   .v4.u16
  </span>
  .
 </p>
 <p>
  Redefined as type
  <span class="pre">
   .v4.u32
  </span>
  in PTX ISA version 2.0. For compatibility with legacy PTX code, 16-bit
  <span class="pre">
   mov
  </span>
  and
  <span class="pre">
   cvt
  </span>
  instructions may be used to read the lower 16-bits of each component of
  <span class="pre">
   %nctaid
  </span>
  .
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>mov.u32  %r0,%nctaid.x;
mov.u16  %rh,%nctaid.x;     // legacy code
</pre>
 <h2>
  <span class="section-number">
   10.8.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-smid">
   Special Registers: %smid
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-smid" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %smid
 </p>
 <p>
  SM identifier.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .u32 %smid;
</pre>
 <p>
  Description
 </p>
 <p>
  A predefined, read-only special register that returns the processor (SM) identifier on which a
particular thread is executing. The SM identifier ranges from
  <span class="pre">
   0
  </span>
  to
  <span class="pre">
   %nsmid-1
  </span>
  . The SM
identifier numbering is not guaranteed to be contiguous.
 </p>
 <p>
  Notes
 </p>
 <p>
  Note that
  <span class="pre">
   %smid
  </span>
  is volatile and returns the location of a thread at the moment when read, but
its value may change during execution, e.g. due to rescheduling of threads following
preemption.
  <span class="pre">
   %smid
  </span>
  is intended mainly to enable profiling and diagnostic code to sample and log
information such as work place mapping and load distribution.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.3.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>mov.u32  %r, %smid;
</pre>
 <h2>
  <span class="section-number">
   10.9.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-nsmid">
   Special Registers: %nsmid
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-nsmid" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %nsmid
 </p>
 <p>
  Number of SM identifiers.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .u32 %nsmid;
</pre>
 <p>
  Description
 </p>
 <p>
  A predefined, read-only special register that returns the maximum number of SM identifiers. The SM
identifier numbering is not guaranteed to be contiguous, so
  <span class="pre">
   %nsmid
  </span>
  may be larger than the
physical number of SMs in the device.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   %nsmid
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>mov.u32  %r, %nsmid;
</pre>
 <h2>
  <span class="section-number">
   10.10.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-gridid">
   Special Registers: %gridid
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-gridid" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %gridid
 </p>
 <p>
  Grid identifier.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .u64 %gridid;
</pre>
 <p>
  Description
 </p>
 <p>
  A predefined, read-only special register initialized with the per-grid temporal grid identifier. The
  <span class="pre">
   %gridid
  </span>
  is used by debuggers to distinguish CTAs and clusters within concurrent (small) grids.
 </p>
 <p>
  During execution, repeated launches of programs may occur, where each launch starts a
grid-of-CTAs. This variable provides the temporal grid launch number for this context.
 </p>
 <p>
  For
  <span class="pre">
   sm_1x
  </span>
  targets,
  <span class="pre">
   %gridid
  </span>
  is limited to the range [0..2
  16
  -1]. For
  <span class="pre">
   sm_20
  </span>
  ,
  <span class="pre">
   %gridid
  </span>
  is limited to the range [0..2
  32
  -1].
  <span class="pre">
   sm_30
  </span>
  supports the entire 64-bit range.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0 as type
  <span class="pre">
   .u16
  </span>
  .
 </p>
 <p>
  Redefined as type
  <span class="pre">
   .u32
  </span>
  in PTX ISA version 1.3.
 </p>
 <p>
  Redefined as type
  <span class="pre">
   .u64
  </span>
  in PTX ISA version 3.0.
 </p>
 <p>
  For compatibility with legacy PTX code, 16-bit and 32-bit
  <span class="pre">
   mov
  </span>
  and
  <span class="pre">
   cvt
  </span>
  instructions may be
used to read the lower 16-bits or 32-bits of each component of
  <span class="pre">
   %gridid
  </span>
  .
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>mov.u64  %s, %gridid;  // 64-bit read of %gridid
mov.u32  %r, %gridid;  // legacy code with 32-bit %gridid
</pre>
 <h2>
  <span class="section-number">
   10.11.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-is-explicit-cluster">
   Special Registers: %is_explicit_cluster
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-is-explicit-cluster" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %is_explicit_cluster
 </p>
 <p>
  Checks if user has explicitly specified cluster launch.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .pred %is_explicit_cluster;
</pre>
 <p>
  Description
 </p>
 <p>
  A predefined, read-only special register initialized with the predicate value of whether the cluster
launch is explicitly specified by user.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.8.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>.reg .pred p;

mov.pred  p, %is_explicit_cluster;
</pre>
 <h2>
  <span class="section-number">
   10.12.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-clusterid">
   Special Registers: %clusterid
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-clusterid" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %clusterid
 </p>
 <p>
  Cluster identifier within a grid.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .v4 .u32 %clusterid;
.sreg .u32 %clusterid.x, %clusterid.y, %clusterid.z;
</pre>
 <p>
  Description
 </p>
 <p>
  A predefined, read-only special register initialized with the cluster identifier in a grid in each
dimension. Each cluster in a grid has a unique identifier.
 </p>
 <p>
  The
  <span class="pre">
   %clusterid
  </span>
  special register contains a 1D, 2D, or 3D vector, depending upon the shape and
rank of the cluster. The fourth element is unused and always returns zero.
 </p>
 <p>
  It is guaranteed that:
 </p>
 <pre>0  &lt;=  %clusterid.x &lt;  %nclusterid.x
0  &lt;=  %clusterid.y &lt;  %nclusterid.y
0  &lt;=  %clusterid.z &lt;  %nclusterid.z
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.8.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>.reg .b32 %r&lt;2&gt;;
.reg .v4 .b32 %rx;

mov.u32     %r0, %clusterid.x;
mov.u32     %r1, %clusterid.z;
mov.v4.u32  %rx, %clusterid;
</pre>
 <h2>
  <span class="section-number">
   10.13.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-nclusterid">
   Special Registers: %nclusterid
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-nclusterid" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %nclusterid
 </p>
 <p>
  Number of cluster identifiers per grid.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .v4 .u32 %nclusterid;
.sreg .u32 %nclusterid.x, %nclusterid.y, %nclusterid.z;
</pre>
 <p>
  Description
 </p>
 <p>
  A predefined, read-only special register initialized with the number of clusters in each grid
dimension.
 </p>
 <p>
  The
  <span class="pre">
   %nclusterid
  </span>
  special register contains a 3D grid shape vector that holds the grid dimensions
in terms of clusters. The fourth element is unused and always returns zero.
 </p>
 <p>
  Refer to the
  Cuda Programming Guide
  for details on the maximum values of
  <span class="pre">
   %nclusterid.{x,y,z}
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.8.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>.reg .b32 %r&lt;2&gt;;
.reg .v4 .b32 %rx;

mov.u32     %r0, %nclusterid.x;
mov.u32     %r1, %nclusterid.z;
mov.v4.u32  %rx, %nclusterid;
</pre>
 <h2>
  <span class="section-number">
   10.14.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-cluster-ctaid">
   Special Registers: %cluster_ctaid
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-cluster-ctaid" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %cluster_ctaid
 </p>
 <p>
  CTA identifier within a cluster.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .v4 .u32 %cluster_ctaid;
.sreg .u32 %cluster_ctaid.x, %cluster_ctaid.y, %cluster_ctaid.z;
</pre>
 <p>
  Description
 </p>
 <p>
  A predefined, read-only special register initialized with the CTA identifier in a cluster in each
dimension. Each CTA in a cluster has a unique CTA identifier.
 </p>
 <p>
  The
  <span class="pre">
   %cluster_ctaid
  </span>
  special register contains a 1D, 2D, or 3D vector, depending upon the shape of
the cluster. The fourth element is unused and always returns zero.
 </p>
 <p>
  It is guaranteed that:
 </p>
 <pre>0  &lt;=  %cluster_ctaid.x &lt;  %cluster_nctaid.x
0  &lt;=  %cluster_ctaid.y &lt;  %cluster_nctaid.y
0  &lt;=  %cluster_ctaid.z &lt;  %cluster_nctaid.z
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.8.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>.reg .b32 %r&lt;2&gt;;
.reg .v4 .b32 %rx;

mov.u32     %r0, %cluster_ctaid.x;
mov.u32     %r1, %cluster_ctaid.z;
mov.v4.u32  %rx, %cluster_ctaid;
</pre>
 <h2>
  <span class="section-number">
   10.15.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-cluster-nctaid">
   Special Registers: %cluster_nctaid
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-cluster-nctaid" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %cluster_nctaid
 </p>
 <p>
  Number of CTA identifiers per cluster.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .v4 .u32 %cluster_nctaid;
.sreg .u32 %cluster_nctaid.x, %cluster_nctaid.y, %cluster_nctaid.z;
</pre>
 <p>
  Description
 </p>
 <p>
  A predefined, read-only special register initialized with the number of CTAs in a cluster in each
dimension.
 </p>
 <p>
  The
  <span class="pre">
   %cluster_nctaid
  </span>
  special register contains a 3D grid shape vector that holds the cluster
dimensions in terms of CTAs. The fourth element is unused and always returns zero.
 </p>
 <p>
  Refer to the
  Cuda Programming Guide
  for details on the maximum values of
  <span class="pre">
   %cluster_nctaid.{x,y,z}
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.8.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>.reg .b32 %r&lt;2&gt;;
.reg .v4 .b32 %rx;

mov.u32     %r0, %cluster_nctaid.x;
mov.u32     %r1, %cluster_nctaid.z;
mov.v4.u32  %rx, %cluster_nctaid;
</pre>
 <h2>
  <span class="section-number">
   10.16.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-cluster-ctarank">
   Special Registers: %cluster_ctarank
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-cluster-ctarank" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %cluster_ctarank
 </p>
 <p>
  CTA identifier in a cluster across all dimensions.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .u32 %cluster_ctarank;
</pre>
 <p>
  Description
 </p>
 <p>
  A predefined, read-only special register initialized with the CTA rank within a cluster across all
dimensions.
 </p>
 <p>
  It is guaranteed that:
 </p>
 <pre>0  &lt;=  %cluster_ctarank &lt;  %cluster_nctarank
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.8.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>.reg .b32 %r;

mov.u32  %r, %cluster_ctarank;
</pre>
 <h2>
  <span class="section-number">
   10.17.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-cluster-nctarank">
   Special Registers: %cluster_nctarank
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-cluster-nctarank" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %cluster_nctarank
 </p>
 <p>
  Number of CTA identifiers in a cluster across all dimensions.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .u32 %cluster_nctarank;
</pre>
 <p>
  Description
 </p>
 <p>
  A predefined, read-only special register initialized with the nunber of CTAs within a cluster across
all dimensions.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.8.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>.reg .b32 %r;

mov.u32  %r, %cluster_nctarank;
</pre>
 <h2>
  <span class="section-number">
   10.18.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-lanemask-eq">
   Special Registers: %lanemask_eq
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-lanemask-eq" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %lanemask_eq
 </p>
 <p>
  32-bit mask with bit set in position equal to the threadâs lane number in the warp.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .u32 %lanemask_eq;
</pre>
 <p>
  Description
 </p>
 <p>
  A predefined, read-only special register initialized with a 32-bit mask with a bit set in the
position equal to the threadâs lane number in the warp.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   %lanemask_eq
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>mov.u32     %r, %lanemask_eq;
</pre>
 <h2>
  <span class="section-number">
   10.19.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-lanemask-le">
   Special Registers: %lanemask_le
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-lanemask-le" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %lanemask_le
 </p>
 <p>
  32-bit mask with bits set in positions less than or equal to the threadâs lane number in the warp.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .u32 %lanemask_le;
</pre>
 <p>
  Description
 </p>
 <p>
  A predefined, read-only special register initialized with a 32-bit mask with bits set in positions
less than or equal to the threadâs lane number in the warp.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   %lanemask_le
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>mov.u32     %r, %lanemask_le
</pre>
 <h2>
  <span class="section-number">
   10.20.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-lanemask-lt">
   Special Registers: %lanemask_lt
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-lanemask-lt" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %lanemask_lt
 </p>
 <p>
  32-bit mask with bits set in positions less than the threadâs lane number in the warp.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .u32 %lanemask_lt;
</pre>
 <p>
  Description
 </p>
 <p>
  A predefined, read-only special register initialized with a 32-bit mask with bits set in positions
less than the threadâs lane number in the warp.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   %lanemask_lt
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>mov.u32     %r, %lanemask_lt;
</pre>
 <h2>
  <span class="section-number">
   10.21.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-lanemask-ge">
   Special Registers: %lanemask_ge
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-lanemask-ge" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %lanemask_ge
 </p>
 <p>
  32-bit mask with bits set in positions greater than or equal to the threadâs lane number in the warp.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .u32 %lanemask_ge;
</pre>
 <p>
  Description
 </p>
 <p>
  A predefined, read-only special register initialized with a 32-bit mask with bits set in positions
greater than or equal to the threadâs lane number in the warp.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   %lanemask_ge
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>mov.u32     %r, %lanemask_ge;
</pre>
 <h2>
  <span class="section-number">
   10.22.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-lanemask-gt">
   Special Registers: %lanemask_gt
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-lanemask-gt" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %lanemask_gt
 </p>
 <p>
  32-bit mask with bits set in positions greater than the threadâs lane number in the warp.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .u32 %lanemask_gt;
</pre>
 <p>
  Description
 </p>
 <p>
  A predefined, read-only special register initialized with a 32-bit mask with bits set in positions
greater than the threadâs lane number in the warp.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   %lanemask_gt
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>mov.u32     %r, %lanemask_gt;
</pre>
 <h2>
  <span class="section-number">
   10.23.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-clock">
   Special Registers: %clock, %clock_hi
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-clock-clock-hi" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %clock, %clock_hi
 </p>
 <span class="pre">
  %clock
 </span>
 <p>
  A predefined, read-only 32-bit unsigned cycle counter.
 </p>
 <span class="pre">
  %clock_hi
 </span>
 <p>
  The upper 32-bits of
  <span class="pre">
   %clock64
  </span>
  special register.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .u32 %clock;
.sreg .u32 %clock_hi;
</pre>
 <p>
  Description
 </p>
 <p>
  Special register
  <span class="pre">
   %clock
  </span>
  and
  <span class="pre">
   %clock_hi
  </span>
  are unsigned 32-bit read-only cycle counters that wrap
silently.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  <span class="pre">
   %clock
  </span>
  introduced in PTX ISA version 1.0.
 </p>
 <p>
  <span class="pre">
   %clock_hi
  </span>
  introduced in PTX ISA version 5.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   %clock
  </span>
  supported on all target architectures.
 </p>
 <p>
  <span class="pre">
   %clock_hi
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>mov.u32 r1,%clock;
mov.u32 r2, %clock_hi;
</pre>
 <h2>
  <span class="section-number">
   10.24.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-clock64">
   Special Registers: %clock64
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-clock64" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %clock64
 </p>
 <p>
  A predefined, read-only 64-bit unsigned cycle counter.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .u64 %clock64;
</pre>
 <p>
  Description
 </p>
 <p>
  Special register
  <span class="pre">
   %clock64
  </span>
  is an unsigned 64-bit read-only cycle counter that wraps silently.
 </p>
 <p>
  Notes
 </p>
 <p>
  The lower 32-bits of
  <span class="pre">
   %clock64
  </span>
  are identical to
  <span class="pre">
   %clock
  </span>
  .
 </p>
 <p>
  The upper 32-bits of
  <span class="pre">
   %clock64
  </span>
  are identical to
  <span class="pre">
   %clock_hi
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   %clock64
  </span>
  requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>mov.u64  r1,%clock64;
</pre>
 <h2>
  <span class="section-number">
   10.25.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-pm0-pm7">
   Special Registers: %pm0..%pm7
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-pm0-pm7" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %pm0..%pm7
 </p>
 <p>
  Performance monitoring counters.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .u32 %pm&lt;8&gt;;
</pre>
 <p>
  Description
 </p>
 <p>
  Special registers
  <span class="pre">
   %pm0..%pm7
  </span>
  are unsigned 32-bit read-only performance monitor counters. Their
behavior is currently undefined.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  <span class="pre">
   %pm0..%pm3
  </span>
  introduced in PTX ISA version 1.3.
 </p>
 <p>
  <span class="pre">
   %pm4..%pm7
  </span>
  introduced in PTX ISA version 3.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   %pm0..%pm3
  </span>
  supported on all target architectures.
 </p>
 <p>
  <span class="pre">
   %pm4..%pm7
  </span>
  require
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>mov.u32  r1,%pm0;
mov.u32  r1,%pm7;
</pre>
 <h2>
  <span class="section-number">
   10.26.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-pm0_64-pm7_64">
   Special Registers: %pm0_64..%pm7_64
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-pm0-64-pm7-64" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %pm0_64..%pm7_64
 </p>
 <p>
  64 bit Performance monitoring counters.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .u64 %pm0_64;
.sreg .u64 %pm1_64;
.sreg .u64 %pm2_64;
.sreg .u64 %pm3_64;
.sreg .u64 %pm4_64;
.sreg .u64 %pm5_64;
.sreg .u64 %pm6_64;
.sreg .u64 %pm7_64;
</pre>
 <p>
  Description
 </p>
 <p>
  Special registers
  <span class="pre">
   %pm0_64..%pm7_64
  </span>
  are unsigned 64-bit read-only performance monitor
counters. Their behavior is currently undefined.
 </p>
 <p>
  Notes
 </p>
 <p>
  The lower 32bits of
  <span class="pre">
   %pm0_64..%pm7_64
  </span>
  are identical to
  <span class="pre">
   %pm0..%pm7
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  <span class="pre">
   %pm0_64..%pm7_64
  </span>
  introduced in PTX ISA version 4.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   %pm0_64..%pm7_64
  </span>
  require
  <span class="pre">
   sm_50
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>mov.u32  r1,%pm0_64;
mov.u32  r1,%pm7_64;
</pre>
 <h2>
  <span class="section-number">
   10.27.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-envreg-32">
   Special Registers: %envreg&lt;32&gt;
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-envreg-32" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %envreg&lt;32&gt;
 </p>
 <p>
  Driver-defined read-only registers.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .b32 %envreg&lt;32&gt;;
</pre>
 <p>
  Description
 </p>
 <p>
  A set of 32 pre-defined read-only registers used to capture execution environment of PTX program
outside of PTX virtual machine. These registers are initialized by the driver prior to kernel launch
and can contain cta-wide or grid-wide values.
 </p>
 <p>
  Precise semantics of these registers is defined in the driver documentation.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.1.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>mov.b32      %r1,%envreg0;  // move envreg0 to %r1
</pre>
 <h2>
  <span class="section-number">
   10.28.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-globaltimer">
   Special Registers: %globaltimer, %globaltimer_lo, %globaltimer_hi
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-globaltimer-globaltimer-lo-globaltimer-hi" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %globaltimer, %globaltimer_lo, %globaltimer_hi
 </p>
 <span class="pre">
  %globaltimer
 </span>
 <p>
  A predefined, 64-bit global nanosecond timer.
 </p>
 <span class="pre">
  %globaltimer_lo
 </span>
 <p>
  The lower 32-bits of %globaltimer.
 </p>
 <span class="pre">
  %globaltimer_hi
 </span>
 <p>
  The upper 32-bits of %globaltimer.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .u64 %globaltimer;
.sreg .u32 %globaltimer_lo, %globaltimer_hi;
</pre>
 <p>
  Description
 </p>
 <p>
  Special registers intended for use by NVIDIA tools. The behavior is target-specific and may change
or be removed in future GPUs. When JIT-compiled to other targets, the value of these registers is
unspecified.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 3.1.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires target
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>mov.u64  r1,%globaltimer;
</pre>
 <h2>
  <span class="section-number">
   10.29.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-reserved-smem">
   Special Registers: %reserved_smem_offset_begin, %reserved_smem_offset_end, %reserved_smem_offset_cap, %reserved_smem_offset_&lt;2&gt;
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-reserved-smem-offset-begin-reserved-smem-offset-end-reserved-smem-offset-cap-reserved-smem-offset-2" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %reserved_smem_offset_begin, %reserved_smem_offset_end, %reserved_smem_offset_cap, %reserved_smem_offset_&lt;2&gt;
 </p>
 <span class="pre">
  %reserved_smem_offset_begin
 </span>
 <p>
  Start of the reserved shared memory region.
 </p>
 <span class="pre">
  %reserved_smem_offset_end
 </span>
 <p>
  End of the reserved shared memory region.
 </p>
 <span class="pre">
  %reserved_smem_offset_cap
 </span>
 <p>
  Total size of the reserved shared memory region.
 </p>
 <span class="pre">
  %reserved_smem_offset_&lt;2&gt;
 </span>
 <p>
  Offsets in the reserved shared memory region.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .b32 %reserved_smem_offset_begin;
.sreg .b32 %reserved_smem_offset_end;
.sreg .b32 %reserved_smem_offset_cap;
.sreg .b32 %reserved_smem_offset_&lt;2&gt;;
</pre>
 <p>
  Description
 </p>
 <p>
  These are predefined, read-only special registers containing information about the shared memory
region which is reserved for the NVIDIA system software use. This region of shared memory is not
available to users, and accessing this region from user code results in undefined behavior. Refer to
  CUDA Programming Guide
  for details.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.6.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Require
  <span class="pre">
   sm_80
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>.reg .b32 %reg_begin, %reg_end, %reg_cap, %reg_offset0, %reg_offset1;

mov.b32 %reg_begin,   %reserved_smem_offset_begin;
mov.b32 %reg_end,     %reserved_smem_offset_end;
mov.b32 %reg_cap,     %reserved_smem_offset_cap;
mov.b32 %reg_offset0, %reserved_smem_offset_0;
mov.b32 %reg_offset1, %reserved_smem_offset_1;
</pre>
 <h2>
  <span class="section-number">
   10.30.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-total-smem-size">
   Special Registers: %total_smem_size
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-total-smem-size" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %total_smem_size
 </p>
 <p>
  Total size of shared memory used by a CTA of a kernel.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .u32 %total_smem_size;
</pre>
 <p>
  Description
 </p>
 <p>
  A predefined, read-only special register initialized with total size of shared memory allocated
(statically and dynamically, excluding the shared memory reserved for the NVIDIA system software
use) for the CTA of a kernel at launch time.
 </p>
 <p>
  Size is returned in multiples of shared memory allocation unit size supported by target
architecture.
 </p>
 <p>
  Allocation unit values are as follows:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Target architecture
    </p>
   </th>
   <th class="head">
    <p>
     Shared memory allocation unit size
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      sm_2x
     </span>
    </p>
   </td>
   <td>
    <p>
     128 bytes
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      sm_3x
     </span>
     ,
     <span class="pre">
      sm_5x
     </span>
     ,
     <span class="pre">
      sm_6x
     </span>
     ,
     <span class="pre">
      sm_7x
     </span>
    </p>
   </td>
   <td>
    <p>
     256 bytes
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      sm_8x
     </span>
     ,
     <span class="pre">
      sm_9x
     </span>
    </p>
   </td>
   <td>
    <p>
     128 bytes
    </p>
   </td>
  </tr>
 </table>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 4.1.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>mov.u32  %r, %total_smem_size;
</pre>
 <h2>
  <span class="section-number">
   10.31.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-aggr-smem-size">
   Special Registers: %aggr_smem_size
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-aggr-smem-size" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %aggr_smem_size
 </p>
 <p>
  Total size of shared memory used by a CTA of a kernel.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .u32 %aggr_smem_size;
</pre>
 <p>
  Description
 </p>
 <p>
  A predefined, read-only special register initialized with total aggregated size of shared memory
consisting of the size of user shared memory allocated (statically and dynamically) at launch time
and the size of shared memory region which is reserved for the NVIDIA system software use.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 8.1.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>mov.u32  %r, %aggr_smem_size;
</pre>
 <h2>
  <span class="section-number">
   10.32.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-dynamic-smem-size">
   Special Registers: %dynamic_smem_size
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-dynamic-smem-size" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %dynamic_smem_size
 </p>
 <p>
  Size of shared memory allocated dynamically at kernel launch.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .u32 %dynamic_smem_size;
</pre>
 <p>
  Description
 </p>
 <p>
  Size of shared memory allocated dynamically at kernel launch.
 </p>
 <p>
  A predefined, read-only special register initialized with size of shared memory allocated dynamically for the CTA of a kernel at launch time.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 4.1.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>mov.u32  %r, %dynamic_smem_size;
</pre>
 <h2>
  <span class="section-number">
   10.33.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-current-graph-exec">
   Special Registers: %current_graph_exec
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#special-registers-current-graph-exec" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  %current_graph_exec
 </p>
 <p>
  An Identifier for currently executing CUDA device graph.
 </p>
 <p>
  Syntax (predefined)
 </p>
 <pre>.sreg .u64 %current_graph_exec;
</pre>
 <p>
  Description
 </p>
 <p>
  A predefined, read-only special register initialized with the identifier referring to the CUDA
device graph being currently executed. This register is 0 if the executing kernel is not part of a
CUDA device graph.
 </p>
 <p>
  Refer to the
  CUDA Programming Guide
  for more details on CUDA device graphs.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 8.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_50
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>mov.u64  r1, %current_graph_exec;
</pre>
 <h1>
  <span class="section-number">
   11.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#directives">
   Directives
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#directives" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <h2>
  <span class="section-number">
   11.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#ptx-module-directives">
   PTX Module Directives
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#ptx-module-directives" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  The following directives declare the PTX ISA version of the code in the module, the target
architecture for which the code was generated, and the size of addresses within the PTX module.
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     .version
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .target
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .address_size
    </span>
   </p>
  </li>
 </ul>
 <h3>
  <span class="section-number">
   11.1.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#ptx-module-directives-version">
   PTX Module Directives: .version
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#ptx-module-directives-version" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  .version
 </p>
 <p>
  PTX ISA version number.
 </p>
 <p>
  Syntax
 </p>
 <pre>.version  major.minor    // major, minor are integers
</pre>
 <p>
  Description
 </p>
 <p>
  Specifies the PTX language version number.
 </p>
 <p>
  The
  major
  number is incremented when there are incompatible changes to the PTX language, such as
changes to the syntax or semantics. The version major number is used by the PTX compiler to ensure
correct execution of legacy PTX code.
 </p>
 <p>
  The
  minor
  number is incremented when new features are added to PTX.
 </p>
 <p>
  Semantics
 </p>
 <p>
  Indicates that this module must be compiled with tools that support an equal or greater version
number.
 </p>
 <p>
  Each PTX module must begin with a
  <span class="pre">
   .version
  </span>
  directive, and no other
  <span class="pre">
   .version
  </span>
  directive is
allowed anywhere else within the module.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>.version 3.1
.version 3.0
.version 2.3
</pre>
 <h3>
  <span class="section-number">
   11.1.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#ptx-module-directives-target">
   PTX Module Directives: .target
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#ptx-module-directives-target" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  .target
 </p>
 <p>
  Architecture and Platform target.
 </p>
 <p>
  Syntax
 </p>
 <pre>.target stringlist         // comma separated list of target specifiers
string = { sm_90a, sm_90,               // sm_9x target architectures
           sm_80, sm_86, sm_87, sm_89,  // sm_8x target architectures
           sm_70, sm_72, sm_75,         // sm_7x target architectures
           sm_60, sm_61, sm_62,         // sm_6x target architectures
           sm_50, sm_52, sm_53,         // sm_5x target architectures
           sm_30, sm_32, sm_35, sm_37,  // sm_3x target architectures
           sm_20,                       // sm_2x target architectures
           sm_10, sm_11, sm_12, sm_13,  // sm_1x target architectures
           texmode_unified, texmode_independent,   // texturing mode
           debug,                                  // platform option
           map_f64_to_f32 };                       // platform option
</pre>
 <p>
  Description
 </p>
 <p>
  Specifies the set of features in the target architecture for which the current PTX code was
generated. In general, generations of SM architectures follow an
  onion layer
  model, where each
generation adds new features and retains all features of previous generations. The onion layer model
allows the PTX code generated for a given target to be run on later generation devices.
 </p>
 <p>
  Target architectures with suffix â
  <span class="pre">
   a
  </span>
  â, such as
  <span class="pre">
   sm_90a
  </span>
  , include architecture-accelerated
features that are supported on the specified architecture only, hence such targets do not follow the
onion layer model. Therefore, PTX code generated for such targets cannot be run on later generation
devices. Architecture-accelerated features can only be used with targets that support these
features.
 </p>
 <p>
  Semantics
 </p>
 <p>
  Each PTX module must begin with a
  <span class="pre">
   .version
  </span>
  directive, immediately followed by a
  <span class="pre">
   .target
  </span>
  directive containing a target architecture and optional platform options. A
  <span class="pre">
   .target
  </span>
  directive
specifies a single target architecture, but subsequent
  <span class="pre">
   .target
  </span>
  directives can be used to change
the set of target features allowed during parsing. A program with multiple
  <span class="pre">
   .target
  </span>
  directives
will compile and run only on devices that support all features of the highest-numbered architecture
listed in the program.
 </p>
 <p>
  PTX features are checked against the specified target architecture, and an error is generated if an
unsupported feature is used.Â  The following table summarizes the features in PTX that vary according
to target architecture.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Target
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      sm_90
     </span>
    </p>
   </td>
   <td>
    <p>
     Baseline feature set for
     <span class="pre">
      sm_90
     </span>
     architecture.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      sm_90a
     </span>
    </p>
   </td>
   <td>
    <p>
     Adds support for
     <span class="pre">
      sm_90a
     </span>
     accelerated
     <span class="pre">
      wgmma
     </span>
     and
     <span class="pre">
      setmaxnreg
     </span>
     instructions.
    </p>
   </td>
  </tr>
 </table>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Target
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      sm_80
     </span>
    </p>
   </td>
   <td>
    <p>
     Baseline feature set for
     <span class="pre">
      sm_80
     </span>
     architecture.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      sm_86
     </span>
    </p>
   </td>
   <td>
    <p>
     Adds support for
     <span class="pre">
      .xorsign
     </span>
     modifier on
     <span class="pre">
      min
     </span>
     and
     <span class="pre">
      max
     </span>
     instructions.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      sm_87
     </span>
    </p>
   </td>
   <td>
    <p>
     Baseline feature set for
     <span class="pre">
      sm_86
     </span>
     architecture.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      sm_89
     </span>
    </p>
   </td>
   <td>
    <p>
     Baseline feature set for
     <span class="pre">
      sm_86
     </span>
     architecture.
    </p>
   </td>
  </tr>
 </table>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Target
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      sm_70
     </span>
    </p>
   </td>
   <td>
    <p>
     Baseline feature set for
     <span class="pre">
      sm_70
     </span>
     architecture.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      sm_72
     </span>
    </p>
   </td>
   <td>
    <p>
     Adds support for integer multiplicand and accumulator matrices in
     <span class="pre">
      wmma
     </span>
     instructions.
    </p>
    <p>
     Adds support for
     <span class="pre">
      cvt.pack
     </span>
     instruction.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      sm_75
     </span>
    </p>
   </td>
   <td>
    <p>
     Adds support for sub-byte integer and single-bit multiplicant matrices in
     <span class="pre">
      wmma
     </span>
     instructions.
    </p>
    <p>
     Adds support for
     <span class="pre">
      ldmatrix
     </span>
     instruction.
    </p>
    <p>
     Adds support for
     <span class="pre">
      movmatrix
     </span>
     instruction.
    </p>
    <p>
     Adds support for
     <span class="pre">
      tanh
     </span>
     instruction.
    </p>
   </td>
  </tr>
 </table>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Target
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      sm_60
     </span>
    </p>
   </td>
   <td>
    <p>
     Baseline feature set for
     <span class="pre">
      sm_60
     </span>
     architecture.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      sm_61
     </span>
    </p>
   </td>
   <td>
    <p>
     Adds support for
     <span class="pre">
      dp2a
     </span>
     and
     <span class="pre">
      dp4a
     </span>
     instructions.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      sm_62
     </span>
    </p>
   </td>
   <td>
    <p>
     Baseline feature set for
     <span class="pre">
      sm_61
     </span>
     architecture.
    </p>
   </td>
  </tr>
 </table>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Target
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      sm_50
     </span>
    </p>
   </td>
   <td>
    <p>
     Baseline feature set for
     <span class="pre">
      sm_50
     </span>
     architecture.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      sm_52
     </span>
    </p>
   </td>
   <td>
    <p>
     Baseline feature set for
     <span class="pre">
      sm_50
     </span>
     architecture.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      sm_53
     </span>
    </p>
   </td>
   <td>
    <p>
     Adds support for arithmetic, comparsion and texture instructions for
     <span class="pre">
      .f16
     </span>
     and
     <span class="pre">
      .f16x2
     </span>
     types.
    </p>
   </td>
  </tr>
 </table>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Target
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      sm_30
     </span>
    </p>
   </td>
   <td>
    <p>
     Baseline feature set for
     <span class="pre">
      sm_30
     </span>
     architecture.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      sm_32
     </span>
    </p>
   </td>
   <td>
    <p>
     Adds 64-bit
     <span class="pre">
      {atom,red}.{and,or,xor,min,max}
     </span>
     instructions.
    </p>
    <p>
     Adds
     <span class="pre">
      shf
     </span>
     instruction.
    </p>
    <p>
     Adds
     <span class="pre">
      ld.global.nc
     </span>
     instruction.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      sm_35
     </span>
    </p>
   </td>
   <td>
    <p>
     Adds support for CUDA Dynamic Parallelism.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      sm_37
     </span>
    </p>
   </td>
   <td>
    <p>
     Baseline feature set for
     <span class="pre">
      sm_35
     </span>
     architecture.
    </p>
   </td>
  </tr>
 </table>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Target
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      sm_20
     </span>
    </p>
   </td>
   <td>
    <p>
     Baseline feature set for
     <span class="pre">
      sm_20
     </span>
     architecture.
    </p>
   </td>
  </tr>
 </table>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Target
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      sm_10
     </span>
    </p>
   </td>
   <td>
    <p>
     Baseline feature set for
     <span class="pre">
      sm_10
     </span>
     architecture.
    </p>
    <p>
     Requires
     <span class="pre">
      map_f64_to_f32
     </span>
     if any
     <span class="pre">
      .f64
     </span>
     instructions used.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      sm_11
     </span>
    </p>
   </td>
   <td>
    <p>
     Adds 64-bit
     <span class="pre">
      {atom,red}.{and,or,xor,min,max}
     </span>
     instructions.
    </p>
    <p>
     Requires
     <span class="pre">
      map_f64_to_f32
     </span>
     if any
     <span class="pre">
      .f64
     </span>
     instructions used.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      sm_12
     </span>
    </p>
   </td>
   <td>
    <p>
     Adds
     <span class="pre">
      {atom,red}.shared
     </span>
     , 64-bit
     <span class="pre">
      {atom,red}.global
     </span>
     ,
     <span class="pre">
      vote
     </span>
     instructions.
    </p>
    <p>
     Requires
     <span class="pre">
      map_f64_to_f32
     </span>
     if any
     <span class="pre">
      .f64
     </span>
     instructions used.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      sm_13
     </span>
    </p>
   </td>
   <td>
    <p>
     Adds double-precision support, including expanded rounding modifiers.
    </p>
    <p>
     Disallows use of
     <span class="pre">
      map_f64_to_f32
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  The texturing mode is specified for an entire module and cannot be changed within the module.
 </p>
 <p>
  The
  <span class="pre">
   .target
  </span>
  debug option declares that the PTX file contains DWARF debug information, and
subsequent compilation of PTX will retain information needed for source-level debugging. If the
debug option is declared, an error message is generated if no DWARF information is found in the
file. The debug option requires PTX ISA version 3.0 or later.
 </p>
 <p>
  <span class="pre">
   map_f64_to_f32
  </span>
  indicates that all double-precision instructions map to single-precision
regardless of the target architecture. This enables high-level language compilers to compile
programs containing type double to target device that do not support double-precision
operations. Note that
  <span class="pre">
   .f64
  </span>
  storage remains as 64-bits, with only half being used by instructions
converted from
  <span class="pre">
   .f64
  </span>
  to
  <span class="pre">
   .f32
  </span>
  .
 </p>
 <p>
  Notes
 </p>
 <p>
  Targets of the form
  <span class="pre">
   compute_xx
  </span>
  are also accepted as synonyms for
  <span class="pre">
   sm_xx
  </span>
  targets.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target strings
  <span class="pre">
   sm_10
  </span>
  and
  <span class="pre">
   sm_11
  </span>
  introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target strings
  <span class="pre">
   sm_12
  </span>
  and
  <span class="pre">
   sm_13
  </span>
  introduced in PTX ISA version 1.2.
 </p>
 <p>
  Texturing mode introduced in PTX ISA version 1.5.
 </p>
 <p>
  Target string
  <span class="pre">
   sm_20
  </span>
  introduced in PTX ISA version 2.0.
 </p>
 <p>
  Target string
  <span class="pre">
   sm_30
  </span>
  introduced in PTX ISA version 3.0.
 </p>
 <p>
  Platform option
  <span class="pre">
   debug
  </span>
  introduced in PTX ISA version 3.0.
 </p>
 <p>
  Target string
  <span class="pre">
   sm_35
  </span>
  introduced in PTX ISA version 3.1.
 </p>
 <p>
  Target strings
  <span class="pre">
   sm_32
  </span>
  and
  <span class="pre">
   sm_50
  </span>
  introduced in PTX ISA version 4.0.
 </p>
 <p>
  Target strings
  <span class="pre">
   sm_37
  </span>
  and
  <span class="pre">
   sm_52
  </span>
  introduced in PTX ISA version 4.1.
 </p>
 <p>
  Target string
  <span class="pre">
   sm_53
  </span>
  introduced in PTX ISA version 4.2.
 </p>
 <p>
  Target string
  <span class="pre">
   sm_60
  </span>
  ,
  <span class="pre">
   sm_61
  </span>
  ,
  <span class="pre">
   sm_62
  </span>
  introduced in PTX ISA version 5.0.
 </p>
 <p>
  Target string
  <span class="pre">
   sm_70
  </span>
  introduced in PTX ISA version 6.0.
 </p>
 <p>
  Target string
  <span class="pre">
   sm_72
  </span>
  introduced in PTX ISA version 6.1.
 </p>
 <p>
  Target string
  <span class="pre">
   sm_75
  </span>
  introduced in PTX ISA version 6.3.
 </p>
 <p>
  Target string
  <span class="pre">
   sm_80
  </span>
  introduced in PTX ISA version 7.0.
 </p>
 <p>
  Target string
  <span class="pre">
   sm_86
  </span>
  introduced in PTX ISA version 7.1.
 </p>
 <p>
  Target string
  <span class="pre">
   sm_87
  </span>
  introduced in PTX ISA version 7.4.
 </p>
 <p>
  Target string
  <span class="pre">
   sm_89
  </span>
  introduced in PTX ISA version 7.8.
 </p>
 <p>
  Target string
  <span class="pre">
   sm_90
  </span>
  introduced in PTX ISA version 7.8.
 </p>
 <p>
  Target string
  <span class="pre">
   sm_90a
  </span>
  introduced in PTX ISA version 8.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  The
  <span class="pre">
   .target
  </span>
  directive is supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>.target sm_10       // baseline target architecture
.target sm_13       // supports double-precision
.target sm_20, texmode_independent
.target sm_90       // baseline target architecture
.target sm_90a      // PTX using arch accelerated features
</pre>
 <h3>
  <span class="section-number">
   11.1.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#ptx-module-directives-address-size">
   PTX Module Directives: .address_size
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#ptx-module-directives-address-size" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  .address_size
 </p>
 <p>
  Address size used throughout PTX module.
 </p>
 <p>
  Syntax
 </p>
 <pre>.address_size  address-size
address-size = { 32, 64 };
</pre>
 <p>
  Description
 </p>
 <p>
  Specifies the address size assumed throughout the module by the PTX code and the binary DWARF
information in PTX.
 </p>
 <p>
  Redefinition of this directive within a module is not allowed. In the presence of separate
compilation all modules must specify (or default to) the same address size.
 </p>
 <p>
  The
  <span class="pre">
   .address_size
  </span>
  directive is optional, but it must immediately follow the
  <span class="pre">
   .target
  </span>
  directive if present within a module.
 </p>
 <p>
  Semantics
 </p>
 <p>
  If the
  <span class="pre">
   .address_size
  </span>
  directive is omitted, the address size defaults to 32.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.3.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>// example directives
   .address_size 32       // addresses are 32 bit
   .address_size 64       // addresses are 64 bit

// example of directive placement within a module
   .version 2.3
   .target sm_20
   .address_size 64
...
.entry foo () {
...
}
</pre>
 <h2>
  <span class="section-number">
   11.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#specifying-kernel-entry-points-and-functions">
   Specifying Kernel Entry Points and Functions
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#specifying-kernel-entry-points-and-functions" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  The following directives specify kernel entry points and functions.
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     .entry
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .func
    </span>
   </p>
  </li>
 </ul>
 <h3>
  <span class="section-number">
   11.2.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-and-function-directives-entry">
   Kernel and Function Directives: .entry
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-and-function-directives-entry" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  .entry
 </p>
 <p>
  Kernel entry point and body, with optional parameters.
 </p>
 <p>
  Syntax
 </p>
 <pre>.entry kernel-name ( param-list )  kernel-body
.entry kernel-name  kernel-body
</pre>
 <p>
  Description
 </p>
 <p>
  Defines a kernel entry point name, parameters, and body for the kernel function.
 </p>
 <p>
  Parameters are passed via
  <span class="pre">
   .param
  </span>
  space memory and are listed within an optional parenthesized
parameter list. Parameters may be referenced by name within the kernel body and loaded into
registers using
  <span class="pre">
   ld.param{::entry}
  </span>
  instructions.
 </p>
 <p>
  In addition to normal parameters, opaque
  <span class="pre">
   .texref
  </span>
  ,
  <span class="pre">
   .samplerref
  </span>
  , and
  <span class="pre">
   .surfref
  </span>
  variables
may be passed as parameters. These parameters can only be referenced by name within texture and
surface load, store, and query instructions and cannot be accessed via
  <span class="pre">
   ld.param
  </span>
  instructions.
 </p>
 <p>
  The shape and size of the CTA executing the kernel are available in special registers.
 </p>
 <p>
  Semantics
 </p>
 <p>
  Specify the entry point for a kernel program.
 </p>
 <p>
  At kernel launch, the kernel dimensions and properties are established and made available via
special registers, e.g.,
  <span class="pre">
   %ntid
  </span>
  ,
  <span class="pre">
   %nctaid
  </span>
  , etc.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  For PTX ISA version 1.4 and later, parameter variables are declared in the kernel parameter
list. For PTX ISA versions 1.0 through 1.3, parameter variables are declared in the kernel body.
 </p>
 <p>
  The maximum memory size supported by PTX for normal (non-opaque type) parameters is 32764
bytes. Depending upon the PTX ISA version, the parameter size limit varies. The following table
shows the allowed parameter size for a PTX ISA version:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     PTX ISA Version
    </p>
   </th>
   <th class="head">
    <p>
     Maximum parameter size (In bytes)
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     PTX ISA version 8.1 and above
    </p>
   </td>
   <td>
    <p>
     32764
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     PTX ISA version 1.5 and above
    </p>
   </td>
   <td>
    <p>
     4352
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     PTX ISA version 1.4 and above
    </p>
   </td>
   <td>
    <p>
     256
    </p>
   </td>
  </tr>
 </table>
 <p>
  The CUDA and OpenCL drivers support the following limits for parameter memory:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Driver
    </p>
   </th>
   <th class="head">
    <p>
     Parameter memory size
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     CUDA
    </p>
   </td>
   <td>
    <p>
     256 bytes for
     <span class="pre">
      sm_1x
     </span>
     , 4096 bytes for
     <span class="pre">
      sm_2x
     </span>
     <span class="pre">
      and
     </span>
     <span class="pre">
      higher
     </span>
     ,
32764 bytes fo
     <span class="pre">
      sm_70
     </span>
     and higher
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     OpenCL
    </p>
   </td>
   <td>
    <p>
     32764 bytes for
     <span class="pre">
      sm_70
     </span>
     and higher, 4352 bytes on
     <span class="pre">
      sm_6x
     </span>
     and lower
    </p>
   </td>
  </tr>
 </table>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>.entry cta_fft
.entry filter ( .param .b32 x, .param .b32 y, .param .b32 z )
{
    .reg .b32 %r&lt;99&gt;;
    ld.param.b32  %r1, [x];
    ld.param.b32  %r2, [y];
    ld.param.b32  %r3, [z];
    ...
}

.entry prefix_sum ( .param .align 4 .s32 pitch[8000] )
{
    .reg .s32 %t;
    ld.param::entry.s32  %t, [pitch];
    ...
}
</pre>
 <h3>
  <span class="section-number">
   11.2.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-and-function-directives-func">
   Kernel and Function Directives: .func
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-and-function-directives-func" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  .func
 </p>
 <p>
  Function definition.
 </p>
 <p>
  Syntax
 </p>
 <pre>.func {.attribute(attr-list)} fname {.noreturn} function-body
.func {.attribute(attr-list)} fname (param-list) {.noreturn} function-body
.func {.attribute(attr-list)} (ret-param) fname (param-list) function-body
</pre>
 <p>
  Description
 </p>
 <p>
  Defines a function, including input and return parameters and optional function body.
 </p>
 <p>
  An optional
  <span class="pre">
   .noreturn
  </span>
  directive indicates that the function does not return to the caller
function.
  <span class="pre">
   .noreturn
  </span>
  directive cannot be specified on functions which have return parameters. See
the description of
  <span class="pre">
   .noreturn
  </span>
  directive in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#performance-tuning-directives-noreturn">
   Performance-Tuning Directives: .noreturn
  </a>
  .
 </p>
 <p>
  An optional
  <span class="pre">
   .attribute
  </span>
  directive specifies additional information associated with the
function. See the description of
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#variable-and-function-attribute-directive-attribute">
   Variable and Function Attribute Directive: .attribute
  </a>
  for allowed attributes.
 </p>
 <p>
  A
  <span class="pre">
   .func
  </span>
  definition with no body provides a function prototype.
 </p>
 <p>
  The parameter lists define locally-scoped variables in the function body. Parameters must be base
types in either the register or parameter state space. Parameters in register state space may be
referenced directly within instructions in the function body. Parameters in
  <span class="pre">
   .param
  </span>
  space are
accessed using
  <span class="pre">
   ld.param{::func}
  </span>
  and
  <span class="pre">
   st.param{::func}
  </span>
  instructions in the body. Parameter
passing is call-by-value.
 </p>
 <p>
  The last parameter in the parameter list may be a
  <span class="pre">
   .param
  </span>
  array of type
  <span class="pre">
   .b8
  </span>
  with no size
specified. It is used to pass an arbitrary number of parameters to the function packed into a single
array object.
 </p>
 <p>
  When calling a function with such an unsized last argument, the last argument may be omitted from
the
  <span class="pre">
   call
  </span>
  instruction if no parameter is passed through it. Accesses to this array parameter must
be within the bounds of the array. The result of an access is undefined if no array was passed, or
if the access was outside the bounds of the actual array being passed.
 </p>
 <p>
  Semantics
 </p>
 <p>
  The PTX syntax hides all details of the underlying calling convention and ABI.
 </p>
 <p>
  The implementation of parameter passing is left to the optimizing translator, which may use a
combination of registers and stack locations to pass parameters.
 </p>
 <p>
  Release Notes
 </p>
 <p>
  For PTX ISA version 1.x code, parameters must be in the register state space, there is no stack, and
recursion is illegal.
 </p>
 <p>
  PTX ISA versions 2.0 and later with target
  <span class="pre">
   sm_20
  </span>
  or higher allow parameters in the
  <span class="pre">
   .param
  </span>
  state space, implements an ABI with stack, and supports recursion.
 </p>
 <p>
  PTX ISA versions 2.0 and later with target
  <span class="pre">
   sm_20
  </span>
  or higher support at most one return value.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Support for unsized array parameter introduced in PTX ISA version 6.0.
 </p>
 <p>
  Support for
  <span class="pre">
   .noreturn
  </span>
  directive introduced in PTX ISA version 6.4.
 </p>
 <p>
  Support for
  <span class="pre">
   .attribute
  </span>
  directive introduced in PTX ISA version 8.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Functions without unsized array parameter supported on all target architectures.
 </p>
 <p>
  Unsized array parameter requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   .noreturn
  </span>
  directive requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   .attribute
  </span>
  directive requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>.func (.reg .b32 rval) foo (.reg .b32 N, .reg .f64 dbl)
{
.reg .b32 localVar;

... use N, dbl;
other code;

mov.b32 rval,result;
ret;
}

...
call (fooval), foo, (val0, val1);  // return value in fooval
...

.func foo (.reg .b32 N, .reg .f64 dbl) .noreturn
{
.reg .b32 localVar;
... use N, dbl;
other code;
mov.b32 rval, result;
ret;
}
...
call foo, (val0, val1);
...

.func (.param .u32 rval) bar(.param .u32 N, .param .align 4 .b8 numbers[])
{
    .reg .b32 input0, input1;
    ld.param.b32   input0, [numbers + 0];
    ld.param.b32   input1, [numbers + 4];
    ...
    other code;
    ret;
}
...

.param .u32 N;
.param .align 4 .b8 numbers[8];
st.param.u32    [N], 2;
st.param.b32    [numbers + 0], 5;
st.param.b32    [numbers + 4], 10;
call (rval), bar, (N, numbers);
...
</pre>
 <h3>
  <span class="section-number">
   11.2.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-and-function-directives-alias">
   Kernel and Function Directives: .alias
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#kernel-and-function-directives-alias" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  .alias
 </p>
 <p>
  Define an alias to existing function symbol.
 </p>
 <p>
  Syntax
 </p>
 <pre>.alias fAlias, fAliasee;
</pre>
 <p>
  Description
 </p>
 <p>
  <span class="pre">
   .alias
  </span>
  is a module scope directive that defines identifier
  <span class="pre">
   fAlias
  </span>
  to be an alias to function
specified by
  <span class="pre">
   fAliasee
  </span>
  .
 </p>
 <p>
  Both
  <span class="pre">
   fAlias
  </span>
  and
  <span class="pre">
   fAliasee
  </span>
  are non-entry function symbols.
 </p>
 <p>
  Identifier
  <span class="pre">
   fAlias
  </span>
  is a function declaration without body.
 </p>
 <p>
  Identifier
  <span class="pre">
   fAliasee
  </span>
  is a function symbol which must be defined in the same module as
  <span class="pre">
   .alias
  </span>
  declaration. Function
  <span class="pre">
   fAliasee
  </span>
  cannot have
  <span class="pre">
   .weak
  </span>
  linkage.
 </p>
 <p>
  Prototype of
  <span class="pre">
   fAlias
  </span>
  and
  <span class="pre">
   fAliasee
  </span>
  must match.
 </p>
 <p>
  Program can use either
  <span class="pre">
   fAlias
  </span>
  or
  <span class="pre">
   fAlisee
  </span>
  identifiers to reference function defined with
  <span class="pre">
   fAliasee
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  <span class="pre">
   .alias
  </span>
  directive introduced in PTX ISA 6.3.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   .alias
  </span>
  directive requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>.visible .func foo(.param .u32 p) {
   ...
}
.visible .func bar(.param .u32 p);
.alias bar, foo;
.entry test()
{
      .param .u32 p;
      ...
      call foo, (p);       // call foo directly
       ...
       .param .u32 p;
       call bar, (p);        // call foo through alias
}
.entry filter ( .param .b32 x, .param .b32 y, .param .b32 z )
{
    .reg .b32 %r1, %r2, %r3;
    ld.param.b32  %r1, [x];
    ld.param.b32  %r2, [y];
    ld.param.b32  %r3, [z];
    ...
}
</pre>
 <h2>
  <span class="section-number">
   11.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-directives">
   Control Flow Directives
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-directives" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  PTX provides directives for specifying potential targets for
  <span class="pre">
   brx.idx
  </span>
  and
  <span class="pre">
   call
  </span>
  instructions. See the descriptions of
  <span class="pre">
   brx.idx
  </span>
  and
  <span class="pre">
   call
  </span>
  for more information.
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     .branchtargets
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .calltargets
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .callprototype
    </span>
   </p>
  </li>
 </ul>
 <h3>
  <span class="section-number">
   11.3.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-directives-branchtargets">
   Control Flow Directives: .branchtargets
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-directives-branchtargets" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  .branchtargets
 </p>
 <p>
  Declare a list of potential branch targets.
 </p>
 <p>
  Syntax
 </p>
 <pre>Label:   .branchtargets  list-of-labels ;
</pre>
 <p>
  Description
 </p>
 <p>
  Declares a list of potential branch targets for a subsequent
  <span class="pre">
   brx.idx
  </span>
  , and associates the list
with the label at the start of the line.
 </p>
 <p>
  All control flow labels in the list must occur within the same function as the declaration.
 </p>
 <p>
  The list of labels may use the compact, shorthand syntax for enumerating a range of labels having a
common prefix, similar to the syntax described in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parameterized-variable-names">
   Parameterized Variable Names
  </a>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.1.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>  .function foo () {
      .reg .u32 %r0;
      ...
      L1:
      ...
      L2:
      ...
      L3:
      ...
      ts: .branchtargets L1, L2, L3;
      @p brx.idx %r0, ts;
      ...

.function bar() {
      .reg .u32 %r0;
      ...
      N0:
      ...
      N1:
      ...
      N2:
      ...
      N3:
      ...
      N4:
      ...
      ts: .branchtargets N&lt;5&gt;;
      @p brx.idx %r0, ts;
      ...
</pre>
 <h3>
  <span class="section-number">
   11.3.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-directives-calltargets">
   Control Flow Directives: .calltargets
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-directives-calltargets" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  .calltargets
 </p>
 <p>
  Declare a list of potential call targets.
 </p>
 <p>
  Syntax
 </p>
 <pre>Label:   .calltargets  list-of-functions ;
</pre>
 <p>
  Description
 </p>
 <p>
  Declares a list of potential call targets for a subsequent indirect call, and associates the list
with the label at the start of the line.
 </p>
 <p>
  All functions named in the list must be declared prior to the
  <span class="pre">
   .calltargets
  </span>
  directive, and all
functions must have the same type signature.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.1.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>calltgt:  .calltargets  fastsin, fastcos;
...
@p   call  (%f1), %r0, (%x), calltgt;
...
</pre>
 <h3>
  <span class="section-number">
   11.3.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-directives-callprototype">
   Control Flow Directives: .callprototype
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#control-flow-directives-callprototype" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  .callprototype
 </p>
 <p>
  Declare a prototype for use in an indirect call.
 </p>
 <p>
  Syntax
 </p>
 <pre> // no input or return parameters
label: .callprototype _ .noreturn;
// input params, no return params
label: .callprototype _ (param-list) .noreturn;
// no input params, // return params
label: .callprototype (ret-param) _ ;
// input, return parameters
label: .callprototype (ret-param) _ (param-list);
</pre>
 <p>
  Description
 </p>
 <p>
  Defines a prototype with no specific function name, and associates the prototype with a label. The
prototype may then be used in indirect call instructions where there is incomplete knowledge of the
possible call targets.
 </p>
 <p>
  Parameters may have either base types in the register or parameter state spaces, or array types in
parameter state space. The sink symbol
  <span class="pre">
   '_'
  </span>
  may be used to avoid dummy parameter names.
 </p>
 <p>
  An optional
  <span class="pre">
   .noreturn
  </span>
  directive indicates that the function does not return to the caller
function.
  <span class="pre">
   .noreturn
  </span>
  directive cannot be specified on functions which have return parameters. See
the description of .noreturn directive in
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#performance-tuning-directives-noreturn">
   Performance-Tuning Directives: .noreturn
  </a>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.1.
 </p>
 <p>
  Support for
  <span class="pre">
   .noreturn
  </span>
  directive introduced in PTX ISA version 6.4.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  <span class="pre">
   .noreturn
  </span>
  directive requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>Fproto1: .callprototype  _ ;
Fproto2: .callprototype  _ (.param .f32 _);
Fproto3: .callprototype  (.param .u32 _) _ ;
Fproto4: .callprototype  (.param .u32 _) _ (.param .f32 _);
...
@p   call  (%val), %r0, (%f1), Fproto4;
...

// example of array parameter
Fproto5: .callprototype _ (.param .b8 _[12]);

Fproto6: .callprototype  _ (.param .f32 _) .noreturn;
...
@p   call  %r0, (%f1), Fproto6;
...
</pre>
 <h2>
  <span class="section-number">
   11.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#performance-tuning-directives">
   Performance-Tuning Directives
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#performance-tuning-directives" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  To provide a mechanism for low-level performance tuning, PTX supports the following directives,
which pass information to the backend optimizing compiler.
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     .maxnreg
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .maxntid
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .reqntid
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .minnctapersm
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .maxnctapersm
    </span>
    (deprecated)
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .pragma
    </span>
   </p>
  </li>
 </ul>
 <p>
  The
  <span class="pre">
   .maxnreg
  </span>
  directive specifies the maximum number of registers to be allocated to a single
thread; the
  <span class="pre">
   .maxntid
  </span>
  directive specifies the maximum number of threads in a thread block (CTA);
the
  <span class="pre">
   .reqntid
  </span>
  directive specifies the required number of threads in a thread block (CTA); and the
  <span class="pre">
   .minnctapersm
  </span>
  directive specifies a minimum number of thread blocks to be scheduled on a single
multiprocessor (SM). These can be used, for example, to throttle the resource requirements (e.g.,
registers) to increase total thread count and provide a greater opportunity to hide memory
latency. The
  <span class="pre">
   .minnctapersm
  </span>
  directive can be used together with either the
  <span class="pre">
   .maxntid
  </span>
  or
  <span class="pre">
   .reqntid
  </span>
  directive to trade-off registers-per-thread against multiprocessor utilization without
needed to directly specify a maximum number of registers. This may achieve better performance when
compiling PTX for multiple devices having different numbers of registers per SM.
 </p>
 <p>
  Currently, the
  <span class="pre">
   .maxnreg
  </span>
  ,
  <span class="pre">
   .maxntid
  </span>
  ,
  <span class="pre">
   .reqntid
  </span>
  , and
  <span class="pre">
   .minnctapersm
  </span>
  directives may be
applied per-entry and must appear between an
  <span class="pre">
   .entry
  </span>
  directive and its body. The directives take
precedence over any module-level constraints passed to the optimizing backend. A warning message is
generated if the directivesâ constraints are inconsistent or cannot be met for the specified target
device.
 </p>
 <p>
  A general
  <span class="pre">
   .pragma
  </span>
  directive is supported for passing information to the PTX backend. The
directive passes a list of strings to the backend, and the strings have no semantics within the PTX
virtual machine model. The interpretation of
  <span class="pre">
   .pragma
  </span>
  values is determined by the backend
implementation and is beyond the scope of the PTX ISA. Note that
  <span class="pre">
   .pragma
  </span>
  directives may appear
at module (file) scope, at entry-scope, or as statements within a kernel or device function body.
 </p>
 <h3>
  <span class="section-number">
   11.4.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#performance-tuning-directives-maxnreg">
   Performance-Tuning Directives: .maxnreg
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#performance-tuning-directives-maxnreg" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  .maxnreg
 </p>
 <p>
  Maximum number of registers that can be allocated per thread.
 </p>
 <p>
  Syntax
 </p>
 <pre>.maxnreg n
</pre>
 <p>
  Description
 </p>
 <p>
  Declare the maximum number of registers per thread in a CTA.
 </p>
 <p>
  Semantics
 </p>
 <p>
  The compiler guarantees that this limit will not be exceeded. The actual number of registers used
may be less; for example, the backend may be able to compile to fewer registers, or the maximum
number of registers may be further constrained by
  <span class="pre">
   .maxntid
  </span>
  and
  <span class="pre">
   .maxctapersm
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.3.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>.entry foo .maxnreg 16 { ... }  // max regs per thread = 16
</pre>
 <h3>
  <span class="section-number">
   11.4.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#performance-tuning-directives-maxntid">
   Performance-Tuning Directives: .maxntid
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#performance-tuning-directives-maxntid" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  .maxntid
 </p>
 <p>
  Maximum number of threads in the thread block (CTA).
 </p>
 <p>
  Syntax
 </p>
 <pre>.maxntid nx
.maxntid nx, ny
.maxntid nx, ny, nz
</pre>
 <p>
  Description
 </p>
 <p>
  Declare the maximum number of threads in the thread block (CTA). This maximum is specified by giving
the maximum extent of each dimension of the 1D, 2D, or 3D CTA.Â  The maximum number of threads is the
product of the maximum extent in each dimension.
 </p>
 <p>
  Semantics
 </p>
 <p>
  The maximum number of threads in the thread block, computed as the product of the maximum extent
specified for each dimension, is guaranteed not to be exceeded in any invocation of the kernel in
which this directive appears. Exceeding the maximum number of threads results in a runtime error or
kernel launch failure.
 </p>
 <p>
  Note that this directive guarantees that the
  total
  number of threads does not exceed the maximum,
but does not guarantee that the limit in any particular dimension is not exceeded.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.3.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>.entry foo .maxntid 256       { ... }  // max threads = 256
.entry bar .maxntid 16,16,4   { ... }  // max threads = 1024
</pre>
 <h3>
  <span class="section-number">
   11.4.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#performance-tuning-directives-reqntid">
   Performance-Tuning Directives: .reqntid
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#performance-tuning-directives-reqntid" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  .reqntid
 </p>
 <p>
  Number of threads in the thread block (CTA).
 </p>
 <p>
  Syntax
 </p>
 <pre>.reqntid nx
.reqntid nx, ny
.reqntid nx, ny, nz
</pre>
 <p>
  Description
 </p>
 <p>
  Declare the number of threads in the thread block (CTA) by specifying the extent of each dimension
of the 1D, 2D, or 3D CTA. The total number of threads is the product of the number of threads in
each dimension.
 </p>
 <p>
  Semantics
 </p>
 <p>
  The size of each CTA dimension specified in any invocation of the kernel is required to be equal to
that specified in this directive. Specifying a different CTA dimension at launch will result in a
runtime error or kernel launch failure.
 </p>
 <p>
  Notes
 </p>
 <p>
  The
  <span class="pre">
   .reqntid
  </span>
  directive cannot be used in conjunction with the
  <span class="pre">
   .maxntid
  </span>
  directive.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.1.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>.entry foo .reqntid 256       { ... }  // num threads = 256
.entry bar .reqntid 16,16,4   { ... }  // num threads = 1024
</pre>
 <h3>
  <span class="section-number">
   11.4.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#performance-tuning-directives-minnctapersm">
   Performance-Tuning Directives: .minnctapersm
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#performance-tuning-directives-minnctapersm" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  .minnctapersm
 </p>
 <p>
  Minimum number of CTAs per SM.
 </p>
 <p>
  Syntax
 </p>
 <pre>.minnctapersm ncta
</pre>
 <p>
  Description
 </p>
 <p>
  Declare the minimum number of CTAs from the kernelâs grid to be mapped to a single multiprocessor
(SM).
 </p>
 <p>
  Notes
 </p>
 <p>
  Optimizations based on
  <span class="pre">
   .minnctapersm
  </span>
  need either
  <span class="pre">
   .maxntid
  </span>
  or
  <span class="pre">
   .reqntid
  </span>
  to be specified as
well.
 </p>
 <p>
  If the total number of threads on a single SM resulting from
  <span class="pre">
   .minnctapersm
  </span>
  and
  <span class="pre">
   .maxntid
  </span>
  /
  <span class="pre">
   .reqntid
  </span>
  exceed maximum number of threads supported by an SM then directive
  <span class="pre">
   .minnctapersm
  </span>
  will be ignored.
 </p>
 <p>
  In PTX ISA version 2.1 or higher, a warning is generated if
  <span class="pre">
   .minnctapersm
  </span>
  is specified without
specifying either
  <span class="pre">
   .maxntid
  </span>
  or
  <span class="pre">
   .reqntid
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0 as a replacement for
  <span class="pre">
   .maxnctapersm
  </span>
  .
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>.entry foo .maxntid 256 .minnctapersm 4 { ... }
</pre>
 <h3>
  <span class="section-number">
   11.4.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#performance-tuning-directives-maxnctapersm">
   Performance-Tuning Directives: .maxnctapersm (deprecated)
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#performance-tuning-directives-maxnctapersm-deprecated" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  .maxnctapersm
 </p>
 <p>
  Maximum number of CTAs per SM.
 </p>
 <p>
  Syntax
 </p>
 <pre>.maxnctapersm ncta
</pre>
 <p>
  Description
 </p>
 <p>
  Declare the maximum number of CTAs from the kernelâs grid that may be mapped to a single
multiprocessor (SM).
 </p>
 <p>
  Notes
 </p>
 <p>
  Optimizations based on .maxnctapersm generally need
  <span class="pre">
   .maxntid
  </span>
  to be specified as well. The
optimizing backend compiler uses
  <span class="pre">
   .maxntid
  </span>
  and
  <span class="pre">
   .maxnctapersm
  </span>
  to compute an upper-bound on
per-thread register usage so that the specified number of CTAs can be mapped to a single
multiprocessor. However, if the number of registers used by the backend is sufficiently lower than
this bound, additional CTAs may be mapped to a single multiprocessor. For this reason,
  <span class="pre">
   .maxnctapersm
  </span>
  has been renamed to .minnctapersm in PTX ISA version 2.0.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.3. Deprecated in PTX ISA version 2.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>.entry foo .maxntid 256 .maxnctapersm 4 { ... }
</pre>
 <h3>
  <span class="section-number">
   11.4.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#performance-tuning-directives-noreturn">
   Performance-Tuning Directives: .noreturn
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#performance-tuning-directives-noreturn" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  .noreturn
 </p>
 <p>
  Indicate that the function does not return to its caller function.
 </p>
 <p>
  Syntax
 </p>
 <pre>.noreturn
</pre>
 <p>
  Description
 </p>
 <p>
  Indicate that the function does not return to its caller function.
 </p>
 <p>
  Semantics
 </p>
 <p>
  An optional
  <span class="pre">
   .noreturn
  </span>
  directive indicates that the function does not return to caller
function.
  <span class="pre">
   .noreturn
  </span>
  directive can only be specified on device functions and must appear between
a
  <span class="pre">
   .func
  </span>
  directive and its body.
 </p>
 <p>
  The directive cannot be specified on functions which have return parameters.
 </p>
 <p>
  If a function with
  <span class="pre">
   .noreturn
  </span>
  directive returns to the caller function at runtime, then the
behavior is undefined.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 6.4.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_30
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>.func foo .noreturn { ... }
</pre>
 <h3>
  <span class="section-number">
   11.4.7.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#performance-tuning-directives-pragma">
   Performance-Tuning Directives: .pragma
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#performance-tuning-directives-pragma" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  .pragma
 </p>
 <p>
  Pass directives to PTX backend compiler.
 </p>
 <p>
  Syntax
 </p>
 <pre>.pragma list-of-strings ;
</pre>
 <p>
  Description
 </p>
 <p>
  Pass module-scoped, entry-scoped, or statement-level directives to the PTX backend compiler.
 </p>
 <p>
  The
  <span class="pre">
   .pragma
  </span>
  directive may occur at module-scope, at entry-scope, or at statement-level.
 </p>
 <p>
  Semantics
 </p>
 <p>
  The interpretation of
  <span class="pre">
   .pragma
  </span>
  directive strings is implementation-specific and has no impact on
PTX semantics. See
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#descriptions-of-pragma-strings">
   Descriptions of .pragma Strings
  </a>
  for
descriptions of the pragma strings defined in
  <span class="pre">
   ptxas
  </span>
  .
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>.pragma "nounroll";    // disable unrolling in backend

// disable unrolling for current kernel
.entry foo .pragma "nounroll"; { ... }
</pre>
 <h2>
  <span class="section-number">
   11.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#debugging-directives">
   Debugging Directives
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#debugging-directives" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  DWARF-format debug information is passed through PTX modules using the following directives:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     @@DWARF
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .section
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .file
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .loc
    </span>
   </p>
  </li>
 </ul>
 <p>
  The
  <span class="pre">
   .section
  </span>
  directive was introduced in PTX ISA version 2.0 and replaces the
  <span class="pre">
   @@DWARF
  </span>
  syntax. The
  <span class="pre">
   @@DWARF
  </span>
  syntax was deprecated in PTX ISA version 2.0 but is supported for legacy PTX
ISA version 1.x code.
 </p>
 <p>
  Beginning with PTX ISA version 3.0, PTX files containing DWARF debug information should include the
  <span class="pre">
   .target
  </span>
  <span class="pre">
   debug
  </span>
  platform option. This forward declaration directs PTX compilation to retain
mappings for source-level debugging.
 </p>
 <h3>
  <span class="section-number">
   11.5.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#debugging-directives-atatdwarf">
   Debugging Directives: @@dwarf
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#debugging-directives-dwarf" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  @@dwarf
 </p>
 <p>
  DWARF-format information.
 </p>
 <p>
  Syntax
 </p>
 <pre>@@DWARF dwarf-string

dwarf-string may have one of the
.byte   byte-list   // comma-separated hexadecimal byte values
.4byte  int32-list  // comma-separated hexadecimal integers in range [0..2^32-1]
.quad   int64-list  // comma-separated hexadecimal integers in range [0..2^64-1]
.4byte  label
.quad   label
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.2. Deprecated as of PTX ISA version 2.0, replaced by
  <span class="pre">
   .section
  </span>
  directive.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>@@DWARF .section .debug_pubnames, "", @progbits
@@DWARF .byte   0x2b, 0x00, 0x00, 0x00, 0x02, 0x00
@@DWARF .4byte  .debug_info
@@DWARF .4byte  0x000006b5, 0x00000364, 0x61395a5f, 0x5f736f63
@@DWARF .4byte  0x6e69616d, 0x63613031, 0x6150736f, 0x736d6172
@@DWARF .byte   0x00, 0x00, 0x00, 0x00, 0x00
</pre>
 <h3>
  <span class="section-number">
   11.5.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#debugging-directives-section">
   Debugging Directives: .section
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#debugging-directives-section" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  .section
 </p>
 <p>
  PTX section definition.
 </p>
 <p>
  Syntax
 </p>
 <pre>.section section_name { dwarf-lines }

dwarf-lines have the following formats:
  .b8    byte-list       // comma-separated list of integers
                         // in range [-128..255]
  .b16   int16-list      // comma-separated list of integers
                         // in range [-2^15..2^16-1]
  .b32   int32-list      // comma-separated list of integers
                         // in range [-2^31..2^32-1]
  label:                 // Define label inside the debug section
  .b64   int64-list      // comma-separated list of integers
                         // in range [-2^63..2^64-1]
  .b32   label
  .b64   label
  .b32   label+imm       // a sum of label address plus a constant integer byte
                         // offset(signed, 32bit)
  .b64   label+imm       // a sum of label address plus a constant integer byte
                         // offset(signed, 64bit)
  .b32   label1-label2   // a difference in label addresses between labels in
                         // the same dwarf section (32bit)
  .b64   label3-label4   // a difference in label addresses between labels in
                         // the same dwarf section (64bit)
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0, replaces
  <span class="pre">
   @@DWARF
  </span>
  syntax.
 </p>
 <p>
  label+imm expression introduced in PTX ISA version 3.2.
 </p>
 <p>
  Support for
  <span class="pre">
   .b16
  </span>
  integers in dwarf-lines introduced in PTX ISA version 6.0.
 </p>
 <p>
  Support for defining
  <span class="pre">
   label
  </span>
  inside the DWARF section is introduced in PTX ISA version 7.2.
 </p>
 <p>
  <span class="pre">
   label1-label2
  </span>
  expression introduced in PTX ISA version 7.5.
 </p>
 <p>
  Negative numbers in dwarf lines introduced in PTX ISA version 7.5.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>.section .debug_pubnames
{
    .b32    LpubNames_end0-LpubNames_begin0
  LpubNames_begin0:
    .b8     0x2b, 0x00, 0x00, 0x00, 0x02, 0x00
    .b32    .debug_info
  info_label1:
    .b32    0x000006b5, 0x00000364, 0x61395a5f, 0x5f736f63
    .b32    0x6e69616d, 0x63613031, 0x6150736f, 0x736d6172
    .b8     0x00, 0x00, 0x00, 0x00, 0x00
  LpubNames_end0:
}

.section .debug_info
{
    .b32 11430
    .b8 2, 0
    .b32 .debug_abbrev
    .b8 8, 1, 108, 103, 101, 110, 102, 101, 58, 32, 69, 68, 71, 32, 52, 46, 49
    .b8 0
    .b32 3, 37, 176, -99
    .b32 info_label1
    .b32 .debug_loc+0x4
    .b8 -11, 11, 112, 97
    .b32 info_label1+12
    .b64 -1
    .b16 -5, -65535
}
</pre>
 <h3>
  <span class="section-number">
   11.5.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#debugging-directives-file">
   Debugging Directives: .file
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#debugging-directives-file" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  .file
 </p>
 <p>
  Source file name.
 </p>
 <p>
  Syntax
 </p>
 <pre>.file file_index "filename" {, timestamp, file_size}
</pre>
 <p>
  Description
 </p>
 <p>
  Associates a source filename with an integer index.
  <span class="pre">
   .loc
  </span>
  directives reference source files by
index.
 </p>
 <p>
  <span class="pre">
   .file
  </span>
  directive allows optionally specifying an unsigned number representing time of last
modification and an unsigned integer representing size in bytes of source file.
  <span class="pre">
   timestamp
  </span>
  and
  <span class="pre">
   file_size
  </span>
  value can be 0 to indicate this information is not available.
 </p>
 <p>
  <span class="pre">
   timestamp
  </span>
  value is in format of C and C++ data type
  <span class="pre">
   time_t
  </span>
  .
 </p>
 <p>
  <span class="pre">
   file_size
  </span>
  is an unsigned 64-bit integer.
 </p>
 <p>
  The
  <span class="pre">
   .file
  </span>
  directive is allowed only in the outermost scope, i.e., at the same level as kernel
and device function declarations.
 </p>
 <p>
  Semantics
 </p>
 <p>
  If timestamp and file size are not specified, they default to 0.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Timestamp and file size introduced in PTX ISA version 3.2.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>.file 1 "example.cu"
.file 2 "kernel.cu"
.file 1 âkernel.cuâ, 1339013327, 64118
</pre>
 <h3>
  <span class="section-number">
   11.5.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#debugging-directives-loc">
   Debugging Directives: .loc
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#debugging-directives-loc" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  .loc
 </p>
 <p>
  Source file location.
 </p>
 <p>
  Syntax
 </p>
 <pre>.loc file_index line_number column_position
.loc file_index line_number column_position,function_name label {+ immediate }, inlined_at file_index2 line_number2 column_position2
</pre>
 <p>
  Description
 </p>
 <p>
  Declares the source file location (source file, line number, and column position) to be associated
with lexically subsequent PTX instructions.
  <span class="pre">
   .loc
  </span>
  refers to
  <span class="pre">
   file_index
  </span>
  which is defined by a
  <span class="pre">
   .file
  </span>
  directive.
 </p>
 <p>
  To indicate PTX instructions that are generated from a function that got inlined, additional
attribute
  <span class="pre">
   .inlined_at
  </span>
  can be specified as part of the
  <span class="pre">
   .loc
  </span>
  directive.
  <span class="pre">
   .inlined_at
  </span>
  attribute specifies source location at which the specified function is inlined.
  <span class="pre">
   file_index2
  </span>
  ,
  <span class="pre">
   line_number2
  </span>
  , and
  <span class="pre">
   column_position2
  </span>
  specify the location at which function is inlined. Source
location specified as part of
  <span class="pre">
   .inlined_at
  </span>
  directive must lexically precede as source location in
  <span class="pre">
   .loc
  </span>
  directive.
 </p>
 <p>
  The
  <span class="pre">
   function_name
  </span>
  attribute specifies an offset in the DWARF section named
  <span class="pre">
   .debug_str
  </span>
  . Offset is specified as
  <span class="pre">
   label
  </span>
  expression or
  <span class="pre">
   label
  </span>
  <span class="pre">
   +
  </span>
  <span class="pre">
   immediate
  </span>
  expression
where
  <span class="pre">
   label
  </span>
  is defined in
  <span class="pre">
   .debug_str
  </span>
  section. DWARF section
  <span class="pre">
   .debug_str
  </span>
  contains ASCII
null-terminated strings that specify the name of the function that is inlined.
 </p>
 <p>
  Note that a PTX instruction may have a single associated source location, determined by the nearest
lexically preceding .loc directive, or no associated source location if there is no preceding .loc
directive. Labels in PTX inherit the location of the closest lexically following instruction. A
label with no following PTX instruction has no associated source location.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  <span class="pre">
   function_name
  </span>
  and
  <span class="pre">
   inlined_at
  </span>
  attributes are introduced in PTX ISA version 7.2.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>    .loc 2 4237 0
L1:                        // line 4237, col 0 of file #2,
                           // inherited from mov
    mov.u32  %r1,%r2;      // line 4237, col 0 of file #2
    add.u32  %r2,%r1,%r3;  // line 4237, col 0 of file #2
...
L2:                        // line 4239, col 5 of file #2,
                           // inherited from sub
    .loc 2 4239 5
    sub.u32  %r2,%r1,%r3;  // line 4239, col 5 of file #2
    .loc 1 21 3
    .loc 1 9 3, function_name info_string0, inlined_at 1 21 3
    ld.global.u32   %r1, [gg]; // Function at line 9
    setp.lt.s32 %p1, %r1, 8;   // inlined at line 21
    .loc 1 27 3
    .loc 1 10 5, function_name info_string1, inlined_at 1 27 3
    .loc 1 15 3, function_name .debug_str+16, inlined_at 1 10 5
    setp.ne.s32 %p2, %r1, 18;
    @%p2 bra    BB2_3;

    .section .debug_str {
    info_string0:
     .b8 95  // _
     .b8 90  // z
     .b8 51  // 3
     .b8 102 // f
     .b8 111 // o
     .b8 111 // o
     .b8 118 // v
     .b8 0

    info_string1:
     .b8 95  // _
     .b8 90  // z
     .b8 51  // 3
     .b8 98  // b
     .b8 97  // a
     .b8 114 // r
     .b8 118 // v
     .b8 0
     .b8 95  // _
     .b8 90  // z
     .b8 51  // 3
     .b8 99  // c
     .b8 97  // a
     .b8 114 // r
     .b8 118 // v
     .b8 0
    }
</pre>
 <h2>
  <span class="section-number">
   11.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#linking-directives">
   Linking Directives
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#linking-directives" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     .extern
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .visible
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .weak
    </span>
   </p>
  </li>
 </ul>
 <h3>
  <span class="section-number">
   11.6.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#linking-directives-extern">
   Linking Directives: .extern
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#linking-directives-extern" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  .extern
 </p>
 <p>
  External symbol declaration.
 </p>
 <p>
  Syntax
 </p>
 <pre>.extern identifier
</pre>
 <p>
  Description
 </p>
 <p>
  Declares identifier to be defined external to the current module. The module defining such
identifier must define it as
  <span class="pre">
   .weak
  </span>
  or
  <span class="pre">
   .visible
  </span>
  only once in a single object file. Extern
declaration of symbol may appear multiple times and references to that get resolved against the
single definition of that symbol.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>.extern .global .b32 foo;  // foo is defined in another module
</pre>
 <h3>
  <span class="section-number">
   11.6.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#linking-directives-visible">
   Linking Directives: .visible
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#linking-directives-visible" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  .visible
 </p>
 <p>
  Visible (externally) symbol declaration.
 </p>
 <p>
  Syntax
 </p>
 <pre>.visible identifier
</pre>
 <p>
  Description
 </p>
 <p>
  Declares identifier to be globally visible. Unlike C, where identifiers are globally visible unless
declared static, PTX identifiers are visible only within the current module unless declared
  <span class="pre">
   .visible
  </span>
  outside the current.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 1.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>.visible .global .b32 foo;  // foo will be externally visible
</pre>
 <h3>
  <span class="section-number">
   11.6.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#linking-directives-weak">
   Linking Directives: .weak
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#linking-directives-weak" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  .weak
 </p>
 <p>
  Visible (externally) symbol declaration.
 </p>
 <p>
  Syntax
 </p>
 <pre>.weak identifier
</pre>
 <p>
  Description
 </p>
 <p>
  Declares identifier to be globally visible but
  weak
  . Weak symbols are similar to globally visible
symbols, except during linking, weak symbols are only chosen after globally visible symbols during
symbol resolution. Unlike globally visible symbols, multiple object files may declare the same weak
symbol, and references to a symbol get resolved against a weak symbol only if no global symbols have
the same name.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 3.1.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Supported on all target architectures.
 </p>
 <p>
  Examples
 </p>
 <pre>.weak .func (.reg .b32 val) foo;  // foo will be externally visible
</pre>
 <h3>
  <span class="section-number">
   11.6.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#linking-directives-common">
   Linking Directives: .common
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#linking-directives-common" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  .common
 </p>
 <p>
  Visible (externally) symbol declaration.
 </p>
 <p>
  Syntax
 </p>
 <pre>.common identifier
</pre>
 <p>
  Description
 </p>
 <p>
  Declares identifier to be globally visible but âcommonâ.
 </p>
 <p>
  Common symbols are similar to globally visible symbols. However multiple object files may declare
the same common symbol and they may have different types and sizes and references to a symbol get
resolved against a common symbol with the largest size.
 </p>
 <p>
  Only one object file can initialize a common symbol and that must have the largest size among all
other definitions of that common symbol from different object files.
 </p>
 <p>
  <span class="pre">
   .common
  </span>
  linking directive can be used only on variables with
  <span class="pre">
   .global
  </span>
  storage. It cannot be
used on function symbols or on symbols with opaque type.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 5.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  <span class="pre">
   .common
  </span>
  directive requires
  <span class="pre">
   sm_20
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>.common .global .u32 gbl;
</pre>
 <h2>
  <span class="section-number">
   11.7.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#cluster-dimension-directives">
   Cluster Dimension Directives
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#cluster-dimension-directives" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  The following directives specify information about clusters:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     .reqnctapercluster
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .explicitcluster
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     .maxclusterrank
    </span>
   </p>
  </li>
 </ul>
 <p>
  The
  <span class="pre">
   .reqnctapercluster
  </span>
  directive specifies the number of CTAs in the cluster. The
  <span class="pre">
   .explicitcluster
  </span>
  directive specifies that the kernel should be launched with explicit cluster
details. The
  <span class="pre">
   .maxclusterrank
  </span>
  directive specifies the maximum number of CTAs in the cluster.
 </p>
 <p>
  The cluster dimension directives can be applied only on kernel functions.
 </p>
 <h3>
  <span class="section-number">
   11.7.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#cluster-dimension-directives-reqnctapercluster">
   Cluster Dimension Directives: .reqnctapercluster
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#cluster-dimension-directives-reqnctapercluster" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  .reqnctapercluster
 </p>
 <p>
  Declare the number of CTAs in the cluster.
 </p>
 <p>
  Syntax
 </p>
 <pre>.reqnctapercluster nx
.reqnctapercluster nx, ny
.reqnctapercluster nx, ny, nz
</pre>
 <p>
  Description
 </p>
 <p>
  Set the number of thread blocks (CTAs) in the cluster by specifying the extent of each dimension of
the 1D, 2D, or 3D cluster. The total number of CTAs is the product of the number of CTAs in each
dimension. For kernels with
  <span class="pre">
   .reqnctapercluster
  </span>
  directive specified, runtime will use the
specified values for configuring the launch if the same are not specified at launch time.
 </p>
 <p>
  Semantics
 </p>
 <p>
  If cluster dimension is explicitly specified at launch time, it should be equal to the values
specified in this directive. Specifying a different cluster dimension at launch will result in a
runtime error or kernel launch failure.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.8.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>.entry foo .reqnctapercluster 2         { . . . }
.entry bar .reqnctapercluster 2, 2, 1   { . . . }
.entry ker .reqnctapercluster 3, 2      { . . . }
</pre>
 <h3>
  <span class="section-number">
   11.7.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#cluster-dimension-directives-explicitcluster">
   Cluster Dimension Directives: .explicitcluster
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#cluster-dimension-directives-explicitcluster" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  .explicitcluster
 </p>
 <p>
  Declare that Kernel must be launched with cluster dimensions explicitly specified.
 </p>
 <p>
  Syntax
 </p>
 <pre>.explicitcluster
</pre>
 <p>
  Description
 </p>
 <p>
  Declares that this Kernel should be launched with cluster dimension explicitly specified.
 </p>
 <p>
  Semantics
 </p>
 <p>
  Kernels with
  <span class="pre">
   .explicitcluster
  </span>
  directive must be launched with cluster dimension explicitly
specified (either at launch time or via
  <span class="pre">
   .reqnctapercluster
  </span>
  ), otherwise program will fail with
runtime error or kernel launch failure.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.8.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>.entry foo .explicitcluster         { . . . }
</pre>
 <h3>
  <span class="section-number">
   11.7.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#cluster-dimension-directives-maxclusterrank">
   Cluster Dimension Directives: .maxclusterrank
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#cluster-dimension-directives-maxclusterrank" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  .maxclusterrank
 </p>
 <p>
  Declare the maximum number of CTAs that can be part of the cluster.
 </p>
 <p>
  Syntax
 </p>
 <pre>.maxclusterrank n
</pre>
 <p>
  Description
 </p>
 <p>
  Declare the maximum number of thread blocks (CTAs) allowed to be part of the cluster.
 </p>
 <p>
  Semantics
 </p>
 <p>
  Product of the number of CTAs in each cluster dimension specified in any invocation of the kernel is
required to be less or equal to that specified in this directive. Otherwise invocation will result
in a runtime error or kernel launch failure.
 </p>
 <p>
  The
  <span class="pre">
   .maxclusterrank
  </span>
  directive cannot be used in conjunction with the
  <span class="pre">
   .reqnctapercluster
  </span>
  directive.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 7.8.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_90
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>.entry foo ..maxclusterrank 8         { . . . }
</pre>
 <h1>
  <span class="section-number">
   12.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#release-notes">
   Release Notes
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#release-notes" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <p>
  This section describes the history of change in the PTX ISA and implementation. The first section
describes ISA and implementation changes in the current release of PTX ISA version 8.5, and the
remaining sections provide a record of changes in previous releases of PTX ISA versions back to PTX
ISA version 2.0.
 </p>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#release-notes-ptx-release-history">
   <span class="std std-numref">
    Table 32
   </span>
  </a>
  shows the PTX release history.
 </p>
 <table class="table-no-stripes docutils align-default" id="release-notes-ptx-release-history">
  <span class="caption-number">
   Table 32
  </span>
  <span class="caption-text">
   PTX Release History
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#release-notes-ptx-release-history" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     PTX ISA Version
    </p>
   </th>
   <th class="head">
    <p>
     CUDA Release
    </p>
   </th>
   <th class="head">
    <p>
     Supported Targets
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     PTX ISA 1.0
    </p>
   </td>
   <td>
    <p>
     CUDA 1.0
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11}
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     PTX ISA 1.1
    </p>
   </td>
   <td>
    <p>
     CUDA 1.1
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11}
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     PTX ISA 1.2
    </p>
   </td>
   <td>
    <p>
     CUDA 2.0
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     PTX ISA 1.3
    </p>
   </td>
   <td>
    <p>
     CUDA 2.1
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     PTX ISA 1.4
    </p>
   </td>
   <td>
    <p>
     CUDA 2.2
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     PTX ISA 1.5
    </p>
   </td>
   <td>
    <p>
     driver r190
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     PTX ISA 2.0
    </p>
   </td>
   <td>
    <p>
     CUDA 3.0, driver r195
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     PTX ISA 2.1
    </p>
   </td>
   <td>
    <p>
     CUDA 3.1, driver r256
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     PTX ISA 2.2
    </p>
   </td>
   <td>
    <p>
     CUDA 3.2, driver r260
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     PTX ISA 2.3
    </p>
   </td>
   <td>
    <p>
     CUDA 4.0, driver r270
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td rowspan="2">
    <p>
     PTX ISA 3.0
    </p>
   </td>
   <td>
    <p>
     CUDA 4.1, driver r285
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     CUDA 4.2, driver r295
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_30
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     PTX ISA 3.1
    </p>
   </td>
   <td>
    <p>
     CUDA 5.0, driver r302
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_{30,35}
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     PTX ISA 3.2
    </p>
   </td>
   <td>
    <p>
     CUDA 5.5, driver r319
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_{30,35}
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     PTX ISA 4.0
    </p>
   </td>
   <td>
    <p>
     CUDA 6.0, driver r331
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_{30,32,35}
     </span>
     ,
     <span class="pre">
      sm_50
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     PTX ISA 4.1
    </p>
   </td>
   <td>
    <p>
     CUDA 6.5, driver r340
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_{30,32,35,37}
     </span>
     ,
     <span class="pre">
      sm_{50,52}
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     PTX ISA 4.2
    </p>
   </td>
   <td>
    <p>
     CUDA 7.0, driver r346
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_{30,32,35,37}
     </span>
     ,
     <span class="pre">
      sm_{50,52,53}
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     PTX ISA 4.3
    </p>
   </td>
   <td>
    <p>
     CUDA 7.5, driver r352
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_{30,32,35,37}
     </span>
     ,
     <span class="pre">
      sm_{50,52,53}
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     PTX ISA 5.0
    </p>
   </td>
   <td>
    <p>
     CUDA 8.0, driver r361
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_{30,32,35,37}
     </span>
     ,
     <span class="pre">
      sm_{50,52,53}
     </span>
     ,
     <span class="pre">
      sm_{60,61,62}
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     PTX ISA 6.0
    </p>
   </td>
   <td>
    <p>
     CUDA 9.0, driver r384
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_{30,32,35,37}
     </span>
     ,
     <span class="pre">
      sm_{50,52,53}
     </span>
     ,
     <span class="pre">
      sm_{60,61,62}
     </span>
     ,
     <span class="pre">
      sm_70
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     PTX ISA 6.1
    </p>
   </td>
   <td>
    <p>
     CUDA 9.1, driver r387
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_{30,32,35,37}
     </span>
     ,
     <span class="pre">
      sm_{50,52,53}
     </span>
     ,
     <span class="pre">
      sm_{60,61,62}
     </span>
     ,
     <span class="pre">
      sm_70
     </span>
     ,
     <span class="pre">
      sm_72
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     PTX ISA 6.2
    </p>
   </td>
   <td>
    <p>
     CUDA 9.2, driver r396
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_{30,32,35,37}
     </span>
     ,
     <span class="pre">
      sm_{50,52,53}
     </span>
     ,
     <span class="pre">
      sm_{60,61,62}
     </span>
     ,
     <span class="pre">
      sm_70
     </span>
     ,
     <span class="pre">
      sm_72
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     PTX ISA 6.3
    </p>
   </td>
   <td>
    <p>
     CUDA 10.0, driver r400
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_{30,32,35,37}
     </span>
     ,
     <span class="pre">
      sm_{50,52,53}
     </span>
     ,
     <span class="pre">
      sm_{60,61,62}
     </span>
     ,
     <span class="pre">
      sm_70
     </span>
     ,
     <span class="pre">
      sm_72
     </span>
     ,
     <span class="pre">
      sm_75
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     PTX ISA 6.4
    </p>
   </td>
   <td>
    <p>
     CUDA 10.1, driver r418
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_{30,32,35,37}
     </span>
     ,
     <span class="pre">
      sm_{50,52,53}
     </span>
     ,
     <span class="pre">
      sm_{60,61,62}
     </span>
     ,
     <span class="pre">
      sm_70
     </span>
     ,
     <span class="pre">
      sm_72
     </span>
     ,
     <span class="pre">
      sm_75
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     PTX ISA 6.5
    </p>
   </td>
   <td>
    <p>
     CUDA 10.2, driver r440
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_{30,32,35,37}
     </span>
     ,
     <span class="pre">
      sm_{50,52,53}
     </span>
     ,
     <span class="pre">
      sm_{60,61,62}
     </span>
     ,
     <span class="pre">
      sm_70
     </span>
     ,
     <span class="pre">
      sm_72
     </span>
     ,
     <span class="pre">
      sm_75
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     PTX ISA 7.0
    </p>
   </td>
   <td>
    <p>
     CUDA 11.0, driver r445
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_{30,32,35,37}
     </span>
     ,
     <span class="pre">
      sm_{50,52,53}
     </span>
     ,
     <span class="pre">
      sm_{60,61,62}
     </span>
     ,
     <span class="pre">
      sm_{70,72,75}
     </span>
     ,
     <span class="pre">
      sm_80
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     PTX ISA 7.1
    </p>
   </td>
   <td>
    <p>
     CUDA 11.1, driver r455
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_{30,32,35,37}
     </span>
     ,
     <span class="pre">
      sm_{50,52,53}
     </span>
     ,
     <span class="pre">
      sm_{60,61,62}
     </span>
     ,
     <span class="pre">
      sm_{70,72,75}
     </span>
     ,
     <span class="pre">
      sm_{80,86}
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     PTX ISA 7.2
    </p>
   </td>
   <td>
    <p>
     CUDA 11.2, driver r460
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_{30,32,35,37}
     </span>
     ,
     <span class="pre">
      sm_{50,52,53}
     </span>
     ,
     <span class="pre">
      sm_{60,61,62}
     </span>
     ,
     <span class="pre">
      sm_{70,72,75}
     </span>
     ,
     <span class="pre">
      sm_{80,86}
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     PTX ISA 7.3
    </p>
   </td>
   <td>
    <p>
     CUDA 11.3, driver r465
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_{30,32,35,37}
     </span>
     ,
     <span class="pre">
      sm_{50,52,53}
     </span>
     ,
     <span class="pre">
      sm_{60,61,62}
     </span>
     ,
     <span class="pre">
      sm_{70,72,75}
     </span>
     ,
     <span class="pre">
      sm_{80,86}
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     PTX ISA 7.4
    </p>
   </td>
   <td>
    <p>
     CUDA 11.4, driver r470
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_{30,32,35,37}
     </span>
     ,
     <span class="pre">
      sm_{50,52,53}
     </span>
     ,
     <span class="pre">
      sm_{60,61,62}
     </span>
     ,
     <span class="pre">
      sm_{70,72,75}
     </span>
     ,
     <span class="pre">
      sm_{80,86,87}
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     PTX ISA 7.5
    </p>
   </td>
   <td>
    <p>
     CUDA 11.5, driver r495
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_{30,32,35,37}
     </span>
     ,
     <span class="pre">
      sm_{50,52,53}
     </span>
     ,
     <span class="pre">
      sm_{60,61,62}
     </span>
     ,
     <span class="pre">
      sm_{70,72,75}
     </span>
     ,
     <span class="pre">
      sm_{80,86,87}
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     PTX ISA 7.6
    </p>
   </td>
   <td>
    <p>
     CUDA 11.6, driver r510
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_{30,32,35,37}
     </span>
     ,
     <span class="pre">
      sm_{50,52,53}
     </span>
     ,
     <span class="pre">
      sm_{60,61,62}
     </span>
     ,
     <span class="pre">
      sm_{70,72,75}
     </span>
     ,
     <span class="pre">
      sm_{80,86,87}
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     PTX ISA 7.7
    </p>
   </td>
   <td>
    <p>
     CUDA 11.7, driver r515
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_{30,32,35,37}
     </span>
     ,
     <span class="pre">
      sm_{50,52,53}
     </span>
     ,
     <span class="pre">
      sm_{60,61,62}
     </span>
     ,
     <span class="pre">
      sm_{70,72,75}
     </span>
     ,
     <span class="pre">
      sm_{80,86,87}
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     PTX ISA 7.8
    </p>
   </td>
   <td>
    <p>
     CUDA 11.8, driver r520
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_{30,32,35,37}
     </span>
     ,
     <span class="pre">
      sm_{50,52,53}
     </span>
     ,
     <span class="pre">
      sm_{60,61,62}
     </span>
     ,
     <span class="pre">
      sm_{70,72,75}
     </span>
     ,
     <span class="pre">
      sm_{80,86,87,89}
     </span>
     ,
     <span class="pre">
      sm_90
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     PTX ISA 8.0
    </p>
   </td>
   <td>
    <p>
     CUDA 12.0, driver r525
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_{30,32,35,37}
     </span>
     ,
     <span class="pre">
      sm_{50,52,53}
     </span>
     ,
     <span class="pre">
      sm_{60,61,62}
     </span>
     ,
     <span class="pre">
      sm_{70,72,75}
     </span>
     ,
     <span class="pre">
      sm_{80,86,87,89}
     </span>
     ,
     <span class="pre">
      sm_{90,90a}
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     PTX ISA 8.1
    </p>
   </td>
   <td>
    <p>
     CUDA 12.1, driver r530
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_{30,32,35,37}
     </span>
     ,
     <span class="pre">
      sm_{50,52,53}
     </span>
     ,
     <span class="pre">
      sm_{60,61,62}
     </span>
     ,
     <span class="pre">
      sm_{70,72,75}
     </span>
     ,
     <span class="pre">
      sm_{80,86,87,89}
     </span>
     ,
     <span class="pre">
      sm_{90,90a}
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     PTX ISA 8.2
    </p>
   </td>
   <td>
    <p>
     CUDA 12.2, driver r535
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_{30,32,35,37}
     </span>
     ,
     <span class="pre">
      sm_{50,52,53}
     </span>
     ,
     <span class="pre">
      sm_{60,61,62}
     </span>
     ,
     <span class="pre">
      sm_{70,72,75}
     </span>
     ,
     <span class="pre">
      sm_{80,86,87,89}
     </span>
     ,
     <span class="pre">
      sm_{90,90a}
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     PTX ISA 8.3
    </p>
   </td>
   <td>
    <p>
     CUDA 12.3, driver r545
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_{30,32,35,37}
     </span>
     ,
     <span class="pre">
      sm_{50,52,53}
     </span>
     ,
     <span class="pre">
      sm_{60,61,62}
     </span>
     ,
     <span class="pre">
      sm_{70,72,75}
     </span>
     ,
     <span class="pre">
      sm_{80,86,87,89}
     </span>
     ,
     <span class="pre">
      sm_{90,90a}
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     PTX ISA 8.4
    </p>
   </td>
   <td>
    <p>
     CUDA 12.4, driver r550
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_{30,32,35,37}
     </span>
     ,
     <span class="pre">
      sm_{50,52,53}
     </span>
     ,
     <span class="pre">
      sm_{60,61,62}
     </span>
     ,
     <span class="pre">
      sm_{70,72,75}
     </span>
     ,
     <span class="pre">
      sm_{80,86,87,89}
     </span>
     ,
     <span class="pre">
      sm_{90,90a}
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     PTX ISA 8.5
    </p>
   </td>
   <td>
    <p>
     CUDA 12.5, driver r555
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      sm_{10,11,12,13}
     </span>
     ,
     <span class="pre">
      sm_20
     </span>
     ,
     <span class="pre">
      sm_{30,32,35,37}
     </span>
     ,
     <span class="pre">
      sm_{50,52,53}
     </span>
     ,
     <span class="pre">
      sm_{60,61,62}
     </span>
     ,
     <span class="pre">
      sm_{70,72,75}
     </span>
     ,
     <span class="pre">
      sm_{80,86,87,89}
     </span>
     ,
     <span class="pre">
      sm_{90,90a}
     </span>
    </p>
   </td>
  </tr>
 </table>
 <h2>
  <span class="section-number">
   12.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-8-5">
   Changes in PTX ISA Version 8.5
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-8-5" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX ISA version 8.5 introduces the following new features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Adds support for
    <span class="pre">
     mma.sp::ordered_metadata
    </span>
    instruction.
   </p>
  </li>
 </ul>
 <p>
  Semantic Changes and Clarifications
 </p>
 <ul class="simple">
  <li>
   <p>
    Values
    <span class="pre">
     0b0000
    </span>
    ,
    <span class="pre">
     0b0101
    </span>
    ,
    <span class="pre">
     0b1010
    </span>
    ,
    <span class="pre">
     0b1111
    </span>
    for sparsity metadata (operand
    <span class="pre">
     e
    </span>
    )
of instruction
    <span class="pre">
     mma.sp
    </span>
    are invalid and their usage results in undefined behavior.
   </p>
  </li>
 </ul>
 <h2>
  <span class="section-number">
   12.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-8-4">
   Changes in PTX ISA Version 8.4
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-8-4" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX ISA version 8.4 introduces the following new features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Extends
    <span class="pre">
     ld
    </span>
    ,
    <span class="pre">
     st
    </span>
    and
    <span class="pre">
     atom
    </span>
    instructions with
    <span class="pre">
     .b128
    </span>
    type to support
    <span class="pre">
     .sys
    </span>
    scope.
   </p>
  </li>
  <li>
   <p>
    Extends integer
    <span class="pre">
     wgmma.mma_async
    </span>
    instruction to support
    <span class="pre">
     .u8.s8
    </span>
    and
    <span class="pre">
     .s8.u8
    </span>
    as
    <span class="pre">
     .atype
    </span>
    and
    <span class="pre">
     .btype
    </span>
    respectively.
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     mma
    </span>
    ,
    <span class="pre">
     mma.sp
    </span>
    instructions to support FP8 types
    <span class="pre">
     .e4m3
    </span>
    and
    <span class="pre">
     .e5m2
    </span>
    .
   </p>
  </li>
 </ul>
 <p>
  Semantic Changes and Clarifications
 </p>
 <p>
  None.
 </p>
 <h2>
  <span class="section-number">
   12.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-8-3">
   Changes in PTX ISA Version 8.3
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-8-3" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX ISA version 8.3 introduces the following new features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Adds support for pragma
    <span class="pre">
     used_bytes_mask
    </span>
    that is used to specify mask for used bytes for a load operation.
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     isspacep
    </span>
    ,
    <span class="pre">
     cvta.to
    </span>
    ,
    <span class="pre">
     ld
    </span>
    and
    <span class="pre">
     st
    </span>
    instructions to accept
    <span class="pre">
     ::entry
    </span>
    and
    <span class="pre">
     ::func
    </span>
    sub-qualifiers with
    <span class="pre">
     .param
    </span>
    state space qualifier.
   </p>
  </li>
  <li>
   <p>
    Adds support for
    <span class="pre">
     .b128
    </span>
    type on instructions
    <span class="pre">
     ld
    </span>
    ,
    <span class="pre">
     ld.global.nc
    </span>
    ,
    <span class="pre">
     ldu
    </span>
    ,
    <span class="pre">
     st
    </span>
    ,
    <span class="pre">
     mov
    </span>
    and
    <span class="pre">
     atom
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Add support for instructions
    <span class="pre">
     tensormap.replace
    </span>
    ,
    <span class="pre">
     tensormap.cp_fenceproxy
    </span>
    and support for qualifier
    <span class="pre">
     .to_proxykind::from_proxykind
    </span>
    on instruction
    <span class="pre">
     fence.proxy
    </span>
    to support modifying
    <span class="pre">
     tensor-map
    </span>
    .
   </p>
  </li>
 </ul>
 <p>
  Semantic Changes and Clarifications
 </p>
 <p>
  None.
 </p>
 <h2>
  <span class="section-number">
   12.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-8-2">
   Changes in PTX ISA Version 8.2
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-8-2" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX ISA version 8.2 introduces the following new features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Adds support for
    <span class="pre">
     .mmio
    </span>
    qualifier on
    <span class="pre">
     ld
    </span>
    and
    <span class="pre">
     st
    </span>
    instructions.
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     lop3
    </span>
    instruction to allow predicate destination.
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     multimem.ld_reduce
    </span>
    instruction to support
    <span class="pre">
     .acc::f32
    </span>
    qualifer to allow
    <span class="pre">
     .f32
    </span>
    precision of the intermediate accumulation.
   </p>
  </li>
  <li>
   <p>
    Extends the asynchronous warpgroup-level matrix multiply-and-accumulate operation
    <span class="pre">
     wgmma.mma_async
    </span>
    to support
    <span class="pre">
     .sp
    </span>
    modifier that allows matrix multiply-accumulate operation
when input matrix A is sparse.
   </p>
  </li>
 </ul>
 <p>
  Semantic Changes and Clarifications
 </p>
 <p>
  The
  <span class="pre">
   .multicast::cluster
  </span>
  qualifier on
  <span class="pre">
   cp.async.bulk
  </span>
  and
  <span class="pre">
   cp.async.bulk.tensor
  </span>
  instructions
is optimized for target architecture
  <span class="pre">
   sm_90a
  </span>
  and may have substantially reduced performance on
other targets and hence
  <span class="pre">
   .multicast::cluster
  </span>
  is advised to be used with
  <span class="pre">
   sm_90a
  </span>
  .
 </p>
 <h2>
  <span class="section-number">
   12.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-8-1">
   Changes in PTX ISA Version 8.1
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-8-1" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX ISA version 8.1 introduces the following new features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Adds support for
    <span class="pre">
     st.async
    </span>
    and
    <span class="pre">
     red.async
    </span>
    instructions for asynchronous store and
asynchronous reduction operations respectively on shared memory.
   </p>
  </li>
  <li>
   <p>
    Adds support for
    <span class="pre">
     .oob
    </span>
    modifier on half-precision
    <span class="pre">
     fma
    </span>
    instruction.
   </p>
  </li>
  <li>
   <p>
    Adds support for
    <span class="pre">
     .satfinite
    </span>
    saturation modifer on
    <span class="pre">
     cvt
    </span>
    instruction for
    <span class="pre">
     .f16
    </span>
    ,
    <span class="pre">
     .bf16
    </span>
    and
    <span class="pre">
     .tf32
    </span>
    formats.
   </p>
  </li>
  <li>
   <p>
    Extends support for
    <span class="pre">
     cvt
    </span>
    with
    <span class="pre">
     .e4m3
    </span>
    /
    <span class="pre">
     .e5m2
    </span>
    to
    <span class="pre">
     sm_89
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     atom
    </span>
    and
    <span class="pre">
     red
    </span>
    instructions to support vector types.
   </p>
  </li>
  <li>
   <p>
    Adds support for special register
    <span class="pre">
     %aggr_smem_size
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     sured
    </span>
    instruction with 64-bit
    <span class="pre">
     min
    </span>
    /
    <span class="pre">
     max
    </span>
    operations.
   </p>
  </li>
  <li>
   <p>
    Adds support for increased kernel parameter size of 32764 bytes.
   </p>
  </li>
  <li>
   <p>
    Adds support for multimem addresses in memory consistency model.
   </p>
  </li>
  <li>
   <p>
    Adds support for
    <span class="pre">
     multimem.ld_reduce
    </span>
    ,
    <span class="pre">
     multimem.st
    </span>
    and
    <span class="pre">
     multimem.red
    </span>
    instructions to
perform memory operations on multimem addresses.
   </p>
  </li>
 </ul>
 <p>
  Semantic Changes and Clarifications
 </p>
 <p>
  None.
 </p>
 <h2>
  <span class="section-number">
   12.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-8-0">
   Changes in PTX ISA Version 8.0
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-8-0" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX ISA version 8.0 introduces the following new features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Adds support for target
    <span class="pre">
     sm_90a
    </span>
    that supports specialized accelerated features.
   </p>
  </li>
  <li>
   <p>
    Adds support for asynchronous warpgroup-level matrix multiply-and-accumulate operation
    <span class="pre">
     wgmma
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Extends the asynchronous copy operations with bulk operations that operate on large data,
including tensor data.
   </p>
  </li>
  <li>
   <p>
    Introduces packed integer types
    <span class="pre">
     .u16x2
    </span>
    and
    <span class="pre">
     .s16x2
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Extends integer arithmetic instruction
    <span class="pre">
     add
    </span>
    to allow packed integer types
    <span class="pre">
     .u16x2
    </span>
    and
    <span class="pre">
     .s16x2
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Extends integer arithmetic instructions
    <span class="pre">
     min
    </span>
    and
    <span class="pre">
     max
    </span>
    to allow packed integer types
    <span class="pre">
     .u16x2
    </span>
    and
    <span class="pre">
     .s16x2
    </span>
    , as well as saturation modifier
    <span class="pre">
     .relu
    </span>
    on
    <span class="pre">
     .s16x2
    </span>
    and
    <span class="pre">
     .s32
    </span>
    types.
   </p>
  </li>
  <li>
   <p>
    Adds support for special register
    <span class="pre">
     %current_graph_exec
    </span>
    that identifies the currently executing
CUDA device graph.
   </p>
  </li>
  <li>
   <p>
    Adds support for
    <span class="pre">
     elect.sync
    </span>
    instruction.
   </p>
  </li>
  <li>
   <p>
    Adds support for
    <span class="pre">
     .unified
    </span>
    attribute on functions and variables.
   </p>
  </li>
  <li>
   <p>
    Adds support for
    <span class="pre">
     setmaxnreg
    </span>
    instruction.
   </p>
  </li>
  <li>
   <p>
    Adds support for
    <span class="pre">
     .sem
    </span>
    qualifier on
    <span class="pre">
     barrier.cluster
    </span>
    instruction.
   </p>
  </li>
  <li>
   <p>
    Extends the
    <span class="pre">
     fence
    </span>
    instruction to allow opcode-specific synchronizaion using
    <span class="pre">
     op_restrict
    </span>
    qualifier.
   </p>
  </li>
  <li>
   <p>
    Adds support for
    <span class="pre">
     .cluster
    </span>
    scope on
    <span class="pre">
     mbarrier.arrive
    </span>
    ,
    <span class="pre">
     mbarrier.arrive_drop
    </span>
    ,
    <span class="pre">
     mbarrier.test_wait
    </span>
    and
    <span class="pre">
     mbarrier.try_wait
    </span>
    operations.
   </p>
  </li>
  <li>
   <p>
    Adds support for transaction count operations on
    <span class="pre">
     mbarrier
    </span>
    objects, specified with
    <span class="pre">
     .expect_tx
    </span>
    and
    <span class="pre">
     .complete_tx
    </span>
    qualifiers.
   </p>
  </li>
 </ul>
 <p>
  Semantic Changes and Clarifications
 </p>
 <p>
  None.
 </p>
 <h2>
  <span class="section-number">
   12.7.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-7-8">
   Changes in PTX ISA Version 7.8
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-7-8" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX ISA version 7.8 introduces the following new features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Adds support for
    <span class="pre">
     sm_89
    </span>
    target architecture.
   </p>
  </li>
  <li>
   <p>
    Adds support for
    <span class="pre">
     sm_90
    </span>
    target architecture.
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     bar
    </span>
    and
    <span class="pre">
     barrier
    </span>
    instructions to accept optional scope qualifier
    <span class="pre">
     .cta
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     .shared
    </span>
    state space qualifier with optional sub-qualifier
    <span class="pre">
     ::cta
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Adds support for
    <span class="pre">
     movmatrix
    </span>
    instruction which transposes a matrix in registers across a warp.
   </p>
  </li>
  <li>
   <p>
    Adds support for
    <span class="pre">
     stmatrix
    </span>
    instruction which stores one or more matrices to shared memory.
   </p>
  </li>
  <li>
   <p>
    Extends the
    <span class="pre">
     .f64
    </span>
    floating point type
    <span class="pre">
     mma
    </span>
    operation with shapes
    <span class="pre">
     .m16n8k4
    </span>
    ,
    <span class="pre">
     .m16n8k8
    </span>
    ,
and
    <span class="pre">
     .m16n8k16
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     add
    </span>
    ,
    <span class="pre">
     sub
    </span>
    ,
    <span class="pre">
     mul
    </span>
    ,
    <span class="pre">
     set
    </span>
    ,
    <span class="pre">
     setp
    </span>
    ,
    <span class="pre">
     cvt
    </span>
    ,
    <span class="pre">
     tanh
    </span>
    ,
    <span class="pre">
     ex2
    </span>
    ,
    <span class="pre">
     atom
    </span>
    and
    <span class="pre">
     red
    </span>
    instructions with
    <span class="pre">
     bf16
    </span>
    alternate floating point data format.
   </p>
  </li>
  <li>
   <p>
    Adds support for new alternate floating-point data formats
    <span class="pre">
     .e4m3
    </span>
    and
    <span class="pre">
     .e5m2
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     cvt
    </span>
    instruction to convert
    <span class="pre">
     .e4m3
    </span>
    and
    <span class="pre">
     .e5m2
    </span>
    alternate floating point data formats.
   </p>
  </li>
  <li>
   <p>
    Adds support for
    <span class="pre">
     griddepcontrol
    </span>
    instruction as a communication mechanism to control the
execution of dependent grids.
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     mbarrier
    </span>
    instruction to allow a new phase completion check operation
    try_wait
    .
   </p>
  </li>
  <li>
   <p>
    Adds support for new thread scope
    <span class="pre">
     .cluster
    </span>
    which is a set of Cooperative Thread Arrays (CTAs).
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     fence
    </span>
    /
    <span class="pre">
     membar
    </span>
    ,
    <span class="pre">
     ld
    </span>
    ,
    <span class="pre">
     st
    </span>
    ,
    <span class="pre">
     atom
    </span>
    , and
    <span class="pre">
     red
    </span>
    instructions to accept
    <span class="pre">
     .cluster
    </span>
    scope.
   </p>
  </li>
  <li>
   <p>
    Adds support for extended visibility of shared state space to all threads within a cluster.
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     .shared
    </span>
    state space qualifier with
    <span class="pre">
     ::cluster
    </span>
    sub-qualifier for cluster-level
visibility of shared memory.
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     isspacep
    </span>
    ,
    <span class="pre">
     cvta
    </span>
    ,
    <span class="pre">
     ld
    </span>
    ,
    <span class="pre">
     st
    </span>
    ,
    <span class="pre">
     atom
    </span>
    , and
    <span class="pre">
     red
    </span>
    instructions to accept
    <span class="pre">
     ::cluster
    </span>
    sub-qualifier with
    <span class="pre">
     .shared
    </span>
    state space qualifier.
   </p>
  </li>
  <li>
   <p>
    Adds support for
    <span class="pre">
     mapa
    </span>
    instruction to map a shared memory address to the corresponding address
in a different CTA within the cluster.
   </p>
  </li>
  <li>
   <p>
    Adds support for
    <span class="pre">
     getctarank
    </span>
    instruction to query the rank of the CTA that contains a given
address.
   </p>
  </li>
  <li>
   <p>
    Adds support for new barrier synchronization instruction
    <span class="pre">
     barrier.cluster
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Extends the memory consistency model to include the new cluster scope.
   </p>
  </li>
  <li>
   <p>
    Adds support for special registers related to cluster information:
    <span class="pre">
     %is_explicit_cluster
    </span>
    ,
    <span class="pre">
     %clusterid
    </span>
    ,
    <span class="pre">
     %nclusterid
    </span>
    ,
    <span class="pre">
     %cluster_ctaid
    </span>
    ,
    <span class="pre">
     %cluster_nctaid
    </span>
    ,
    <span class="pre">
     %cluster_ctarank
    </span>
    ,
    <span class="pre">
     %cluster_nctarank
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Adds support for cluster dimension directives
    <span class="pre">
     .reqnctapercluster
    </span>
    ,
    <span class="pre">
     .explicitcluster
    </span>
    , and
    <span class="pre">
     .maxclusterrank
    </span>
    .
   </p>
  </li>
 </ul>
 <p>
  Semantic Changes and Clarifications
 </p>
 <p>
  None.
 </p>
 <h2>
  <span class="section-number">
   12.8.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-7-7">
   Changes in PTX ISA Version 7.7
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-7-7" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX ISA version 7.7 introduces the following new features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Extends
    <span class="pre">
     isspacep
    </span>
    and
    <span class="pre">
     cvta
    </span>
    instructions to include the
    <span class="pre">
     .param
    </span>
    state space for kernel
function parameters.
   </p>
  </li>
 </ul>
 <p>
  Semantic Changes and Clarifications
 </p>
 <p>
  None.
 </p>
 <h2>
  <span class="section-number">
   12.9.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-7-6">
   Changes in PTX ISA Version 7.6
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-7-6" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX ISA version 7.6 introduces the following new features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Support for
    <span class="pre">
     szext
    </span>
    instruction which performs sign-extension or zero-extension on a specified
value.
   </p>
  </li>
  <li>
   <p>
    Support for
    <span class="pre">
     bmsk
    </span>
    instruction which creates a bitmask of the specified width starting at the
specified bit position.
   </p>
  </li>
  <li>
   <p>
    Support for special registers
    <span class="pre">
     %reserved_smem_offset_begin
    </span>
    ,
    <span class="pre">
     %reserved_smem_offset_end
    </span>
    ,
    <span class="pre">
     %reserved_smem_offset_cap
    </span>
    ,
    <span class="pre">
     %reserved_smem_offset&lt;2&gt;
    </span>
    .
   </p>
  </li>
 </ul>
 <p>
  Semantic Changes and Clarifications
 </p>
 <p>
  None.
 </p>
 <h2>
  <span class="section-number">
   12.10.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-7-5">
   Changes in PTX ISA Version 7.5
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-7-5" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX ISA version 7.5 introduces the following new features:
 </p>
 <ul>
  <li>
   <p>
    Debug information enhancements to support label difference and negative values in the
    <span class="pre">
     .section
    </span>
    debugging directive.
   </p>
  </li>
  <li>
   <p>
    Support for
    <span class="pre">
     ignore-src
    </span>
    operand on
    <span class="pre">
     cp.async
    </span>
    instruction.
   </p>
  </li>
  <li>
   <p>
    Extensions to the memory consistency model to introduce the following new concepts:
   </p>
   <ul class="simple">
    <li>
     <p>
      A
      memory proxy
      as an abstract label for different methods of memory access.
     </p>
    </li>
    <li>
     <p>
      Virtual aliases as distinct memory addresses accessing the same physical memory location.
     </p>
    </li>
   </ul>
  </li>
  <li>
   <p>
    Support for new
    <span class="pre">
     fence.proxy
    </span>
    and
    <span class="pre">
     membar.proxy
    </span>
    instructions to allow synchronization of
memory accesses performed via virtual aliases.
   </p>
  </li>
 </ul>
 <p>
  Semantic Changes and Clarifications
 </p>
 <p>
  None.
 </p>
 <h2>
  <span class="section-number">
   12.11.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-7-4">
   Changes in PTX ISA Version 7.4
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-7-4" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX ISA version 7.4 introduces the following new features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Support for
    <span class="pre">
     sm_87
    </span>
    target architecture.
   </p>
  </li>
  <li>
   <p>
    Support for
    <span class="pre">
     .level::eviction_priority
    </span>
    qualifier which allows specifying cache eviction
priority hints on
    <span class="pre">
     ld
    </span>
    ,
    <span class="pre">
     ld.global.nc
    </span>
    ,
    <span class="pre">
     st
    </span>
    , and
    <span class="pre">
     prefetch
    </span>
    instructions.
   </p>
  </li>
  <li>
   <p>
    Support for
    <span class="pre">
     .level::prefetch_size
    </span>
    qualifier which allows specifying data prefetch hints on
    <span class="pre">
     ld
    </span>
    and
    <span class="pre">
     cp.async
    </span>
    instructions.
   </p>
  </li>
  <li>
   <p>
    Support for
    <span class="pre">
     createpolicy
    </span>
    instruction which allows construction of different types of cache
eviction policies.
   </p>
  </li>
  <li>
   <p>
    Support for
    <span class="pre">
     .level::cache_hint
    </span>
    qualifier which allows the use of cache eviction policies with
    <span class="pre">
     ld
    </span>
    ,
    <span class="pre">
     ld.global.nc
    </span>
    ,
    <span class="pre">
     st
    </span>
    ,
    <span class="pre">
     atom
    </span>
    ,
    <span class="pre">
     red
    </span>
    and
    <span class="pre">
     cp.async
    </span>
    instructions.
   </p>
  </li>
  <li>
   <p>
    Support for
    <span class="pre">
     applypriority
    </span>
    and
    <span class="pre">
     discard
    </span>
    operations on cached data.
   </p>
  </li>
 </ul>
 <p>
  Semantic Changes and Clarifications
 </p>
 <p>
  None.
 </p>
 <h2>
  <span class="section-number">
   12.12.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-7-3">
   Changes in PTX ISA Version 7.3
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-7-3" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX ISA version 7.3 introduces the following new features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Extends
    <span class="pre">
     mask()
    </span>
    operator used in initializers to also support integer constant expression.
   </p>
  </li>
  <li>
   <p>
    Adds support for stack manpulation instructions that allow manipulating stack using
    <span class="pre">
     stacksave
    </span>
    and
    <span class="pre">
     stackrestore
    </span>
    instructions and allocation of per-thread stack using
    <span class="pre">
     alloca
    </span>
    instruction.
   </p>
  </li>
 </ul>
 <p>
  Semantic Changes and Clarifications
 </p>
 <p>
  The unimplemented version of
  <span class="pre">
   alloca
  </span>
  from the older PTX ISA specification has been replaced with
new stack manipulation instructions in PTX ISA version 7.3.
 </p>
 <h2>
  <span class="section-number">
   12.13.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-7-2">
   Changes in PTX ISA Version 7.2
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-7-2" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX ISA version 7.2 introduces the following new features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Enhances
    <span class="pre">
     .loc
    </span>
    directive to represent inline function information.
   </p>
  </li>
  <li>
   <p>
    Adds support to define labels inside the debug sections.
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     min
    </span>
    and
    <span class="pre">
     max
    </span>
    instructions to support
    <span class="pre">
     .xorsign
    </span>
    and
    <span class="pre">
     .abs
    </span>
    modifiers.
   </p>
  </li>
 </ul>
 <p>
  Semantic Changes and Clarifications
 </p>
 <p>
  None.
 </p>
 <h2>
  <span class="section-number">
   12.14.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-7-1">
   Changes in PTX ISA Version 7.1
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-7-1" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX ISA version 7.1 introduces the following new features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Support for
    <span class="pre">
     sm_86
    </span>
    target architecture.
   </p>
  </li>
  <li>
   <p>
    Adds a new operator,
    <span class="pre">
     mask()
    </span>
    , to extract a specific byte from variableâs address used in
initializers.
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     tex
    </span>
    and
    <span class="pre">
     tld4
    </span>
    instructions to return an optional predicate that indicates if data
at specified coordinates is resident in memory.
   </p>
  </li>
  <li>
   <p>
    Extends single-bit
    <span class="pre">
     wmma
    </span>
    and
    <span class="pre">
     mma
    </span>
    instructions to support
    <span class="pre">
     .and
    </span>
    operation.
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     mma
    </span>
    instruction to support
    <span class="pre">
     .sp
    </span>
    modifier that allows matrix multiply-accumulate
operation when input matrix A is sparse.
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     mbarrier.test_wait
    </span>
    instruction to test the completion of specific phase parity.
   </p>
  </li>
 </ul>
 <p>
  Semantic Changes and Clarifications
 </p>
 <p>
  None.
 </p>
 <h2>
  <span class="section-number">
   12.15.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-7-0">
   Changes in PTX ISA Version 7.0
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-7-0" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX ISA version 7.0 introduces the following new features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Support for
    <span class="pre">
     sm_80
    </span>
    target architecture.
   </p>
  </li>
  <li>
   <p>
    Adds support for asynchronous copy instructions that allow copying of data asynchronously from one
state space to another.
   </p>
  </li>
  <li>
   <p>
    Adds support for
    <span class="pre">
     mbarrier
    </span>
    instructions that allow creation of
    mbarrier objects
    in memory and
use of these objects to synchronize threads and asynchronous copy operations initiated by threads.
   </p>
  </li>
  <li>
   <p>
    Adds support for
    <span class="pre">
     redux.sync
    </span>
    instruction which allows reduction operation across threads in a
warp.
   </p>
  </li>
  <li>
   <p>
    Adds support for new alternate floating-point data formats
    <span class="pre">
     .bf16
    </span>
    and
    <span class="pre">
     .tf32
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     wmma
    </span>
    instruction to support
    <span class="pre">
     .f64
    </span>
    type with shape
    <span class="pre">
     .m8n8k4
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     wmma
    </span>
    instruction to support
    <span class="pre">
     .bf16
    </span>
    data format.
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     wmma
    </span>
    instruction to support
    <span class="pre">
     .tf32
    </span>
    data format with shape
    <span class="pre">
     .m16n16k8
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     mma
    </span>
    instruction to support
    <span class="pre">
     .f64
    </span>
    type with shape
    <span class="pre">
     .m8n8k4
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     mma
    </span>
    instruction to support
    <span class="pre">
     .bf16
    </span>
    and
    <span class="pre">
     .tf32
    </span>
    data formats with shape
    <span class="pre">
     .m16n8k8
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     mma
    </span>
    instruction to support new shapes
    <span class="pre">
     .m8n8k128
    </span>
    ,
    <span class="pre">
     .m16n8k4
    </span>
    ,
    <span class="pre">
     .m16n8k16
    </span>
    ,
    <span class="pre">
     .m16n8k32
    </span>
    ,
    <span class="pre">
     .m16n8k64
    </span>
    ,
    <span class="pre">
     .m16n8k128
    </span>
    and
    <span class="pre">
     .m16n8k256
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     abs
    </span>
    and
    <span class="pre">
     neg
    </span>
    instructions to support
    <span class="pre">
     .bf16
    </span>
    and
    <span class="pre">
     .bf16x2
    </span>
    data formats.
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     min
    </span>
    and
    <span class="pre">
     max
    </span>
    instructions to support
    <span class="pre">
     .NaN
    </span>
    modifier and
    <span class="pre">
     .f16
    </span>
    ,
    <span class="pre">
     .f16x2
    </span>
    ,
    <span class="pre">
     .bf16
    </span>
    and
    <span class="pre">
     .bf16x2
    </span>
    data formats.
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     fma
    </span>
    instruction to support
    <span class="pre">
     .relu
    </span>
    saturation mode and
    <span class="pre">
     .bf16
    </span>
    and
    <span class="pre">
     .bf16x2
    </span>
    data formats.
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     cvt
    </span>
    instruction to support
    <span class="pre">
     .relu
    </span>
    saturation mode and
    <span class="pre">
     .f16
    </span>
    ,
    <span class="pre">
     .f16x2
    </span>
    ,
    <span class="pre">
     .bf16
    </span>
    ,
    <span class="pre">
     .bf16x2
    </span>
    and
    <span class="pre">
     .tf32
    </span>
    destination formats.
   </p>
  </li>
  <li>
   <p>
    Adds support for
    <span class="pre">
     tanh
    </span>
    instruction that computes hyperbolic-tangent.
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     ex2
    </span>
    instruction to support
    <span class="pre">
     .f16
    </span>
    and
    <span class="pre">
     .f16x2
    </span>
    types.
   </p>
  </li>
 </ul>
 <p>
  Semantic Changes and Clarifications
 </p>
 <p>
  None.
 </p>
 <h2>
  <span class="section-number">
   12.16.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-6-5">
   Changes in PTX ISA Version 6.5
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-6-5" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX ISA version 6.5 introduces the following new features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Adds support for integer destination types for half precision comparison instruction
    <span class="pre">
     set
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     abs
    </span>
    instruction to support
    <span class="pre">
     .f16
    </span>
    and
    <span class="pre">
     .f16x2
    </span>
    types.
   </p>
  </li>
  <li>
   <p>
    Adds support for
    <span class="pre">
     cvt.pack
    </span>
    instruction which allows converting two integer values and packing
the results together.
   </p>
  </li>
  <li>
   <p>
    Adds new shapes
    <span class="pre">
     .m16n8k8
    </span>
    ,
    <span class="pre">
     .m8n8k16
    </span>
    and
    <span class="pre">
     .m8n8k32
    </span>
    on the
    <span class="pre">
     mma
    </span>
    instruction.
   </p>
  </li>
  <li>
   <p>
    Adds support for
    <span class="pre">
     ldmatrix
    </span>
    instruction which loads one or more matrices from shared memory for
    <span class="pre">
     mma
    </span>
    instruction.
   </p>
  </li>
 </ul>
 <p>
  Removed Features
 </p>
 <p>
  PTX ISA version 6.5 removes the following features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Support for
    <span class="pre">
     .satfinite
    </span>
    qualifier on floating point
    <span class="pre">
     wmma.mma
    </span>
    instruction has been
removed. This support was deprecated since PTX ISA version 6.4.
   </p>
  </li>
 </ul>
 <p>
  Semantic Changes and Clarifications
 </p>
 <p>
  None.
 </p>
 <h2>
  <span class="section-number">
   12.17.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-6-4">
   Changes in PTX ISA Version 6.4
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-6-4" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX ISA version 6.4 introduces the following new features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Adds support for
    <span class="pre">
     .noreturn
    </span>
    directive which can be used to indicate a function does not return
to itâs caller function.
   </p>
  </li>
  <li>
   <p>
    Adds support for
    <span class="pre">
     mma
    </span>
    instruction which allows performing matrix multiply-and-accumulate
operation.
   </p>
  </li>
 </ul>
 <p>
  Deprecated Features
 </p>
 <p>
  PTX ISA version 6.4 deprecates the following features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Support for
    <span class="pre">
     .satfinite
    </span>
    qualifier on floating point
    <span class="pre">
     wmma.mma
    </span>
    instruction.
   </p>
  </li>
 </ul>
 <p>
  Removed Features
 </p>
 <p>
  PTX ISA version 6.4 removes the following features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Support for
    <span class="pre">
     shfl
    </span>
    and
    <span class="pre">
     vote
    </span>
    instructions without the
    <span class="pre">
     .sync
    </span>
    qualifier has been removed
for
    <span class="pre">
     .target
    </span>
    <span class="pre">
     sm_70
    </span>
    and higher. This support was deprecated since PTX ISA version 6.0 as
documented in PTX ISA version 6.2.
   </p>
  </li>
 </ul>
 <p>
  Semantic Changes and Clarifications
 </p>
 <ul class="simple">
  <li>
   <p>
    Clarified that resolving references of a
    <span class="pre">
     .weak
    </span>
    symbol considers only
    <span class="pre">
     .weak
    </span>
    or
    <span class="pre">
     .visible
    </span>
    symbols with the same name and does not consider local symbols with the same name.
   </p>
  </li>
  <li>
   <p>
    Clarified that in
    <span class="pre">
     cvt
    </span>
    instruction, modifier
    <span class="pre">
     .ftz
    </span>
    can only be specified when either
    <span class="pre">
     .atype
    </span>
    or
    <span class="pre">
     .dtype
    </span>
    is
    <span class="pre">
     .f32
    </span>
    .
   </p>
  </li>
 </ul>
 <h2>
  <span class="section-number">
   12.18.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-6-3">
   Changes in PTX ISA Version 6.3
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-6-3" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX ISA version 6.3 introduces the following new features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Support for
    <span class="pre">
     sm_75
    </span>
    target architecture.
   </p>
  </li>
  <li>
   <p>
    Adds support for a new instruction
    <span class="pre">
     nanosleep
    </span>
    that suspends a thread for a specified duration.
   </p>
  </li>
  <li>
   <p>
    Adds support for
    <span class="pre">
     .alias
    </span>
    directive which allows definining alias to function symbol.
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     atom
    </span>
    instruction to perform
    <span class="pre">
     .f16
    </span>
    addition operation and
    <span class="pre">
     .cas.b16
    </span>
    operation.
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     red
    </span>
    instruction to perform
    <span class="pre">
     .f16
    </span>
    addition operation.
   </p>
  </li>
  <li>
   <p>
    The
    <span class="pre">
     wmma
    </span>
    instructions are extended to support multiplicand matrices of type
    <span class="pre">
     .s8
    </span>
    ,
    <span class="pre">
     .u8
    </span>
    ,
    <span class="pre">
     .s4
    </span>
    ,
    <span class="pre">
     .u4
    </span>
    ,
    <span class="pre">
     .b1
    </span>
    and accumulator matrices of type
    <span class="pre">
     .s32
    </span>
    .
   </p>
  </li>
 </ul>
 <p>
  Semantic Changes and Clarifications
 </p>
 <ul class="simple">
  <li>
   <p>
    Introduced the mandatory
    <span class="pre">
     .aligned
    </span>
    qualifier for all
    <span class="pre">
     wmma
    </span>
    instructions.
   </p>
  </li>
  <li>
   <p>
    Specified the alignment required for the base address and stride parameters passed to
    <span class="pre">
     wmma.load
    </span>
    and
    <span class="pre">
     wmma.store
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Clarified that layout of fragment returned by
    <span class="pre">
     wmma
    </span>
    operation is architecture dependent and
passing
    <span class="pre">
     wmma
    </span>
    fragments around functions compiled for different link compatible SM
architectures may not work as expected.
   </p>
  </li>
  <li>
   <p>
    Clarified that atomicity for
    <span class="pre">
     {atom/red}.f16x2}
    </span>
    operations is guranteed separately for each of
the two
    <span class="pre">
     .f16
    </span>
    elements but not guranteed to be atomic as single 32-bit access.
   </p>
  </li>
 </ul>
 <h2>
  <span class="section-number">
   12.19.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-6-2">
   Changes in PTX ISA Version 6.2
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-6-2" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX ISA version 6.2 introduces the following new features:
 </p>
 <ul class="simple">
  <li>
   <p>
    A new instruction
    <span class="pre">
     activemask
    </span>
    for querying active threads in a warp.
   </p>
  </li>
  <li>
   <p>
    Extends atomic and reduction instructions to perform
    <span class="pre">
     .f16x2
    </span>
    addition operation with mandatory
    <span class="pre">
     .noftz
    </span>
    qualifier.
   </p>
  </li>
 </ul>
 <p>
  Deprecated Features
 </p>
 <p>
  PTX ISA version 6.2 deprecates the following features:
 </p>
 <ul class="simple">
  <li>
   <p>
    The use of
    <span class="pre">
     shfl
    </span>
    and
    <span class="pre">
     vote
    </span>
    instructions without the
    <span class="pre">
     .sync
    </span>
    is deprecated retrospectively
from PTX ISA version 6.0, which introduced the
    <span class="pre">
     sm_70
    </span>
    architecture that implements
    <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#independent-thread-scheduling">
     Independent Thread Scheduling
    </a>
    .
   </p>
  </li>
 </ul>
 <p>
  Semantic Changes and Clarifications
 </p>
 <ul class="simple">
  <li>
   <p>
    Clarified that
    <span class="pre">
     wmma
    </span>
    instructions can be used in conditionally executed code only if it is
known that all threads in the warp evaluate the condition identically, otherwise behavior is
undefined.
   </p>
  </li>
  <li>
   <p>
    In the memory consistency model, the definition of
    morally strong operations
    was updated to
exclude fences from the requirement of
    complete overlap
    since fences do not access memory.
   </p>
  </li>
 </ul>
 <h2>
  <span class="section-number">
   12.20.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-6-1">
   Changes in PTX ISA Version 6.1
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-6-1" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX ISA version 6.1 introduces the following new features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Support for
    <span class="pre">
     sm_72
    </span>
    target architecture.
   </p>
  </li>
  <li>
   <p>
    Support for new matrix shapes
    <span class="pre">
     32x8x16
    </span>
    and
    <span class="pre">
     8x32x16
    </span>
    in
    <span class="pre">
     wmma
    </span>
    instruction.
   </p>
  </li>
 </ul>
 <p>
  Semantic Changes and Clarifications
 </p>
 <p>
  None.
 </p>
 <h2>
  <span class="section-number">
   12.21.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-6-0">
   Changes in PTX ISA Version 6.0
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-6-0" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX ISA version 6.0 introduces the following new features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Support for
    <span class="pre">
     sm_70
    </span>
    target architecture.
   </p>
  </li>
  <li>
   <p>
    Specifies the memory consistency model for programs running on
    <span class="pre">
     sm_70
    </span>
    and later architectures.
   </p>
  </li>
  <li>
   <p>
    Various extensions to memory instructions to specify memory synchronization semantics and scopes
at which such synchronization can be observed.
   </p>
  </li>
  <li>
   <p>
    New instruction
    <span class="pre">
     wmma
    </span>
    for matrix operations which allows loading matrices from memory,
performing multiply-and-accumulate on them and storing result in memory.
   </p>
  </li>
  <li>
   <p>
    Support for new
    <span class="pre">
     barrier
    </span>
    instruction.
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     neg
    </span>
    instruction to support
    <span class="pre">
     .f16
    </span>
    and
    <span class="pre">
     .f16x2
    </span>
    types.
   </p>
  </li>
  <li>
   <p>
    A new instruction
    <span class="pre">
     fns
    </span>
    which allows finding n-th set bit in integer.
   </p>
  </li>
  <li>
   <p>
    A new instruction
    <span class="pre">
     bar.warp.sync
    </span>
    which allows synchronizing threads in warp.
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     vote
    </span>
    and
    <span class="pre">
     shfl
    </span>
    instructions with
    <span class="pre">
     .sync
    </span>
    modifier which waits for specified
threads before executing the
    <span class="pre">
     vote
    </span>
    and
    <span class="pre">
     shfl
    </span>
    operation respectively.
   </p>
  </li>
  <li>
   <p>
    A new instruction
    <span class="pre">
     match.sync
    </span>
    which allows broadcasting and comparing a value across threads in
warp.
   </p>
  </li>
  <li>
   <p>
    A new instruction
    <span class="pre">
     brx.idx
    </span>
    which allows branching to a label indexed from list of potential
targets.
   </p>
  </li>
  <li>
   <p>
    Support for unsized array parameter for
    <span class="pre">
     .func
    </span>
    which can be used to implement variadic
functions.
   </p>
  </li>
  <li>
   <p>
    Support for
    <span class="pre">
     .b16
    </span>
    integer type in dwarf-lines.
   </p>
  </li>
  <li>
   <p>
    Support for taking address of device function return parameters using
    <span class="pre">
     mov
    </span>
    instruction.
   </p>
  </li>
 </ul>
 <p>
  Semantic Changes and Clarifications
 </p>
 <ul class="simple">
  <li>
   <p>
    Semantics of
    <span class="pre">
     bar
    </span>
    instruction were updated to indicate that executing thread waits for other
non-exited threads from itâs warp.
   </p>
  </li>
  <li>
   <p>
    Support for indirect branch introduced in PTX 2.1 which was unimplemented has been removed from
the spec.
   </p>
  </li>
  <li>
   <p>
    Support for taking address of labels, using labels in initializers which was unimplemented has
been removed from the spec.
   </p>
  </li>
  <li>
   <p>
    Support for variadic functions which was unimplemented has been removed from the spec.
   </p>
  </li>
 </ul>
 <h2>
  <span class="section-number">
   12.22.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-5-0">
   Changes in PTX ISA Version 5.0
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-5-0" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX ISA version 5.0 introduces the following new features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Support for
    <span class="pre">
     sm_60
    </span>
    ,
    <span class="pre">
     sm_61
    </span>
    ,
    <span class="pre">
     sm_62
    </span>
    target architecture.
   </p>
  </li>
  <li>
   <p>
    Extends atomic and reduction instructions to perform double-precision add operation.
   </p>
  </li>
  <li>
   <p>
    Extends atomic and reduction instructions to specify
    <span class="pre">
     scope
    </span>
    modifier.
   </p>
  </li>
  <li>
   <p>
    A new
    <span class="pre">
     .common
    </span>
    directive to permit linking multiple object files containing declarations of the
same symbol with different size.
   </p>
  </li>
  <li>
   <p>
    A new
    <span class="pre">
     dp4a
    </span>
    instruction which allows 4-way dot product with accumulate operation.
   </p>
  </li>
  <li>
   <p>
    A new
    <span class="pre">
     dp2a
    </span>
    instruction which allows 2-way dot product with accumulate operation.
   </p>
  </li>
  <li>
   <p>
    Support for special register
    <span class="pre">
     %clock_hi
    </span>
    .
   </p>
  </li>
 </ul>
 <p>
  Semantic Changes and Clarifications
 </p>
 <p>
  Semantics of cache modifiers on
  <span class="pre">
   ld
  </span>
  and
  <span class="pre">
   st
  </span>
  instructions were clarified to reflect cache
operations are treated as performance hint only and do not change memory consistency behavior of the
program.
 </p>
 <p>
  Semantics of
  <span class="pre">
   volatile
  </span>
  operations on
  <span class="pre">
   ld
  </span>
  and
  <span class="pre">
   st
  </span>
  instructions were clarified to reflect how
  <span class="pre">
   volatile
  </span>
  operations are handled by optimizing compiler.
 </p>
 <h2>
  <span class="section-number">
   12.23.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-4-3">
   Changes in PTX ISA Version 4.3
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-4-3" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX ISA version 4.3 introduces the following new features:
 </p>
 <ul class="simple">
  <li>
   <p>
    A new
    <span class="pre">
     lop3
    </span>
    instruction which allows arbitrary logical operation on 3 inputs.
   </p>
  </li>
  <li>
   <p>
    Adds support for 64-bit computations in extended precision arithmetic instructions.
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     tex.grad
    </span>
    instruction to support
    <span class="pre">
     cube
    </span>
    and
    <span class="pre">
     acube
    </span>
    geometries.
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     tld4
    </span>
    instruction to support
    <span class="pre">
     a2d
    </span>
    ,
    <span class="pre">
     cube
    </span>
    and
    <span class="pre">
     acube
    </span>
    geometries.
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     tex
    </span>
    and
    <span class="pre">
     tld4
    </span>
    instructions to support optional operands for offset vector and depth
compare.
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     txq
    </span>
    instruction to support querying texture fields from specific LOD.
   </p>
  </li>
 </ul>
 <p>
  Semantic Changes and Clarifications
 </p>
 <p>
  None.
 </p>
 <h2>
  <span class="section-number">
   12.24.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-4-2">
   Changes in PTX ISA Version 4.2
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-4-2" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX ISA version 4.2 introduces the following new features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Support for
    <span class="pre">
     sm_53
    </span>
    target architecture.
   </p>
  </li>
  <li>
   <p>
    Support for arithmetic, comparsion and texture instructions for
    <span class="pre">
     .f16
    </span>
    and
    <span class="pre">
     .f16x2
    </span>
    types.
   </p>
  </li>
  <li>
   <p>
    Support for
    <span class="pre">
     memory_layout
    </span>
    field for surfaces and
    <span class="pre">
     suq
    </span>
    instruction support for querying this
field.
   </p>
  </li>
 </ul>
 <p>
  Semantic Changes and Clarifications
 </p>
 <p>
  Semantics for parameter passing under ABI were updated to indicate
  <span class="pre">
   ld.param
  </span>
  and
  <span class="pre">
   st.param
  </span>
  instructions used for argument passing cannot be predicated.
 </p>
 <p>
  Semantics of
  <span class="pre">
   {atom/red}.add.f32
  </span>
  were updated to indicate subnormal inputs and results are
flushed to sign-preserving zero for atomic operations on global memory; whereas atomic operations on
shared memory preserve subnormal inputs and results and donât flush them to zero.
 </p>
 <h2>
  <span class="section-number">
   12.25.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-4-1">
   Changes in PTX ISA Version 4.1
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-4-1" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX ISA version 4.1 introduces the following new features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Support for
    <span class="pre">
     sm_37
    </span>
    and
    <span class="pre">
     sm_52
    </span>
    target architectures.
   </p>
  </li>
  <li>
   <p>
    Support for new fields
    <span class="pre">
     array_size
    </span>
    ,
    <span class="pre">
     num_mipmap_levels
    </span>
    and
    <span class="pre">
     num_samples
    </span>
    for Textures, and
the
    <span class="pre">
     txq
    </span>
    instruction support for querying these fields.
   </p>
  </li>
  <li>
   <p>
    Support for new field
    <span class="pre">
     array_size
    </span>
    for Surfaces, and the
    <span class="pre">
     suq
    </span>
    instruction support for
querying this field.
   </p>
  </li>
  <li>
   <p>
    Support for special registers
    <span class="pre">
     %total_smem_size
    </span>
    and
    <span class="pre">
     %dynamic_smem_size
    </span>
    .
   </p>
  </li>
 </ul>
 <p>
  Semantic Changes and Clarifications
 </p>
 <p>
  None.
 </p>
 <h2>
  <span class="section-number">
   12.26.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-4-0">
   Changes in PTX ISA Version 4.0
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-4-0" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX ISA version 4.0 introduces the following new features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Support for
    <span class="pre">
     sm_32
    </span>
    and
    <span class="pre">
     sm_50
    </span>
    target architectures.
   </p>
  </li>
  <li>
   <p>
    Support for 64bit performance counter special registers
    <span class="pre">
     %pm0_64,..,%pm7_64
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    A new
    <span class="pre">
     istypep
    </span>
    instruction.
   </p>
  </li>
  <li>
   <p>
    A new instruction,
    <span class="pre">
     rsqrt.approx.ftz.f64
    </span>
    has been added to compute a fast approximation of the
square root reciprocal of a value.
   </p>
  </li>
  <li>
   <p>
    Support for a new directive
    <span class="pre">
     .attribute
    </span>
    for specifying special attributes of a variable.
   </p>
  </li>
  <li>
   <p>
    Support for
    <span class="pre">
     .managed
    </span>
    variable attribute.
   </p>
  </li>
 </ul>
 <p>
  Semantic Changes and Clarifications
 </p>
 <p>
  The
  <span class="pre">
   vote
  </span>
  instruction semantics were updated to clearly indicate that an inactive thread in a
warp contributes a 0 for its entry when participating in
  <span class="pre">
   vote.ballot.b32
  </span>
  .
 </p>
 <h2>
  <span class="section-number">
   12.27.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-3-2">
   Changes in PTX ISA Version 3.2
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-3-2" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX ISA version 3.2 introduces the following new features:
 </p>
 <ul class="simple">
  <li>
   <p>
    The texture instruction supports reads from multi-sample and multisample array textures.
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     .section
    </span>
    debugging directive to include label + immediate expressions.
   </p>
  </li>
  <li>
   <p>
    Extends
    <span class="pre">
     .file
    </span>
    directive to include timestamp and file size information.
   </p>
  </li>
 </ul>
 <p>
  Semantic Changes and Clarifications
 </p>
 <p>
  The
  <span class="pre">
   vavrg2
  </span>
  and
  <span class="pre">
   vavrg4
  </span>
  instruction semantics were updated to indicate that instruction adds 1
only if Va[i] + Vb[i] is non-negative, and that the addition result is shifted by 1 (rather than
being divided by 2).
 </p>
 <h2>
  <span class="section-number">
   12.28.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-3-1">
   Changes in PTX ISA Version 3.1
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-3-1" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX ISA version 3.1 introduces the following new features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Support for
    <span class="pre">
     sm_35
    </span>
    target architecture.
   </p>
  </li>
  <li>
   <p>
    Support for CUDA Dynamic Parallelism, which enables a kernel to create and synchronize new work.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     ld.global.nc
    </span>
    for loading read-only global data though the non-coherent texture cache.
   </p>
  </li>
  <li>
   <p>
    A new funnel shift instruction,
    <span class="pre">
     shf
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Extends atomic and reduction instructions to perform 64-bit
    <span class="pre">
     {and,
    </span>
    <span class="pre">
     or,
    </span>
    <span class="pre">
     xor}
    </span>
    operations, and
64-bit integer
    <span class="pre">
     {min,
    </span>
    <span class="pre">
     max}
    </span>
    operations.
   </p>
  </li>
  <li>
   <p>
    Adds support for
    <span class="pre">
     mipmaps
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Adds support for indirect access to textures and surfaces.
   </p>
  </li>
  <li>
   <p>
    Extends support for generic addressing to include the
    <span class="pre">
     .const
    </span>
    state space, and adds a new
operator,
    <span class="pre">
     generic()
    </span>
    , to form a generic address for
    <span class="pre">
     .global
    </span>
    or
    <span class="pre">
     .const
    </span>
    variables used in
initializers.
   </p>
  </li>
  <li>
   <p>
    A new
    <span class="pre">
     .weak
    </span>
    directive to permit linking multiple object files containing declarations of the
same symbol.
   </p>
  </li>
 </ul>
 <p>
  Semantic Changes and Clarifications
 </p>
 <p>
  PTX 3.1 redefines the default addressing for global variables in initializers, from generic
addresses to offsets in the global state space. Legacy PTX code is treated as having an implicit
  <span class="pre">
   generic()
  </span>
  operator for each global variable used in an initializer. PTX 3.1 code should either
include explicit
  <span class="pre">
   generic()
  </span>
  operators in initializers, use
  <span class="pre">
   cvta.global
  </span>
  to form generic
addresses at runtime, or load from the non-generic address using
  <span class="pre">
   ld.global
  </span>
  .
 </p>
 <p>
  Instruction
  <span class="pre">
   mad.f32
  </span>
  requires a rounding modifier for
  <span class="pre">
   sm_20
  </span>
  and higher targets. However for
PTX ISA version 3.0 and earlier, ptxas does not enforce this requirement and
  <span class="pre">
   mad.f32
  </span>
  silently
defaults to
  <span class="pre">
   mad.rn.f32
  </span>
  . For PTX ISA version 3.1, ptxas generates a warning and defaults to
  <span class="pre">
   mad.rn.f32
  </span>
  , and in subsequent releases ptxas will enforce the requirement for PTX ISA version
3.2 and later.
 </p>
 <h2>
  <span class="section-number">
   12.29.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-3-0">
   Changes in PTX ISA Version 3.0
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-3-0" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX ISA version 3.0 introduces the following new features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Support for
    <span class="pre">
     sm_30
    </span>
    target architectures.
   </p>
  </li>
  <li>
   <p>
    SIMD video instructions.
   </p>
  </li>
  <li>
   <p>
    A new warp shuffle instruction.
   </p>
  </li>
  <li>
   <p>
    Instructions
    <span class="pre">
     mad.cc
    </span>
    and
    <span class="pre">
     madc
    </span>
    for efficient, extended-precision integer multiplication.
   </p>
  </li>
  <li>
   <p>
    Surface instructions with 3D and array geometries.
   </p>
  </li>
  <li>
   <p>
    The texture instruction supports reads from cubemap and cubemap array textures.
   </p>
  </li>
  <li>
   <p>
    Platform option
    <span class="pre">
     .target
    </span>
    debug to declare that a PTX module contains
    <span class="pre">
     DWARF
    </span>
    debug information.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     pmevent.mask
    </span>
    , for triggering multiple performance monitor events.
   </p>
  </li>
  <li>
   <p>
    Performance monitor counter special registers
    <span class="pre">
     %pm4..%pm7
    </span>
    .
   </p>
  </li>
 </ul>
 <p>
  Semantic Changes and Clarifications
 </p>
 <p>
  Special register
  <span class="pre">
   %gridid
  </span>
  has been extended from 32-bits to 64-bits.
 </p>
 <p>
  PTX ISA version 3.0 deprecates module-scoped
  <span class="pre">
   .reg
  </span>
  and
  <span class="pre">
   .local
  </span>
  variables when compiling to the
Application Binary Interface (ABI). When compiling without use of the ABI, module-scoped
  <span class="pre">
   .reg
  </span>
  and
  <span class="pre">
   .local
  </span>
  variables are supported as before. When compiling legacy PTX code (ISA versions prior
to 3.0) containing module-scoped
  <span class="pre">
   .reg
  </span>
  or
  <span class="pre">
   .local
  </span>
  variables, the compiler silently disables
use of the ABI.
 </p>
 <p>
  The
  <span class="pre">
   shfl
  </span>
  instruction semantics were updated to clearly indicate that value of source operand
  <span class="pre">
   a
  </span>
  is unpredictable for inactive and predicated-off threads within the warp.
 </p>
 <p>
  PTX modules no longer allow duplicate
  <span class="pre">
   .version
  </span>
  directives. This feature was unimplemented, so
there is no semantic change.
 </p>
 <p>
  Unimplemented instructions
  <span class="pre">
   suld.p
  </span>
  and
  <span class="pre">
   sust.p.{u32,s32,f32}
  </span>
  have been removed.
 </p>
 <h2>
  <span class="section-number">
   12.30.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-2-3">
   Changes in PTX ISA Version 2.3
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-2-3" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX 2.3 adds support for texture arrays. The texture array feature supports access to an array of 1D
or 2D textures, where an integer indexes into the array of textures, and then one or two
single-precision floating point coordinates are used to address within the selected 1D or 2D
texture.
 </p>
 <p>
  PTX 2.3 adds a new directive,
  <span class="pre">
   .address_size
  </span>
  , for specifying the size of addresses.
 </p>
 <p>
  Variables in
  <span class="pre">
   .const
  </span>
  and
  <span class="pre">
   .global
  </span>
  state spaces are initialized to zero by default.
 </p>
 <p>
  Semantic Changes and Clarifications
 </p>
 <p>
  The semantics of the
  <span class="pre">
   .maxntid
  </span>
  directive have been updated to match the current
implementation. Specifically,
  <span class="pre">
   .maxntid
  </span>
  only guarantees that the total number of threads in a
thread block does not exceed the maximum. Previously, the semantics indicated that the maximum was
enforced separately in each dimension, which is not the case.
 </p>
 <p>
  Bit field extract and insert instructions BFE and BFI now indicate that the
  <span class="pre">
   len
  </span>
  and
  <span class="pre">
   pos
  </span>
  operands are restricted to the value range
  <span class="pre">
   0..255
  </span>
  .
 </p>
 <p>
  Unimplemented instructions
  <span class="pre">
   {atom,red}.{min,max}.f32
  </span>
  have been removed.
 </p>
 <h2>
  <span class="section-number">
   12.31.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-2-2">
   Changes in PTX ISA Version 2.2
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-2-2" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  PTX 2.2 adds a new directive for specifying kernel parameter attributes; specifically, there is a
new directives for specifying that a kernel parameter is a pointer, for specifying to which state
space the parameter points, and for optionally specifying the alignment of the memory to which the
parameter points.
 </p>
 <p>
  PTX 2.2 adds a new field named
  <span class="pre">
   force_unnormalized_coords
  </span>
  to the
  <span class="pre">
   .samplerref
  </span>
  opaque
type. This field is used in the independent texturing mode to override the
  <span class="pre">
   normalized_coords
  </span>
  field in the texture header. This field is needed to support languages such as OpenCL, which
represent the property of normalized/unnormalized coordinates in the sampler header rather than in
the texture header.
 </p>
 <p>
  PTX 2.2 deprecates explicit constant banks and supports a large, flat address space for the
  <span class="pre">
   .const
  </span>
  state space. Legacy PTX that uses explicit constant banks is still supported.
 </p>
 <p>
  PTX 2.2 adds a new
  <span class="pre">
   tld4
  </span>
  instruction for loading a component (
  <span class="pre">
   r
  </span>
  ,
  <span class="pre">
   g
  </span>
  ,
  <span class="pre">
   b
  </span>
  , or
  <span class="pre">
   a
  </span>
  ) from
the four texels compising the bilinear interpolation footprint of a given texture location. This
instruction may be used to compute higher-precision bilerp results in software, or for performing
higher-bandwidth texture loads.
 </p>
 <p>
  Semantic Changes and Clarifications
 </p>
 <p>
  None.
 </p>
 <h2>
  <span class="section-number">
   12.32.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-2-1">
   Changes in PTX ISA Version 2.1
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-2-1" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  The underlying, stack-based ABI is supported in PTX ISA version 2.1 for
  <span class="pre">
   sm_2x
  </span>
  targets.
 </p>
 <p>
  Support for indirect calls has been implemented for
  <span class="pre">
   sm_2x
  </span>
  targets.
 </p>
 <p>
  New directives,
  <span class="pre">
   .branchtargets
  </span>
  and
  <span class="pre">
   .calltargets
  </span>
  , have been added for specifying potential
targets for indirect branches and indirect function calls. A
  <span class="pre">
   .callprototype
  </span>
  directive has been
added for declaring the type signatures for indirect function calls.
 </p>
 <p>
  The names of
  <span class="pre">
   .global
  </span>
  and
  <span class="pre">
   .const
  </span>
  variables can now be specified in variable initializers to
represent their addresses.
 </p>
 <p>
  A set of thirty-two driver-specific execution environment special registers has been added. These
are named
  <span class="pre">
   %envreg0..%envreg31
  </span>
  .
 </p>
 <p>
  Textures and surfaces have new fields for channel data type and channel order, and the
  <span class="pre">
   txq
  </span>
  and
  <span class="pre">
   suq
  </span>
  instructions support queries for these fields.
 </p>
 <p>
  Directive
  <span class="pre">
   .minnctapersm
  </span>
  has replaced the
  <span class="pre">
   .maxnctapersm
  </span>
  directive.
 </p>
 <p>
  Directive
  <span class="pre">
   .reqntid
  </span>
  has been added to allow specification of exact CTA dimensions.
 </p>
 <p>
  A new instruction,
  <span class="pre">
   rcp.approx.ftz.f64
  </span>
  , has been added to compute a fast, gross approximate
reciprocal.
 </p>
 <p>
  Semantic Changes and Clarifications
 </p>
 <p>
  A warning is emitted if
  <span class="pre">
   .minnctapersm
  </span>
  is specified without also specifying
  <span class="pre">
   .maxntid
  </span>
  .
 </p>
 <h2>
  <span class="section-number">
   12.33.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-2-0">
   Changes in PTX ISA Version 2.0
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#changes-in-ptx-isa-version-2-0" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  New Features
 </p>
 <p>
  Floating Point Extensions
 </p>
 <p>
  This section describes the floating-point changes in PTX ISA version 2.0 for
  <span class="pre">
   sm_20
  </span>
  targets. The
goal is to achieve IEEE 754 compliance wherever possible, while maximizing backward compatibility
with legacy PTX ISA version 1.x code and
  <span class="pre">
   sm_1x
  </span>
  targets.
 </p>
 <p>
  The changes from PTX ISA version 1.x are as follows:
 </p>
 <ul class="simple">
  <li>
   <p>
    Single-precision instructions support subnormal numbers by default for
    <span class="pre">
     sm_20
    </span>
    targets. The
    <span class="pre">
     .ftz
    </span>
    modifier may be used to enforce backward compatibility with
    <span class="pre">
     sm_1x
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Single-precision
    <span class="pre">
     add
    </span>
    ,
    <span class="pre">
     sub
    </span>
    , and
    <span class="pre">
     mul
    </span>
    now support
    <span class="pre">
     .rm
    </span>
    and
    <span class="pre">
     .rp
    </span>
    rounding modifiers
for
    <span class="pre">
     sm_20
    </span>
    targets.
   </p>
  </li>
  <li>
   <p>
    A single-precision fused multiply-add (fma) instruction has been added, with support for IEEE 754
compliant rounding modifiers and support for subnormal numbers. The
    <span class="pre">
     fma.f32
    </span>
    instruction also
supports
    <span class="pre">
     .ftz
    </span>
    and
    <span class="pre">
     .sat
    </span>
    modifiers.
    <span class="pre">
     fma.f32
    </span>
    requires
    <span class="pre">
     sm_20
    </span>
    . The
    <span class="pre">
     mad.f32
    </span>
    instruction has been extended with rounding modifiers so that itâs synonymous with
    <span class="pre">
     fma.f32
    </span>
    for
    <span class="pre">
     sm_20
    </span>
    targets. Both
    <span class="pre">
     fma.f32
    </span>
    and
    <span class="pre">
     mad.f32
    </span>
    require a rounding modifier for
    <span class="pre">
     sm_20
    </span>
    targets.
   </p>
  </li>
  <li>
   <p>
    The
    <span class="pre">
     mad.f32
    </span>
    instruction
    without rounding
    is retained so that compilers can generate code for
    <span class="pre">
     sm_1x
    </span>
    targets. When code compiled for
    <span class="pre">
     sm_1x
    </span>
    is executed on
    <span class="pre">
     sm_20
    </span>
    devices,
    <span class="pre">
     mad.f32
    </span>
    maps to
    <span class="pre">
     fma.rn.f32
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Single- and double-precision
    <span class="pre">
     div
    </span>
    ,
    <span class="pre">
     rcp
    </span>
    , and
    <span class="pre">
     sqrt
    </span>
    with IEEE 754 compliant rounding have
been added. These are indicated by the use of a rounding modifier and require
    <span class="pre">
     sm_20
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Instructions
    <span class="pre">
     testp
    </span>
    and
    <span class="pre">
     copysign
    </span>
    have been added.
   </p>
  </li>
 </ul>
 <p>
  New Instructions
 </p>
 <p>
  A
  load uniform
  instruction,
  <span class="pre">
   ldu
  </span>
  , has been added.
 </p>
 <p>
  Surface instructions support additional
  <span class="pre">
   .clamp
  </span>
  modifiers,
  <span class="pre">
   .clamp
  </span>
  and
  <span class="pre">
   .zero
  </span>
  .
 </p>
 <p>
  Instruction
  <span class="pre">
   sust
  </span>
  now supports formatted surface stores.
 </p>
 <p>
  A
  count leading zeros
  instruction,
  <span class="pre">
   clz
  </span>
  , has been added.
 </p>
 <p>
  A
  find leading non-sign bit instruction
  ,
  <span class="pre">
   bfind
  </span>
  , has been added.
 </p>
 <p>
  A
  bit reversal
  instruction,
  <span class="pre">
   brev
  </span>
  , has been added.
 </p>
 <p>
  Bit field extract and insert instructions,
  <span class="pre">
   bfe
  </span>
  and
  <span class="pre">
   bfi
  </span>
  , have been added.
 </p>
 <p>
  A
  population count
  instruction,
  <span class="pre">
   popc
  </span>
  , has been added.
 </p>
 <p>
  A
  vote ballot
  instruction,
  <span class="pre">
   vote.ballot.b32
  </span>
  , has been added.
 </p>
 <p>
  Instructions
  <span class="pre">
   {atom,red}.add.f32
  </span>
  have been implemented.
 </p>
 <p>
  Instructions
  <span class="pre">
   {atom,red}
  </span>
  .shared have been extended to handle 64-bit data types for
  <span class="pre">
   sm_20
  </span>
  targets.
 </p>
 <p>
  A system-level membar instruction,
  <span class="pre">
   membar.sys
  </span>
  , has been added.
 </p>
 <p>
  The
  <span class="pre">
   bar
  </span>
  instruction has been extended as follows:
 </p>
 <ul class="simple">
  <li>
   <p>
    A
    <span class="pre">
     bar.arrive
    </span>
    instruction has been added.
   </p>
  </li>
  <li>
   <p>
    Instructions
    <span class="pre">
     bar.red.popc.u32
    </span>
    and
    <span class="pre">
     bar.red.{and,or}.pred
    </span>
    have been added.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     bar
    </span>
    now supports optional thread count and register operands.
   </p>
  </li>
 </ul>
 <p>
  Scalar video instructions (includes
  <span class="pre">
   prmt
  </span>
  ) have been added.
 </p>
 <p>
  Instruction
  <span class="pre">
   isspacep
  </span>
  for querying whether a generic address falls within a specified state space
window has been added.
 </p>
 <p>
  Instruction
  <span class="pre">
   cvta
  </span>
  for converting global, local, and shared addresses to generic address and
vice-versa has been added.
 </p>
 <p>
  Other New Features
 </p>
 <p>
  Instructions
  <span class="pre">
   ld
  </span>
  ,
  <span class="pre">
   ldu
  </span>
  ,
  <span class="pre">
   st
  </span>
  ,
  <span class="pre">
   prefetch
  </span>
  ,
  <span class="pre">
   prefetchu
  </span>
  ,
  <span class="pre">
   isspacep
  </span>
  ,
  <span class="pre">
   cvta
  </span>
  ,
  <span class="pre">
   atom
  </span>
  ,
and
  <span class="pre">
   red
  </span>
  now support generic addressing.
 </p>
 <p>
  New special registers
  <span class="pre">
   %nwarpid
  </span>
  ,
  <span class="pre">
   %nsmid
  </span>
  ,
  <span class="pre">
   %clock64
  </span>
  ,
  <span class="pre">
   %lanemask_{eq,le,lt,ge,gt}
  </span>
  have
been added.
 </p>
 <p>
  Cache operations have been added to instructions
  <span class="pre">
   ld
  </span>
  ,
  <span class="pre">
   st
  </span>
  ,
  <span class="pre">
   suld
  </span>
  , and
  <span class="pre">
   sust
  </span>
  , e.g., for
  <span class="pre">
   prefetching
  </span>
  to specified level of memory hierarchy. Instructions
  <span class="pre">
   prefetch
  </span>
  and
  <span class="pre">
   prefetchu
  </span>
  have also been added.
 </p>
 <p>
  The
  <span class="pre">
   .maxnctapersm
  </span>
  directive was deprecated and replaced with
  <span class="pre">
   .minnctapersm
  </span>
  to better match
its behavior and usage.
 </p>
 <p>
  A new directive,
  <span class="pre">
   .section
  </span>
  , has been added to replace the
  <span class="pre">
   @@DWARF
  </span>
  syntax for passing
DWARF-format debugging information through PTX.
 </p>
 <p>
  A new directive,
  <span class="pre">
   .pragma
  </span>
  <span class="pre">
   nounroll
  </span>
  , has been added to allow users to disable loop unrolling.
 </p>
 <p>
  Semantic Changes and Clarifications
 </p>
 <p>
  The errata in
  <span class="pre">
   cvt.ftz
  </span>
  for PTX ISA versions 1.4 and earlier, where single-precision subnormal
inputs and results were not flushed to zero if either source or destination type size was 64-bits,
has been fixed. In PTX ISA version 1.5 and later,
  <span class="pre">
   cvt.ftz
  </span>
  (and
  <span class="pre">
   cvt
  </span>
  for
  <span class="pre">
   .target
  </span>
  <span class="pre">
   sm_1x
  </span>
  ,
where
  <span class="pre">
   .ftz
  </span>
  is implied) instructions flush single-precision subnormal inputs and results to
sign-preserving zero for all combinations of floating-point instruction types. To maintain
compatibility with legacy PTX code, if .version is 1.4 or earlier, single-precision subnormal inputs
and results are flushed to sign-preserving zero only when neither source nor destination type size
is 64-bits.
 </p>
 <p>
  Components of special registers
  <span class="pre">
   %tid
  </span>
  ,
  <span class="pre">
   %ntid
  </span>
  ,
  <span class="pre">
   %ctaid
  </span>
  , and
  <span class="pre">
   %nctaid
  </span>
  have been extended
from 16-bits to 32-bits. These registers now have type
  <span class="pre">
   .v4.u32
  </span>
  .
 </p>
 <p>
  The number of samplers available in independent texturing mode was incorrectly listed as thirty-two
in PTX ISA version 1.5; the correct number is sixteen.
 </p>
 <h1>
  <span class="section-number">
   14.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#descriptions-pragma-strings">
   Descriptions of .pragma Strings
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#descriptions-of-pragma-strings" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <p>
  This section describes the
  <span class="pre">
   .pragma
  </span>
  strings defined by ptxas.
 </p>
 <h2>
  <span class="section-number">
   14.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#pragma-strings-nounroll">
   Pragma Strings: ânounrollâ
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#pragma-strings-nounroll" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  ânounrollâ
 </p>
 <p>
  Disable loop unrolling in optimizing the backend compiler.
 </p>
 <p>
  Syntax
 </p>
 <pre>.pragma "nounroll";
</pre>
 <p>
  Description
 </p>
 <p>
  The
  <span class="pre">
   "nounroll"
  </span>
  <span class="pre">
   pragma
  </span>
  is a directive to disable loop unrolling in the optimizing backend
compiler.
 </p>
 <p>
  The
  <span class="pre">
   "nounroll"
  </span>
  <span class="pre">
   pragma
  </span>
  is allowed at module, entry-function, and statement levels, with the
following meanings:
 </p>
 module scope
 <p>
  disables unrolling for all loops in module, including loops preceding the
  <span class="pre">
   .pragma
  </span>
  .
 </p>
 entry-function scope
 <p>
  disables unrolling for all loops in the entry function body.
 </p>
 statement-level pragma
 <p>
  disables unrolling of the loop for which the current block is the loop header.
 </p>
 <p>
  Note that in order to have the desired effect at statement level, the
  <span class="pre">
   "nounroll"
  </span>
  directive must
appear before any instruction statements in the loop header basic block for the desired loop. The
loop header block is defined as the block that dominates all blocks in the loop body and is the
target of the loop backedge. Statement-level
  <span class="pre">
   "nounroll"
  </span>
  directives appearing outside of loop
header blocks are silently ignored.
 </p>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 2.0.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_20
  </span>
  or higher. Ignored for
  <span class="pre">
   sm_1x
  </span>
  targets.
 </p>
 <p>
  Examples
 </p>
 <pre>.entry foo (...)
.pragma "nounroll";  // do not unroll any loop in this function
{
...
}

.func bar (...)
{
...
L1_head:
     .pragma "nounroll";  // do not unroll this loop
     ...
@p   bra L1_end;
L1_body:
     ...
L1_continue:
     bra L1_head;
L1_end:
     ...
}
</pre>
 <h2>
  <span class="section-number">
   14.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#pragma-strings-used-bytes-mask">
   Pragma Strings: âused_bytes_maskâ
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#pragma-strings-used-bytes-mask" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  âused_bytes_maskâ
 </p>
 <p>
  Mask for indicating used bytes in data of ld operation.
 </p>
 <p>
  Syntax
 </p>
 <pre>.pragma "used_bytes_mask mask";
</pre>
 <p>
  Description
 </p>
 <p>
  The
  <span class="pre">
   "used_bytes_mask"
  </span>
  <span class="pre">
   pragma
  </span>
  is a directive that specifies used bytes in a load
operation based on the mask provided.
 </p>
 <p>
  <span class="pre">
   "used_bytes_mask"
  </span>
  <span class="pre">
   pragma
  </span>
  needs to be specified prior to a load instruction for which
information about bytes used from the load operation is needed.
Pragma is ignored if instruction following it is not a load instruction.
 </p>
 <p>
  For a load instruction without this pragma, all bytes from the load operation are assumed
to be used.
 </p>
 <p>
  Operand
  <span class="pre">
   mask
  </span>
  is a 32-bit integer with set bits indicating the used bytes in data of
load operation.
 </p>
 <p>
  Semantics
 </p>
 <pre>Each bit in mask operand corresponds to a byte data where each set bit represents the used byte.
Most-significant bit corresponds to most-significant byte of data.

// For 4 bytes load with only lower 3 bytes used
.pragma "used_bytes_mask 0x7";
ld.global.u32 %r0, [gbl];     // Higher 1 byte from %r0 is unused

// For vector load of 16 bytes with lower 12 bytes used
.pragma "used_bytes_mask 0xfff";
ld.global.v4.u32 {%r0, %r1, %r2, %r3}, [gbl];  // %r3 unused
</pre>
 <p>
  PTX ISA Notes
 </p>
 <p>
  Introduced in PTX ISA version 8.3.
 </p>
 <p>
  Target ISA Notes
 </p>
 <p>
  Requires
  <span class="pre">
   sm_50
  </span>
  or higher.
 </p>
 <p>
  Examples
 </p>
 <pre>.pragma "used_bytes_mask 0xfff";
ld.global.v4.u32 {%r0, %r1, %r2, %r3}, [gbl]; // Only lower 12 bytes used
</pre>
 <h1>
  <span class="section-number">
   15.
  </span>
  Notices
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#notices" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <h2>
  <span class="section-number">
   15.1.
  </span>
  Notice
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#notice" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  This document is provided for information purposes only and shall not be regarded as a warranty of a certain functionality, condition, or quality of a product. NVIDIA Corporation (âNVIDIAâ) makes no representations or warranties, expressed or implied, as to the accuracy or completeness of the information contained in this document and assumes no responsibility for any errors contained herein. NVIDIA shall have no liability for the consequences or use of such information or for any infringement of patents or other rights of third parties that may result from its use. This document is not a commitment to develop, release, or deliver any Material (defined below), code, or functionality.
 </p>
 <p>
  NVIDIA reserves the right to make corrections, modifications, enhancements, improvements, and any other changes to this document, at any time without notice.
 </p>
 <p>
  Customer should obtain the latest relevant information before placing orders and should verify that such information is current and complete.
 </p>
 <p>
  NVIDIA products are sold subject to the NVIDIA standard terms and conditions of sale supplied at the time of order acknowledgement, unless otherwise agreed in an individual sales agreement signed by authorized representatives of NVIDIA and customer (âTerms of Saleâ). NVIDIA hereby expressly objects to applying any customer general terms and conditions with regards to the purchase of the NVIDIA product referenced in this document. No contractual obligations are formed either directly or indirectly by this document.
 </p>
 <p>
  NVIDIA products are not designed, authorized, or warranted to be suitable for use in medical, military, aircraft, space, or life support equipment, nor in applications where failure or malfunction of the NVIDIA product can reasonably be expected to result in personal injury, death, or property or environmental damage. NVIDIA accepts no liability for inclusion and/or use of NVIDIA products in such equipment or applications and therefore such inclusion and/or use is at customerâs own risk.
 </p>
 <p>
  NVIDIA makes no representation or warranty that products based on this document will be suitable for any specified use. Testing of all parameters of each product is not necessarily performed by NVIDIA. It is customerâs sole responsibility to evaluate and determine the applicability of any information contained in this document, ensure the product is suitable and fit for the application planned by customer, and perform the necessary testing for the application in order to avoid a default of the application or the product. Weaknesses in customerâs product designs may affect the quality and reliability of the NVIDIA product and may result in additional or different conditions and/or requirements beyond those contained in this document. NVIDIA accepts no liability related to any default, damage, costs, or problem which may be based on or attributable to: (i) the use of the NVIDIA product in any manner that is contrary to this document or (ii) customer product designs.
 </p>
 <p>
  No license, either expressed or implied, is granted under any NVIDIA patent right, copyright, or other NVIDIA intellectual property right under this document. Information published by NVIDIA regarding third-party products or services does not constitute a license from NVIDIA to use such products or services or a warranty or endorsement thereof. Use of such information may require a license from a third party under the patents or other intellectual property rights of the third party, or a license from NVIDIA under the patents or other intellectual property rights of NVIDIA.
 </p>
 <p>
  Reproduction of information in this document is permissible only if approved in advance by NVIDIA in writing, reproduced without alteration and in full compliance with all applicable export laws and regulations, and accompanied by all associated conditions, limitations, and notices.
 </p>
 <p>
  THIS DOCUMENT AND ALL NVIDIA DESIGN SPECIFICATIONS, REFERENCE BOARDS, FILES, DRAWINGS, DIAGNOSTICS, LISTS, AND OTHER DOCUMENTS (TOGETHER AND SEPARATELY, âMATERIALSâ) ARE BEING PROVIDED âAS IS.â NVIDIA MAKES NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL NVIDIA BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF ANY USE OF THIS DOCUMENT, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. Notwithstanding any damages that customer might incur for any reason whatsoever, NVIDIAâs aggregate and cumulative liability towards customer for the products described herein shall be limited in accordance with the Terms of Sale for the product.
 </p>
 <h2>
  <span class="section-number">
   15.2.
  </span>
  OpenCL
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#opencl" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  OpenCL is a trademark of Apple Inc. used under license to the Khronos Group Inc.
 </p>
 <h2>
  <span class="section-number">
   15.3.
  </span>
  Trademarks
  <a class="headerlink" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#trademarks" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  NVIDIA and the NVIDIA logo are trademarks or registered trademarks of NVIDIA Corporation in the U.S. and other countries. Other company and product names may be trademarks of the respective companies with which they are associated.
 </p>
 <p class="notices">
  <a href="https://www.nvidia.com/en-us/about-nvidia/privacy-policy/" target="_blank">
   Privacy Policy
  </a>
  |
  <a href="https://www.nvidia.com/en-us/about-nvidia/privacy-center/" target="_blank">
   Manage My Privacy
  </a>
  |
  <a href="https://www.nvidia.com/en-us/preferences/start/" target="_blank">
   Do Not Sell or Share My Data
  </a>
  |
  <a href="https://www.nvidia.com/en-us/about-nvidia/terms-of-service/" target="_blank">
   Terms of Service
  </a>
  |
  <a href="https://www.nvidia.com/en-us/about-nvidia/accessibility/" target="_blank">
   Accessibility
  </a>
  |
  <a href="https://www.nvidia.com/en-us/about-nvidia/company-policies/" target="_blank">
   Corporate Policies
  </a>
  |
  <a href="https://www.nvidia.com/en-us/product-security/" target="_blank">
   Product Security
  </a>
  |
  <a href="https://www.nvidia.com/en-us/contact/" target="_blank">
   Contact
  </a>
 </p>
 <p>
  Copyright Â© 2007-2024, NVIDIA Corporation &amp; affiliates. All rights reserved.
 </p>
 <p>
  <span class="lastupdated">
   Last updated on Jul 1, 2024.
  </span>
 </p>
</body>
</body></html>