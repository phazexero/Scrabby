<html><head><title>NVRTC</title></head><body><body class="wy-body-for-nav">
 <a href="https://docs.nvidia.com/cuda/nvrtc/contents.html">
 </a>
 <ul class="current">
  <li class="toctree-l1 current">
   <a class="current reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html">
    1. Introduction
   </a>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#getting-started">
    2. Getting Started
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#system-requirements">
      2.1. System Requirements
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#installation">
      2.2. Installation
     </a>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#user-interface">
    3. User Interface
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#error-handling">
      3.1. Error Handling
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#enumerations">
        3.1.1. Enumerations
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#functions">
        3.1.2. Functions
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#general-information-query">
      3.2. General Information Query
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#id1">
        3.2.1. Functions
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#compilation">
      3.3. Compilation
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#id2">
        3.3.1. Functions
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#typedefs">
        3.3.2. Typedefs
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#supported-compile-options">
      3.4. Supported Compile Options
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#host-helper">
      3.5. Host Helper
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#id3">
        3.5.1. Functions
       </a>
      </li>
     </ul>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#language">
    4. Language
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#execution-space">
      4.1. Execution Space
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#separate-compilation">
      4.2. Separate Compilation
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#dynamic-parallelism">
      4.3. Dynamic Parallelism
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#integer-size">
      4.4. Integer Size
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#include-syntax">
      4.5. Include Syntax
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#predefined-macros">
      4.6. Predefined Macros
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#predefined-types">
      4.7. Predefined Types
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#builtin-functions">
      4.8. Builtin Functions
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#default-c-dialect">
      4.9. Default C++ Dialect
     </a>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#basic-usage">
    5. Basic Usage
   </a>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#accessing-lowered-names">
    6. Accessing Lowered Names
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#example">
      6.1. Example
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#notes">
      6.2. Notes
     </a>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#interfacing-with-template-host-code">
    7. Interfacing With Template Host Code
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#template-host-code-example">
      7.1. Template Host Code Example
     </a>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#versioning-scheme">
    8. Versioning Scheme
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#nvrtc-shared-library-versioning">
      8.1. NVRTC Shared Library Versioning
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#nvrtc-builtins-library">
      8.2. NVRTC-builtins Library
     </a>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#miscellaneous-notes">
    9. Miscellaneous Notes
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#thread-safety">
      9.1. Thread Safety
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#stack-size">
      9.2. Stack Size
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#nvrtc-static-library">
      9.3. NVRTC Static Library
     </a>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#example-saxpy">
    10. Example: SAXPY
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#code-saxpy-cpp">
      10.1. Code (saxpy.cpp)
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#host-type-name-build-instructions">
      10.2. Host Type Name Build Instructions
     </a>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#example-using-lowered-name">
    11. Example: Using Lowered Name
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#code-lowered-name-cpp">
      11.1. Code (lowered-name.cpp)
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#lowered-name-build-instructions">
      11.2. Lowered Name Build Instructions
     </a>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#example-using-nvrtcgettypename">
    12. Example: Using nvrtcGetTypeName
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#code-host-type-name-cpp">
      12.1. Code (host-type-name.cpp)
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#nvrtcgettypename-build-instructions">
      12.2. nvrtcGetTypeName Build Instructions
     </a>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#example-dynamic-parallelism">
    13. Example: Dynamic Parallelism
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#dynamic-parallelism-build-instructions">
      13.1. Dynamic Parallelism Build Instructions
     </a>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#example-device-lto-link-time-optimization">
    14. Example: Device LTO (link time optimization)
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#code-offline-cu">
      14.1. Code (offline.cu)
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#code-online-cpp">
      14.2. Code (online.cpp)
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#device-lto-build-instructions">
      14.3. Device LTO Build Instructions
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#notices">
      14.4. Notices
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#notice">
        14.4.1. Notice
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#opencl">
        14.4.2. OpenCL
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#trademarks">
        14.4.3. Trademarks
       </a>
      </li>
     </ul>
    </li>
   </ul>
  </li>
 </ul>
 <a href="https://docs.nvidia.com/cuda/nvrtc/contents.html">
  NVRTC
 </a>
 <ul class="wy-breadcrumbs">
  <li>
   <a class="icon icon-home" href="https://docs.nvidia.com/cuda/index.html">
   </a>
   Â»
  </li>
  <li>
   <span class="section-number">
    1.
   </span>
   Introduction
  </li>
  <li class="wy-breadcrumbs-aside">
   <span>
    v12.5 |
   </span>
   <a class="reference external" href="https://docs.nvidia.com/cuda/pdf/NVRTC_User_Guide.pdf">
    PDF
   </a>
   <span>
    |
   </span>
   <a class="reference external" href="https://developer.nvidia.com/cuda-toolkit-archive">
    Archive
   </a>
   <span>
    Â
   </span>
  </li>
 </ul>
 <p class="rubric-h1 rubric">
  nvrtc
 </p>
 <p>
  The User guide for the NVRTC library.
 </p>
 <h1>
  <span class="section-number">
   1.
  </span>
  Introduction
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#introduction" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <p>
  NVRTC is a runtime compilation library for CUDA C++. It accepts CUDA C++ source code in
character string form and creates handles that can be used to obtain the PTX. The PTX
string generated by NVRTC can be loaded by
  <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__MODULE.html#group__CUDA__MODULE_1g04ce266ce03720f479eab76136b90c0b">
   cuModuleLoadData
  </a>
  and
  <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__MODULE.html#group__CUDA__MODULE_1g9e8047e9dbf725f0cd7cafd18bfd4d12">
   cuModuleLoadDataEx
  </a>
  , and
linked with other modules by using the nvJitLink library or using
  <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__MODULE.html#group__CUDA__MODULE_1g3ebcd2ccb772ba9c120937a2d2831b77">
   cuLinkAddData
  </a>
  of the
CUDA Driver API. This facility can often provide optimizations and performance not
possible in a purely offline static compilation.
 </p>
 <p>
  In the absence of NVRTC (or any runtime compilation support in CUDA), users needed to
spawn a separate process to execute nvcc at runtime if they wished to implement runtime
compilation in their applications or libraries, and, unfortunately, this approach has
the following drawbacks:
 </p>
 <ul class="simple">
  <li>
   <p>
    The compilation overhead tends to be higher than necessary.
   </p>
  </li>
  <li>
   <p>
    End users are required to install nvcc and related tools which make it complicated to distribute applications that use runtime compilation.
   </p>
  </li>
 </ul>
 <p>
  NVRTC addresses these issues by providing a library interface that eliminates overhead associated with spawning separate processes, disk I/O,and so on, while keeping application deployment simple.
 </p>
 <h1>
  <span class="section-number">
   2.
  </span>
  Getting Started
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#getting-started" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <h2>
  <span class="section-number">
   2.1.
  </span>
  System Requirements
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#system-requirements" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  NVRTC requires the following system configuration:
 </p>
 <ul class="simple">
  <li>
   <p>
    Operating System: Linux x86_64, Linux ppc64le, Linux aarch64 or Windows x86_64.
   </p>
  </li>
  <li>
   <p>
    GPU: Any GPU with CUDA Compute Capability 2.0 or higher.
   </p>
  </li>
  <li>
   <p>
    CUDA Toolkit and Driver.
   </p>
  </li>
 </ul>
 <h2>
  <span class="section-number">
   2.2.
  </span>
  Installation
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#installation" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  NVRTC is part of the CUDA Toolkit release and the components are organized as follows in the CUDA toolkit installation directory:
 </p>
 <ul class="simple">
  <li>
   <p>
    On Windows:
   </p>
   <ul>
    <li>
     <p>
      <span class="pre">
       include\nvrtc.h
      </span>
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       bin\nvrtc64_Major
      </span>
      <span class="pre">
       Release
      </span>
      <span class="pre">
       VersionMinor
      </span>
      <span class="pre">
       Release
      </span>
      <span class="pre">
       Version_0.dll
      </span>
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       bin\nvrtc-builtins64_Major
      </span>
      <span class="pre">
       Release
      </span>
      <span class="pre">
       VersionMinor
      </span>
      <span class="pre">
       Release
      </span>
      <span class="pre">
       Version.dll
      </span>
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       lib\x64\nvrtc.lib
      </span>
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       lib\x64\nvrtc_static.lib
      </span>
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       lib\x64\nvrtc-builtins_static.lib
      </span>
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       doc\pdf\NVRTC_User_Guide.pdf
      </span>
     </p>
    </li>
   </ul>
  </li>
  <li>
   <p>
    On Linux:
   </p>
   <ul>
    <li>
     <p>
      <span class="pre">
       include/nvrtc.h
      </span>
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       lib64/libnvrtc.so
      </span>
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       lib64/libnvrtc.so.Major
      </span>
      <span class="pre">
       Release
      </span>
      <span class="pre">
       Version.Minor
      </span>
      <span class="pre">
       Release
      </span>
      <span class="pre">
       Version
      </span>
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       lib64/libnvrtc.so.Major
      </span>
      <span class="pre">
       Release
      </span>
      <span class="pre">
       Version.Minor
      </span>
      <span class="pre">
       Release
      </span>
      <span class="pre">
       Version.&lt;build
      </span>
      <span class="pre">
       version&gt;
      </span>
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       lib64/libnvrtc-builtins.so
      </span>
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       lib64/libnvrtc-builtins.so.Major
      </span>
      <span class="pre">
       Release
      </span>
      <span class="pre">
       Version.Minor
      </span>
      <span class="pre">
       Release
      </span>
      <span class="pre">
       Version
      </span>
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       lib64/libnvrtc-builtins.so.Major
      </span>
      <span class="pre">
       Release
      </span>
      <span class="pre">
       Version.Minor
      </span>
      <span class="pre">
       Release
      </span>
      <span class="pre">
       Version.&lt;build
      </span>
      <span class="pre">
       version&gt;
      </span>
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       lib64/libnvrtc_static.a
      </span>
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       lib64/libnvrtc-builtins_static.a
      </span>
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       doc/pdf/NVRTC_User_Guide.pdf
      </span>
     </p>
    </li>
   </ul>
  </li>
 </ul>
 <h1>
  <span class="section-number">
   3.
  </span>
  User Interface
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#user-interface" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <p>
  This chapter presents the API of NVRTC. Basic usage of the API is explained in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#basic-usage">
   Basic Usage
  </a>
  .
 </p>
 <ul class="simple">
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#error-handling">
     Error Handling
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#general-information-query">
     General Information Query
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#compilation">
     Compilation
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#supported-compile-options">
     Supported Compile Options
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#host-helper">
     Host Helper
    </a>
   </p>
  </li>
 </ul>
 <h2>
  <span class="section-number">
   3.1.
  </span>
  Error Handling
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#error-handling" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p id="group__error">
  NVRTC defines the following enumeration type and function for API call error handling.
 </p>
 <p class="rubric-h2 rubric">
  Enumerations
 </p>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
  <span class="std std-ref">
   nvrtcResult
  </span>
 </a>
 <p>
  The enumerated type nvrtcResult defines API call result codes.
 </p>
 <p class="rubric-h2 rubric">
  Functions
 </p>
 <span class="tag-as-table-cell">
  const char *
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1gace77107f185310fb006e7f9a722009e6">
  <span class="std std-ref">
   nvrtcGetErrorString
  </span>
 </a>
 (nvrtcResult result)
 <p>
  nvrtcGetErrorString is a helper function that returns a string describing the given nvrtcResult code, e.g., NVRTC_SUCCESS to
  <span class="pre">
   "NVRTC_SUCCESS"
  </span>
  .
 </p>
 <h3>
  <span class="section-number">
   3.1.1.
  </span>
  Enumerations
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#enumerations" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <span class="k">
  <span class="pre">
   enum
  </span>
 </span>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    nvrtcResult
   </span>
  </span>
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv411nvrtcResult" title="Permalink to this definition">
  ï
 </a>
 <p>
  The enumerated type nvrtcResult defines API call result codes.
 </p>
 <p>
  NVRTC API functions return nvrtcResult to indicate the call result.
 </p>
 <p>
  Values:
 </p>
 <span class="k">
  <span class="pre">
   enumerator
  </span>
 </span>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    NVRTC_SUCCESS
   </span>
  </span>
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv4N11nvrtcResult13NVRTC_SUCCESSE" title="Permalink to this definition">
  ï
 </a>
 <span class="k">
  <span class="pre">
   enumerator
  </span>
 </span>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    NVRTC_ERROR_OUT_OF_MEMORY
   </span>
  </span>
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv4N11nvrtcResult25NVRTC_ERROR_OUT_OF_MEMORYE" title="Permalink to this definition">
  ï
 </a>
 <span class="k">
  <span class="pre">
   enumerator
  </span>
 </span>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    NVRTC_ERROR_PROGRAM_CREATION_FAILURE
   </span>
  </span>
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv4N11nvrtcResult36NVRTC_ERROR_PROGRAM_CREATION_FAILUREE" title="Permalink to this definition">
  ï
 </a>
 <span class="k">
  <span class="pre">
   enumerator
  </span>
 </span>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    NVRTC_ERROR_INVALID_INPUT
   </span>
  </span>
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv4N11nvrtcResult25NVRTC_ERROR_INVALID_INPUTE" title="Permalink to this definition">
  ï
 </a>
 <span class="k">
  <span class="pre">
   enumerator
  </span>
 </span>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    NVRTC_ERROR_INVALID_PROGRAM
   </span>
  </span>
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv4N11nvrtcResult27NVRTC_ERROR_INVALID_PROGRAME" title="Permalink to this definition">
  ï
 </a>
 <span class="k">
  <span class="pre">
   enumerator
  </span>
 </span>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    NVRTC_ERROR_INVALID_OPTION
   </span>
  </span>
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv4N11nvrtcResult26NVRTC_ERROR_INVALID_OPTIONE" title="Permalink to this definition">
  ï
 </a>
 <span class="k">
  <span class="pre">
   enumerator
  </span>
 </span>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    NVRTC_ERROR_COMPILATION
   </span>
  </span>
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv4N11nvrtcResult23NVRTC_ERROR_COMPILATIONE" title="Permalink to this definition">
  ï
 </a>
 <span class="k">
  <span class="pre">
   enumerator
  </span>
 </span>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    NVRTC_ERROR_BUILTIN_OPERATION_FAILURE
   </span>
  </span>
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv4N11nvrtcResult37NVRTC_ERROR_BUILTIN_OPERATION_FAILUREE" title="Permalink to this definition">
  ï
 </a>
 <span class="k">
  <span class="pre">
   enumerator
  </span>
 </span>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    NVRTC_ERROR_NO_NAME_EXPRESSIONS_AFTER_COMPILATION
   </span>
  </span>
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv4N11nvrtcResult49NVRTC_ERROR_NO_NAME_EXPRESSIONS_AFTER_COMPILATIONE" title="Permalink to this definition">
  ï
 </a>
 <span class="k">
  <span class="pre">
   enumerator
  </span>
 </span>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    NVRTC_ERROR_NO_LOWERED_NAMES_BEFORE_COMPILATION
   </span>
  </span>
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv4N11nvrtcResult47NVRTC_ERROR_NO_LOWERED_NAMES_BEFORE_COMPILATIONE" title="Permalink to this definition">
  ï
 </a>
 <span class="k">
  <span class="pre">
   enumerator
  </span>
 </span>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    NVRTC_ERROR_NAME_EXPRESSION_NOT_VALID
   </span>
  </span>
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv4N11nvrtcResult37NVRTC_ERROR_NAME_EXPRESSION_NOT_VALIDE" title="Permalink to this definition">
  ï
 </a>
 <span class="k">
  <span class="pre">
   enumerator
  </span>
 </span>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    NVRTC_ERROR_INTERNAL_ERROR
   </span>
  </span>
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv4N11nvrtcResult26NVRTC_ERROR_INTERNAL_ERRORE" title="Permalink to this definition">
  ï
 </a>
 <span class="k">
  <span class="pre">
   enumerator
  </span>
 </span>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    NVRTC_ERROR_TIME_FILE_WRITE_FAILED
   </span>
  </span>
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv4N11nvrtcResult34NVRTC_ERROR_TIME_FILE_WRITE_FAILEDE" title="Permalink to this definition">
  ï
 </a>
 <h3>
  <span class="section-number">
   3.1.2.
  </span>
  Functions
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#functions" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <span class="k">
  <span class="pre">
   const
  </span>
 </span>
 <span class="kt">
  <span class="pre">
   char
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    nvrtcGetErrorString
   </span>
  </span>
 </span>
 <span class="sig-paren">
  (
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv411nvrtcResult" title="nvrtcResult">
  <span class="n">
   <span class="pre">
    nvrtcResult
   </span>
  </span>
 </a>
 <span class="n sig-param">
  <span class="pre">
   result
  </span>
 </span>
 <span class="sig-paren">
  )
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv419nvrtcGetErrorString11nvrtcResult" title="Permalink to this definition">
  ï
 </a>
 <p>
  nvrtcGetErrorString is a helper function that returns a string describing the given nvrtcResult code, e.g., NVRTC_SUCCESS to
  <span class="pre">
   "NVRTC_SUCCESS"
  </span>
  .
 </p>
 <p>
  For unrecognized enumeration values, it returns
  <span class="pre">
   "NVRTC_ERROR
  </span>
  <span class="pre">
   unknown"
  </span>
  .
 </p>
 Parameters
 <p>
  result
  â
  [in]
  CUDA Runtime Compilation API result code.
 </p>
 Returns
 <p>
  Message string for the given
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
   <span class="std std-ref">
    nvrtcResult
   </span>
  </a>
  code.
 </p>
 <h2>
  <span class="section-number">
   3.2.
  </span>
  General Information Query
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#general-information-query" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p id="group__query">
  NVRTC defines the following function for general information query.
 </p>
 <p class="rubric-h2 rubric">
  Functions
 </p>
 <span class="tag-as-table-cell">
  nvrtcResult
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__query_1gad02fe42a81d969c0efbeb8e4ec78450d">
  <span class="std std-ref">
   nvrtcGetNumSupportedArchs
  </span>
 </a>
 (int *numArchs)
 <p>
  nvrtcGetNumSupportedArchs sets the output parameter
  <span class="pre">
   numArchs
  </span>
  with the number of architectures supported by NVRTC.
 </p>
 <span class="tag-as-table-cell">
  nvrtcResult
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__query_1ga04c729958964c5e7b889a644f086ad4a">
  <span class="std std-ref">
   nvrtcGetSupportedArchs
  </span>
 </a>
 (int *supportedArchs)
 <p>
  nvrtcGetSupportedArchs populates the array passed via the output parameter
  <span class="pre">
   supportedArchs
  </span>
  with the architectures supported by NVRTC.
 </p>
 <span class="tag-as-table-cell">
  nvrtcResult
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__query_1ga7492ae22a599fc3a7cd654915b91d790">
  <span class="std std-ref">
   nvrtcVersion
  </span>
 </a>
 (int *major, int *minor)
 <p>
  nvrtcVersion sets the output parameters
  <span class="pre">
   major
  </span>
  and
  <span class="pre">
   minor
  </span>
  with the CUDA Runtime Compilation version number.
 </p>
 <h3>
  <span class="section-number">
   3.2.1.
  </span>
  Functions
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#id1" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv411nvrtcResult" title="nvrtcResult">
  <span class="n">
   <span class="pre">
    nvrtcResult
   </span>
  </span>
 </a>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    nvrtcGetNumSupportedArchs
   </span>
  </span>
 </span>
 <span class="sig-paren">
  (
 </span>
 <span class="kt">
  <span class="pre">
   int
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   numArchs
  </span>
 </span>
 <span class="sig-paren">
  )
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv425nvrtcGetNumSupportedArchsPi" title="Permalink to this definition">
  ï
 </a>
 <p>
  nvrtcGetNumSupportedArchs sets the output parameter
  <span class="pre">
   numArchs
  </span>
  with the number of architectures supported by NVRTC.
 </p>
 <p>
  This can then be used to pass an array to
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__query_1ga04c729958964c5e7b889a644f086ad4a">
   <span class="std std-ref">
    nvrtcGetSupportedArchs
   </span>
  </a>
  to get the supported architectures.
 </p>
 <p>
  see
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__query_1ga04c729958964c5e7b889a644f086ad4a">
   <span class="std std-ref">
    nvrtcGetSupportedArchs
   </span>
  </a>
 </p>
 Parameters
 <p>
  numArchs
  â
  [out]
  number of supported architectures.
 </p>
 Returns
 <ul class="simple">
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_SUCCESS
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_INPUT
     </span>
    </a>
   </p>
  </li>
 </ul>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv411nvrtcResult" title="nvrtcResult">
  <span class="n">
   <span class="pre">
    nvrtcResult
   </span>
  </span>
 </a>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    nvrtcGetSupportedArchs
   </span>
  </span>
 </span>
 <span class="sig-paren">
  (
 </span>
 <span class="kt">
  <span class="pre">
   int
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   supportedArchs
  </span>
 </span>
 <span class="sig-paren">
  )
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv422nvrtcGetSupportedArchsPi" title="Permalink to this definition">
  ï
 </a>
 <p>
  nvrtcGetSupportedArchs populates the array passed via the output parameter
  <span class="pre">
   supportedArchs
  </span>
  with the architectures supported by NVRTC.
 </p>
 <p>
  The array is sorted in the ascending order. The size of the array to be passed can be determined using
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__query_1gad02fe42a81d969c0efbeb8e4ec78450d">
   <span class="std std-ref">
    nvrtcGetNumSupportedArchs
   </span>
  </a>
  .
 </p>
 <p>
  see
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__query_1gad02fe42a81d969c0efbeb8e4ec78450d">
   <span class="std std-ref">
    nvrtcGetNumSupportedArchs
   </span>
  </a>
 </p>
 Parameters
 <p>
  supportedArchs
  â
  [out]
  sorted array of supported architectures.
 </p>
 Returns
 <ul class="simple">
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_SUCCESS
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_INPUT
     </span>
    </a>
   </p>
  </li>
 </ul>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv411nvrtcResult" title="nvrtcResult">
  <span class="n">
   <span class="pre">
    nvrtcResult
   </span>
  </span>
 </a>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    nvrtcVersion
   </span>
  </span>
 </span>
 <span class="sig-paren">
  (
 </span>
 <span class="kt">
  <span class="pre">
   int
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   major
  </span>
 </span>
 ,
 <span class="kt">
  <span class="pre">
   int
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   minor
  </span>
 </span>
 <span class="sig-paren">
  )
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv412nvrtcVersionPiPi" title="Permalink to this definition">
  ï
 </a>
 <p>
  nvrtcVersion sets the output parameters
  <span class="pre">
   major
  </span>
  and
  <span class="pre">
   minor
  </span>
  with the CUDA Runtime Compilation version number.
 </p>
 Parameters
 <ul class="simple">
  <li>
   <p>
    major
    â
    [out]
    CUDA Runtime Compilation major version number.
   </p>
  </li>
  <li>
   <p>
    minor
    â
    [out]
    CUDA Runtime Compilation minor version number.
   </p>
  </li>
 </ul>
 Returns
 <ul class="simple">
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_SUCCESS
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_INPUT
     </span>
    </a>
   </p>
  </li>
 </ul>
 <h2>
  <span class="section-number">
   3.3.
  </span>
  Compilation
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#compilation" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p id="group__compilation">
  NVRTC defines the following type and functions for actual compilation.
 </p>
 <p class="rubric-h2 rubric">
  Functions
 </p>
 <span class="tag-as-table-cell">
  nvrtcResult
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1ga0b07e4173b28a10682f21edc7140844e">
  <span class="std std-ref">
   nvrtcAddNameExpression
  </span>
 </a>
 (nvrtcProgram prog, const char *const name_expression)
 <p>
  nvrtcAddNameExpression notes the given name expression denoting the address of a
  global
  function or
  device
  /__constant__ variable.
 </p>
 <span class="tag-as-table-cell">
  nvrtcResult
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1ga1f3136029db1413e362154b567297e8b">
  <span class="std std-ref">
   nvrtcCompileProgram
  </span>
 </a>
 (nvrtcProgram prog, int numOptions, const char *const *options)
 <p>
  nvrtcCompileProgram compiles the given program.
 </p>
 <span class="tag-as-table-cell">
  nvrtcResult
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1ga9ae65f68911d1cf0adda2af4ad8cb458">
  <span class="std std-ref">
   nvrtcCreateProgram
  </span>
 </a>
 (nvrtcProgram *prog, const char *src, const char *name, int numHeaders, const char *const *headers, const char *const *includeNames)
 <p>
  nvrtcCreateProgram creates an instance of nvrtcProgram with the given input parameters, and sets the output parameter
  <span class="pre">
   prog
  </span>
  with it.
 </p>
 <span class="tag-as-table-cell">
  nvrtcResult
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1gaaa237c59615b7d4f48d5b308b5c9b140">
  <span class="std std-ref">
   nvrtcDestroyProgram
  </span>
 </a>
 (nvrtcProgram *prog)
 <p>
  nvrtcDestroyProgram destroys the given program.
 </p>
 <span class="tag-as-table-cell">
  nvrtcResult
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1ga4ecc086d17712082178a241941efcd41">
  <span class="std std-ref">
   nvrtcGetCUBIN
  </span>
 </a>
 (nvrtcProgram prog, char *cubin)
 <p>
  nvrtcGetCUBIN stores the cubin generated by the previous compilation of
  <span class="pre">
   prog
  </span>
  in the memory pointed by
  <span class="pre">
   cubin
  </span>
  .
 </p>
 <span class="tag-as-table-cell">
  nvrtcResult
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1gaea4745f354b8768f3e9777490d87adf0">
  <span class="std std-ref">
   nvrtcGetCUBINSize
  </span>
 </a>
 (nvrtcProgram prog, size_t *cubinSizeRet)
 <p>
  nvrtcGetCUBINSize sets the value of
  <span class="pre">
   cubinSizeRet
  </span>
  with the size of the cubin generated by the previous compilation of
  <span class="pre">
   prog
  </span>
  .
 </p>
 <span class="tag-as-table-cell">
  nvrtcResult
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1gaf177b85a16bd879ba5d814e7afd5e2a0">
  <span class="std std-ref">
   nvrtcGetLTOIR
  </span>
 </a>
 (nvrtcProgram prog, char *LTOIR)
 <p>
  nvrtcGetLTOIR stores the LTO IR generated by the previous compilation of
  <span class="pre">
   prog
  </span>
  in the memory pointed by
  <span class="pre">
   LTOIR
  </span>
  .
 </p>
 <span class="tag-as-table-cell">
  nvrtcResult
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1gac2343fbb195dec6a0c10de30e35f2371">
  <span class="std std-ref">
   nvrtcGetLTOIRSize
  </span>
 </a>
 (nvrtcProgram prog, size_t *LTOIRSizeRet)
 <p>
  nvrtcGetLTOIRSize sets the value of
  <span class="pre">
   LTOIRSizeRet
  </span>
  with the size of the LTO IR generated by the previous compilation of
  <span class="pre">
   prog
  </span>
  .
 </p>
 <span class="tag-as-table-cell">
  nvrtcResult
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1ga2543158bd0e25649254a9d86a81e4f50">
  <span class="std std-ref">
   nvrtcGetLoweredName
  </span>
 </a>
 (nvrtcProgram prog, const char *const name_expression, const char **lowered_name)
 <p>
  nvrtcGetLoweredName extracts the lowered (mangled) name for a
  global
  function or
  device
  /__constant__ variable, and updates *lowered_name to point to it.
 </p>
 <span class="tag-as-table-cell">
  nvrtcResult
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1ga398a540d5b4eb38492af9d0468b0145b">
  <span class="std std-ref">
   nvrtcGetNVVM
  </span>
 </a>
 (nvrtcProgram prog, char *nvvm)
 <p>
  DEPRECATION NOTICE: This function will be removed in a future release.
 </p>
 <span class="tag-as-table-cell">
  nvrtcResult
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1ga97df8ee486fb49370c34e3a831eafcfb">
  <span class="std std-ref">
   nvrtcGetNVVMSize
  </span>
 </a>
 (nvrtcProgram prog, size_t *nvvmSizeRet)
 <p>
  DEPRECATION NOTICE: This function will be removed in a future release.
 </p>
 <span class="tag-as-table-cell">
  nvrtcResult
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1ga475c7f5a59f9c69a03541e496942ed19">
  <span class="std std-ref">
   nvrtcGetOptiXIR
  </span>
 </a>
 (nvrtcProgram prog, char *optixir)
 <p>
  nvrtcGetOptiXIR stores the OptiX IR generated by the previous compilation of
  <span class="pre">
   prog
  </span>
  in the memory pointed by
  <span class="pre">
   optixir
  </span>
  .
 </p>
 <span class="tag-as-table-cell">
  nvrtcResult
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1ga4b9ff77cc01b3ec20e73606fa9d8dd1e">
  <span class="std std-ref">
   nvrtcGetOptiXIRSize
  </span>
 </a>
 (nvrtcProgram prog, size_t *optixirSizeRet)
 <p>
  nvrtcGetOptiXIRSize sets the value of
  <span class="pre">
   optixirSizeRet
  </span>
  with the size of the OptiX IR generated by the previous compilation of
  <span class="pre">
   prog
  </span>
  .
 </p>
 <span class="tag-as-table-cell">
  nvrtcResult
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1gac9a66bbbd47c256f4a8955517b3965da">
  <span class="std std-ref">
   nvrtcGetPTX
  </span>
 </a>
 (nvrtcProgram prog, char *ptx)
 <p>
  nvrtcGetPTX stores the PTX generated by the previous compilation of
  <span class="pre">
   prog
  </span>
  in the memory pointed by
  <span class="pre">
   ptx
  </span>
  .
 </p>
 <span class="tag-as-table-cell">
  nvrtcResult
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1gac622d6ffb6fff71e209407da19612c1a">
  <span class="std std-ref">
   nvrtcGetPTXSize
  </span>
 </a>
 (nvrtcProgram prog, size_t *ptxSizeRet)
 <p>
  nvrtcGetPTXSize sets the value of
  <span class="pre">
   ptxSizeRet
  </span>
  with the size of the PTX generated by the previous compilation of
  <span class="pre">
   prog
  </span>
  (including the trailing
  <span class="pre">
   NULL
  </span>
  ).
 </p>
 <span class="tag-as-table-cell">
  nvrtcResult
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1ga74c550e5cab81efbd59e4f72579edbd1">
  <span class="std std-ref">
   nvrtcGetProgramLog
  </span>
 </a>
 (nvrtcProgram prog, char *log)
 <p>
  nvrtcGetProgramLog stores the log generated by the previous compilation of
  <span class="pre">
   prog
  </span>
  in the memory pointed by
  <span class="pre">
   log
  </span>
  .
 </p>
 <span class="tag-as-table-cell">
  nvrtcResult
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1ga59944bb118095ab53eec8994d056a18d">
  <span class="std std-ref">
   nvrtcGetProgramLogSize
  </span>
 </a>
 (nvrtcProgram prog, size_t *logSizeRet)
 <p>
  nvrtcGetProgramLogSize sets
  <span class="pre">
   logSizeRet
  </span>
  with the size of the log generated by the previous compilation of
  <span class="pre">
   prog
  </span>
  (including the trailing
  <span class="pre">
   NULL
  </span>
  ).
 </p>
 <p class="rubric-h2 rubric">
  Typedefs
 </p>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1gaa64ec636c8e3e1e8ea10028866c4594b">
  <span class="std std-ref">
   nvrtcProgram
  </span>
 </a>
 <p>
  nvrtcProgram is the unit of compilation, and an opaque handle for a program.
 </p>
 <h3>
  <span class="section-number">
   3.3.1.
  </span>
  Functions
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#id2" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv411nvrtcResult" title="nvrtcResult">
  <span class="n">
   <span class="pre">
    nvrtcResult
   </span>
  </span>
 </a>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    nvrtcAddNameExpression
   </span>
  </span>
 </span>
 <span class="sig-paren">
  (
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv412nvrtcProgram" title="nvrtcProgram">
  <span class="n">
   <span class="pre">
    nvrtcProgram
   </span>
  </span>
 </a>
 <span class="n sig-param">
  <span class="pre">
   prog
  </span>
 </span>
 ,
 <span class="k">
  <span class="pre">
   const
  </span>
 </span>
 <span class="kt">
  <span class="pre">
   char
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="k">
  <span class="pre">
   const
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   name_expression
  </span>
 </span>
 <span class="sig-paren">
  )
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv422nvrtcAddNameExpression12nvrtcProgramPCKc" title="Permalink to this definition">
  ï
 </a>
 <p>
  nvrtcAddNameExpression notes the given name expression denoting the address of a
  global
  function or
  device
  /__constant__ variable.
 </p>
 <p>
  The identical name expression string must be provided on a subsequent call to nvrtcGetLoweredName to extract the lowered name.
 </p>
 <p class="admonition-title">
  See also
 </p>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1ga2543158bd0e25649254a9d86a81e4f50">
   <span class="std std-ref">
    nvrtcGetLoweredName
   </span>
  </a>
 </p>
 Parameters
 <ul class="simple">
  <li>
   <p>
    prog
    â
    [in]
    CUDA Runtime Compilation program.
   </p>
  </li>
  <li>
   <p>
    name_expression
    â
    [in]
    constant expression denoting the address of a
    global
    function or
    device
    /__constant__ variable.
   </p>
  </li>
 </ul>
 Returns
 <ul class="simple">
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_SUCCESS
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_PROGRAM
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_INPUT
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_NO_NAME_EXPRESSIONS_AFTER_COMPILATION
     </span>
    </a>
   </p>
  </li>
 </ul>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv411nvrtcResult" title="nvrtcResult">
  <span class="n">
   <span class="pre">
    nvrtcResult
   </span>
  </span>
 </a>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    nvrtcCompileProgram
   </span>
  </span>
 </span>
 <span class="sig-paren">
  (
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv412nvrtcProgram" title="nvrtcProgram">
  <span class="n">
   <span class="pre">
    nvrtcProgram
   </span>
  </span>
 </a>
 <span class="n sig-param">
  <span class="pre">
   prog
  </span>
 </span>
 ,
 <span class="kt">
  <span class="pre">
   int
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   numOptions
  </span>
 </span>
 ,
 <span class="k">
  <span class="pre">
   const
  </span>
 </span>
 <span class="kt">
  <span class="pre">
   char
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="k">
  <span class="pre">
   const
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   options
  </span>
 </span>
 <span class="sig-paren">
  )
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv419nvrtcCompileProgram12nvrtcProgramiPPCKc" title="Permalink to this definition">
  ï
 </a>
 <p>
  nvrtcCompileProgram compiles the given program.
 </p>
 <p>
  It supports compile options listed in
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__options">
   <span class="std std-ref">
    Supported Compile Options
   </span>
  </a>
  .
 </p>
 Parameters
 <ul class="simple">
  <li>
   <p>
    prog
    â
    [in]
    CUDA Runtime Compilation program.
   </p>
  </li>
  <li>
   <p>
    numOptions
    â
    [in]
    Number of compiler options passed.
   </p>
  </li>
  <li>
   <p>
    options
    â
    [in]
    Compiler options in the form of C string array.
    <span class="pre">
     options
    </span>
    can be
    <span class="pre">
     NULL
    </span>
    when
    <span class="pre">
     numOptions
    </span>
    is 0.
   </p>
  </li>
 </ul>
 Returns
 <ul class="simple">
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_SUCCESS
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_OUT_OF_MEMORY
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_INPUT
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_PROGRAM
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_OPTION
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_COMPILATION
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_BUILTIN_OPERATION_FAILURE
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_TIME_FILE_WRITE_FAILED
     </span>
    </a>
   </p>
  </li>
 </ul>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv411nvrtcResult" title="nvrtcResult">
  <span class="n">
   <span class="pre">
    nvrtcResult
   </span>
  </span>
 </a>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    nvrtcCreateProgram
   </span>
  </span>
 </span>
 <span class="sig-paren">
  (
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv412nvrtcProgram" title="nvrtcProgram">
  <span class="n">
   <span class="pre">
    nvrtcProgram
   </span>
  </span>
 </a>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   prog
  </span>
 </span>
 ,
 <span class="k">
  <span class="pre">
   const
  </span>
 </span>
 <span class="kt">
  <span class="pre">
   char
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   src
  </span>
 </span>
 ,
 <span class="k">
  <span class="pre">
   const
  </span>
 </span>
 <span class="kt">
  <span class="pre">
   char
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   name
  </span>
 </span>
 ,
 <span class="kt">
  <span class="pre">
   int
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   numHeaders
  </span>
 </span>
 ,
 <span class="k">
  <span class="pre">
   const
  </span>
 </span>
 <span class="kt">
  <span class="pre">
   char
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="k">
  <span class="pre">
   const
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   headers
  </span>
 </span>
 ,
 <span class="k">
  <span class="pre">
   const
  </span>
 </span>
 <span class="kt">
  <span class="pre">
   char
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="k">
  <span class="pre">
   const
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   includeNames
  </span>
 </span>
 <span class="sig-paren">
  )
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv418nvrtcCreateProgramP12nvrtcProgramPKcPKciPPCKcPPCKc" title="Permalink to this definition">
  ï
 </a>
 <p>
  nvrtcCreateProgram creates an instance of nvrtcProgram with the given input parameters, and sets the output parameter
  <span class="pre">
   prog
  </span>
  with it.
 </p>
 <p class="admonition-title">
  See also
 </p>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1gaaa237c59615b7d4f48d5b308b5c9b140">
   <span class="std std-ref">
    nvrtcDestroyProgram
   </span>
  </a>
 </p>
 Parameters
 <ul class="simple">
  <li>
   <p>
    prog
    â
    [out]
    CUDA Runtime Compilation program.
   </p>
  </li>
  <li>
   <p>
    src
    â
    [in]
    CUDA program source.
   </p>
  </li>
  <li>
   <p>
    name
    â
    [in]
    CUDA program name.
    <span class="pre">
     name
    </span>
    can be
    <span class="pre">
     NULL
    </span>
    ;
    <span class="pre">
     "default_program"
    </span>
    is used when
    <span class="pre">
     name
    </span>
    is
    <span class="pre">
     NULL
    </span>
    or ââ.
   </p>
  </li>
  <li>
   <p>
    numHeaders
    â
    [in]
    Number of headers used.
    <span class="pre">
     numHeaders
    </span>
    must be greater than or equal to 0.
   </p>
  </li>
  <li>
   <p>
    headers
    â
    [in]
    Sources of the headers.
    <span class="pre">
     headers
    </span>
    can be
    <span class="pre">
     NULL
    </span>
    when
    <span class="pre">
     numHeaders
    </span>
    is 0.
   </p>
  </li>
  <li>
   <p>
    includeNames
    â
    [in]
    Name of each header by which they can be included in the CUDA program source.
    <span class="pre">
     includeNames
    </span>
    can be
    <span class="pre">
     NULL
    </span>
    when
    <span class="pre">
     numHeaders
    </span>
    is 0. These headers must be included with the exact names specified here.
   </p>
  </li>
 </ul>
 Returns
 <ul class="simple">
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_SUCCESS
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_OUT_OF_MEMORY
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_PROGRAM_CREATION_FAILURE
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_INPUT
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_PROGRAM
     </span>
    </a>
   </p>
  </li>
 </ul>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv411nvrtcResult" title="nvrtcResult">
  <span class="n">
   <span class="pre">
    nvrtcResult
   </span>
  </span>
 </a>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    nvrtcDestroyProgram
   </span>
  </span>
 </span>
 <span class="sig-paren">
  (
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv412nvrtcProgram" title="nvrtcProgram">
  <span class="n">
   <span class="pre">
    nvrtcProgram
   </span>
  </span>
 </a>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   prog
  </span>
 </span>
 <span class="sig-paren">
  )
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv419nvrtcDestroyProgramP12nvrtcProgram" title="Permalink to this definition">
  ï
 </a>
 <p>
  nvrtcDestroyProgram destroys the given program.
 </p>
 <p class="admonition-title">
  See also
 </p>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1ga9ae65f68911d1cf0adda2af4ad8cb458">
   <span class="std std-ref">
    nvrtcCreateProgram
   </span>
  </a>
 </p>
 Parameters
 <p>
  prog
  â
  [in]
  CUDA Runtime Compilation program.
 </p>
 Returns
 <ul class="simple">
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_SUCCESS
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_PROGRAM
     </span>
    </a>
   </p>
  </li>
 </ul>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv411nvrtcResult" title="nvrtcResult">
  <span class="n">
   <span class="pre">
    nvrtcResult
   </span>
  </span>
 </a>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    nvrtcGetCUBIN
   </span>
  </span>
 </span>
 <span class="sig-paren">
  (
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv412nvrtcProgram" title="nvrtcProgram">
  <span class="n">
   <span class="pre">
    nvrtcProgram
   </span>
  </span>
 </a>
 <span class="n sig-param">
  <span class="pre">
   prog
  </span>
 </span>
 ,
 <span class="kt">
  <span class="pre">
   char
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   cubin
  </span>
 </span>
 <span class="sig-paren">
  )
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv413nvrtcGetCUBIN12nvrtcProgramPc" title="Permalink to this definition">
  ï
 </a>
 <p>
  nvrtcGetCUBIN stores the cubin generated by the previous compilation of
  <span class="pre">
   prog
  </span>
  in the memory pointed by
  <span class="pre">
   cubin
  </span>
  .
 </p>
 <p>
  No cubin is available if the value specified to
  <span class="pre">
   -arch
  </span>
  is a virtual architecture instead of an actual architecture.
 </p>
 <p class="admonition-title">
  See also
 </p>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1gaea4745f354b8768f3e9777490d87adf0">
   <span class="std std-ref">
    nvrtcGetCUBINSize
   </span>
  </a>
 </p>
 Parameters
 <ul class="simple">
  <li>
   <p>
    prog
    â
    [in]
    CUDA Runtime Compilation program.
   </p>
  </li>
  <li>
   <p>
    cubin
    â
    [out]
    Compiled and assembled result.
   </p>
  </li>
 </ul>
 Returns
 <ul class="simple">
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_SUCCESS
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_INPUT
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_PROGRAM
     </span>
    </a>
   </p>
  </li>
 </ul>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv411nvrtcResult" title="nvrtcResult">
  <span class="n">
   <span class="pre">
    nvrtcResult
   </span>
  </span>
 </a>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    nvrtcGetCUBINSize
   </span>
  </span>
 </span>
 <span class="sig-paren">
  (
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv412nvrtcProgram" title="nvrtcProgram">
  <span class="n">
   <span class="pre">
    nvrtcProgram
   </span>
  </span>
 </a>
 <span class="n sig-param">
  <span class="pre">
   prog
  </span>
 </span>
 ,
 <span class="n">
  <span class="pre">
   size_t
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   cubinSizeRet
  </span>
 </span>
 <span class="sig-paren">
  )
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv417nvrtcGetCUBINSize12nvrtcProgramP6size_t" title="Permalink to this definition">
  ï
 </a>
 <p>
  nvrtcGetCUBINSize sets the value of
  <span class="pre">
   cubinSizeRet
  </span>
  with the size of the cubin generated by the previous compilation of
  <span class="pre">
   prog
  </span>
  .
 </p>
 <p>
  The value of cubinSizeRet is set to 0 if the value specified to
  <span class="pre">
   -arch
  </span>
  is a virtual architecture instead of an actual architecture.
 </p>
 <p class="admonition-title">
  See also
 </p>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1ga4ecc086d17712082178a241941efcd41">
   <span class="std std-ref">
    nvrtcGetCUBIN
   </span>
  </a>
 </p>
 Parameters
 <ul class="simple">
  <li>
   <p>
    prog
    â
    [in]
    CUDA Runtime Compilation program.
   </p>
  </li>
  <li>
   <p>
    cubinSizeRet
    â
    [out]
    Size of the generated cubin.
   </p>
  </li>
 </ul>
 Returns
 <ul class="simple">
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_SUCCESS
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_INPUT
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_PROGRAM
     </span>
    </a>
   </p>
  </li>
 </ul>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv411nvrtcResult" title="nvrtcResult">
  <span class="n">
   <span class="pre">
    nvrtcResult
   </span>
  </span>
 </a>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    nvrtcGetLTOIR
   </span>
  </span>
 </span>
 <span class="sig-paren">
  (
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv412nvrtcProgram" title="nvrtcProgram">
  <span class="n">
   <span class="pre">
    nvrtcProgram
   </span>
  </span>
 </a>
 <span class="n sig-param">
  <span class="pre">
   prog
  </span>
 </span>
 ,
 <span class="kt">
  <span class="pre">
   char
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   LTOIR
  </span>
 </span>
 <span class="sig-paren">
  )
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv413nvrtcGetLTOIR12nvrtcProgramPc" title="Permalink to this definition">
  ï
 </a>
 <p>
  nvrtcGetLTOIR stores the LTO IR generated by the previous compilation of
  <span class="pre">
   prog
  </span>
  in the memory pointed by
  <span class="pre">
   LTOIR
  </span>
  .
 </p>
 <p>
  No LTO IR is available if the program was compiled without
  <span class="pre">
   -dlto
  </span>
  .
 </p>
 <p class="admonition-title">
  See also
 </p>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1gac2343fbb195dec6a0c10de30e35f2371">
   <span class="std std-ref">
    nvrtcGetLTOIRSize
   </span>
  </a>
 </p>
 Parameters
 <ul class="simple">
  <li>
   <p>
    prog
    â
    [in]
    CUDA Runtime Compilation program.
   </p>
  </li>
  <li>
   <p>
    LTOIR
    â
    [out]
    Compiled result.
   </p>
  </li>
 </ul>
 Returns
 <ul class="simple">
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_SUCCESS
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_INPUT
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_PROGRAM
     </span>
    </a>
   </p>
  </li>
 </ul>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv411nvrtcResult" title="nvrtcResult">
  <span class="n">
   <span class="pre">
    nvrtcResult
   </span>
  </span>
 </a>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    nvrtcGetLTOIRSize
   </span>
  </span>
 </span>
 <span class="sig-paren">
  (
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv412nvrtcProgram" title="nvrtcProgram">
  <span class="n">
   <span class="pre">
    nvrtcProgram
   </span>
  </span>
 </a>
 <span class="n sig-param">
  <span class="pre">
   prog
  </span>
 </span>
 ,
 <span class="n">
  <span class="pre">
   size_t
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   LTOIRSizeRet
  </span>
 </span>
 <span class="sig-paren">
  )
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv417nvrtcGetLTOIRSize12nvrtcProgramP6size_t" title="Permalink to this definition">
  ï
 </a>
 <p>
  nvrtcGetLTOIRSize sets the value of
  <span class="pre">
   LTOIRSizeRet
  </span>
  with the size of the LTO IR generated by the previous compilation of
  <span class="pre">
   prog
  </span>
  .
 </p>
 <p>
  The value of LTOIRSizeRet is set to 0 if the program was not compiled with
  <span class="pre">
   -dlto
  </span>
  .
 </p>
 <p class="admonition-title">
  See also
 </p>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1gaf177b85a16bd879ba5d814e7afd5e2a0">
   <span class="std std-ref">
    nvrtcGetLTOIR
   </span>
  </a>
 </p>
 Parameters
 <ul class="simple">
  <li>
   <p>
    prog
    â
    [in]
    CUDA Runtime Compilation program.
   </p>
  </li>
  <li>
   <p>
    LTOIRSizeRet
    â
    [out]
    Size of the generated LTO IR.
   </p>
  </li>
 </ul>
 Returns
 <ul class="simple">
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_SUCCESS
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_INPUT
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_PROGRAM
     </span>
    </a>
   </p>
  </li>
 </ul>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv411nvrtcResult" title="nvrtcResult">
  <span class="n">
   <span class="pre">
    nvrtcResult
   </span>
  </span>
 </a>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    nvrtcGetLoweredName
   </span>
  </span>
 </span>
 <span class="sig-paren">
  (
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv412nvrtcProgram" title="nvrtcProgram">
  <span class="n">
   <span class="pre">
    nvrtcProgram
   </span>
  </span>
 </a>
 <span class="n sig-param">
  <span class="pre">
   prog
  </span>
 </span>
 ,
 <span class="k">
  <span class="pre">
   const
  </span>
 </span>
 <span class="kt">
  <span class="pre">
   char
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="k">
  <span class="pre">
   const
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   name_expression
  </span>
 </span>
 ,
 <span class="k">
  <span class="pre">
   const
  </span>
 </span>
 <span class="kt">
  <span class="pre">
   char
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   lowered_name
  </span>
 </span>
 <span class="sig-paren">
  )
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv419nvrtcGetLoweredName12nvrtcProgramPCKcPPKc" title="Permalink to this definition">
  ï
 </a>
 <p>
  nvrtcGetLoweredName extracts the lowered (mangled) name for a
  global
  function or
  device
  /__constant__ variable, and updates *lowered_name to point to it.
 </p>
 <p>
  The memory containing the name is released when the NVRTC program is destroyed by nvrtcDestroyProgram. The identical name expression must have been previously provided to nvrtcAddNameExpression.
 </p>
 <p class="admonition-title">
  See also
 </p>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1ga0b07e4173b28a10682f21edc7140844e">
   <span class="std std-ref">
    nvrtcAddNameExpression
   </span>
  </a>
 </p>
 Parameters
 <ul class="simple">
  <li>
   <p>
    prog
    â
    [in]
    CUDA Runtime Compilation program.
   </p>
  </li>
  <li>
   <p>
    name_expression
    â
    [in]
    constant expression denoting the address of a
    global
    function or
    device
    /__constant__ variable.
   </p>
  </li>
  <li>
   <p>
    lowered_name
    â
    [out]
    initialized by the function to point to a C string containing the lowered (mangled) name corresponding to the provided name expression.
   </p>
  </li>
 </ul>
 Returns
 <ul class="simple">
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_SUCCESS
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_NO_LOWERED_NAMES_BEFORE_COMPILATION
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_PROGRAM
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_INPUT
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_NAME_EXPRESSION_NOT_VALID
     </span>
    </a>
   </p>
  </li>
 </ul>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv411nvrtcResult" title="nvrtcResult">
  <span class="n">
   <span class="pre">
    nvrtcResult
   </span>
  </span>
 </a>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    nvrtcGetNVVM
   </span>
  </span>
 </span>
 <span class="sig-paren">
  (
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv412nvrtcProgram" title="nvrtcProgram">
  <span class="n">
   <span class="pre">
    nvrtcProgram
   </span>
  </span>
 </a>
 <span class="n sig-param">
  <span class="pre">
   prog
  </span>
 </span>
 ,
 <span class="kt">
  <span class="pre">
   char
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   nvvm
  </span>
 </span>
 <span class="sig-paren">
  )
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv412nvrtcGetNVVM12nvrtcProgramPc" title="Permalink to this definition">
  ï
 </a>
 <p>
  DEPRECATION NOTICE: This function will be removed in a future release.
 </p>
 <p>
  Please use nvrtcGetLTOIR (and nvrtcGetLTOIRSize) instead.
 </p>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv411nvrtcResult" title="nvrtcResult">
  <span class="n">
   <span class="pre">
    nvrtcResult
   </span>
  </span>
 </a>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    nvrtcGetNVVMSize
   </span>
  </span>
 </span>
 <span class="sig-paren">
  (
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv412nvrtcProgram" title="nvrtcProgram">
  <span class="n">
   <span class="pre">
    nvrtcProgram
   </span>
  </span>
 </a>
 <span class="n sig-param">
  <span class="pre">
   prog
  </span>
 </span>
 ,
 <span class="n">
  <span class="pre">
   size_t
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   nvvmSizeRet
  </span>
 </span>
 <span class="sig-paren">
  )
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv416nvrtcGetNVVMSize12nvrtcProgramP6size_t" title="Permalink to this definition">
  ï
 </a>
 <p>
  DEPRECATION NOTICE: This function will be removed in a future release.
 </p>
 <p>
  Please use nvrtcGetLTOIRSize (and nvrtcGetLTOIR) instead.
 </p>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv411nvrtcResult" title="nvrtcResult">
  <span class="n">
   <span class="pre">
    nvrtcResult
   </span>
  </span>
 </a>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    nvrtcGetOptiXIR
   </span>
  </span>
 </span>
 <span class="sig-paren">
  (
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv412nvrtcProgram" title="nvrtcProgram">
  <span class="n">
   <span class="pre">
    nvrtcProgram
   </span>
  </span>
 </a>
 <span class="n sig-param">
  <span class="pre">
   prog
  </span>
 </span>
 ,
 <span class="kt">
  <span class="pre">
   char
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   optixir
  </span>
 </span>
 <span class="sig-paren">
  )
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv415nvrtcGetOptiXIR12nvrtcProgramPc" title="Permalink to this definition">
  ï
 </a>
 <p>
  nvrtcGetOptiXIR stores the OptiX IR generated by the previous compilation of
  <span class="pre">
   prog
  </span>
  in the memory pointed by
  <span class="pre">
   optixir
  </span>
  .
 </p>
 <p>
  No OptiX IR is available if the program was compiled with options incompatible with OptiX IR generation.
 </p>
 <p class="admonition-title">
  See also
 </p>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1ga4b9ff77cc01b3ec20e73606fa9d8dd1e">
   <span class="std std-ref">
    nvrtcGetOptiXIRSize
   </span>
  </a>
 </p>
 Parameters
 <ul class="simple">
  <li>
   <p>
    prog
    â
    [in]
    CUDA Runtime Compilation program.
   </p>
  </li>
  <li>
   <p>
    Optix
    â
    [out]
    IR Compiled result.
   </p>
  </li>
 </ul>
 Returns
 <ul class="simple">
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_SUCCESS
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_INPUT
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_PROGRAM
     </span>
    </a>
   </p>
  </li>
 </ul>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv411nvrtcResult" title="nvrtcResult">
  <span class="n">
   <span class="pre">
    nvrtcResult
   </span>
  </span>
 </a>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    nvrtcGetOptiXIRSize
   </span>
  </span>
 </span>
 <span class="sig-paren">
  (
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv412nvrtcProgram" title="nvrtcProgram">
  <span class="n">
   <span class="pre">
    nvrtcProgram
   </span>
  </span>
 </a>
 <span class="n sig-param">
  <span class="pre">
   prog
  </span>
 </span>
 ,
 <span class="n">
  <span class="pre">
   size_t
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   optixirSizeRet
  </span>
 </span>
 <span class="sig-paren">
  )
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv419nvrtcGetOptiXIRSize12nvrtcProgramP6size_t" title="Permalink to this definition">
  ï
 </a>
 <p>
  nvrtcGetOptiXIRSize sets the value of
  <span class="pre">
   optixirSizeRet
  </span>
  with the size of the OptiX IR generated by the previous compilation of
  <span class="pre">
   prog
  </span>
  .
 </p>
 <p>
  The value of nvrtcGetOptiXIRSize is set to 0 if the program was compiled with options incompatible with OptiX IR generation.
 </p>
 <p class="admonition-title">
  See also
 </p>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1ga475c7f5a59f9c69a03541e496942ed19">
   <span class="std std-ref">
    nvrtcGetOptiXIR
   </span>
  </a>
 </p>
 Parameters
 <ul class="simple">
  <li>
   <p>
    prog
    â
    [in]
    CUDA Runtime Compilation program.
   </p>
  </li>
  <li>
   <p>
    optixirSizeRet
    â
    [out]
    Size of the generated LTO IR.
   </p>
  </li>
 </ul>
 Returns
 <ul class="simple">
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_SUCCESS
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_INPUT
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_PROGRAM
     </span>
    </a>
   </p>
  </li>
 </ul>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv411nvrtcResult" title="nvrtcResult">
  <span class="n">
   <span class="pre">
    nvrtcResult
   </span>
  </span>
 </a>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    nvrtcGetPTX
   </span>
  </span>
 </span>
 <span class="sig-paren">
  (
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv412nvrtcProgram" title="nvrtcProgram">
  <span class="n">
   <span class="pre">
    nvrtcProgram
   </span>
  </span>
 </a>
 <span class="n sig-param">
  <span class="pre">
   prog
  </span>
 </span>
 ,
 <span class="kt">
  <span class="pre">
   char
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   ptx
  </span>
 </span>
 <span class="sig-paren">
  )
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv411nvrtcGetPTX12nvrtcProgramPc" title="Permalink to this definition">
  ï
 </a>
 <p>
  nvrtcGetPTX stores the PTX generated by the previous compilation of
  <span class="pre">
   prog
  </span>
  in the memory pointed by
  <span class="pre">
   ptx
  </span>
  .
 </p>
 <p class="admonition-title">
  See also
 </p>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1gac622d6ffb6fff71e209407da19612c1a">
   <span class="std std-ref">
    nvrtcGetPTXSize
   </span>
  </a>
 </p>
 Parameters
 <ul class="simple">
  <li>
   <p>
    prog
    â
    [in]
    CUDA Runtime Compilation program.
   </p>
  </li>
  <li>
   <p>
    ptx
    â
    [out]
    Compiled result.
   </p>
  </li>
 </ul>
 Returns
 <ul class="simple">
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_SUCCESS
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_INPUT
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_PROGRAM
     </span>
    </a>
   </p>
  </li>
 </ul>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv411nvrtcResult" title="nvrtcResult">
  <span class="n">
   <span class="pre">
    nvrtcResult
   </span>
  </span>
 </a>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    nvrtcGetPTXSize
   </span>
  </span>
 </span>
 <span class="sig-paren">
  (
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv412nvrtcProgram" title="nvrtcProgram">
  <span class="n">
   <span class="pre">
    nvrtcProgram
   </span>
  </span>
 </a>
 <span class="n sig-param">
  <span class="pre">
   prog
  </span>
 </span>
 ,
 <span class="n">
  <span class="pre">
   size_t
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   ptxSizeRet
  </span>
 </span>
 <span class="sig-paren">
  )
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv415nvrtcGetPTXSize12nvrtcProgramP6size_t" title="Permalink to this definition">
  ï
 </a>
 <p>
  nvrtcGetPTXSize sets the value of
  <span class="pre">
   ptxSizeRet
  </span>
  with the size of the PTX generated by the previous compilation of
  <span class="pre">
   prog
  </span>
  (including the trailing
  <span class="pre">
   NULL
  </span>
  ).
 </p>
 <p class="admonition-title">
  See also
 </p>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1gac9a66bbbd47c256f4a8955517b3965da">
   <span class="std std-ref">
    nvrtcGetPTX
   </span>
  </a>
 </p>
 Parameters
 <ul class="simple">
  <li>
   <p>
    prog
    â
    [in]
    CUDA Runtime Compilation program.
   </p>
  </li>
  <li>
   <p>
    ptxSizeRet
    â
    [out]
    Size of the generated PTX (including the trailing
    <span class="pre">
     NULL
    </span>
    ).
   </p>
  </li>
 </ul>
 Returns
 <ul class="simple">
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_SUCCESS
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_INPUT
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_PROGRAM
     </span>
    </a>
   </p>
  </li>
 </ul>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv411nvrtcResult" title="nvrtcResult">
  <span class="n">
   <span class="pre">
    nvrtcResult
   </span>
  </span>
 </a>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    nvrtcGetProgramLog
   </span>
  </span>
 </span>
 <span class="sig-paren">
  (
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv412nvrtcProgram" title="nvrtcProgram">
  <span class="n">
   <span class="pre">
    nvrtcProgram
   </span>
  </span>
 </a>
 <span class="n sig-param">
  <span class="pre">
   prog
  </span>
 </span>
 ,
 <span class="kt">
  <span class="pre">
   char
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   log
  </span>
 </span>
 <span class="sig-paren">
  )
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv418nvrtcGetProgramLog12nvrtcProgramPc" title="Permalink to this definition">
  ï
 </a>
 <p>
  nvrtcGetProgramLog stores the log generated by the previous compilation of
  <span class="pre">
   prog
  </span>
  in the memory pointed by
  <span class="pre">
   log
  </span>
  .
 </p>
 <p class="admonition-title">
  See also
 </p>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1ga59944bb118095ab53eec8994d056a18d">
   <span class="std std-ref">
    nvrtcGetProgramLogSize
   </span>
  </a>
 </p>
 Parameters
 <ul class="simple">
  <li>
   <p>
    prog
    â
    [in]
    CUDA Runtime Compilation program.
   </p>
  </li>
  <li>
   <p>
    log
    â
    [out]
    Compilation log.
   </p>
  </li>
 </ul>
 Returns
 <ul class="simple">
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_SUCCESS
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_INPUT
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_PROGRAM
     </span>
    </a>
   </p>
  </li>
 </ul>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv411nvrtcResult" title="nvrtcResult">
  <span class="n">
   <span class="pre">
    nvrtcResult
   </span>
  </span>
 </a>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    nvrtcGetProgramLogSize
   </span>
  </span>
 </span>
 <span class="sig-paren">
  (
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv412nvrtcProgram" title="nvrtcProgram">
  <span class="n">
   <span class="pre">
    nvrtcProgram
   </span>
  </span>
 </a>
 <span class="n sig-param">
  <span class="pre">
   prog
  </span>
 </span>
 ,
 <span class="n">
  <span class="pre">
   size_t
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   logSizeRet
  </span>
 </span>
 <span class="sig-paren">
  )
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv422nvrtcGetProgramLogSize12nvrtcProgramP6size_t" title="Permalink to this definition">
  ï
 </a>
 <p>
  nvrtcGetProgramLogSize sets
  <span class="pre">
   logSizeRet
  </span>
  with the size of the log generated by the previous compilation of
  <span class="pre">
   prog
  </span>
  (including the trailing
  <span class="pre">
   NULL
  </span>
  ).
 </p>
 <p>
  Note that compilation log may be generated with warnings and informative messages, even when the compilation of
  <span class="pre">
   prog
  </span>
  succeeds.
 </p>
 <p class="admonition-title">
  See also
 </p>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1ga74c550e5cab81efbd59e4f72579edbd1">
   <span class="std std-ref">
    nvrtcGetProgramLog
   </span>
  </a>
 </p>
 Parameters
 <ul class="simple">
  <li>
   <p>
    prog
    â
    [in]
    CUDA Runtime Compilation program.
   </p>
  </li>
  <li>
   <p>
    logSizeRet
    â
    [out]
    Size of the compilation log (including the trailing
    <span class="pre">
     NULL
    </span>
    ).
   </p>
  </li>
 </ul>
 Returns
 <ul class="simple">
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_SUCCESS
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_INPUT
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INVALID_PROGRAM
     </span>
    </a>
   </p>
  </li>
 </ul>
 <h3>
  <span class="section-number">
   3.3.2.
  </span>
  Typedefs
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#typedefs" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <span class="k">
  <span class="pre">
   typedef
  </span>
 </span>
 <span class="k">
  <span class="pre">
   struct
  </span>
 </span>
 <span class="n">
  <span class="pre">
   _nvrtcProgram
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    nvrtcProgram
   </span>
  </span>
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv412nvrtcProgram" title="Permalink to this definition">
  ï
 </a>
 <p>
  nvrtcProgram is the unit of compilation, and an opaque handle for a program.
 </p>
 <p>
  To compile a CUDA program string, an instance of nvrtcProgram must be created first with
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1ga9ae65f68911d1cf0adda2af4ad8cb458">
   <span class="std std-ref">
    nvrtcCreateProgram
   </span>
  </a>
  , then compiled with
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1ga1f3136029db1413e362154b567297e8b">
   <span class="std std-ref">
    nvrtcCompileProgram
   </span>
  </a>
  .
 </p>
 <h2>
  <span class="section-number">
   3.4.
  </span>
  Supported Compile Options
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#supported-compile-options" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p id="group__options">
  NVRTC supports the compile options below.
 </p>
 <p>
  Option names with two preceding dashs (
  <span class="pre">
   --
  </span>
  ) are long option names and option names with one preceding dash (
  <span class="pre">
   -
  </span>
  ) are short option names. Short option names can be used instead of long option names. When a compile option takes an argument, an assignment operator (
  <span class="pre">
   =
  </span>
  ) is used to separate the compile option argument from the compile option name, e.g.,
  <span class="pre">
   "--gpu-architecture=compute_60"
  </span>
  . Alternatively, the compile option name and the argument can be specified in separate strings without an assignment operator, .e.g,
  <span class="pre">
   "--gpu-architecture"
  </span>
  <span class="pre">
   "compute_60"
  </span>
  . Single-character short option names, such as
  <span class="pre">
   -D
  </span>
  ,
  <span class="pre">
   -U
  </span>
  , and
  <span class="pre">
   -I
  </span>
  , do not require an assignment operator, and the compile option name and the argument can be present in the same string with or without spaces between them. For instance,
  <span class="pre">
   "-D=&lt;def&gt;"
  </span>
  ,
  <span class="pre">
   "-D&lt;def&gt;"
  </span>
  , and
  <span class="pre">
   "-D
  </span>
  <span class="pre">
   &lt;def&gt;"
  </span>
  are all supported.
 </p>
 <p>
  The valid compiler options are:
 </p>
 <ul class="simple">
  <li>
   <p>
    Compilation targets
   </p>
   <ul>
    <li>
     <p>
      <span class="pre">
       --gpu-architecture=&lt;arch&gt;
      </span>
      (
      <span class="pre">
       -arch
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Specify the name of the class of GPU architectures for which the input must be compiled.
     </p>
     <ul>
      <li>
       <p>
        Valid
        <span class="pre">
         &lt;arch&gt;
        </span>
        s:
       </p>
       <ul>
        <li>
         <p>
          <span class="pre">
           compute_50
          </span>
         </p>
        </li>
        <li>
         <p>
          <span class="pre">
           compute_52
          </span>
         </p>
        </li>
        <li>
         <p>
          <span class="pre">
           compute_53
          </span>
         </p>
        </li>
        <li>
         <p>
          <span class="pre">
           compute_60
          </span>
         </p>
        </li>
        <li>
         <p>
          <span class="pre">
           compute_61
          </span>
         </p>
        </li>
        <li>
         <p>
          <span class="pre">
           compute_62
          </span>
         </p>
        </li>
        <li>
         <p>
          <span class="pre">
           compute_70
          </span>
         </p>
        </li>
        <li>
         <p>
          <span class="pre">
           compute_72
          </span>
         </p>
        </li>
        <li>
         <p>
          <span class="pre">
           compute_75
          </span>
         </p>
        </li>
        <li>
         <p>
          <span class="pre">
           compute_80
          </span>
         </p>
        </li>
        <li>
         <p>
          <span class="pre">
           compute_87
          </span>
         </p>
        </li>
        <li>
         <p>
          <span class="pre">
           compute_89
          </span>
         </p>
        </li>
        <li>
         <p>
          <span class="pre">
           compute_90
          </span>
         </p>
        </li>
        <li>
         <p>
          <span class="pre">
           compute_90a
          </span>
         </p>
        </li>
        <li>
         <p>
          <span class="pre">
           sm_50
          </span>
         </p>
        </li>
        <li>
         <p>
          <span class="pre">
           sm_52
          </span>
         </p>
        </li>
        <li>
         <p>
          <span class="pre">
           sm_53
          </span>
         </p>
        </li>
        <li>
         <p>
          <span class="pre">
           sm_60
          </span>
         </p>
        </li>
        <li>
         <p>
          <span class="pre">
           sm_61
          </span>
         </p>
        </li>
        <li>
         <p>
          <span class="pre">
           sm_62
          </span>
         </p>
        </li>
        <li>
         <p>
          <span class="pre">
           sm_70
          </span>
         </p>
        </li>
        <li>
         <p>
          <span class="pre">
           sm_72
          </span>
         </p>
        </li>
        <li>
         <p>
          <span class="pre">
           sm_75
          </span>
         </p>
        </li>
        <li>
         <p>
          <span class="pre">
           sm_80
          </span>
         </p>
        </li>
        <li>
         <p>
          <span class="pre">
           sm_87
          </span>
         </p>
        </li>
        <li>
         <p>
          <span class="pre">
           sm_89
          </span>
         </p>
        </li>
        <li>
         <p>
          <span class="pre">
           sm_90
          </span>
         </p>
        </li>
        <li>
         <p>
          <span class="pre">
           sm_90a
          </span>
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        Default:
        <span class="pre">
         compute_52
        </span>
       </p>
      </li>
     </ul>
    </li>
   </ul>
  </li>
  <li>
   <p>
    Separate compilation / whole-program compilation
   </p>
   <ul>
    <li>
     <p>
      <span class="pre">
       --device-c
      </span>
      (
      <span class="pre">
       -dc
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Generate relocatable code that can be linked with other relocatable device code. It is equivalent to
     </p>
     &amp;#8212;relocatable-device-code=true.
    </li>
    <li>
     <p>
      <span class="pre">
       --device-w
      </span>
      (
      <span class="pre">
       -dw
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Generate non-relocatable code. It is equivalent to
     </p>
     <span class="pre">
      --relocatable-device-code=false
     </span>
     .
    </li>
    <li>
     <p>
      <span class="pre">
       --relocatable-device-code={true|false}
      </span>
      (
      <span class="pre">
       -rdc
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Enable (disable) the generation of relocatable device code.
     </p>
     <ul>
      <li>
       <p>
        Default:
        <span class="pre">
         false
        </span>
       </p>
      </li>
     </ul>
    </li>
    <li>
     <p>
      <span class="pre">
       --extensible-whole-program
      </span>
      (
      <span class="pre">
       -ewp
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Do extensible whole program compilation of device code.
     </p>
     <ul>
      <li>
       <p>
        Default:
        <span class="pre">
         false
        </span>
       </p>
      </li>
     </ul>
    </li>
   </ul>
  </li>
  <li>
   <p>
    Debugging support
   </p>
   <ul>
    <li>
     <p>
      <span class="pre">
       --device-debug
      </span>
      (
      <span class="pre">
       -G
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Generate debug information. If
     </p>
     &amp;#8212;dopt is not specified, then turns off all optimizations.
    </li>
    <li>
     <p>
      <span class="pre">
       --generate-line-info
      </span>
      (
      <span class="pre">
       -lineinfo
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Generate line-number information.
     </p>
    </li>
   </ul>
  </li>
  <li>
   <p>
    Code generation
   </p>
   <ul>
    <li>
     <p>
      <span class="pre">
       --dopt
      </span>
      on (
      <span class="pre">
       -dopt
      </span>
      )
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       --dopt=on
      </span>
      Enable device code optimization. When specified along with â-Gâ, enables limited debug information generation for optimized device code (currently, only line number information). When â-Gâ is not specified, â-dopt=onâ is implicit.
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       --ptxas-options
      </span>
      &lt;options&gt; (
      <span class="pre">
       -Xptxas
      </span>
      )
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       --ptxas-options=&lt;options&gt;
      </span>
      Specify options directly to ptxas, the PTX optimizing assembler.
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       --maxrregcount=&lt;N&gt;
      </span>
      (
      <span class="pre">
       -maxrregcount
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Specify the maximum amount of registers that GPU functions can use. Until a function-specific limit, a higher value will generally increase the performance of individual GPU threads that execute this function. However, because thread registers are allocated from a global register pool on each GPU, a higher value of this option will also reduce the maximum thread block size, thereby reducing the amount of thread parallelism. Hence, a good maxrregcount value is the result of a trade-off. If this option is not specified, then no maximum is assumed. Value less than the minimum registers required by ABI will be bumped up by the compiler to ABI minimum limit.
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       --ftz={true|false}
      </span>
      (
      <span class="pre">
       -ftz
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      When performing single-precision floating-point operations, flush denormal values to zero or preserve denormal values.
     </p>
     <span class="pre">
      --use_fast_math
     </span>
     implies
     <span class="pre">
      --ftz=true
     </span>
     .
     <ul>
      <li>
       <p>
        Default:
        <span class="pre">
         false
        </span>
       </p>
      </li>
     </ul>
    </li>
    <li>
     <p>
      <span class="pre">
       --prec-sqrt={true|false}
      </span>
      (
      <span class="pre">
       -prec-sqrt
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      For single-precision floating-point square root, use IEEE round-to-nearest mode or use a faster approximation.
     </p>
     <span class="pre">
      --use_fast_math
     </span>
     implies
     <span class="pre">
      --prec-sqrt=false
     </span>
     .
     <ul>
      <li>
       <p>
        Default:
        <span class="pre">
         true
        </span>
       </p>
      </li>
     </ul>
    </li>
    <li>
     <p>
      <span class="pre">
       --prec-div={true|false}
      </span>
      (
      <span class="pre">
       -prec-div
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      For single-precision floating-point division and reciprocals, use IEEE round-to-nearest mode or use a faster approximation.
     </p>
     <span class="pre">
      --use_fast_math
     </span>
     implies
     <span class="pre">
      --prec-div=false
     </span>
     .
     <ul>
      <li>
       <p>
        Default:
        <span class="pre">
         true
        </span>
       </p>
      </li>
     </ul>
    </li>
    <li>
     <p>
      <span class="pre">
       --fmad={true|false}
      </span>
      (
      <span class="pre">
       -fmad
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Enables (disables) the contraction of floating-point multiplies and adds/subtracts into floating-point multiply-add operations (FMAD, FFMA, or DFMA).
     </p>
     <span class="pre">
      --use_fast_math
     </span>
     implies
     <span class="pre">
      --fmad=true
     </span>
     .
     <ul>
      <li>
       <p>
        Default:
        <span class="pre">
         true
        </span>
       </p>
      </li>
     </ul>
    </li>
    <li>
     <p>
      <span class="pre">
       --use_fast_math
      </span>
      (
      <span class="pre">
       -use_fast_math
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Make use of fast math operations.
     </p>
     <span class="pre">
      --use_fast_math
     </span>
     implies
     <span class="pre">
      --ftz=true
     </span>
     <span class="pre">
      --prec-div=false
     </span>
     <span class="pre">
      --prec-sqrt=false
     </span>
     <span class="pre">
      --fmad=true
     </span>
     .
    </li>
    <li>
     <p>
      <span class="pre">
       --extra-device-vectorization
      </span>
      (
      <span class="pre">
       -extra-device-vectorization
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Enables more aggressive device code vectorization in the NVVM optimizer.
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       --modify-stack-limit={true|false}
      </span>
      (
      <span class="pre">
       -modify-stack-limit
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      On Linux, during compilation, use
     </p>
     <span class="pre">
      setrlimit()
     </span>
     to increase stack size to maximum allowed. The limit is reset to the previous value at the end of compilation. Note:
     <span class="pre">
      setrlimit()
     </span>
     changes the value for the entire process.
     <ul>
      <li>
       <p>
        Default:
        <span class="pre">
         true
        </span>
       </p>
      </li>
     </ul>
    </li>
    <li>
     <p>
      <span class="pre">
       --dlink-time-opt
      </span>
      (
      <span class="pre">
       -dlto
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Generate intermediate code for later link-time optimization. It implies
     </p>
     <span class="pre">
      -rdc=true
     </span>
     . Note: when this option is used the nvrtcGetLTOIR API should be used, as PTX or Cubin will not be generated.
    </li>
    <li>
     <p>
      <span class="pre">
       --gen-opt-lto
      </span>
      (
      <span class="pre">
       -gen-opt-lto
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Run the optimizer passes before generating the LTO IR.
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       --optix-ir
      </span>
      (
      <span class="pre">
       -optix-ir
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Generate OptiX IR. The Optix IR is only intended for consumption by OptiX through appropriate APIs. This feature is not supported with link-time-optimization (
     </p>
     <span class="pre">
      -dlto
     </span>
     <p>
      )
     </p>
     <p>
      . Note: when this option is used the nvrtcGetOptiX API should be used, as PTX or Cubin will not be generated.
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       --jump-table-density=
      </span>
      [0-101] (
      <span class="pre">
       -jtd
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Specify the case density percentage in switch statements, and use it as a minimal threshold to determine whether jump table(brx.idx instruction) will be used to implement a switch statement. Default value is 101. The percentage ranges from 0 to 101 inclusively.
     </p>
    </li>
   </ul>
  </li>
  <li>
   <p>
    Preprocessing
   </p>
   <ul>
    <li>
     <p>
      <span class="pre">
       --define-macro=&lt;def&gt;
      </span>
      (
      <span class="pre">
       -D
      </span>
      )
      <span class="pre">
       &lt;def&gt;
      </span>
      can be either
      <span class="pre">
       &lt;name&gt;
      </span>
      or
      <span class="pre">
       &lt;name=definitions&gt;
      </span>
      .
     </p>
     <ul>
      <li>
       <p>
        <span class="pre">
         &lt;name&gt;
        </span>
        Predefine
        <span class="pre">
         &lt;name&gt;
        </span>
        as a macro with definition
        <span class="pre">
         1
        </span>
        .
       </p>
      </li>
      <li>
       <p>
        <span class="pre">
         &lt;name&gt;=&lt;definition&gt;
        </span>
        The contents of
        <span class="pre">
         &lt;definition&gt;
        </span>
        are tokenized and preprocessed as if they appeared during translation phase three in a
        <span class="pre">
         #define
        </span>
        directive. In particular, the definition will be truncated by embedded new line characters.
       </p>
      </li>
     </ul>
    </li>
    <li>
     <p>
      <span class="pre">
       --undefine-macro=&lt;def&gt;
      </span>
      (
      <span class="pre">
       -U
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Cancel any previous definition of
     </p>
     <span class="pre">
      &lt;def&gt;
     </span>
     .
    </li>
    <li>
     <p>
      <span class="pre">
       --include-path=&lt;dir&gt;
      </span>
      (
      <span class="pre">
       -I
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Add the directory
     </p>
     <span class="pre">
      &lt;dir&gt;
     </span>
     to the list of directories to be searched for headers. These paths are searched after the list of headers given to
     <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__compilation_1ga9ae65f68911d1cf0adda2af4ad8cb458">
      <span class="std std-ref">
       nvrtcCreateProgram
      </span>
     </a>
     .
    </li>
    <li>
     <p>
      <span class="pre">
       --pre-include=&lt;header&gt;
      </span>
      (
      <span class="pre">
       -include
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Preinclude
     </p>
     <span class="pre">
      &lt;header&gt;
     </span>
     during preprocessing.
    </li>
    <li>
     <p>
      <span class="pre">
       --no-source-include
      </span>
      (
      <span class="pre">
       -no-source-include
      </span>
      ) The preprocessor by default adds the directory of each input sources to the include path. This option disables this feature and only considers the path specified explicitly.
     </p>
    </li>
   </ul>
  </li>
  <li>
   <p>
    Language Dialect
   </p>
   <ul>
    <li>
     <p>
      <span class="pre">
       --std={c++03|c++11|c++14|c++17|c++20}
      </span>
      (
      <span class="pre">
       -std={c++11|c++14|c++17|c++20}
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Set language dialect to C++03, C++11, C++14, C++17 or C++20
     </p>
     <ul>
      <li>
       <p>
        Default:
        <span class="pre">
         c++17
        </span>
       </p>
      </li>
     </ul>
    </li>
    <li>
     <p>
      <span class="pre">
       --builtin-move-forward={true|false}
      </span>
      (
      <span class="pre">
       -builtin-move-forward
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Provide builtin definitions of
     </p>
     <span class="pre">
      std::move
     </span>
     and
     <span class="pre">
      std::forward
     </span>
     , when C++11 or later language dialect is selected.
     <ul>
      <li>
       <p>
        Default:
        <span class="pre">
         true
        </span>
       </p>
      </li>
     </ul>
    </li>
    <li>
     <p>
      <span class="pre">
       --builtin-initializer-list={true|false}
      </span>
      (
      <span class="pre">
       -builtin-initializer-list
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Provide builtin definitions of
     </p>
     <span class="pre">
      std::initializer_list
     </span>
     class and member functions when C++11 or later language dialect is selected.
     <ul>
      <li>
       <p>
        Default:
        <span class="pre">
         true
        </span>
       </p>
      </li>
     </ul>
    </li>
   </ul>
  </li>
  <li>
   <p>
    Misc.
   </p>
   <ul>
    <li>
     <p>
      <span class="pre">
       --disable-warnings
      </span>
      (
      <span class="pre">
       -w
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Inhibit all warning messages.
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       --restrict
      </span>
      (
      <span class="pre">
       -restrict
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Programmer assertion that all kernel pointer parameters are restrict pointers.
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       --device-as-default-execution-space
      </span>
      (
      <span class="pre">
       -default-device
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Treat entities with no execution space annotation as
     </p>
     <span class="pre">
      __device__
     </span>
     entities.
    </li>
    <li>
     <p>
      <span class="pre">
       --device-int128
      </span>
      (
      <span class="pre">
       -device-int128
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Allow the
     </p>
     <span class="pre">
      __int128
     </span>
     type in device code. Also causes the macro
     <span class="pre">
      __CUDACC_RTC_INT128__
     </span>
     to be defined.
    </li>
    <li>
     <p>
      <span class="pre">
       --optimization-info=&lt;kind&gt;
      </span>
      (
      <span class="pre">
       -opt-info
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Provide optimization reports for the specified kind of optimization. The following kind tags are supported:
     </p>
     <ul>
      <li>
       <p>
        <span class="pre">
         inline
        </span>
        : emit a remark when a function is inlined.
       </p>
      </li>
     </ul>
    </li>
    <li>
     <p>
      <span class="pre">
       --display-error-number
      </span>
      (
      <span class="pre">
       -err-no
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Display diagnostic number for warning messages. (Default)
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       --no-display-error-number
      </span>
      (
      <span class="pre">
       -no-err-no
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Disables the display of a diagnostic number for warning messages.
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       --diag-error=&lt;error-number&gt;
      </span>
      ,â¦ (
      <span class="pre">
       -diag-error
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Emit error for specified diagnostic message number(s). Message numbers can be separated by comma.
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       --diag-suppress=&lt;error-number&gt;
      </span>
      ,â¦ (
      <span class="pre">
       -diag-suppress
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Suppress specified diagnostic message number(s). Message numbers can be separated by comma.
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       --diag-warn=&lt;error-number&gt;
      </span>
      ,â¦ (
      <span class="pre">
       -diag-warn
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Emit warning for specified diagnostic message number(s). Message numbers can be separated by comma.
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       --brief-diagnostics={true|false}
      </span>
      (
      <span class="pre">
       -brief-diag
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      This option disables or enables showing source line and column info in a diagnostic. The
     </p>
     &amp;#8212;brief-diagnostics=true will not show the source line and column info.
     <ul>
      <li>
       <p>
        Default:
        <span class="pre">
         false
        </span>
       </p>
      </li>
     </ul>
    </li>
    <li>
     <p>
      <span class="pre">
       --time=&lt;file-name&gt;
      </span>
      (
      <span class="pre">
       -time
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Generate a comma separated value table with the time taken by each compilation phase, and append it at the end of the file given as the option argument. If the file does not exist, the column headings are generated in the first row of the table. If the file name is â-â, the timing data is written to the compilation log.
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       --split-compile=
      </span>
      &lt;number of threads&gt; (
      <span class="pre">
       -split-compile=
      </span>
     </p>
     <p>
      &lt;number of threads&gt;)
     </p>
     <p>
      Perform compiler optimizations in parallel. Split compilation attempts to reduce compile time by enabling the compiler to run certain optimization passes concurrently. This option accepts a numerical value that specifies the maximum number of threads the compiler can use. One can also allow the compiler to use the maximum threads available on the system by setting
     </p>
     &amp;#8212;split-compile=0. Setting &amp;#8212;split-compile=1 will cause this option to be ignored.
    </li>
    <li>
     <p>
      <span class="pre">
       --fdevice-syntax-only
      </span>
      (
      <span class="pre">
       -fdevice-syntax-only
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Ends device compilation after front-end syntax checking. This option does not generate valid device code.
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       --minimal
      </span>
      (
      <span class="pre">
       -minimal
      </span>
     </p>
     <p>
      )
     </p>
     <p>
      Omit certain language features to reduce compile time for small programs. In particular, the following are omitted:
     </p>
     <ul>
      <li>
       <p>
        Texture and surface functions and associated types, e.g.,
        <span class="pre">
         cudaTextureObject_t
        </span>
        .
       </p>
      </li>
      <li>
       <p>
        CUDA Runtime Functions that are provided by the cudadevrt device code library, typically named with prefix âcudaâ, e.g.,
        <span class="pre">
         cudaMalloc
        </span>
        .
       </p>
      </li>
      <li>
       <p>
        Kernel launch from device code.
       </p>
      </li>
      <li>
       <p>
        Types and macros associated with CUDA Runtime and Driver APIs, provided by cuda/tools/cudart/driver_types.h, typically named with prefix âcudaâ, e.g.,
        <span class="pre">
         cudaError_t
        </span>
        .
       </p>
      </li>
     </ul>
    </li>
   </ul>
  </li>
 </ul>
 <h2>
  <span class="section-number">
   3.5.
  </span>
  Host Helper
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#host-helper" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p id="group__hosthelper">
  NVRTC defines the following functions for easier interaction with host code.
 </p>
 <p class="rubric-h2 rubric">
  Functions
 </p>
 <span class="tag-as-table-cell">
  nvrtcResult
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__hosthelper_1ga6e22e29ebd768ef8cb001af6866f07e7">
  <span class="std std-ref">
   nvrtcGetTypeName
  </span>
 </a>
 (const std::type_info &amp;tinfo, std::string *result)
 <p>
  nvrtcGetTypeName stores the source level name of a type in the given std::string location.
 </p>
 <span class="tag-as-table-cell">
  nvrtcResult
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__hosthelper_1ga793010cbd3f789a26ca956fd463d73cb">
  <span class="std std-ref">
   nvrtcGetTypeName
  </span>
 </a>
 (std::string *result)
 <p>
  nvrtcGetTypeName stores the source level name of the template type argument T in the given std::string location.
 </p>
 <h3>
  <span class="section-number">
   3.5.1.
  </span>
  Functions
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#id3" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <span class="k">
  <span class="pre">
   inline
  </span>
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv411nvrtcResult" title="nvrtcResult">
  <span class="n">
   <span class="pre">
    nvrtcResult
   </span>
  </span>
 </a>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    nvrtcGetTypeName
   </span>
  </span>
 </span>
 <span class="sig-paren">
  (
 </span>
 <span class="k">
  <span class="pre">
   const
  </span>
 </span>
 <span class="n">
  <span class="pre">
   std
  </span>
 </span>
 <span class="p">
  <span class="pre">
   ::
  </span>
 </span>
 <span class="n">
  <span class="pre">
   type_info
  </span>
 </span>
 <span class="p">
  <span class="pre">
   &amp;
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   tinfo
  </span>
 </span>
 ,
 <span class="n">
  <span class="pre">
   std
  </span>
 </span>
 <span class="p">
  <span class="pre">
   ::
  </span>
 </span>
 <span class="n">
  <span class="pre">
   string
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   result
  </span>
 </span>
 <span class="sig-paren">
  )
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv416nvrtcGetTypeNameRKNSt9type_infoEPNSt6stringE" title="Permalink to this definition">
  ï
 </a>
 <p>
  nvrtcGetTypeName stores the source level name of a type in the given std::string location.
 </p>
 <p>
  This function is only provided when the macro NVRTC_GET_TYPE_NAME is defined with a non-zero value. It uses abi::__cxa_demangle or UnDecorateSymbolName function calls to extract the type name, when using gcc/clang or cl.exe compilers, respectively. If the name extraction fails, it will return NVRTC_INTERNAL_ERROR, otherwise *result is initialized with the extracted name.
 </p>
 <p>
  Windows-specific notes:
 </p>
 <ul class="simple">
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__hosthelper_1ga6e22e29ebd768ef8cb001af6866f07e7">
     <span class="std std-ref">
      nvrtcGetTypeName()
     </span>
    </a>
    is not multi-thread safe because it calls UnDecorateSymbolName(), which is not multi-thread safe.
   </p>
  </li>
  <li>
   <p>
    The returned string may contain Microsoft-specific keywords such as __ptr64 and __cdecl.
   </p>
  </li>
 </ul>
 Parameters
 <ul class="simple">
  <li>
   <p>
    tinfo
    â
    [in]
    reference to object of type std::type_info for a given type.
   </p>
  </li>
  <li>
   <p>
    result
    â
    [in]
    pointer to std::string in which to store the type name.
   </p>
  </li>
 </ul>
 Returns
 <ul class="simple">
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_SUCCESS
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INTERNAL_ERROR
     </span>
    </a>
   </p>
  </li>
 </ul>
 <span class="k">
  <span class="pre">
   template
  </span>
 </span>
 <span class="p">
  <span class="pre">
   &lt;
  </span>
 </span>
 <span class="k">
  <span class="pre">
   typename
  </span>
 </span>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    T
   </span>
  </span>
 </span>
 <span class="p">
  <span class="pre">
   &gt;
  </span>
 </span>
 <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv411nvrtcResult" title="nvrtcResult">
  <span class="n">
   <span class="pre">
    nvrtcResult
   </span>
  </span>
 </a>
 <span class="sig-name descname">
  <span class="n">
   <span class="pre">
    nvrtcGetTypeName
   </span>
  </span>
 </span>
 <span class="sig-paren">
  (
 </span>
 <span class="n">
  <span class="pre">
   std
  </span>
 </span>
 <span class="p">
  <span class="pre">
   ::
  </span>
 </span>
 <span class="n">
  <span class="pre">
   string
  </span>
 </span>
 <span class="p">
  <span class="pre">
   *
  </span>
 </span>
 <span class="n sig-param">
  <span class="pre">
   result
  </span>
 </span>
 <span class="sig-paren">
  )
 </span>
 <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#_CPPv4I0E16nvrtcGetTypeName11nvrtcResultPNSt6stringE" title="Permalink to this definition">
  ï
 </a>
 <p>
  nvrtcGetTypeName stores the source level name of the template type argument T in the given std::string location.
 </p>
 <p>
  This function is only provided when the macro NVRTC_GET_TYPE_NAME is defined with a non-zero value. It uses abi::__cxa_demangle or UnDecorateSymbolName function calls to extract the type name, when using gcc/clang or cl.exe compilers, respectively. If the name extraction fails, it will return NVRTC_INTERNAL_ERROR, otherwise *result is initialized with the extracted name.
 </p>
 <p>
  Windows-specific notes:
 </p>
 <ul class="simple">
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__hosthelper_1ga6e22e29ebd768ef8cb001af6866f07e7">
     <span class="std std-ref">
      nvrtcGetTypeName()
     </span>
    </a>
    is not multi-thread safe because it calls UnDecorateSymbolName(), which is not multi-thread safe.
   </p>
  </li>
  <li>
   <p>
    The returned string may contain Microsoft-specific keywords such as __ptr64 and __cdecl.
   </p>
  </li>
 </ul>
 Parameters
 <p>
  result
  â
  [in]
  pointer to std::string in which to store the type name.
 </p>
 Returns
 <ul class="simple">
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_SUCCESS
     </span>
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#group__error_1ga31e41ef222c0ea75b4c48f715b3cd9f0">
     <span class="std std-ref">
      NVRTC_ERROR_INTERNAL_ERROR
     </span>
    </a>
   </p>
  </li>
 </ul>
 <h1>
  <span class="section-number">
   4.
  </span>
  Language
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#language" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <p>
  Unlike the offline nvcc compiler, NVRTC is meant for compiling only device CUDA C++ code. It does not accept host code or host compiler extensions in the input code, unless otherwise noted.
 </p>
 <h2>
  <span class="section-number">
   4.1.
  </span>
  Execution Space
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#execution-space" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  NVRTC uses
  <span class="pre">
   __host__
  </span>
  as the default execution space, and it generates an error if it encounters any host code in the input. That is, if the input contains entities with explicit
  <span class="pre">
   __host__
  </span>
  annotations or no execution space annotation, NVRTC will emit an error.
  <span class="pre">
   __host__
  </span>
  <span class="pre">
   __device__
  </span>
  functions are treated as device functions.
 </p>
 <p>
  NVRTC provides a compile option,
  <span class="pre">
   --device-as-default-execution-space
  </span>
  (refer to
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#supported-compile-options">
   Supported Compile Options
  </a>
  ), that enables an alternative compilation mode, in which entities with no execution space annotations are treated as
  <span class="pre">
   __device__
  </span>
  <span class="pre">
   entities
  </span>
  .
 </p>
 <h2>
  <span class="section-number">
   4.2.
  </span>
  Separate Compilation
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#separate-compilation" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  NVRTC itself does not provide any linker. Users can, however, use the nvJitLink library or
  <span class="pre">
   cuLinkAddData
  </span>
  in the CUDA Driver API to link the generated relocatable PTX code with other relocatable code. To generate relocatable PTX code, the compile option
  <span class="pre">
   --relocatable-device-code=true
  </span>
  or
  <span class="pre">
   --device-c
  </span>
  is required.
 </p>
 <h2>
  <span class="section-number">
   4.3.
  </span>
  Dynamic Parallelism
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#dynamic-parallelism" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  NVRTC supports dynamic parallelism under the following conditions:
 </p>
 <ul class="simple">
  <li>
   <p>
    Compilation target must be compute 35 or higher.
   </p>
  </li>
  <li>
   <p>
    Either separate compilation (
    <span class="pre">
     --relocatable-device-code=true
    </span>
    or
    <span class="pre">
     --device-c
    </span>
    ) or extensible whole program compilation (
    <span class="pre">
     --extensible-whole-program
    </span>
    ) must be enabled.
   </p>
  </li>
  <li>
   <p>
    Generated PTX must be linked against the CUDA device runtime (cudadevrt) library (refer to
    <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#separate-compilation">
     Separate Compilation
    </a>
    ).
   </p>
  </li>
 </ul>
 <p>
  Example:
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#dynamic-parallelism">
   Dynamic Parallelism
  </a>
  provides a simple example.
 </p>
 <h2>
  <span class="section-number">
   4.4.
  </span>
  Integer Size
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#integer-size" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  Different operating systems define integer type sizes differently.
Linux x86_64 implements LP64, and Windows x86_64 implements LLP64.
 </p>
 <table class="docutils align-default" id="id9">
  <span class="caption-text">
   Table 1. Integer sizes in bits for LLP64 and LP64
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#id9" title="Permalink to this table">
   ï
  </a>
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      short
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      int
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      long
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      long
     </span>
     <span class="pre">
      long
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     pointers and
     <span class="pre">
      size_t
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     LLP64
    </p>
   </td>
   <td>
    <p>
     16
    </p>
   </td>
   <td>
    <p>
     32
    </p>
   </td>
   <td>
    <p>
     32
    </p>
   </td>
   <td>
    <p>
     64
    </p>
   </td>
   <td>
    <p>
     64
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     LP64
    </p>
   </td>
   <td>
    <p>
     16
    </p>
   </td>
   <td>
    <p>
     32
    </p>
   </td>
   <td>
    <p>
     64
    </p>
   </td>
   <td>
    <p>
     64
    </p>
   </td>
   <td>
    <p>
     64
    </p>
   </td>
  </tr>
 </table>
 <p>
  NVRTC implements LP64 on Linux and LLP64 on Windows.
 </p>
 <p>
  NVRTC supports 128-bit integer types through the
  <span class="pre">
   __int128
  </span>
  type. This can be enabled with the
  <span class="pre">
   --device-int128
  </span>
  flag. 128-bit integer support is not available on Windows.
 </p>
 <h2>
  <span class="section-number">
   4.5.
  </span>
  Include Syntax
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#include-syntax" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  When
  <span class="pre">
   nvrtcCompileProgram()
  </span>
  is called, the current working directory is added to the header search path used for locating files included with the quoted syntax (for example,
  <span class="pre">
   #include
  </span>
  <span class="pre">
   "foo.h"
  </span>
  ), before the code is compiled.
 </p>
 <h2>
  <span class="section-number">
   4.6.
  </span>
  Predefined Macros
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#predefined-macros" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     __CUDACC_RTC__
    </span>
    : useful for distinguishing between runtime and offline
    <span class="pre">
     nvcc
    </span>
    compilation in user code.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     __CUDACC__
    </span>
    : defined with same semantics as with offline
    <span class="pre">
     nvcc
    </span>
    compilation.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     __CUDACC_RDC__
    </span>
    : defined with same semantics as with offline
    <span class="pre">
     nvcc
    </span>
    compilation.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     __CUDACC_EWP__
    </span>
    : defined with same semantics as with offline
    <span class="pre">
     nvcc
    </span>
    compilation.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     __CUDACC_DEBUG__
    </span>
    : defined with same semantics as with offline
    <span class="pre">
     nvcc
    </span>
    compilation.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     __CUDA_ARCH__
    </span>
    : defined with same semantics as with offline
    <span class="pre">
     nvcc
    </span>
    compilation.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     __CUDA_ARCH_LIST__
    </span>
    : defined with same semantics as with offline
    <span class="pre">
     nvcc
    </span>
    compilation.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     __CUDACC_VER_MAJOR__
    </span>
    : defined with the major version number as returned by
    <span class="pre">
     nvrtcVersion
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     __CUDACC_VER_MINOR__
    </span>
    : defined with the minor version number as returned by
    <span class="pre">
     nvrtcVersion
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     __CUDACC_VER_BUILD__
    </span>
    : defined with the build version number.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     __NVCC_DIAG_PRAGMA_SUPPORT__
    </span>
    : defined with same semantics as with offline
    <span class="pre">
     nvcc
    </span>
    compilation.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     __CUDACC_RTC_INT128__
    </span>
    : defined when
    <span class="pre">
     -device-int128
    </span>
    flag is specified during compilation, and indicates that
    <span class="pre">
     __int128
    </span>
    type is supported.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     NULL
    </span>
    : null pointer constant.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     va_start
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     va_end
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     va_arg
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     va_copy
    </span>
    : defined when language dialect C++11 or later is selected.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     __cplusplus
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     _WIN64
    </span>
    : defined on Windows platforms.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     __LP64__
    </span>
    : defined on non-Windows platforms where
    <span class="pre">
     long
    </span>
    <span class="pre">
     int
    </span>
    and pointer types are 64-bits.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     __cdecl
    </span>
    : defined to empty on all platforms.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     __ptr64
    </span>
    : defined to empty on Windows platforms.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     __CUDACC_RTC_MINIMAL__
    </span>
    : defined when
    <span class="pre">
     -minimal
    </span>
    flag is specified during compilation (since CUDA 12.4).
   </p>
  </li>
  <li>
   <p>
    Macros defined in nv/target header are implicitly provided, e.g.,
    <span class="pre">
     NV_IF_TARGET
    </span>
    .
   </p>
  </li>
 </ul>
 <h2>
  <span class="section-number">
   4.7.
  </span>
  Predefined Types
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#predefined-types" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     clock_t
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     size_t
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     ptrdiff_t
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     va_list
    </span>
    : Note that the definition of this type may be different than the one selected by nvcc when compiling CUDA code.
   </p>
  </li>
  <li>
   <p>
    Predefined types such as
    <span class="pre">
     dim3
    </span>
    ,
    <span class="pre">
     char4
    </span>
    , etc., that are  available in the CUDA Runtime headers when compiling offline with
    <span class="pre">
     nvcc
    </span>
    are also available, unless otherwise noted.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     std::initializer_list&lt;T&gt;
    </span>
    : implicitly provided in C++11 and later dialects, unless
    <span class="pre">
     -builtin-initializer-list=false
    </span>
    is specified.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     std::move&lt;T&gt;,
    </span>
    <span class="pre">
     std::forward&lt;T&gt;
    </span>
    : implicitly provided in C++11 and later dialects, unless
    <span class="pre">
     -builtin-move-forward=false
    </span>
    is specified.
   </p>
  </li>
 </ul>
 <h2>
  <span class="section-number">
   4.8.
  </span>
  Builtin Functions
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#builtin-functions" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  Builtin functions provided by the CUDA Runtime headers when compiling offline with
  <span class="pre">
   nvcc
  </span>
  are available, unless otherwise noted.
 </p>
 <h2>
  <span class="section-number">
   4.9.
  </span>
  Default C++ Dialect
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#default-c-dialect" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  The default C++ dialect is C++17. Other dialects can be selected using the
  <span class="pre">
   -std
  </span>
  flag.
 </p>
 <h1>
  <span class="section-number">
   5.
  </span>
  Basic Usage
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#basic-usage" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <p>
  This section of the document uses a simple example,
  Single-Precision Î±âX Plus Y
  (SAXPY), shown in
  <a class="reference external" href="https://docs.nvidia.com/cuda/nvrtc/index.html#basic-usage__cuda-source-string-for-saxpy">
   Figure 1
  </a>
  to explain what is involved in runtime compilation with NVRTC. For brevity and readability, error checks on the API return values are not shown. The complete code listing is available in
  <a class="reference external" href="https://docs.nvidia.com/cuda/nvrtc/index.html#example-saxpy">
   Example: SAXPY
  </a>
  .
 </p>
 <p>
  Figure 1. CUDA source string for SAXPY
 </p>
 <pre><span class="k">const</span><span class="kt">char</span><span class="o">*</span><span class="n">saxpy</span><span class="o">=</span><span class="s">"                                          </span><span class="se">\n</span><span class="s">\</span>
<span class="s">extern </span><span class="se">\"</span><span class="s">C</span><span class="se">\"</span><span class="s"> __global__                                        </span><span class="se">\n</span><span class="s">\</span>
<span class="s">void saxpy(float a, float *x, float *y, float *out, size_t n)  </span><span class="se">\n</span><span class="s">\</span>
<span class="s">{                                                              </span><span class="se">\n</span><span class="s">\</span>
<span class="s">   size_t tid = blockIdx.x * blockDim.x + threadIdx.x;         </span><span class="se">\n</span><span class="s">\</span>
<span class="s">   if (tid &lt; n) {                                              </span><span class="se">\n</span><span class="s">\</span>
<span class="s">      out[tid] = a * x[tid] + y[tid];                          </span><span class="se">\n</span><span class="s">\</span>
<span class="s">   }                                                           </span><span class="se">\n</span><span class="s">\</span>
<span class="s">}                                                              </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
</pre>
 <p>
  First, an instance of
  <span class="pre">
   nvrtcProgram
  </span>
  needs to be created.  Figure 2 shows creation of
  <span class="pre">
   nvrtcProgram
  </span>
  for SAXPY. As SAXPY does not require any header, 0 is passed as
  <span class="pre">
   numHeaders
  </span>
  , and NULL as
  <span class="pre">
   headers
  </span>
  and
  <span class="pre">
   includeNames
  </span>
  .
 </p>
 <p>
  Figure 2. nvrtcProgram creation for SAXPY
 </p>
 <pre><span class="n">nvrtcProgram</span><span class="n">prog</span><span class="p">;</span>
<span class="n">nvrtcCreateProgram</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prog</span><span class="p">,</span><span class="c1">// prog</span>
<span class="n">saxpy</span><span class="p">,</span><span class="c1">// buffer</span>
<span class="s">"saxpy.cu"</span><span class="p">,</span><span class="c1">// name</span>
<span class="mi">0</span><span class="p">,</span><span class="c1">// numHeaders</span>
<span class="nb">NULL</span><span class="p">,</span><span class="c1">// headers</span>
<span class="nb">NULL</span><span class="p">);</span><span class="c1">// includeNames</span>
</pre>
 <p>
  If SAXPY had any #include directives, the contents of the files that are
#includeâd can be passed as elements of headers, and their names as elements
of includeNames. For example,
  <span class="pre">
   #include
  </span>
  <span class="pre">
   &lt;foo.h&gt;
  </span>
  and
  <span class="pre">
   #include
  </span>
  <span class="pre">
   &lt;bar.h&gt;
  </span>
  would
require 2 as
  <span class="pre">
   numHeaders
  </span>
  ,
  <span class="pre">
   {
  </span>
  <span class="pre">
   "&lt;contents
  </span>
  <span class="pre">
   of
  </span>
  <span class="pre">
   foo.h&gt;",
  </span>
  <span class="pre">
   "&lt;contents
  </span>
  <span class="pre">
   of
  </span>
  <span class="pre">
   bar.h&gt;"
  </span>
  <span class="pre">
   }
  </span>
  as headers, and
  <span class="pre">
   {
  </span>
  <span class="pre">
   "foo.h",
  </span>
  <span class="pre">
   "bar.h"
  </span>
  <span class="pre">
   }
  </span>
  as
  <span class="pre">
   includeNames
  </span>
  (
  <span class="pre">
   &lt;contents
  </span>
  <span class="pre">
   of
  </span>
  <span class="pre">
   foo.h&gt;
  </span>
  and
  <span class="pre">
   &lt;contents
  </span>
  <span class="pre">
   of
  </span>
  <span class="pre">
   bar.h&gt;
  </span>
  must be replaced by the actual contents of
  <span class="pre">
   foo.h
  </span>
  and
  <span class="pre">
   bar.h
  </span>
  ). Alternatively, the compile option
  <span class="pre">
   -I
  </span>
  can be used if the header
is guaranteed to exist in the file system at runtime.
 </p>
 <p>
  Once the instance of
  <span class="pre">
   nvrtcProgram
  </span>
  for compilation is created, it can be
compiled by
  <span class="pre">
   nvrtcCompileProgram
  </span>
  as shown in Figure 3. Two compile options
are used in this example,
  <span class="pre">
   --gpu-architecture=compute_80
  </span>
  and
  <span class="pre">
   --fmad=false
  </span>
  ,
to generate code for the compute_80 architecture and to disable the
contraction of floating-point multiplies and adds/subtracts into
floating-point multiply-add operations. Other combinations of compile
options can be used as needed and Supported Compile Options lists valid
compile options.
 </p>
 <p>
  Figure 3. Compilation of SAXPY for compute_80 with FMAD enabled
 </p>
 <pre><span class="k">const</span><span class="kt">char</span><span class="o">*</span><span class="n">opts</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="s">"--gpu-architecture=compute_80"</span><span class="p">,</span>
<span class="s">"--fmad=false"</span><span class="p">};</span>
<span class="n">nvrtcCompileProgram</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="c1">// prog</span>
<span class="mi">2</span><span class="p">,</span><span class="c1">// numOptions</span>
<span class="n">opts</span><span class="p">);</span><span class="c1">// options</span>
</pre>
 <p>
  After the compilation completes, users can obtain the program compilation
log and the generated PTX as Figure 4 shows. NVRTC does not generate valid
PTX when the compilation fails, and it may generate program compilation log
even when the compilation succeeds if needed.
 </p>
 <p>
  An
  <span class="pre">
   nvrtcProgram
  </span>
  can be compiled by
  <span class="pre">
   nvrtcCompileProgram
  </span>
  multiple times with
different compile options, and users can only retrieve the PTX and the log
generated by the last compilation.
 </p>
 <p>
  Figure 4. Obtaining generated PTX and program compilation log
 </p>
 <pre><span class="c1">// Obtain compilation log from the program.</span>

<span class="kt">size_t</span><span class="n">logSize</span><span class="p">;</span>

<span class="n">nvrtcGetProgramLogSize</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="o">&amp;</span><span class="n">logSize</span><span class="p">);</span>
<span class="kt">char</span><span class="o">*</span><span class="n">log</span><span class="o">=</span><span class="n">new</span><span class="kt">char</span><span class="p">[</span><span class="n">logSize</span><span class="p">];</span>
<span class="n">nvrtcGetProgramLog</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="n">log</span><span class="p">);</span>
<span class="c1">// Obtain PTX from the program.</span>
<span class="kt">size_t</span><span class="n">ptxSize</span><span class="p">;</span>
<span class="n">nvrtcGetPTXSize</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="o">&amp;</span><span class="n">ptxSize</span><span class="p">);</span>
<span class="kt">char</span><span class="o">*</span><span class="n">ptx</span><span class="o">=</span><span class="n">new</span><span class="kt">char</span><span class="p">[</span><span class="n">ptxSize</span><span class="p">];</span>
<span class="n">nvrtcGetPTX</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="n">ptx</span><span class="p">);</span>
</pre>
 <p>
  When the instance of
  <span class="pre">
   nvrtcProgram
  </span>
  is no longer needed, it can be destroyed by
  <span class="pre">
   nvrtcDestroyProgram
  </span>
  as shown in Figure 5.
 </p>
 <p>
  Figure 5. Destruction of nvrtcProgram
 </p>
 <pre><span class="n">nvrtcDestroyProgram</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prog</span><span class="p">);</span>
</pre>
 <p>
  The generated PTX can be further manipulated by the CUDA Driver API for execution or linking. Figure 6 shows an example code sequence for execution of the generated PTX.
 </p>
 <p>
  Figure 6. Execution of SAXPY using the PTX generated by NVRTC
 </p>
 <pre><span class="n">CUdevice</span><span class="n">cuDevice</span><span class="p">;</span>
<span class="n">CUcontext</span><span class="n">context</span><span class="p">;</span>
<span class="n">CUmodule</span><span class="n">module</span><span class="p">;</span>
<span class="n">CUfunction</span><span class="n">kernel</span><span class="p">;</span>
<span class="n">cuInit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">cuDeviceGet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cuDevice</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="n">cuCtxCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">cuDevice</span><span class="p">);</span>
<span class="n">cuModuleLoadDataEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module</span><span class="p">,</span><span class="n">ptx</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="n">cuModuleGetFunction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kernel</span><span class="p">,</span><span class="n">module</span><span class="p">,</span><span class="s">"saxpy"</span><span class="p">);</span>
<span class="kt">size_t</span><span class="n">n</span><span class="o">=</span><span class="kt">size_t</span><span class="n">n</span><span class="o">=</span><span class="n">NUM_THREADS</span><span class="o">*</span><span class="n">NUM_BLOCKS</span><span class="p">;</span>
<span class="kt">size_t</span><span class="n">bufferSize</span><span class="o">=</span><span class="n">n</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span>
<span class="kt">float</span><span class="n">a</span><span class="o">=</span><span class="p">...;</span>
<span class="kt">float</span><span class="o">*</span><span class="n">hX</span><span class="o">=</span><span class="p">...,</span><span class="o">*</span><span class="n">hY</span><span class="o">=</span><span class="p">...,</span><span class="o">*</span><span class="n">hOut</span><span class="o">=</span><span class="p">...;</span>
<span class="n">CUdeviceptr</span><span class="n">dX</span><span class="p">,</span><span class="n">dY</span><span class="p">,</span><span class="n">dOut</span><span class="p">;</span>
<span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dX</span><span class="p">,</span><span class="n">bufferSize</span><span class="p">);</span>
<span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dY</span><span class="p">,</span><span class="n">bufferSize</span><span class="p">);</span>
<span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dOut</span><span class="p">,</span><span class="n">bufferSize</span><span class="p">);</span>
<span class="n">cuMemcpyHtoD</span><span class="p">(</span><span class="n">dX</span><span class="p">,</span><span class="n">hX</span><span class="p">,</span><span class="n">bufferSize</span><span class="p">);</span>
<span class="n">cuMemcpyHtoD</span><span class="p">(</span><span class="n">dY</span><span class="p">,</span><span class="n">hY</span><span class="p">,</span><span class="n">bufferSize</span><span class="p">);</span>
<span class="kt">void</span><span class="o">*</span><span class="n">args</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="o">&amp;</span><span class="n">dX</span><span class="p">,</span><span class="o">&amp;</span><span class="n">dY</span><span class="p">,</span><span class="o">&amp;</span><span class="n">dOut</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">};</span>
<span class="n">cuLaunchKernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span>
<span class="n">NUM_THREADS</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="c1">// grid dim</span>
<span class="n">NUM_BLOCKS</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="c1">// block dim</span>
<span class="mi">0</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="c1">// shared mem and stream</span>
<span class="n">args</span><span class="p">,</span><span class="c1">// arguments</span>
<span class="mi">0</span><span class="p">);</span>
<span class="n">cuCtxSynchronize</span><span class="p">();</span>
<span class="n">cuMemcpyDtoH</span><span class="p">(</span><span class="n">hOut</span><span class="p">,</span><span class="n">dOut</span><span class="p">,</span><span class="n">bufferSize</span><span class="p">);</span>
</pre>
 <h1>
  <span class="section-number">
   6.
  </span>
  Accessing Lowered Names
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#accessing-lowered-names" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <p>
  NVRTC will mangle
  <span class="pre">
   __global__
  </span>
  function names and names of
  <span class="pre">
   __device__
  </span>
  and
  <span class="pre">
   __constant__
  </span>
  variables as specified by the IA64 ABI. If the generated
PTX is being loaded using the CUDA Driver API, the kernel function or
  <span class="pre">
   __device__
  </span>
  /
  <span class="pre">
   __constant__
  </span>
  variable must be looked up by name, but this
is hard to do when the name has been mangled. To address this problem,
NVRTC provides API functions that map source level
  <span class="pre">
   __global__
  </span>
  function
or
  <span class="pre">
   __device__
  </span>
  /
  <span class="pre">
   __constant__
  </span>
  variable names to the mangled names present
in the generated PTX.
 </p>
 <p>
  The two API functions
  <span class="pre">
   nvrtcAddNameExpression
  </span>
  and
  <span class="pre">
   nvrtcGetLoweredName
  </span>
  work together to provide this functionality. First, a âname expressionâ
string denoting the address for the
  <span class="pre">
   __global__
  </span>
  function or
  <span class="pre">
   __device__
  </span>
  /
  <span class="pre">
   __constant__
  </span>
  variable is provided to
  <span class="pre">
   nvrtcAddNameExpression
  </span>
  .
Then, the program is compiled with
  <span class="pre">
   nvrtcCompileProgram
  </span>
  . During compilation,
NVRTC will parse the name expression string as a C++ constant expression at
the end of the user program. The constant expression must provide the address
of the
  <span class="pre">
   __global__
  </span>
  function or
  <span class="pre">
   __device__
  </span>
  /
  <span class="pre">
   __constant__
  </span>
  variable. Finally,
the function
  <span class="pre">
   nvrtcGetLoweredName
  </span>
  is called with the original name expression
and it returns a pointer to the lowered name. The lowered name can be used
to refer to the kernel or variable in the CUDA Driver API.
 </p>
 <p>
  NVRTC guarantees that any
  <span class="pre">
   __global__
  </span>
  function or
  <span class="pre">
   __device__/__constant__
  </span>
  variable referenced in a call to
  <span class="pre">
   nvrtcAddNameExpression
  </span>
  will be present in
the generated PTX (if the definition is available in the input source code).
 </p>
 <h2>
  <span class="section-number">
   6.1.
  </span>
  Example
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#example" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  Example: Using Lowered Name`_
  lists a complete runnable example. Some relevant snippets:
 </p>
 <ol class="arabic">
  <li>
   <p>
    The GPU source code (âgpu_programâ) contains definitions of various
    <span class="pre">
     __global__
    </span>
    functions/function templates and
    <span class="pre">
     __device__
    </span>
    /
    <span class="pre">
     __constant__
    </span>
    variables:
   </p>
   <pre><span class="k">const</span><span class="kt">char</span><span class="o">*</span><span class="n">gpu_program</span><span class="o">=</span><span class="s">"                                     </span><span class="se">\n</span><span class="s">\</span>
<span class="s">__device__ int V1; // set from host code                        </span><span class="se">\n</span><span class="s">\</span>
<span class="s">static __global__ void f1(int *result) { *result = V1 + 10; }   </span><span class="se">\n</span><span class="s">\</span>
<span class="s">namespace N1 {                                                  </span><span class="se">\n</span><span class="s">\</span>
<span class="s">   namespace N2 {                                               </span><span class="se">\n</span><span class="s">\</span>
<span class="s">      __constant__ int V2; // set from host code                </span><span class="se">\n</span><span class="s">\</span>
<span class="s">      __global__ void f2(int *result) { *result = V2 + 20; }    </span><span class="se">\n</span><span class="s">\</span>
<span class="s">   }                                                            </span><span class="se">\n</span><span class="s">\</span>
<span class="s">}                                                               </span><span class="se">\n</span><span class="s">\</span>
<span class="s">template&lt;typename T&gt;                                            </span><span class="se">\n</span><span class="s">\</span>
<span class="s">__global__ void f3(int *result) { *result = sizeof(T); }        </span><span class="se">\n</span><span class="s">\</span>
</pre>
  </li>
  <li>
   <p>
    The host source code invokes
    <span class="pre">
     nvrtcAddNameExpression
    </span>
    with various name expressions referring to the address of
    <span class="pre">
     __global__
    </span>
    functions and
    <span class="pre">
     __device__
    </span>
    /
    <span class="pre">
     __constant__
    </span>
    variables:
   </p>
   <pre><span class="n">kernel_name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"&amp;f1"</span><span class="p">);</span>
<span class="p">..</span>
<span class="n">kernel_name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"N1::N2::f2"</span><span class="p">);</span>
<span class="p">..</span>
<span class="n">kernel_name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"f3&lt;int&gt;"</span><span class="p">);</span>
<span class="p">..</span>
<span class="n">kernel_name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"f3&lt;double&gt;"</span><span class="p">);</span>

<span class="c1">// add name expressions to NVRTC. Note this must be done before</span>
<span class="c1">// the program is compiled.</span>
<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">name_vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcAddNameExpression</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="n">kernel_name_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">()));</span>
<span class="p">..</span>
<span class="c1">// add expressions for  __device__ / __constant__ variables to NVRTC</span>
<span class="n">variable_name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"&amp;V1"</span><span class="p">);</span>
<span class="p">..</span>
<span class="n">variable_name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"&amp;N1::N2::V2"</span><span class="p">);</span>
<span class="p">..</span>
<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">variable_name_vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcAddNameExpression</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span>
<span class="n">variable_name_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">()));</span>
</pre>
  </li>
  <li>
   <p>
    The GPU program is then compiled with
    <span class="pre">
     nvrtcCompileProgram
    </span>
    . The generated PTX is loaded on the GPU. The mangled names of the
    <span class="pre">
     __device__
    </span>
    /
    <span class="pre">
     __constant__
    </span>
    variables and
    <span class="pre">
     __global__
    </span>
    functions are looked up:
   </p>
   <pre><span class="c1">// note: this call must be made after NVRTC program has been</span>
<span class="c1">// compiled and before it has been destroyed.</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetLoweredName</span><span class="p">(</span>
<span class="n">prog</span><span class="p">,</span>
<span class="n">variable_name_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">(),</span><span class="c1">// name expression</span>
<span class="o">&amp;</span><span class="n">name</span><span class="c1">// lowered name</span>
<span class="p">));</span>
<span class="p">..</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetLoweredName</span><span class="p">(</span>
<span class="n">prog</span><span class="p">,</span>
<span class="n">kernel_name_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">(),</span><span class="c1">// name expression</span>
<span class="o">&amp;</span><span class="n">name</span><span class="c1">// lowered name</span>
<span class="p">));</span>
</pre>
  </li>
  <li>
   <p>
    The mangled name of the
    <span class="pre">
     __device__
    </span>
    /
    <span class="pre">
     __constant__
    </span>
    variable is then used to lookup the variable in the module and update its value using the CUDA Driver API:
   </p>
   <pre><span class="n">CUdeviceptr</span><span class="n">variable_addr</span><span class="p">;</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleGetGlobal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">variable_addr</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">module</span><span class="p">,</span><span class="n">name</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemcpyHtoD</span><span class="p">(</span><span class="n">variable_addr</span><span class="p">,</span>
<span class="o">&amp;</span><span class="n">initial_value</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">initial_value</span><span class="p">)));</span>
</pre>
  </li>
  <li>
   <p>
    The mangled name of the kernel is then used to launch it using the CUDA Driver API:
   </p>
   <pre><span class="n">CUfunction</span><span class="n">kernel</span><span class="p">;</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleGetFunction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kernel</span><span class="p">,</span><span class="n">module</span><span class="p">,</span><span class="n">name</span><span class="p">));</span>
<span class="p">...</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span>
<span class="n">cuLaunchKernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span>
<span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="c1">// grid dim</span>
<span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="c1">// block dim</span>
<span class="mi">0</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="c1">// shared mem and stream</span>
<span class="n">args</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
</pre>
  </li>
 </ol>
 <h2>
  <span class="section-number">
   6.2.
  </span>
  Notes
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#notes" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <ul>
  <li>
   <p>
    Sequence of calls: All name expressions must be added using
    <span class="pre">
     nvrtcAddNameExpression
    </span>
    before the NVRTC program is compiled with
    <span class="pre">
     nvrtcCompileProgram
    </span>
    . This is required
because the name expressions are parsed at the end of the user program, and may
trigger template instantiations. The lowered names must be looked up by calling
    <span class="pre">
     nvrtcGetLoweredName
    </span>
    only after the NVRTC program has been compiled, and before it
has been destroyed. The pointer returned by
    <span class="pre">
     nvrtcGetLoweredName
    </span>
    points to memory
owned by NVRTC, and this memory is freed when the NVRTC program has been destroyed
(
    <span class="pre">
     nvrtcDestroyProgram
    </span>
    ). Thus the correct sequence of calls is:
    <span class="pre">
     nvrtcAddNameExpression
    </span>
    ,
    <span class="pre">
     nvrtcCompileProgram
    </span>
    ,
    <span class="pre">
     nvrtcGetLoweredName
    </span>
    ,
    <span class="pre">
     nvrtcDestroyProgram
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Identical Name Expressions: The name expression string passed to
    <span class="pre">
     nvrtcAddNameExpression
    </span>
    and
    <span class="pre">
     nvrtcGetLoweredName
    </span>
    must have identical characters. For example, âfooâ and âfoo â
are not identical strings, even though semantically they refer to the same entity (foo),
because the second string has a extra whitespace character.
   </p>
  </li>
  <li>
   <p>
    Constant Expressions: The characters in the name expression string are parsed as a C++
constant expression at the end of the user program. Any errors during parsing will cause
compilation failure and compiler diagnostics will be generated in the compilation log.
The constant expression must refer to the address of a
    <span class="pre">
     __global__
    </span>
    function or
    <span class="pre">
     __device__/__constant__
    </span>
    variable.
   </p>
  </li>
  <li>
   <p>
    Address of overloaded function: If the NVRTC source code has multiple overloaded
    <span class="pre">
     __global__
    </span>
    functions, then the name expression must use a cast operation to disambiguate.
However, casts are not allowed in constant expression for C++ dialects before C++11.
If using such name expressions, please compile the code in C++11 or later dialect
using the
    <span class="pre">
     -std
    </span>
    command line flag. Example: Consider that the GPU code string contains:
   </p>
   <pre><span class="n">__global__</span><span class="kt">void</span><span class="n">foo</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="p">{</span><span class="p">}</span>
<span class="n">__global__</span><span class="kt">void</span><span class="n">foo</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="p">{</span><span class="p">}</span>
</pre>
   <p>
    The name expression
    <span class="pre">
     (void(*)(int))foo
    </span>
    correctly disambiguates
    <span class="pre">
     foo(int)
    </span>
    , but the program must be compiled in C++11 or later dialect (such as
    <span class="pre">
     -std=c++11
    </span>
    ) because casts are not allowed in pre-C++11 constant expressions.
   </p>
  </li>
 </ul>
 <h1>
  <span class="section-number">
   7.
  </span>
  Interfacing With Template Host Code
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#interfacing-with-template-host-code" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <p>
  In some scenarios, it is useful to instantiate
  <span class="pre">
   __global__
  </span>
  function templates in device
code based on template arguments in host code. The NVRTC helper function nvrtcGetTypeName
can be used to extract the source level name of a type in host code, and this string can be
used to instantiate a
  <span class="pre">
   __global__
  </span>
  function template and get the mangled name of the
instantiation using the
  <span class="pre">
   nvrtcAddNameExpression
  </span>
  and
  <span class="pre">
   nvrtcGetLoweredName
  </span>
  functions.
 </p>
 <p>
  <span class="pre">
   nvrtcGetTypeName
  </span>
  is defined inline in the NVRTC header file, and is available when the
macro
  <span class="pre">
   NVRTC_GET_TYPE_NAME
  </span>
  is defined with a non-zero value. It uses the
  <span class="pre">
   abi::__cxa_demangle
  </span>
  and
  <span class="pre">
   UnDecorateSymbolName
  </span>
  host code functions when using gcc/clang and cl.exe compilers,
respectively. Users may need to specify additional header paths and libraries to find the
host functions used (
  <span class="pre">
   abi::__cxa_demangle
  </span>
  <span class="pre">
   /
  </span>
  <span class="pre">
   UnDecorateSymbolName
  </span>
  ). Refer to the build instructions
for the example below for reference (
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#nvrtcgettypename-build-instructions">
   nvrtcGetTypeName Build Instructions
  </a>
  ).
 </p>
 <h2>
  <span class="section-number">
   7.1.
  </span>
  Template Host Code Example
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#template-host-code-example" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#example-using-nvrtcgettypename">
   Example: Using nvrtcGetTypeName
  </a>
  lists a complete runnable example. Some relevant snippets:
 </p>
 <ol class="arabic">
  <li>
   <p>
    The GPU source code (
    <span class="pre">
     gpu_program
    </span>
    ) contains definitions of a
    <span class="pre">
     __global__
    </span>
    function template:
   </p>
   <pre><span class="k">const</span><span class="kt">char</span><span class="o">*</span><span class="n">gpu_program</span><span class="o">=</span><span class="s">" </span><span class="se">\n</span><span class="s">\</span>
<span class="s">namespace N1 { struct S1_t { int i; double d; }; } </span><span class="se">\n</span><span class="s">\</span>
<span class="s">template&lt;typename T&gt; </span><span class="se">\n</span><span class="s">\</span>
<span class="s">__global__ void f3(int *result) { *result = sizeof(T); } </span><span class="se">\n</span><span class="s">\</span>
<span class="se">\n</span><span class="s">"</span><span class="p">;</span>
</pre>
  </li>
  <li>
   <p>
    The host code function
    <span class="pre">
     getKernelNameForType
    </span>
    creates the name expression for a
    <span class="pre">
     __global__
    </span>
    function template instantiation based on the host template type T. The name of the type T is extracted using
    <span class="pre">
     nvrtcGetTypeName
    </span>
    :
   </p>
   <pre><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="n">T</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="n">getKernelNameForType</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">// Look up the source level name string for the type "T" using</span>
<span class="c1">// nvrtcGetTypeName() and use it to create the kernel name</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="n">type_name</span><span class="p">;</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetTypeName</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type_name</span><span class="p">));</span>
<span class="k">return</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"f3&lt;"</span><span class="p">)</span><span class="o">+</span><span class="n">type_name</span><span class="o">+</span><span class="s">"&gt;"</span><span class="p">;</span>
<span class="p">}</span>
</pre>
  </li>
  <li>
   <p>
    The name expressions are presented to NVRTC using the
    <span class="pre">
     nvrtcAddNameExpression
    </span>
    function:
   </p>
   <pre><span class="n">name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">getKernelNameForType</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
<span class="p">..</span>
<span class="n">name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">getKernelNameForType</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">());</span>
<span class="p">..</span>
<span class="n">name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">getKernelNameForType</span><span class="o">&lt;</span><span class="n">N1</span><span class="o">::</span><span class="n">S1_t</span><span class="o">&gt;</span><span class="p">());</span>
<span class="p">..</span>
<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">name_vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcAddNameExpression</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="n">name_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">()));</span>
</pre>
  </li>
  <li>
   <p>
    The GPU program is then compiled with
    <span class="pre">
     nvrtcCompileProgram
    </span>
    . The generated PTX is loaded on the GPU. The mangled names of the
    <span class="pre">
     __global__
    </span>
    function template instantiations are looked up:
   </p>
   <pre><span class="c1">// note: this call must be made after NVRTC program has been</span>
<span class="c1">// compiled and before it has been destroyed.</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetLoweredName</span><span class="p">(</span>
<span class="n">prog</span><span class="p">,</span>
<span class="n">name_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">(),</span><span class="c1">// name expression</span>
<span class="o">&amp;</span><span class="n">name</span><span class="c1">// lowered name</span>
<span class="p">));</span>
</pre>
  </li>
  <li>
   <p>
    The mangled name is then used to launch the kernel using the CUDA Driver API:
   </p>
   <pre><span class="n">CUfunction</span><span class="n">kernel</span><span class="p">;</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleGetFunction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kernel</span><span class="p">,</span><span class="n">module</span><span class="p">,</span><span class="n">name</span><span class="p">));</span>
<span class="p">...</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span>
<span class="n">cuLaunchKernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span>
<span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="c1">// grid dim</span>
<span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="c1">// block dim</span>
<span class="mi">0</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="c1">// shared mem and stream</span>
<span class="n">args</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
</pre>
  </li>
 </ol>
 <h1>
  <span class="section-number">
   8.
  </span>
  Versioning Scheme
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#versioning-scheme" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <h2>
  <span class="section-number">
   8.1.
  </span>
  NVRTC Shared Library Versioning
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#nvrtc-shared-library-versioning" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  In the following, MAJOR and MINOR denote the major and minor versions of the CUDA Toolkit. For example, for CUDA 11.2, MAJOR is â11â and MINOR is â2â.
 </p>
 <ul class="simple">
  <li>
   <p>
    Linux:
   </p>
   <ul>
    <li>
     <p>
      In CUDA toolkits prior to CUDA 11.3, the soname was set to âMAJOR.MINORâ.
     </p>
    </li>
    <li>
     <p>
      In CUDA 11.3 and later 11.x toolkits, the soname field is set to â11.2â.
     </p>
    </li>
    <li>
     <p>
      In CUDA toolkits with major version &gt; 11 (e.g. CUDA 12.x), the soname field is set to âMAJORâ.
     </p>
    </li>
   </ul>
  </li>
  <li>
   <p>
    Windows:
   </p>
   <ul>
    <li>
     <p>
      In CUDA toolkits prior to cuda 11.3, the DLL name was of the form ânvrtc64_XY_0.dllâ, where X = MAJOR, Y = MINOR.
     </p>
    </li>
    <li>
     <p>
      In CUDA 11.3 and later 11.x toolkits, the DLL name is ânvrtc64_112_0.dllâ.
     </p>
    </li>
    <li>
     <p>
      In CUDA toolkits with major version &gt; 11 (e.g. CUDA 12.x), the DLL name is of the form ânvrtc64_X0_0.dllâ where X = MAJOR.
     </p>
    </li>
   </ul>
  </li>
 </ul>
 <p>
  Consider a CUDA toolkit with major version &gt; 11. The NVRTC shared library in this CUDA  toolkit will have the same soname (Linux) or DLL name (Windows) as an NVRTC shared library  in a previous minor version of the same CUDA toolkit. Similarly, the NVRTC shared library in CUDA 11.3 and later 11.x releases will have the same soname (Linux) or DLL name (Windows) as the NVRTC shared library in CUDA 11.2.
 </p>
 <p>
  As a consequence of the versioning scheme described above, an NVRTC client that links
against a particular NVRTC shared library will continue to work with a future NVRTC shared
library with a matching soname (Linux) or DLL name (Windows). This allows the NVRTC client
to take advantage of bug fixes and enhancements available in the more recent NVRTC shared
library
  <a class="footnote-reference brackets" href="https://docs.nvidia.com/cuda/nvrtc/index.html#id7" id="id4">
   1
  </a>
  . However, the more recent NVRTC shared library may generate PTX with a version that
is not accepted by the CUDA Driver API functions of an older CUDA driver, as explained in the
  <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#dynamic-code-generation">
   Best Practices Guide
  </a>
  .
 </p>
 <p>
  Some approaches to resolving this issue:
 </p>
 <ul class="simple">
  <li>
   <p>
    Install a more recent CUDA driver that is compatible with the CUDA toolkit containing the NVRTC library being used.
   </p>
  </li>
  <li>
   <p>
    Compile directly to SASS instead of PTX with NVRTC (refer to
    <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#dynamic-code-generation">
     Best Practices Guide
    </a>
    ).
   </p>
  </li>
 </ul>
 <p>
  Alternately, an NVRTC client can either link against the static NVRTC library or redistribute
a specific version of the NVRTC shared library and use dlopen (Linux) or LoadLibrary (Windows)
functions to use that library at run time. Either approach allows the NVRTC client to maintain
control over the version of NVRTC being used during deployment, to ensure predictable functionality and performance.
 </p>
 <h2>
  <span class="section-number">
   8.2.
  </span>
  NVRTC-builtins Library
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#nvrtc-builtins-library" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  The NVRTC-builtins library contains helper code that is part of the NVRTC package.
It is only used by the NVRTC library internally. Each NVRTC library is only compatible
with the NVRTC-builtins library from the same CUDA toolkit.
 </p>
 <h1>
  <span class="section-number">
   9.
  </span>
  Miscellaneous Notes
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#miscellaneous-notes" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <h2>
  <span class="section-number">
   9.1.
  </span>
  Thread Safety
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#thread-safety" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  Multiple threads can invoke NVRTC API functions concurrently, as long as there is no race
condition. In this context, a race condition is defined to occur if multiple threads
concurrently invoke NVRTC API functions with the same nvrtcProgram argument, where at
least one thread is invoking either
  <span class="pre">
   nvrtcCompileProgram
  </span>
  or
  <span class="pre">
   nvrtcAddNameExpression
  </span>
  <a class="footnote-reference brackets" href="https://docs.nvidia.com/cuda/nvrtc/index.html#id8" id="id6">
   2
  </a>
  .
 </p>
 <p>
  Since CUDA 12.3, NVRTC allows concurrent invocations of
  <span class="pre">
   nvrtcCompileProgram
  </span>
  to potentially concurrently also invoke the embedded NVVM optimizer/codegen phase.
Setting the environment variable
  <span class="pre">
   NVRTC_DISABLE_CONCURRENT_NVVM
  </span>
  disables this behavior,
i.e., invocations of the embedded NVVM optimizer/codegen phase will be serialized.
 </p>
 <h2>
  <span class="section-number">
   9.2.
  </span>
  Stack Size
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#stack-size" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  On Linux, NVRTC will increase the stack size to the maximum allowed using the
  <span class="pre">
   setrlimit()
  </span>
  function during compilation. This reduces the chance that the compiler will run out of stack when processing complex input sources. The stack size is reset to the previous value when compilation is completed.
 </p>
 <p>
  Because
  <span class="pre">
   setrlimit()
  </span>
  changes the stack size for the entire process, it will also affect
other application threads that may be executing concurrently. The command line flag
  <span class="pre">
   -modify-stack-limit=false
  </span>
  will prevent NVRTC from modifying the stack limit.
 </p>
 <h2>
  <span class="section-number">
   9.3.
  </span>
  NVRTC Static Library
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#nvrtc-static-library" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  The NVRTC static library references functions defined in the NVRTC-builtins static library and the PTX compiler static library. Please see Build Instructions for an example.
 </p>
 <h1>
  <span class="section-number">
   10.
  </span>
  Example: SAXPY
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#example-saxpy" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <h2>
  <span class="section-number">
   10.1.
  </span>
  Code (saxpy.cpp)
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#code-saxpy-cpp" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <pre><span class="cp">#include</span><span class="cpf">&lt;nvrtc.h&gt;</span>
<span class="cp">#include</span><span class="cpf">&lt;cuda.h&gt;</span>
<span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span>

<span class="cp">#define NUM_THREADS 128</span>
<span class="cp">#define NUM_BLOCKS 32</span>
<span class="cp">#define NVRTC_SAFE_CALL(x)                                        \</span>
<span class="cp">  do {                                                            \</span>
<span class="cp">    nvrtcResult result = x;                                       \</span>
<span class="cp">    if (result != NVRTC_SUCCESS) {                                \</span>
<span class="cp">      std::cerr &lt;&lt; "\nerror: " #x " failed with error "           \</span>
<span class="cp">                &lt;&lt; nvrtcGetErrorString(result) &lt;&lt; '\n';           \</span>
<span class="cp">      exit(1);                                                    \</span>
<span class="cp">    }                                                             \</span>
<span class="cp">} while(0)</span>
<span class="cp">#define CUDA_SAFE_CALL(x)                                         \</span>
<span class="cp">  do {                                                            \</span>
<span class="cp">    CUresult result = x;                                          \</span>
<span class="cp">    if (result != CUDA_SUCCESS) {                                 \</span>
<span class="cp">      const char *msg;                                            \</span>
<span class="cp">      cuGetErrorName(result, &amp;msg);                               \</span>
<span class="cp">      std::cerr &lt;&lt; "\nerror: " #x " failed with error "           \</span>
<span class="cp">                &lt;&lt; msg &lt;&lt; '\n';                                   \</span>
<span class="cp">      exit(1);                                                    \</span>
<span class="cp">    }                                                             \</span>
<span class="cp">} while(0)</span>

<span class="k">const</span><span class="kt">char</span><span class="o">*</span><span class="n">saxpy</span><span class="o">=</span><span class="s">"                                           </span><span class="se">\n</span><span class="s">\</span>
<span class="s">extern </span><span class="se">\"</span><span class="s">C</span><span class="se">\"</span><span class="s"> __global__                                         </span><span class="se">\n</span><span class="s">\</span>
<span class="s">void saxpy(float a, float *x, float *y, float *out, size_t n)   </span><span class="se">\n</span><span class="s">\</span>
<span class="s">{                                                               </span><span class="se">\n</span><span class="s">\</span>
<span class="s">  size_t tid = blockIdx.x * blockDim.x + threadIdx.x;           </span><span class="se">\n</span><span class="s">\</span>
<span class="s">  if (tid &lt; n) {                                                </span><span class="se">\n</span><span class="s">\</span>
<span class="s">    out[tid] = a * x[tid] + y[tid];                             </span><span class="se">\n</span><span class="s">\</span>
<span class="s">  }                                                             </span><span class="se">\n</span><span class="s">\</span>
<span class="s">}                                                               </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

<span class="kt">int</span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="c1">// Create an instance of nvrtcProgram with the SAXPY code string.</span>
<span class="n">nvrtcProgram</span><span class="n">prog</span><span class="p">;</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span>
<span class="n">nvrtcCreateProgram</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prog</span><span class="p">,</span><span class="c1">// prog</span>
<span class="n">saxpy</span><span class="p">,</span><span class="c1">// buffer</span>
<span class="s">"saxpy.cu"</span><span class="p">,</span><span class="c1">// name</span>
<span class="mi">0</span><span class="p">,</span><span class="c1">// numHeaders</span>
<span class="nb">NULL</span><span class="p">,</span><span class="c1">// headers</span>
<span class="nb">NULL</span><span class="p">));</span><span class="c1">// includeNames</span>
<span class="c1">// Compile the program with fmad disabled.</span>
<span class="c1">// Note: Can specify GPU target architecture explicitly with '-arch' flag.</span>
<span class="k">const</span><span class="kt">char</span><span class="o">*</span><span class="n">opts</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="s">"--fmad=false"</span><span class="p">};</span>
<span class="n">nvrtcResult</span><span class="n">compileResult</span><span class="o">=</span><span class="n">nvrtcCompileProgram</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="c1">// prog</span>
<span class="mi">1</span><span class="p">,</span><span class="c1">// numOptions</span>
<span class="n">opts</span><span class="p">);</span><span class="c1">// options</span>
<span class="c1">// Obtain compilation log from the program.</span>
<span class="kt">size_t</span><span class="n">logSize</span><span class="p">;</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetProgramLogSize</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="o">&amp;</span><span class="n">logSize</span><span class="p">));</span>
<span class="kt">char</span><span class="o">*</span><span class="n">log</span><span class="o">=</span><span class="n">new</span><span class="kt">char</span><span class="p">[</span><span class="n">logSize</span><span class="p">];</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetProgramLog</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="n">log</span><span class="p">));</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">log</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
<span class="n">delete</span><span class="p">[]</span><span class="n">log</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">compileResult</span><span class="o">!=</span><span class="n">NVRTC_SUCCESS</span><span class="p">)</span><span class="p">{</span>
<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// Obtain PTX from the program.</span>
<span class="kt">size_t</span><span class="n">ptxSize</span><span class="p">;</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetPTXSize</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="o">&amp;</span><span class="n">ptxSize</span><span class="p">));</span>
<span class="kt">char</span><span class="o">*</span><span class="n">ptx</span><span class="o">=</span><span class="n">new</span><span class="kt">char</span><span class="p">[</span><span class="n">ptxSize</span><span class="p">];</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetPTX</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="n">ptx</span><span class="p">));</span>
<span class="c1">// Destroy the program.</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcDestroyProgram</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prog</span><span class="p">));</span>
<span class="c1">// Load the generated PTX and get a handle to the SAXPY kernel.</span>
<span class="n">CUdevice</span><span class="n">cuDevice</span><span class="p">;</span>
<span class="n">CUcontext</span><span class="n">context</span><span class="p">;</span>
<span class="n">CUmodule</span><span class="n">module</span><span class="p">;</span>
<span class="n">CUfunction</span><span class="n">kernel</span><span class="p">;</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuInit</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuDeviceGet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cuDevice</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">cuDevice</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleLoadDataEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module</span><span class="p">,</span><span class="n">ptx</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleGetFunction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kernel</span><span class="p">,</span><span class="n">module</span><span class="p">,</span><span class="s">"saxpy"</span><span class="p">));</span>
<span class="c1">// Generate input for execution, and create output buffers.</span>
<span class="kt">size_t</span><span class="n">n</span><span class="o">=</span><span class="n">NUM_THREADS</span><span class="o">*</span><span class="n">NUM_BLOCKS</span><span class="p">;</span>
<span class="kt">size_t</span><span class="n">bufferSize</span><span class="o">=</span><span class="n">n</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span>
<span class="kt">float</span><span class="n">a</span><span class="o">=</span><span class="mf">5.1f</span><span class="p">;</span>
<span class="kt">float</span><span class="o">*</span><span class="n">hX</span><span class="o">=</span><span class="n">new</span><span class="kt">float</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="o">*</span><span class="n">hY</span><span class="o">=</span><span class="n">new</span><span class="kt">float</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="o">*</span><span class="n">hOut</span><span class="o">=</span><span class="n">new</span><span class="kt">float</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="p">{</span>
<span class="n">hX</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="n">hY</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">CUdeviceptr</span><span class="n">dX</span><span class="p">,</span><span class="n">dY</span><span class="p">,</span><span class="n">dOut</span><span class="p">;</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dX</span><span class="p">,</span><span class="n">bufferSize</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dY</span><span class="p">,</span><span class="n">bufferSize</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dOut</span><span class="p">,</span><span class="n">bufferSize</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemcpyHtoD</span><span class="p">(</span><span class="n">dX</span><span class="p">,</span><span class="n">hX</span><span class="p">,</span><span class="n">bufferSize</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemcpyHtoD</span><span class="p">(</span><span class="n">dY</span><span class="p">,</span><span class="n">hY</span><span class="p">,</span><span class="n">bufferSize</span><span class="p">));</span>
<span class="c1">// Execute SAXPY.</span>
<span class="kt">void</span><span class="o">*</span><span class="n">args</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="o">&amp;</span><span class="n">dX</span><span class="p">,</span><span class="o">&amp;</span><span class="n">dY</span><span class="p">,</span><span class="o">&amp;</span><span class="n">dOut</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">};</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span>
<span class="n">cuLaunchKernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span>
<span class="n">NUM_BLOCKS</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="c1">// grid dim</span>
<span class="n">NUM_THREADS</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="c1">// block dim</span>
<span class="mi">0</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="c1">// shared mem and stream</span>
<span class="n">args</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span><span class="c1">// arguments</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxSynchronize</span><span class="p">());</span>
<span class="c1">// Retrieve and print output.</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemcpyDtoH</span><span class="p">(</span><span class="n">hOut</span><span class="p">,</span><span class="n">dOut</span><span class="p">,</span><span class="n">bufferSize</span><span class="p">));</span>
<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="p">{</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="s">" * "</span><span class="o">&lt;&lt;</span><span class="n">hX</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="s">" + "</span><span class="o">&lt;&lt;</span><span class="n">hY</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="o">&lt;&lt;</span><span class="s">" = "</span><span class="o">&lt;&lt;</span><span class="n">hOut</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// Release resources.</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemFree</span><span class="p">(</span><span class="n">dX</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemFree</span><span class="p">(</span><span class="n">dY</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemFree</span><span class="p">(</span><span class="n">dOut</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleUnload</span><span class="p">(</span><span class="n">module</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxDestroy</span><span class="p">(</span><span class="n">context</span><span class="p">));</span>
<span class="n">delete</span><span class="p">[]</span><span class="n">hX</span><span class="p">;</span>
<span class="n">delete</span><span class="p">[]</span><span class="n">hY</span><span class="p">;</span>
<span class="n">delete</span><span class="p">[]</span><span class="n">hOut</span><span class="p">;</span>
<span class="n">delete</span><span class="p">[]</span><span class="n">ptx</span><span class="p">;</span>
<span class="k">return</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>
 <h2>
  <span class="section-number">
   10.2.
  </span>
  Host Type Name Build Instructions
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#host-type-name-build-instructions" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  Assuming the environment variable
  <span class="pre">
   CUDA_PATH
  </span>
  points to the CUDA Toolkit installation directory, build this example as:
 </p>
 <ul>
  <li>
   <p>
    With NVRTC shared library:
   </p>
   <ul>
    <li>
     <p>
      Windows:
     </p>
     <pre>cl.exe saxpy.cpp /Fesaxpy ^
   /I "%CUDA_PATH%"\include ^
   "%CUDA_PATH%"\lib\x64\nvrtc.lib "%CUDA_PATH%"\lib\x64\cuda.lib
</pre>
    </li>
    <li>
     <p>
      Linux:
     </p>
     <pre>g++ saxpy.cpp -o saxpy \
   -I $CUDA_PATH/include \
   -L $CUDA_PATH/lib64 \
   -lnvrtc -lcuda \
   -Wl,-rpath,$CUDA_PATH/lib64
</pre>
    </li>
   </ul>
  </li>
  <li>
   <p>
    With NVRTC static library:
   </p>
   <ul>
    <li>
     <p>
      Windows:
     </p>
     <pre>cl.exe saxpy.cpp /Fesaxpy  ^
    /I "%CUDA_PATH%"\include ^
    "%CUDA_PATH%"\lib\x64\nvrtc_static.lib ^
    "%CUDA_PATH%"\lib\x64\nvrtc-builtins_static.lib ^
    "%CUDA_PATH%"\lib\x64\nvptxcompiler_static.lib ^
    "%CUDA_PATH%"\lib\x64\cuda.lib user32.lib Ws2_32.lib
</pre>
    </li>
    <li>
     <p>
      Linux:
     </p>
     <pre>g++ saxpy.cpp -o saxpy \
   -I $CUDA_PATH/include \
   -L $CUDA_PATH/lib64 \
   -lnvrtc_static -lnvrtc-builtins_static -lnvptxcompiler_static -lcuda \
   -lpthread
</pre>
    </li>
   </ul>
  </li>
 </ul>
 <h1>
  <span class="section-number">
   11.
  </span>
  Example: Using Lowered Name
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#example-using-lowered-name" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <h2>
  <span class="section-number">
   11.1.
  </span>
  Code (lowered-name.cpp)
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#code-lowered-name-cpp" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <pre><span class="cp">#include</span><span class="cpf">&lt;nvrtc.h&gt;</span>
<span class="cp">#include</span><span class="cpf">&lt;cuda.h&gt;</span>
<span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="cpf">&lt;vector&gt;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span>

<span class="cp">#define NVRTC_SAFE_CALL(x)                                        \</span>
<span class="cp">do {                                                              \</span>
<span class="cp">   nvrtcResult result = x;                                        \</span>
<span class="cp">   if (result != NVRTC_SUCCESS) {                                 \</span>
<span class="cp">      std::cerr &lt;&lt; "\nerror: " #x " failed with error "           \</span>
<span class="cp">               &lt;&lt; nvrtcGetErrorString(result) &lt;&lt; '\n';            \</span>
<span class="cp">      exit(1);                                                    \</span>
<span class="cp">   }                                                              \</span>
<span class="cp">} while(0)</span>
<span class="cp">#define CUDA_SAFE_CALL(x)                                         \</span>
<span class="cp">do {                                                              \</span>
<span class="cp">   CUresult result = x;                                           \</span>
<span class="cp">   if (result != CUDA_SUCCESS) {                                  \</span>
<span class="cp">      const char *msg;                                            \</span>
<span class="cp">      cuGetErrorName(result, &amp;msg);                               \</span>
<span class="cp">      std::cerr &lt;&lt; "\nerror: " #x " failed with error "           \</span>
<span class="cp">               &lt;&lt; msg &lt;&lt; '\n';                                    \</span>
<span class="cp">      exit(1);                                                    \</span>
<span class="cp">   }                                                              \</span>
<span class="cp">} while(0)</span>

<span class="k">const</span><span class="kt">char</span><span class="o">*</span><span class="n">gpu_program</span><span class="o">=</span><span class="s">"</span>
<span class="n">__device__</span><span class="kt">int</span><span class="n">V1</span><span class="p">;</span><span class="c1">// set from host code                        \n\</span>
<span class="c1">  static __global__ void f1(int *result) { *result = V1 + 10; }   \n\</span>
<span class="c1">  namespace N1 {                                                  \n\</span>
<span class="c1">    namespace N2 {                                                \n\</span>
<span class="c1">       __constant__ int V2; // set from host code                 \n\</span>
<span class="c1">       __global__ void f2(int *result) { *result = V2 + 20; }     \n\</span>
<span class="c1">      }                                                           \n\</span>
<span class="c1">   }                                                              \n\</span>
<span class="c1">   template&lt;typename T&gt;                                           \n\</span>
<span class="c1">   __global__ void f3(int *result) { *result = sizeof(T); }       \n\</span>
<span class="c1">                                                                  \n";</span>

<span class="kt">int</span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="c1">// Create an instance of nvrtcProgram</span>
<span class="n">nvrtcProgram</span><span class="n">prog</span><span class="p">;</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcCreateProgram</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prog</span><span class="p">,</span><span class="c1">// prog</span>
<span class="n">gpu_program</span><span class="p">,</span><span class="c1">// buffer</span>
<span class="s">"prog.cu"</span><span class="p">,</span><span class="c1">// name</span>
<span class="mi">0</span><span class="p">,</span><span class="c1">// numHeaders</span>
<span class="nb">NULL</span><span class="p">,</span><span class="c1">// headers</span>
<span class="nb">NULL</span><span class="p">));</span><span class="c1">// includeNames</span>

<span class="c1">// add all name expressions for kernels</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="n">kernel_name_vec</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="n">variable_name_vec</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">variable_initial_value</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">expected_result</span><span class="p">;</span>

<span class="c1">// note the name expressions are parsed as constant expressions</span>
<span class="n">kernel_name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"&amp;f1"</span><span class="p">);</span>
<span class="n">expected_result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">10</span><span class="o">+</span><span class="mi">100</span><span class="p">);</span>

<span class="n">kernel_name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"N1::N2::f2"</span><span class="p">);</span>
<span class="n">expected_result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">20</span><span class="o">+</span><span class="mi">200</span><span class="p">);</span>

<span class="n">kernel_name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"f3&lt;int&gt;"</span><span class="p">);</span>
<span class="n">expected_result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

<span class="n">kernel_name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"f3&lt;double&gt;"</span><span class="p">);</span>
<span class="n">expected_result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>

<span class="c1">// add kernel name expressions to NVRTC. Note this must be done before</span>
<span class="c1">// the program is compiled.</span>
<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">kernel_name_vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcAddNameExpression</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="n">kernel_name_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">()));</span>

<span class="c1">// add expressions for  __device__ / __constant__ variables to NVRTC</span>
<span class="n">variable_name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"&amp;V1"</span><span class="p">);</span>
<span class="n">variable_initial_value</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

<span class="n">variable_name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"&amp;N1::N2::V2"</span><span class="p">);</span>
<span class="n">variable_initial_value</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>

<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">variable_name_vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcAddNameExpression</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="n">variable_name_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">()));</span>

<span class="n">nvrtcResult</span><span class="n">compileResult</span><span class="o">=</span><span class="n">nvrtcCompileProgram</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="c1">// prog</span>
<span class="mi">0</span><span class="p">,</span><span class="c1">// numOptions</span>
<span class="nb">NULL</span><span class="p">);</span><span class="c1">// options</span>
<span class="c1">// Obtain compilation log from the program.</span>
<span class="kt">size_t</span><span class="n">logSize</span><span class="p">;</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetProgramLogSize</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="o">&amp;</span><span class="n">logSize</span><span class="p">));</span>
<span class="kt">char</span><span class="o">*</span><span class="n">log</span><span class="o">=</span><span class="n">new</span><span class="kt">char</span><span class="p">[</span><span class="n">logSize</span><span class="p">];</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetProgramLog</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="n">log</span><span class="p">));</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">log</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
<span class="n">delete</span><span class="p">[]</span><span class="n">log</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">compileResult</span><span class="o">!=</span><span class="n">NVRTC_SUCCESS</span><span class="p">)</span><span class="p">{</span>
<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// Obtain PTX from the program.</span>
<span class="kt">size_t</span><span class="n">ptxSize</span><span class="p">;</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetPTXSize</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="o">&amp;</span><span class="n">ptxSize</span><span class="p">));</span>
<span class="kt">char</span><span class="o">*</span><span class="n">ptx</span><span class="o">=</span><span class="n">new</span><span class="kt">char</span><span class="p">[</span><span class="n">ptxSize</span><span class="p">];</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetPTX</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="n">ptx</span><span class="p">));</span>
<span class="c1">// Load the generated PTX</span>
<span class="n">CUdevice</span><span class="n">cuDevice</span><span class="p">;</span>
<span class="n">CUcontext</span><span class="n">context</span><span class="p">;</span>
<span class="n">CUmodule</span><span class="n">module</span><span class="p">;</span>

<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuInit</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuDeviceGet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cuDevice</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">cuDevice</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleLoadDataEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module</span><span class="p">,</span><span class="n">ptx</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>

<span class="n">CUdeviceptr</span><span class="n">dResult</span><span class="p">;</span>
<span class="kt">int</span><span class="n">hResult</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dResult</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">hResult</span><span class="p">)));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemcpyHtoD</span><span class="p">(</span><span class="n">dResult</span><span class="p">,</span><span class="o">&amp;</span><span class="n">hResult</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">hResult</span><span class="p">)));</span>

<span class="c1">// for each of the __device__/__constant__ variable address</span>
<span class="c1">// expressions provided to NVRTC, extract the lowered name for the</span>
<span class="c1">// corresponding variable, and set its value</span>
<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">variable_name_vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="p">{</span>
<span class="k">const</span><span class="kt">char</span><span class="o">*</span><span class="n">name</span><span class="p">;</span>

<span class="c1">// note: this call must be made after NVRTC program has been</span>
<span class="c1">// compiled and before it has been destroyed.</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetLoweredName</span><span class="p">(</span>
<span class="n">prog</span><span class="p">,</span>
<span class="n">variable_name_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">(),</span><span class="c1">// name expression</span>
<span class="o">&amp;</span><span class="n">name</span><span class="c1">// lowered name</span>
<span class="p">));</span>
<span class="kt">int</span><span class="n">initial_value</span><span class="o">=</span><span class="n">variable_initial_value</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="c1">// get pointer to variable using lowered name, and set its</span>
<span class="c1">// initial value</span>
<span class="n">CUdeviceptr</span><span class="n">variable_addr</span><span class="p">;</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleGetGlobal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">variable_addr</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">module</span><span class="p">,</span><span class="n">name</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemcpyHtoD</span><span class="p">(</span><span class="n">variable_addr</span><span class="p">,</span><span class="o">&amp;</span><span class="n">initial_value</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">initial_value</span><span class="p">)));</span>
<span class="p">}</span>


<span class="c1">// for each of the kernel name expressions previously provided to NVRTC,</span>
<span class="c1">// extract the lowered name for corresponding __global__ function,</span>
<span class="c1">// and launch it.</span>

<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">kernel_name_vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="p">{</span>
<span class="k">const</span><span class="kt">char</span><span class="o">*</span><span class="n">name</span><span class="p">;</span>

<span class="c1">// note: this call must be made after NVRTC program has been</span>
<span class="c1">// compiled and before it has been destroyed.</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetLoweredName</span><span class="p">(</span>
<span class="n">prog</span><span class="p">,</span>
<span class="n">kernel_name_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">(),</span><span class="c1">// name expression</span>
<span class="o">&amp;</span><span class="n">name</span><span class="c1">// lowered name</span>
<span class="p">));</span>

<span class="c1">// get pointer to kernel from loaded PTX</span>
<span class="n">CUfunction</span><span class="n">kernel</span><span class="p">;</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleGetFunction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kernel</span><span class="p">,</span><span class="n">module</span><span class="p">,</span><span class="n">name</span><span class="p">));</span>

<span class="c1">// launch the kernel</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"</span><span class="se">\n</span><span class="s">launching "</span><span class="o">&lt;&lt;</span><span class="n">name</span><span class="o">&lt;&lt;</span><span class="s">" ("</span>
<span class="o">&lt;&lt;</span><span class="n">kernel_name_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="s">")"</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="kt">void</span><span class="o">*</span><span class="n">args</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="o">&amp;</span><span class="n">dResult</span><span class="p">};</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span>
<span class="n">cuLaunchKernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span>
<span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="c1">// grid dim</span>
<span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="c1">// block dim</span>
<span class="mi">0</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="c1">// shared mem and stream</span>
<span class="n">args</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span><span class="c1">// arguments</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxSynchronize</span><span class="p">());</span>

<span class="c1">// Retrieve the result</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemcpyDtoH</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hResult</span><span class="p">,</span><span class="n">dResult</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">hResult</span><span class="p">)));</span>

<span class="c1">// check against expected value</span>
<span class="k">if</span><span class="p">(</span><span class="n">expected_result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span><span class="n">hResult</span><span class="p">)</span><span class="p">{</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"</span><span class="se">\n</span><span class="s"> Error: expected result = "</span><span class="o">&lt;&lt;</span><span class="n">expected_result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="o">&lt;&lt;</span><span class="s">" , actual result = "</span><span class="o">&lt;&lt;</span><span class="n">hResult</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span><span class="c1">// for</span>

<span class="c1">// Release resources.</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemFree</span><span class="p">(</span><span class="n">dResult</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleUnload</span><span class="p">(</span><span class="n">module</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxDestroy</span><span class="p">(</span><span class="n">context</span><span class="p">));</span>
<span class="n">delete</span><span class="p">[]</span><span class="n">ptx</span><span class="p">;</span>

<span class="c1">// Destroy the program.</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcDestroyProgram</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prog</span><span class="p">));</span>

<span class="k">return</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>
 <h2>
  <span class="section-number">
   11.2.
  </span>
  Lowered Name Build Instructions
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#lowered-name-build-instructions" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  Assuming the environment variable
  <span class="pre">
   CUDA_PATH
  </span>
  points to CUDA Toolkit installation directory, build this example as:
 </p>
 <ul>
  <li>
   <p>
    With NVRTC shared library:
   </p>
   <ul>
    <li>
     <p>
      Windows:
     </p>
     <pre>cl.exe lowered-name.cpp /Felowered-name ^
/I "%CUDA_PATH%"\include ^
"%CUDA_PATH%"\lib\x64\nvrtc.lib "%CUDA_PATH%"\lib\x64\cuda.lib
</pre>
    </li>
    <li>
     <p>
      Linux:
     </p>
     <pre>g++ lowered-name.cpp -o lowered-name \
-I $CUDA_PATH/include \
-L $CUDA_PATH/lib64 \
-lnvrtc -lcuda \
-Wl,-rpath,$CUDA_PATH/lib64
</pre>
    </li>
   </ul>
  </li>
  <li>
   <p>
    With NVRTC static library:
   </p>
   <ul>
    <li>
     <p>
      Windows:
     </p>
     <pre>cl.exe lowered-name.cpp /Felowered-name  ^
/I "%CUDA_PATH%"\include ^
"%CUDA_PATH%"\lib\x64\nvrtc_static.lib ^
"%CUDA_PATH%"\lib\x64\nvrtc-builtins_static.lib ^
"%CUDA_PATH%"\lib\x64\nvptxcompiler_static.lib ^
"%CUDA_PATH%"\lib\x64\cuda.lib user32.lib Ws2_32.lib
</pre>
    </li>
    <li>
     <p>
      Linux:
     </p>
     <pre>g++ lowered-name.cpp -o lowered-name \
-I $CUDA_PATH/include \
-L $CUDA_PATH/lib64 \
-lnvrtc_static -lnvrtc-builtins_static -lnvptxcompiler_static \
-lcuda -lpthread
</pre>
    </li>
   </ul>
  </li>
 </ul>
 <h1>
  <span class="section-number">
   12.
  </span>
  Example: Using nvrtcGetTypeName
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#example-using-nvrtcgettypename" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <h2>
  <span class="section-number">
   12.1.
  </span>
  Code (host-type-name.cpp)
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#code-host-type-name-cpp" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <pre><span class="cp">#include</span><span class="cpf">&lt;nvrtc.h&gt;</span>
<span class="cp">#include</span><span class="cpf">&lt;cuda.h&gt;</span>
<span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="cpf">&lt;vector&gt;</span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span>

<span class="cp">#define NVRTC_SAFE_CALL(x)                                        \</span>
<span class="cp">do {                                                            \</span>
<span class="cp">   nvrtcResult result = x;                                       \</span>
<span class="cp">   if (result != NVRTC_SUCCESS) {                                \</span>
<span class="cp">      std::cerr &lt;&lt; "\nerror: " #x " failed with error "           \</span>
<span class="cp">               &lt;&lt; nvrtcGetErrorString(result) &lt;&lt; '\n';           \</span>
<span class="cp">      exit(1);                                                    \</span>
<span class="cp">   }                                                             \</span>
<span class="cp">} while(0)</span>
<span class="cp">#define CUDA_SAFE_CALL(x)                                         \</span>
<span class="cp">do {                                                            \</span>
<span class="cp">   CUresult result = x;                                          \</span>
<span class="cp">   if (result != CUDA_SUCCESS) {                                 \</span>
<span class="cp">      const char *msg;                                            \</span>
<span class="cp">      cuGetErrorName(result, &amp;msg);                               \</span>
<span class="cp">      std::cerr &lt;&lt; "\nerror: " #x " failed with error "           \</span>
<span class="cp">               &lt;&lt; msg &lt;&lt; '\n';                                   \</span>
<span class="cp">      exit(1);                                                    \</span>
<span class="cp">   }                                                             \</span>
<span class="cp">} while(0)</span>

<span class="k">const</span><span class="kt">char</span><span class="o">*</span><span class="n">gpu_program</span><span class="o">=</span><span class="s">"                                     </span><span class="se">\n</span><span class="s">\</span>
<span class="s">namespace N1 { struct S1_t { int i; double d; }; }              </span><span class="se">\n</span><span class="s">\</span>
<span class="s">template&lt;typename T&gt;                                            </span><span class="se">\n</span><span class="s">\</span>
<span class="s">__global__ void f3(int *result) { *result = sizeof(T); }        </span><span class="se">\n</span><span class="s">\</span>
<span class="se">\n</span><span class="s">"</span><span class="p">;</span>


<span class="c1">// note: this structure is also defined in GPU code string. Should ideally</span>
<span class="c1">// be in a header file included by both GPU code string and by CPU code.</span>
<span class="n">namespace</span><span class="n">N1</span><span class="p">{</span><span class="k">struct</span><span class="nc">S1_t</span><span class="p">{</span><span class="kt">int</span><span class="n">i</span><span class="p">;</span><span class="kt">double</span><span class="n">d</span><span class="p">;</span><span class="p">};</span><span class="p">};</span>
<span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="n">T</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="n">getKernelNameForType</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">// Look up the source level name string for the type "T" using</span>
<span class="c1">// nvrtcGetTypeName() and use it to create the kernel name</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="n">type_name</span><span class="p">;</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetTypeName</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type_name</span><span class="p">));</span>
<span class="k">return</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"f3&lt;"</span><span class="p">)</span><span class="o">+</span><span class="n">type_name</span><span class="o">+</span><span class="s">"&gt;"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="c1">// Create an instance of nvrtcProgram</span>
<span class="n">nvrtcProgram</span><span class="n">prog</span><span class="p">;</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span>
<span class="n">nvrtcCreateProgram</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prog</span><span class="p">,</span><span class="c1">// prog</span>
<span class="n">gpu_program</span><span class="p">,</span><span class="c1">// buffer</span>
<span class="s">"gpu_program.cu"</span><span class="p">,</span><span class="c1">// name</span>
<span class="mi">0</span><span class="p">,</span><span class="c1">// numHeaders</span>
<span class="nb">NULL</span><span class="p">,</span><span class="c1">// headers</span>
<span class="nb">NULL</span><span class="p">));</span><span class="c1">// includeNames</span>

<span class="c1">// add all name expressions for kernels</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="n">name_vec</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">expected_result</span><span class="p">;</span>

<span class="c1">// note the name expressions are parsed as constant expressions</span>
<span class="n">name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">getKernelNameForType</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
<span class="n">expected_result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

<span class="n">name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">getKernelNameForType</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">());</span>
<span class="n">expected_result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>

<span class="n">name_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">getKernelNameForType</span><span class="o">&lt;</span><span class="n">N1</span><span class="o">::</span><span class="n">S1_t</span><span class="o">&gt;</span><span class="p">());</span>
<span class="n">expected_result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">N1</span><span class="o">::</span><span class="n">S1_t</span><span class="p">));</span>


<span class="c1">// add name expressions to NVRTC. Note this must be done before</span>
<span class="c1">// the program is compiled.</span>
<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">name_vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcAddNameExpression</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="n">name_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">()));</span>

<span class="n">nvrtcResult</span><span class="n">compileResult</span><span class="o">=</span><span class="n">nvrtcCompileProgram</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="c1">// prog</span>
<span class="mi">0</span><span class="p">,</span><span class="c1">// numOptions</span>
<span class="nb">NULL</span><span class="p">);</span><span class="c1">// options</span>
<span class="c1">// Obtain compilation log from the program.</span>
<span class="kt">size_t</span><span class="n">logSize</span><span class="p">;</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetProgramLogSize</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="o">&amp;</span><span class="n">logSize</span><span class="p">));</span>
<span class="kt">char</span><span class="o">*</span><span class="n">log</span><span class="o">=</span><span class="n">new</span><span class="kt">char</span><span class="p">[</span><span class="n">logSize</span><span class="p">];</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetProgramLog</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="n">log</span><span class="p">));</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">log</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
<span class="n">delete</span><span class="p">[]</span><span class="n">log</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">compileResult</span><span class="o">!=</span><span class="n">NVRTC_SUCCESS</span><span class="p">)</span><span class="p">{</span>
<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// Obtain PTX from the program.</span>
<span class="kt">size_t</span><span class="n">ptxSize</span><span class="p">;</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetPTXSize</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="o">&amp;</span><span class="n">ptxSize</span><span class="p">));</span>
<span class="kt">char</span><span class="o">*</span><span class="n">ptx</span><span class="o">=</span><span class="n">new</span><span class="kt">char</span><span class="p">[</span><span class="n">ptxSize</span><span class="p">];</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetPTX</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="n">ptx</span><span class="p">));</span>


<span class="c1">// Load the generated PTX</span>
<span class="n">CUdevice</span><span class="n">cuDevice</span><span class="p">;</span>
<span class="n">CUcontext</span><span class="n">context</span><span class="p">;</span>
<span class="n">CUmodule</span><span class="n">module</span><span class="p">;</span>

<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuInit</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuDeviceGet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cuDevice</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">cuDevice</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleLoadDataEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module</span><span class="p">,</span><span class="n">ptx</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>

<span class="n">CUdeviceptr</span><span class="n">dResult</span><span class="p">;</span>
<span class="kt">int</span><span class="n">hResult</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dResult</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">hResult</span><span class="p">)));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemcpyHtoD</span><span class="p">(</span><span class="n">dResult</span><span class="p">,</span><span class="o">&amp;</span><span class="n">hResult</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">hResult</span><span class="p">)));</span>

<span class="c1">// for each of the name expressions previously provided to NVRTC,</span>
<span class="c1">// extract the lowered name for corresponding __global__ function,</span>
<span class="c1">// and launch it.</span>

<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">name_vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="p">{</span>
<span class="k">const</span><span class="kt">char</span><span class="o">*</span><span class="n">name</span><span class="p">;</span>

<span class="c1">// note: this call must be made after NVRTC program has been</span>
<span class="c1">// compiled and before it has been destroyed.</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetLoweredName</span><span class="p">(</span>
<span class="n">prog</span><span class="p">,</span>
<span class="n">name_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">(),</span><span class="c1">// name expression</span>
<span class="o">&amp;</span><span class="n">name</span><span class="c1">// lowered name</span>
<span class="p">));</span>

<span class="c1">// get pointer to kernel from loaded PTX</span>
<span class="n">CUfunction</span><span class="n">kernel</span><span class="p">;</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleGetFunction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kernel</span><span class="p">,</span><span class="n">module</span><span class="p">,</span><span class="n">name</span><span class="p">));</span>

<span class="c1">// launch the kernel</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"</span><span class="se">\n</span><span class="s">launching "</span><span class="o">&lt;&lt;</span><span class="n">name</span><span class="o">&lt;&lt;</span><span class="s">" ("</span>
<span class="o">&lt;&lt;</span><span class="n">name_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="s">")"</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="kt">void</span><span class="o">*</span><span class="n">args</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="o">&amp;</span><span class="n">dResult</span><span class="p">};</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span>
<span class="n">cuLaunchKernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span>
<span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="c1">// grid dim</span>
<span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="c1">// block dim</span>
<span class="mi">0</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="c1">// shared mem and stream</span>
<span class="n">args</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span><span class="c1">// arguments</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxSynchronize</span><span class="p">());</span>

<span class="c1">// Retrieve the result</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemcpyDtoH</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hResult</span><span class="p">,</span><span class="n">dResult</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">hResult</span><span class="p">)));</span>

<span class="c1">// check against expected value</span>
<span class="k">if</span><span class="p">(</span><span class="n">expected_result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span><span class="n">hResult</span><span class="p">)</span><span class="p">{</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"</span><span class="se">\n</span><span class="s"> Error: expected result = "</span><span class="o">&lt;&lt;</span><span class="n">expected_result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="o">&lt;&lt;</span><span class="s">" , actual result = "</span><span class="o">&lt;&lt;</span><span class="n">hResult</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span><span class="c1">// for</span>

<span class="c1">// Release resources.</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemFree</span><span class="p">(</span><span class="n">dResult</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleUnload</span><span class="p">(</span><span class="n">module</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxDestroy</span><span class="p">(</span><span class="n">context</span><span class="p">));</span>
<span class="n">delete</span><span class="p">[]</span><span class="n">ptx</span><span class="p">;</span>

<span class="c1">// Destroy the program.</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcDestroyProgram</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prog</span><span class="p">));</span>

<span class="k">return</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>
 <h2>
  <span class="section-number">
   12.2.
  </span>
  nvrtcGetTypeName Build Instructions
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#nvrtcgettypename-build-instructions" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  Assuming the environment variable
  <span class="pre">
   CUDA_PATH
  </span>
  points to CUDA Toolkit installation
directory, build this example as:
 </p>
 <ul>
  <li>
   <p>
    With NVRTC shared library:
   </p>
   <ul>
    <li>
     <p>
      Windows:
     </p>
     <pre>cl.exe -DNVRTC_GET_TYPE_NAME=1 host-type-name.cpp /Fehost-type-name ^
   /I "%CUDA_PATH%"\include ^
   "%CUDA_PATH%"\lib\x64\nvrtc.lib "%CUDA_PATH%"\lib\x64\cuda.lib DbgHelp.lib
</pre>
    </li>
    <li>
     <p>
      Linux:
     </p>
     <pre>g++ -DNVRTC_GET_TYPE_NAME=1 host-type-name.cpp -o host-type-name \
   -I $CUDA_PATH/include \
   -L $CUDA_PATH/lib64 \
   -lnvrtc -lcuda \
   -Wl,-rpath,$CUDA_PATH/lib64
</pre>
    </li>
   </ul>
  </li>
  <li>
   <p>
    With NVRTC static library:
   </p>
   <ul>
    <li>
     <p>
      Windows:
     </p>
     <pre>cl.exe -DNVRTC_GET_TYPE_NAME=1 host-type-name.cpp /Fehost-type-name  ^
   /I "%CUDA_PATH%"\include ^
   "%CUDA_PATH%"\lib\x64\nvrtc_static.lib ^
   "%CUDA_PATH%"\lib\x64\nvrtc-builtins_static.lib ^
   "%CUDA_PATH%"\lib\x64\nvptxcompiler_static.lib ^
   "%CUDA_PATH%"\lib\x64\cuda.lib DbgHelp.lib user32.lib Ws2_32.lib
</pre>
    </li>
    <li>
     <p>
      Linux:
     </p>
     <pre>g++ -DNVRTC_GET_TYPE_NAME=1 host-type-name.cpp -o host-type-name \
   -I $CUDA_PATH/include \
   -L $CUDA_PATH/lib64 \
   -lnvrtc_static -lnvrtc-builtins_static -lnvptxcompiler_static \
   -lcuda -lpthread
</pre>
    </li>
   </ul>
  </li>
 </ul>
 <h1>
  <span class="section-number">
   13.
  </span>
  Example: Dynamic Parallelism
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#example-dynamic-parallelism" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <p>
  Code (dynamic-parallelism.cpp)
 </p>
 <pre><span class="cp">#include</span><span class="cpf">&lt;nvrtc.h&gt;</span>
<span class="cp">#include</span><span class="cpf">&lt;cuda.h&gt;</span>
<span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span>

<span class="cp">#define NVRTC_SAFE_CALL(x)                                        \</span>
<span class="cp">do {                                                              \</span>
<span class="cp">   nvrtcResult result = x;                                        \</span>
<span class="cp">   if (result != NVRTC_SUCCESS) {                                 \</span>
<span class="cp">      std::cerr &lt;&lt; "\nerror: " #x " failed with error "           \</span>
<span class="cp">                &lt;&lt; nvrtcGetErrorString(result) &lt;&lt; '\n';           \</span>
<span class="cp">      exit(1);                                                    \</span>
<span class="cp">   }                                                              \</span>
<span class="cp">} while(0)</span>
<span class="cp">#define CUDA_SAFE_CALL(x)                                         \</span>
<span class="cp">do {                                                              \</span>
<span class="cp">   CUresult result = x;                                           \</span>
<span class="cp">   if (result != CUDA_SUCCESS) {                                  \</span>
<span class="cp">      const char *msg;                                            \</span>
<span class="cp">      cuGetErrorName(result, &amp;msg);                               \</span>
<span class="cp">      std::cerr &lt;&lt; "\nerror: " #x " failed with error "           \</span>
<span class="cp">                &lt;&lt; msg &lt;&lt; '\n';                                   \</span>
<span class="cp">      exit(1);                                                    \</span>
<span class="cp">   }                                                              \</span>
<span class="cp">} while(0)</span>

<span class="k">const</span><span class="kt">char</span><span class="o">*</span><span class="n">dynamic_parallelism</span><span class="o">=</span><span class="s">"                             </span><span class="se">\n</span><span class="s">\</span>
<span class="s">extern </span><span class="se">\"</span><span class="s">C</span><span class="se">\"</span><span class="s"> __global__                                         </span><span class="se">\n</span><span class="s">\</span>
<span class="s">void child(float *out, size_t n)                                </span><span class="se">\n</span><span class="s">\</span>
<span class="s">{                                                               </span><span class="se">\n</span><span class="s">\</span>
<span class="s">   size_t tid = blockIdx.x * blockDim.x + threadIdx.x;          </span><span class="se">\n</span><span class="s">\</span>
<span class="s">   if (tid &lt; n) {                                               </span><span class="se">\n</span><span class="s">\</span>
<span class="s">      out[tid] = tid;                                           </span><span class="se">\n</span><span class="s">\</span>
<span class="s">   }                                                            </span><span class="se">\n</span><span class="s">\</span>
<span class="s">}                                                               </span><span class="se">\n</span><span class="s">\</span>
<span class="se">\n</span><span class="s">\</span>
<span class="s">extern </span><span class="se">\"</span><span class="s">C</span><span class="se">\"</span><span class="s"> __global__                                         </span><span class="se">\n</span><span class="s">\</span>
<span class="s">void parent(float *out, size_t n,                               </span><span class="se">\n</span><span class="s">\</span>
<span class="s">            size_t numBlocks, size_t numThreads)                </span><span class="se">\n</span><span class="s">\</span>
<span class="s">{                                                               </span><span class="se">\n</span><span class="s">\</span>
<span class="s">   child&lt;&lt;&lt;numBlocks, numThreads&gt;&gt;&gt;(out, n);                    </span><span class="se">\n</span><span class="s">\</span>
<span class="s">   cudaDeviceSynchronize();                                     </span><span class="se">\n</span><span class="s">\</span>
<span class="s">}                                                               </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="kt">int</span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="n">argc</span><span class="p">,</span><span class="kt">char</span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="k">if</span><span class="p">(</span><span class="n">argc</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">)</span><span class="p">{</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Usage: dynamic-parallelism &lt;path to cudadevrt library&gt;</span><span class="se">\n\n</span><span class="s">"</span>
<span class="o">&lt;&lt;</span><span class="s">"&lt;path to cudadevrt library&gt; must include the cudadevrt</span><span class="se">\n</span><span class="s">"</span>
<span class="o">&lt;&lt;</span><span class="s">"library name itself, e.g., Z:</span><span class="se">\\</span><span class="s">path</span><span class="se">\\</span><span class="s">to</span><span class="se">\\</span><span class="s">cudadevrt.lib on </span><span class="se">\n</span><span class="s">"</span>
<span class="o">&lt;&lt;</span><span class="s">"Windows and /path/to/libcudadevrt.a on Linux.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">size_t</span><span class="n">numBlocks</span><span class="o">=</span><span class="mi">32</span><span class="p">;</span>
<span class="kt">size_t</span><span class="n">numThreads</span><span class="o">=</span><span class="mi">128</span><span class="p">;</span>
<span class="c1">// Create an instance of nvrtcProgram with the code string.</span>
<span class="n">nvrtcProgram</span><span class="n">prog</span><span class="p">;</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span>
<span class="n">nvrtcCreateProgram</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prog</span><span class="p">,</span><span class="c1">// prog</span>
<span class="n">dynamic_parallelism</span><span class="p">,</span><span class="c1">// buffer</span>
<span class="s">"dynamic_parallelism.cu"</span><span class="p">,</span><span class="c1">// name</span>
<span class="mi">0</span><span class="p">,</span><span class="c1">// numHeaders</span>
<span class="nb">NULL</span><span class="p">,</span><span class="c1">// headers</span>
<span class="nb">NULL</span><span class="p">));</span><span class="c1">// includeNames</span>
<span class="c1">// Compile the program for compute_35 with rdc enabled.</span>
<span class="k">const</span><span class="kt">char</span><span class="o">*</span><span class="n">opts</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="s">"--gpu-architecture=compute_35"</span><span class="p">,</span>
<span class="s">"--relocatable-device-code=true"</span><span class="p">};</span>
<span class="n">nvrtcResult</span><span class="n">compileResult</span><span class="o">=</span><span class="n">nvrtcCompileProgram</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="c1">// prog</span>
<span class="mi">2</span><span class="p">,</span><span class="c1">// numOptions</span>
<span class="n">opts</span><span class="p">);</span><span class="c1">// options</span>
<span class="c1">// Obtain compilation log from the program.</span>
<span class="kt">size_t</span><span class="n">logSize</span><span class="p">;</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetProgramLogSize</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="o">&amp;</span><span class="n">logSize</span><span class="p">));</span>
<span class="kt">char</span><span class="o">*</span><span class="n">log</span><span class="o">=</span><span class="n">new</span><span class="kt">char</span><span class="p">[</span><span class="n">logSize</span><span class="p">];</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetProgramLog</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="n">log</span><span class="p">));</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">log</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
<span class="n">delete</span><span class="p">[]</span><span class="n">log</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">compileResult</span><span class="o">!=</span><span class="n">NVRTC_SUCCESS</span><span class="p">)</span><span class="p">{</span>
<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// Obtain PTX from the program.</span>
<span class="kt">size_t</span><span class="n">ptxSize</span><span class="p">;</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetPTXSize</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="o">&amp;</span><span class="n">ptxSize</span><span class="p">));</span>
<span class="kt">char</span><span class="o">*</span><span class="n">ptx</span><span class="o">=</span><span class="n">new</span><span class="kt">char</span><span class="p">[</span><span class="n">ptxSize</span><span class="p">];</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetPTX</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="n">ptx</span><span class="p">));</span>
<span class="c1">// Destroy the program.</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcDestroyProgram</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prog</span><span class="p">));</span>
<span class="c1">// Load the generated PTX and get a handle to the parent kernel.</span>
<span class="n">CUdevice</span><span class="n">cuDevice</span><span class="p">;</span>
<span class="n">CUcontext</span><span class="n">context</span><span class="p">;</span>
<span class="n">CUlinkState</span><span class="n">linkState</span><span class="p">;</span>
<span class="n">CUmodule</span><span class="n">module</span><span class="p">;</span>
<span class="n">CUfunction</span><span class="n">kernel</span><span class="p">;</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuInit</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuDeviceGet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cuDevice</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">cuDevice</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuLinkCreate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">&amp;</span><span class="n">linkState</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuLinkAddFile</span><span class="p">(</span><span class="n">linkState</span><span class="p">,</span><span class="n">CU_JIT_INPUT_LIBRARY</span><span class="p">,</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
<span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuLinkAddData</span><span class="p">(</span><span class="n">linkState</span><span class="p">,</span><span class="n">CU_JIT_INPUT_PTX</span><span class="p">,</span>
<span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">ptx</span><span class="p">,</span><span class="n">ptxSize</span><span class="p">,</span><span class="s">"dynamic_parallelism.ptx"</span><span class="p">,</span>
<span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
<span class="kt">size_t</span><span class="n">cubinSize</span><span class="p">;</span>
<span class="kt">void</span><span class="o">*</span><span class="n">cubin</span><span class="p">;</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuLinkComplete</span><span class="p">(</span><span class="n">linkState</span><span class="p">,</span><span class="o">&amp;</span><span class="n">cubin</span><span class="p">,</span><span class="o">&amp;</span><span class="n">cubinSize</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleLoadData</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module</span><span class="p">,</span><span class="n">cubin</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleGetFunction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kernel</span><span class="p">,</span><span class="n">module</span><span class="p">,</span><span class="s">"parent"</span><span class="p">));</span>
<span class="c1">// Generate input for execution, and create output buffers.</span>
<span class="kt">size_t</span><span class="n">n</span><span class="o">=</span><span class="n">numBlocks</span><span class="o">*</span><span class="n">numThreads</span><span class="p">;</span>
<span class="kt">size_t</span><span class="n">bufferSize</span><span class="o">=</span><span class="n">n</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span>
<span class="kt">float</span><span class="o">*</span><span class="n">hOut</span><span class="o">=</span><span class="n">new</span><span class="kt">float</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="n">CUdeviceptr</span><span class="n">dX</span><span class="p">,</span><span class="n">dY</span><span class="p">,</span><span class="n">dOut</span><span class="p">;</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dOut</span><span class="p">,</span><span class="n">bufferSize</span><span class="p">));</span>
<span class="c1">// Execute parent kernel.</span>
<span class="kt">void</span><span class="o">*</span><span class="n">args</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="o">&amp;</span><span class="n">dOut</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">,</span><span class="o">&amp;</span><span class="n">numBlocks</span><span class="p">,</span><span class="o">&amp;</span><span class="n">numThreads</span><span class="p">};</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span>
<span class="n">cuLaunchKernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span>
<span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="c1">// grid dim</span>
<span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="c1">// block dim</span>
<span class="mi">0</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="c1">// shared mem and stream</span>
<span class="n">args</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span><span class="c1">// arguments</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxSynchronize</span><span class="p">());</span>
<span class="c1">// Retrieve and print output.</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemcpyDtoH</span><span class="p">(</span><span class="n">hOut</span><span class="p">,</span><span class="n">dOut</span><span class="p">,</span><span class="n">bufferSize</span><span class="p">));</span>

<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="p">{</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">hOut</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// Release resources.</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemFree</span><span class="p">(</span><span class="n">dOut</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleUnload</span><span class="p">(</span><span class="n">module</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuLinkDestroy</span><span class="p">(</span><span class="n">linkState</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxDestroy</span><span class="p">(</span><span class="n">context</span><span class="p">));</span>
<span class="n">delete</span><span class="p">[]</span><span class="n">hOut</span><span class="p">;</span>
<span class="n">delete</span><span class="p">[]</span><span class="n">ptx</span><span class="p">;</span>
<span class="k">return</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>
 <h2>
  <span class="section-number">
   13.1.
  </span>
  Dynamic Parallelism Build Instructions
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#dynamic-parallelism-build-instructions" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  Assuming the environment variable
  <span class="pre">
   CUDA_PATH
  </span>
  points to CUDA Toolkit installation directory, build this example as:
 </p>
 <ul>
  <li>
   <p>
    With NVRTC shared library:
   </p>
   <ul>
    <li>
     <p>
      Windows:
     </p>
     <pre>cl.exe dynamic-parallelism.cpp /Fedynamic-parallelism ^
   /I "%CUDA_PATH%\include" ^
   "%CUDA_PATH%"\lib\x64\nvrtc.lib "%CUDA_PATH%"\lib\x64\cuda.lib
</pre>
    </li>
    <li>
     <p>
      Linux:
     </p>
     <pre>g++ dynamic-parallelism.cpp -o dynamic-parallelism \
   -I $CUDA_PATH/include \
   -L $CUDA_PATH/lib64 \
   -lnvrtc -lcuda \
   -Wl,-rpath,$CUDA_PATH/lib64
</pre>
    </li>
   </ul>
  </li>
  <li>
   <p>
    With NVRTC static library:
   </p>
   <ul>
    <li>
     <p>
      Windows:
     </p>
     <pre>cl.exe dynamic-parallelism.cpp /Fedynamic-parallelism  ^
   /I "%CUDA_PATH%"\include ^
   "%CUDA_PATH%"\lib\x64\nvrtc_static.lib ^
   "%CUDA_PATH%"\lib\x64\nvrtc-builtins_static.lib ^
   "%CUDA_PATH%"\lib\x64\nvptxcompiler_static.lib ^
  "%CUDA_PATH%"\lib\x64\cuda.lib user32.lib Ws2_32.lib
</pre>
    </li>
    <li>
     <p>
      Linux:
     </p>
     <pre>g++ dynamic-parallelism.cpp -o dynamic-parallelism \
   -I $CUDA_PATH/include \
   -L $CUDA_PATH/lib64 \
   -lnvrtc_static -lnvrtc-builtins_static -lnvptxcompiler_static -lcuda \
   -lpthread
</pre>
    </li>
   </ul>
  </li>
 </ul>
 <h1>
  <span class="section-number">
   14.
  </span>
  Example: Device LTO (link time optimization)
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#example-device-lto-link-time-optimization" title="Permalink to this headline">
   ï
  </a>
 </h1>
 <p>
  This section demonstrates device link time optimization (LTO).
There are two units of LTO IR. The first unit is generated offline using nvcc, by specifying the architecture as
  <span class="pre">
   -arch
  </span>
  <span class="pre">
   lto_XX
  </span>
  (refer to
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#code-offline-cu">
   Code (offline.cu)
  </a>
  ).
The generated LTO IR is packaged in a fatbinary.
 </p>
 <p>
  The second unit is generated online using NVRTC, by specifying the flag
  <span class="pre">
   -dlto
  </span>
  (refer to
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#code-online-cpp">
   Code (online.cpp)
  </a>
  ).
 </p>
 <p>
  These two units are then passed to
  <span class="pre">
   libnvJitLink*
  </span>
  API functions, which link together the LTO IR, run the optimizer on the linked IR and generate a cubin (refer to
  <a class="reference internal" href="https://docs.nvidia.com/cuda/nvrtc/index.html#code-online-cpp">
   Code (online.cpp)
  </a>
  ). The cubin is then loaded on the GPU and executed.
 </p>
 <h2>
  <span class="section-number">
   14.1.
  </span>
  Code (offline.cu)
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#code-offline-cu" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <pre><span class="n">__device__</span><span class="kt">float</span><span class="n">compute</span><span class="p">(</span><span class="kt">float</span><span class="n">a</span><span class="p">,</span><span class="kt">float</span><span class="n">x</span><span class="p">,</span><span class="kt">float</span><span class="n">y</span><span class="p">)</span><span class="p">{</span>
<span class="k">return</span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</pre>
 <h2>
  <span class="section-number">
   14.2.
  </span>
  Code (online.cpp)
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#code-online-cpp" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <pre><span class="cp">#include</span><span class="cpf">&lt;nvrtc.h&gt;</span>
<span class="cp">#include</span><span class="cpf">&lt;cuda.h&gt;</span>
<span class="cp">#include</span><span class="cpf">&lt;nvJitLink.h&gt;</span>
<span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span>

<span class="cp">#define NUM_THREADS 128</span>
<span class="cp">#define NUM_BLOCKS 32</span>

<span class="cp">#define NVRTC_SAFE_CALL(x)                                        \</span>
<span class="cp">do {                                                              \</span>
<span class="cp">   nvrtcResult result = x;                                        \</span>
<span class="cp">   if (result != NVRTC_SUCCESS) {                                 \</span>
<span class="cp">      std::cerr &lt;&lt; "\nerror: " #x " failed with error "           \</span>
<span class="cp">                &lt;&lt; nvrtcGetErrorString(result) &lt;&lt; '\n';           \</span>
<span class="cp">      exit(1);                                                    \</span>
<span class="cp">   }                                                              \</span>
<span class="cp">} while(0)</span>

<span class="cp">#define CUDA_SAFE_CALL(x)                                         \</span>
<span class="cp">do {                                                              \</span>
<span class="cp">   CUresult result = x;                                           \</span>
<span class="cp">   if (result != CUDA_SUCCESS) {                                  \</span>
<span class="cp">      const char *msg;                                            \</span>
<span class="cp">      cuGetErrorName(result, &amp;msg);                               \</span>
<span class="cp">      std::cerr &lt;&lt; "\nerror: " #x " failed with error "           \</span>
<span class="cp">                &lt;&lt; msg &lt;&lt; '\n';                                   \</span>
<span class="cp">      exit(1);                                                    \</span>
<span class="cp">   }                                                              \</span>
<span class="cp">} while(0)</span>

<span class="cp">#define NVJITLINK_SAFE_CALL(h,x)                                  \</span>
<span class="cp">do {                                                              \</span>
<span class="cp">   nvJitLinkResult result = x;                                    \</span>
<span class="cp">   if (result != NVJITLINK_SUCCESS) {                             \</span>
<span class="cp">      std::cerr &lt;&lt; "\nerror: " #x " failed with error "           \</span>
<span class="cp">                &lt;&lt; result &lt;&lt; '\n';                                \</span>
<span class="cp">      size_t lsize;                                               \</span>
<span class="cp">      result = nvJitLinkGetErrorLogSize(h, &amp;lsize);               \</span>
<span class="cp">      if (result == NVJITLINK_SUCCESS &amp;&amp; lsize &gt; 0) {             \</span>
<span class="cp">         char *log = (char*)malloc(lsize);                        \</span>
<span class="cp">         result = nvJitLinkGetErrorLog(h, log);                   \</span>
<span class="cp">         if (result == NVJITLINK_SUCCESS) {                       \</span>
<span class="cp">            std::cerr &lt;&lt; "error: " &lt;&lt; log &lt;&lt; '\n';                \</span>
<span class="cp">            free(log);                                            \</span>
<span class="cp">         }                                                        \</span>
<span class="cp">      }                                                           \</span>
<span class="cp">      exit(1);                                                    \</span>
<span class="cp">   }                                                              \</span>
<span class="cp">} while(0)</span>

<span class="k">const</span><span class="kt">char</span><span class="o">*</span><span class="n">lto_saxpy</span><span class="o">=</span><span class="s">"                                       </span><span class="se">\n</span><span class="s">\</span>
<span class="s">extern __device__ float compute(float a, float x, float y);     </span><span class="se">\n</span><span class="s">\</span>
<span class="se">\n</span><span class="s">\</span>
<span class="s">extern </span><span class="se">\"</span><span class="s">C</span><span class="se">\"</span><span class="s"> __global__                                         </span><span class="se">\n</span><span class="s">\</span>
<span class="s">void saxpy(float a, float *x, float *y, float *out, size_t n)   </span><span class="se">\n</span><span class="s">\</span>
<span class="s">{                                                               </span><span class="se">\n</span><span class="s">\</span>
<span class="s">   size_t tid = blockIdx.x * blockDim.x + threadIdx.x;          </span><span class="se">\n</span><span class="s">\</span>
<span class="s">   if (tid &lt; n) {                                               </span><span class="se">\n</span><span class="s">\</span>
<span class="s">      out[tid] = compute(a, x[tid], y[tid]);                    </span><span class="se">\n</span><span class="s">\</span>
<span class="s">   }                                                            </span><span class="se">\n</span><span class="s">\</span>
<span class="s">} </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

<span class="kt">int</span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="n">argc</span><span class="p">,</span><span class="kt">char</span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="kt">size_t</span><span class="n">numBlocks</span><span class="o">=</span><span class="mi">32</span><span class="p">;</span>
<span class="kt">size_t</span><span class="n">numThreads</span><span class="o">=</span><span class="mi">128</span><span class="p">;</span>
<span class="c1">// Create an instance of nvrtcProgram with the code string.</span>
<span class="n">nvrtcProgram</span><span class="n">prog</span><span class="p">;</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span>
<span class="n">nvrtcCreateProgram</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prog</span><span class="p">,</span><span class="c1">// prog</span>
<span class="n">lto_saxpy</span><span class="p">,</span><span class="c1">// buffer</span>
<span class="s">"lto_saxpy.cu"</span><span class="p">,</span><span class="c1">// name</span>
<span class="mi">0</span><span class="p">,</span><span class="c1">// numHeaders</span>
<span class="nb">NULL</span><span class="p">,</span><span class="c1">// headers</span>
<span class="nb">NULL</span><span class="p">));</span><span class="c1">// includeNames</span>

<span class="c1">// specify that LTO IR should be generated for LTO operation</span>
<span class="k">const</span><span class="kt">char</span><span class="o">*</span><span class="n">opts</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="s">"-dlto"</span><span class="p">,</span>
<span class="s">"--relocatable-device-code=true"</span><span class="p">};</span>
<span class="n">nvrtcResult</span><span class="n">compileResult</span><span class="o">=</span><span class="n">nvrtcCompileProgram</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="c1">// prog</span>
<span class="mi">2</span><span class="p">,</span><span class="c1">// numOptions</span>
<span class="n">opts</span><span class="p">);</span><span class="c1">// options</span>
<span class="c1">// Obtain compilation log from the program.</span>
<span class="kt">size_t</span><span class="n">logSize</span><span class="p">;</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetProgramLogSize</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="o">&amp;</span><span class="n">logSize</span><span class="p">));</span>
<span class="kt">char</span><span class="o">*</span><span class="n">log</span><span class="o">=</span><span class="n">new</span><span class="kt">char</span><span class="p">[</span><span class="n">logSize</span><span class="p">];</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetProgramLog</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="n">log</span><span class="p">));</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">log</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
<span class="n">delete</span><span class="p">[]</span><span class="n">log</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">compileResult</span><span class="o">!=</span><span class="n">NVRTC_SUCCESS</span><span class="p">)</span><span class="p">{</span>
<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// Obtain generated LTO IR from the program.</span>
<span class="kt">size_t</span><span class="n">LTOIRSize</span><span class="p">;</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetLTOIRSize</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="o">&amp;</span><span class="n">LTOIRSize</span><span class="p">));</span>
<span class="kt">char</span><span class="o">*</span><span class="n">LTOIR</span><span class="o">=</span><span class="n">new</span><span class="kt">char</span><span class="p">[</span><span class="n">LTOIRSize</span><span class="p">];</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetLTOIR</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="n">LTOIR</span><span class="p">));</span>
<span class="c1">// Destroy the program.</span>
<span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcDestroyProgram</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prog</span><span class="p">));</span>

<span class="n">CUdevice</span><span class="n">cuDevice</span><span class="p">;</span>
<span class="n">CUcontext</span><span class="n">context</span><span class="p">;</span>
<span class="n">CUmodule</span><span class="n">module</span><span class="p">;</span>
<span class="n">CUfunction</span><span class="n">kernel</span><span class="p">;</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuInit</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuDeviceGet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cuDevice</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">cuDevice</span><span class="p">));</span>

<span class="c1">// Load the generated LTO IR and the LTO IR generated offline</span>
<span class="c1">// and link them together.</span>
<span class="n">nvJitLinkHandle</span><span class="n">handle</span><span class="p">;</span>
<span class="c1">// Dynamically determine the arch to link for</span>
<span class="kt">int</span><span class="n">major</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span><span class="n">minor</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuDeviceGetAttribute</span><span class="p">(</span><span class="o">&amp;</span><span class="n">major</span><span class="p">,</span>
<span class="n">CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR</span><span class="p">,</span><span class="n">cuDevice</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuDeviceGetAttribute</span><span class="p">(</span><span class="o">&amp;</span><span class="n">minor</span><span class="p">,</span>
<span class="n">CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR</span><span class="p">,</span><span class="n">cuDevice</span><span class="p">));</span>
<span class="kt">int</span><span class="n">arch</span><span class="o">=</span><span class="n">major</span><span class="o">*</span><span class="mi">10</span><span class="o">+</span><span class="n">minor</span><span class="p">;</span>
<span class="kt">char</span><span class="n">smbuf</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="n">sprintf</span><span class="p">(</span><span class="n">smbuf</span><span class="p">,</span><span class="s">"-arch=sm_%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">arch</span><span class="p">);</span>
<span class="k">const</span><span class="kt">char</span><span class="o">*</span><span class="n">lopts</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="s">"-dlto"</span><span class="p">,</span><span class="n">smbuf</span><span class="p">};</span>
<span class="n">NVJITLINK_SAFE_CALL</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">nvJitLinkCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">lopts</span><span class="p">));</span>

<span class="c1">// NOTE: assumes "offline.fatbin" is in the current directory</span>
<span class="c1">// The fatbinary contains LTO IR generated offline using nvcc</span>
<span class="n">NVJITLINK_SAFE_CALL</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">nvJitLinkAddFile</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">NVJITLINK_INPUT_FATBIN</span><span class="p">,</span>
<span class="s">"offline.fatbin"</span><span class="p">));</span>
<span class="n">NVJITLINK_SAFE_CALL</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">nvJitLinkAddData</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">NVJITLINK_INPUT_LTOIR</span><span class="p">,</span>
<span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">LTOIR</span><span class="p">,</span><span class="n">LTOIRSize</span><span class="p">,</span><span class="s">"lto_online"</span><span class="p">));</span>

<span class="c1">// The call to nvJitLinkComplete causes linker to link together the two</span>
<span class="c1">// LTO IR modules (offline and online), do optimization on the linked LTO IR,</span>
<span class="c1">// and generate cubin from it.</span>
<span class="n">NVJITLINK_SAFE_CALL</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">nvJitLinkComplete</span><span class="p">(</span><span class="n">handle</span><span class="p">));</span>
<span class="kt">size_t</span><span class="n">cubinSize</span><span class="p">;</span>
<span class="n">NVJITLINK_SAFE_CALL</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">nvJitLinkGetLinkedCubinSize</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="o">&amp;</span><span class="n">cubinSize</span><span class="p">));</span>
<span class="kt">void</span><span class="o">*</span><span class="n">cubin</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="n">cubinSize</span><span class="p">);</span>
<span class="n">NVJITLINK_SAFE_CALL</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">nvJitLinkGetLinkedCubin</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">cubin</span><span class="p">));</span>
<span class="n">NVJITLINK_SAFE_CALL</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">nvJitLinkDestroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">));</span>


<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleLoadData</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module</span><span class="p">,</span><span class="n">cubin</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleGetFunction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kernel</span><span class="p">,</span><span class="n">module</span><span class="p">,</span><span class="s">"saxpy"</span><span class="p">));</span>

<span class="c1">// Generate input for execution, and create output buffers.</span>
<span class="kt">size_t</span><span class="n">n</span><span class="o">=</span><span class="n">NUM_THREADS</span><span class="o">*</span><span class="n">NUM_BLOCKS</span><span class="p">;</span>
<span class="kt">size_t</span><span class="n">bufferSize</span><span class="o">=</span><span class="n">n</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span>
<span class="kt">float</span><span class="n">a</span><span class="o">=</span><span class="mf">5.1f</span><span class="p">;</span>
<span class="kt">float</span><span class="o">*</span><span class="n">hX</span><span class="o">=</span><span class="n">new</span><span class="kt">float</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="o">*</span><span class="n">hY</span><span class="o">=</span><span class="n">new</span><span class="kt">float</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="o">*</span><span class="n">hOut</span><span class="o">=</span><span class="n">new</span><span class="kt">float</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="p">{</span>
<span class="n">hX</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="n">hY</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">CUdeviceptr</span><span class="n">dX</span><span class="p">,</span><span class="n">dY</span><span class="p">,</span><span class="n">dOut</span><span class="p">;</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dX</span><span class="p">,</span><span class="n">bufferSize</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dY</span><span class="p">,</span><span class="n">bufferSize</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dOut</span><span class="p">,</span><span class="n">bufferSize</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemcpyHtoD</span><span class="p">(</span><span class="n">dX</span><span class="p">,</span><span class="n">hX</span><span class="p">,</span><span class="n">bufferSize</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemcpyHtoD</span><span class="p">(</span><span class="n">dY</span><span class="p">,</span><span class="n">hY</span><span class="p">,</span><span class="n">bufferSize</span><span class="p">));</span>
<span class="c1">// Execute SAXPY.</span>
<span class="kt">void</span><span class="o">*</span><span class="n">args</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="o">&amp;</span><span class="n">dX</span><span class="p">,</span><span class="o">&amp;</span><span class="n">dY</span><span class="p">,</span><span class="o">&amp;</span><span class="n">dOut</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">};</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span>
<span class="n">cuLaunchKernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span>
<span class="n">NUM_BLOCKS</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="c1">// grid dim</span>
<span class="n">NUM_THREADS</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="c1">// block dim</span>
<span class="mi">0</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="c1">// shared mem and stream</span>
<span class="n">args</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span><span class="c1">// arguments</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxSynchronize</span><span class="p">());</span>
<span class="c1">// Retrieve and print output.</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemcpyDtoH</span><span class="p">(</span><span class="n">hOut</span><span class="p">,</span><span class="n">dOut</span><span class="p">,</span><span class="n">bufferSize</span><span class="p">));</span>

<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="p">{</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="s">" * "</span><span class="o">&lt;&lt;</span><span class="n">hX</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="s">" + "</span><span class="o">&lt;&lt;</span><span class="n">hY</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="o">&lt;&lt;</span><span class="s">" = "</span><span class="o">&lt;&lt;</span><span class="n">hOut</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// Release resources.</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemFree</span><span class="p">(</span><span class="n">dX</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemFree</span><span class="p">(</span><span class="n">dY</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuMemFree</span><span class="p">(</span><span class="n">dOut</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleUnload</span><span class="p">(</span><span class="n">module</span><span class="p">));</span>
<span class="n">CUDA_SAFE_CALL</span><span class="p">(</span><span class="n">cuCtxDestroy</span><span class="p">(</span><span class="n">context</span><span class="p">));</span>
<span class="n">free</span><span class="p">(</span><span class="n">cubin</span><span class="p">);</span>
<span class="n">delete</span><span class="p">[]</span><span class="n">hX</span><span class="p">;</span>
<span class="n">delete</span><span class="p">[]</span><span class="n">hY</span><span class="p">;</span>
<span class="n">delete</span><span class="p">[]</span><span class="n">hOut</span><span class="p">;</span>
<span class="n">delete</span><span class="p">[]</span><span class="n">LTOIR</span><span class="p">;</span>
<span class="k">return</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>
 <h2>
  <span class="section-number">
   14.3.
  </span>
  Device LTO Build Instructions
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#device-lto-build-instructions" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <p>
  Assuming the environment variable
  <span class="pre">
   CUDA_PATH
  </span>
  points to the CUDA Toolkit installation directory, build this example as:
 </p>
 <ul>
  <li>
   <p>
    Compile offline.cu to fatbinary containing LTO IR (change
    <span class="pre">
     lto_52
    </span>
    to a different lto_XX architecture as appropriate).
   </p>
   <pre>nvcc -arch lto_52 -rdc=true -fatbin offline.cu
</pre>
  </li>
  <li>
   <p>
    With NVRTC shared library:
   </p>
   <ul>
    <li>
     <p>
      Windows:
     </p>
     <pre>cl.exe online.cpp /Feonline ^
   /I "%CUDA_PATH%\include" ^
   "%CUDA_PATH%"\lib\x64\nvrtc.lib ^
   "%CUDA_PATH%"\lib\x64\nvJitLink.lib ^
   "%CUDA_PATH%"\lib\x64\cuda.lib
</pre>
    </li>
    <li>
     <p>
      Linux:
     </p>
     <pre>g++ online.cpp -o online \
   -I $CUDA_PATH/include \
   -L $CUDA_PATH/lib64 \
   -lnvrtc -lnvJitLink -lcuda \
   -Wl,-rpath,$CUDA_PATH/lib64
</pre>
    </li>
   </ul>
  </li>
  <li>
   <p>
    With NVRTC static library:
   </p>
   <ul>
    <li>
     <p>
      Windows:
     </p>
     <pre>cl.exe online.cpp /Feonline  ^
   /I "%CUDA_PATH%"\include ^
   "%CUDA_PATH%"\lib\x64\nvrtc_static.lib ^
   "%CUDA_PATH%"\lib\x64\nvrtc-builtins_static.lib ^
   "%CUDA_PATH%"\lib\x64\nvJitLink_static.lib ^
   "%CUDA_PATH%"\lib\x64\nvptxcompiler_static.lib ^
   "%CUDA_PATH%"\lib\x64\cuda.lib user32.lib Ws2_32.lib
</pre>
    </li>
    <li>
     <p>
      Linux:
     </p>
     <pre>g++ online.cpp -o online \
   -I $CUDA_PATH/include \
   -L $CUDA_PATH/lib64 \
   -lnvrtc_static -lnvrtc-builtins_static -lnvJitLink_static -lnvptxcompiler_static -lcuda \
   -lpthread
</pre>
    </li>
   </ul>
  </li>
 </ul>
 <h2>
  <span class="section-number">
   14.4.
  </span>
  Notices
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#notices" title="Permalink to this headline">
   ï
  </a>
 </h2>
 <h3>
  <span class="section-number">
   14.4.1.
  </span>
  Notice
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#notice" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  This document is provided for information purposes only and shall not be regarded as a warranty of a certain functionality, condition, or quality of a product. NVIDIA Corporation (âNVIDIAâ) makes no representations or warranties, expressed or implied, as to the accuracy or completeness of the information contained in this document and assumes no responsibility for any errors contained herein. NVIDIA shall have no liability for the consequences or use of such information or for any infringement of patents or other rights of third parties that may result from its use. This document is not a commitment to develop, release, or deliver any Material (defined below), code, or functionality.
 </p>
 <p>
  NVIDIA reserves the right to make corrections, modifications, enhancements, improvements, and any other changes to this document, at any time without notice.
 </p>
 <p>
  Customer should obtain the latest relevant information before placing orders and should verify that such information is current and complete.
 </p>
 <p>
  NVIDIA products are sold subject to the NVIDIA standard terms and conditions of sale supplied at the time of order acknowledgement, unless otherwise agreed in an individual sales agreement signed by authorized representatives of NVIDIA and customer (âTerms of Saleâ). NVIDIA hereby expressly objects to applying any customer general terms and conditions with regards to the purchase of the NVIDIA product referenced in this document. No contractual obligations are formed either directly or indirectly by this document.
 </p>
 <p>
  NVIDIA products are not designed, authorized, or warranted to be suitable for use in medical, military, aircraft, space, or life support equipment, nor in applications where failure or malfunction of the NVIDIA product can reasonably be expected to result in personal injury, death, or property or environmental damage. NVIDIA accepts no liability for inclusion and/or use of NVIDIA products in such equipment or applications and therefore such inclusion and/or use is at customerâs own risk.
 </p>
 <p>
  NVIDIA makes no representation or warranty that products based on this document will be suitable for any specified use. Testing of all parameters of each product is not necessarily performed by NVIDIA. It is customerâs sole responsibility to evaluate and determine the applicability of any information contained in this document, ensure the product is suitable and fit for the application planned by customer, and perform the necessary testing for the application in order to avoid a default of the application or the product. Weaknesses in customerâs product designs may affect the quality and reliability of the NVIDIA product and may result in additional or different conditions and/or requirements beyond those contained in this document. NVIDIA accepts no liability related to any default, damage, costs, or problem which may be based on or attributable to: (i) the use of the NVIDIA product in any manner that is contrary to this document or (ii) customer product designs.
 </p>
 <p>
  No license, either expressed or implied, is granted under any NVIDIA patent right, copyright, or other NVIDIA intellectual property right under this document. Information published by NVIDIA regarding third-party products or services does not constitute a license from NVIDIA to use such products or services or a warranty or endorsement thereof. Use of such information may require a license from a third party under the patents or other intellectual property rights of the third party, or a license from NVIDIA under the patents or other intellectual property rights of NVIDIA.
 </p>
 <p>
  Reproduction of information in this document is permissible only if approved in advance by NVIDIA in writing, reproduced without alteration and in full compliance with all applicable export laws and regulations, and accompanied by all associated conditions, limitations, and notices.
 </p>
 <p>
  THIS DOCUMENT AND ALL NVIDIA DESIGN SPECIFICATIONS, REFERENCE BOARDS, FILES, DRAWINGS, DIAGNOSTICS, LISTS, AND OTHER DOCUMENTS (TOGETHER AND SEPARATELY, âMATERIALSâ) ARE BEING PROVIDED âAS IS.â NVIDIA MAKES NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL NVIDIA BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF ANY USE OF THIS DOCUMENT, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. Notwithstanding any damages that customer might incur for any reason whatsoever, NVIDIAâs aggregate and cumulative liability towards customer for the products described herein shall be limited in accordance with the Terms of Sale for the product.
 </p>
 <h3>
  <span class="section-number">
   14.4.2.
  </span>
  OpenCL
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#opencl" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  OpenCL is a trademark of Apple Inc. used under license to the Khronos Group Inc.
 </p>
 <h3>
  <span class="section-number">
   14.4.3.
  </span>
  Trademarks
  <a class="headerlink" href="https://docs.nvidia.com/cuda/nvrtc/index.html#trademarks" title="Permalink to this headline">
   ï
  </a>
 </h3>
 <p>
  NVIDIA and the NVIDIA logo are trademarks or registered trademarks of NVIDIA Corporation in the U.S. and other countries. Other company and product names may be trademarks of the respective companies with which they are associated.
 </p>
 <span class="brackets">
  <a class="fn-backref" href="https://docs.nvidia.com/cuda/nvrtc/index.html#id4">
   1
  </a>
 </span>
 <p>
  Changes to compiler optimizer heuristics in the newer NVRTC shared library may also potentially cause performance perturbations for generated code.
 </p>
 <span class="brackets">
  <a class="fn-backref" href="https://docs.nvidia.com/cuda/nvrtc/index.html#id6">
   2
  </a>
 </span>
 <p>
  These API functions modify the state of the associated
  <span class="pre">
   nvrtcProgram
  </span>
  .
 </p>
 <p class="notices">
  <a href="https://www.nvidia.com/en-us/about-nvidia/privacy-policy/" target="_blank">
   Privacy Policy
  </a>
  |
  <a href="https://www.nvidia.com/en-us/about-nvidia/privacy-center/" target="_blank">
   Manage My Privacy
  </a>
  |
  <a href="https://www.nvidia.com/en-us/preferences/start/" target="_blank">
   Do Not Sell or Share My Data
  </a>
  |
  <a href="https://www.nvidia.com/en-us/about-nvidia/terms-of-service/" target="_blank">
   Terms of Service
  </a>
  |
  <a href="https://www.nvidia.com/en-us/about-nvidia/accessibility/" target="_blank">
   Accessibility
  </a>
  |
  <a href="https://www.nvidia.com/en-us/about-nvidia/company-policies/" target="_blank">
   Corporate Policies
  </a>
  |
  <a href="https://www.nvidia.com/en-us/product-security/" target="_blank">
   Product Security
  </a>
  |
  <a href="https://www.nvidia.com/en-us/contact/" target="_blank">
   Contact
  </a>
 </p>
 <p>
  Copyright Â© 2014-2024, NVIDIA Corporation &amp; affiliates. All rights reserved.
 </p>
 <p>
  <span class="lastupdated">
   Last updated on Jul 1, 2024.
  </span>
 </p>
</body>
</body></html>