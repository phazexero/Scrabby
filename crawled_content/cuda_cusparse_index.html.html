<html><head><title>cuSPARSE</title></head><body><body class="wy-body-for-nav">
 <a href="https://docs.nvidia.com/cuda/cusparse/contents.html">
 </a>
 <ul class="current">
  <li class="toctree-l1 current">
   <a class="current reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html">
    1.
    Introduction
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#library-organization-and-features">
      1.1. Library Organization and Features
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#static-library-support">
      1.2. Static Library Support
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#library-dependencies">
      1.3. Library Dependencies
     </a>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#using-the-cusparse-api">
    2.
    Using the cuSPARSE API
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#apis-usage-notes">
      2.1. APIs Usage Notes
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#deprecated-apis">
      2.2. Deprecated APIs
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#thread-safety">
      2.3. Thread Safety
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#result-reproducibility">
      2.4. Result Reproducibility
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#nan-and-inf-propagation">
      2.5. NaN and Inf Propagation
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#parallelism-with-streams">
      2.6. Parallelism with Streams
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#compatibility-and-versioning">
      2.7. Compatibility and Versioning
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#optimization-notes">
      2.8. Optimization Notes
     </a>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-storage-formats">
    3.
    cuSPARSE Storage Formats
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#index-base">
      3.1. Index Base
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#vector-formats">
      3.2. Vector Formats
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#dense-vector-format">
        3.2.1. Dense Vector Format
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#sparse-vector-format">
        3.2.2. Sparse Vector Format
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#matrix-formats">
      3.3. Matrix Formats
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#dense-matrix-format">
        3.3.1. Dense Matrix Format
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#coordinate-coo">
        3.3.2. Coordinate (COO)
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#compressed-sparse-row-csr">
        3.3.3. Compressed Sparse Row (CSR)
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#compressed-sparse-column-csc">
        3.3.4. Compressed Sparse Column (CSC)
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#sliced-ellpack-sell">
        3.3.5. Sliced Ellpack (SELL)
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#block-sparse-row-bsr">
        3.3.6. Block Sparse Row (BSR)
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#blocked-ellpack-blocked-ell">
        3.3.7. Blocked Ellpack (BLOCKED-ELL)
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#extended-bsr-format-bsrx-deprecated">
        3.3.8. Extended BSR Format (BSRX) [DEPRECATED]
       </a>
      </li>
     </ul>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-basic-apis">
    4.
    cuSPARSE Basic APIs
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-types-reference">
      4.1. cuSPARSE Types Reference
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cudadatatype-t">
        4.1.1. cudaDataType_t
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
        4.1.2. cusparseStatus_t
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsehandle-t">
        4.1.3. cusparseHandle_t
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsepointermode-t">
        4.1.4. cusparsePointerMode_t
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseoperation-t">
        4.1.5. cusparseOperation_t
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsediagtype-t">
        4.1.6. cusparseDiagType_t
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsefillmode-t">
        4.1.7. cusparseFillMode_t
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseindexbase-t">
        4.1.8. cusparseIndexBase_t
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedirection-t">
        4.1.9. cusparseDirection_t
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-management-api">
      4.2. cuSPARSE Management API
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreate">
        4.2.1. cusparseCreate()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedestroy">
        4.2.2. cusparseDestroy()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsegeterrorname">
        4.2.3. cusparseGetErrorName()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsegeterrorstring">
        4.2.4. cusparseGetErrorString()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsegetproperty">
        4.2.5. cusparseGetProperty()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsegetversion">
        4.2.6. cusparseGetVersion()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsegetpointermode">
        4.2.7. cusparseGetPointerMode()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsesetpointermode">
        4.2.8. cusparseSetPointerMode()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsegetstream">
        4.2.9. cusparseGetStream()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsesetstream">
        4.2.10. cusparseSetStream()
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-logging-api">
      4.3. cuSPARSE Logging API
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseloggersetcallback">
        4.3.1. cusparseLoggerSetCallback()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseloggersetfile">
        4.3.2. cusparseLoggerSetFile()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseloggeropenfile">
        4.3.3. cusparseLoggerOpenFile()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseloggersetlevel">
        4.3.4. cusparseLoggerSetLevel()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseloggersetmask">
        4.3.5. cusparseLoggerSetMask()
       </a>
      </li>
     </ul>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-legacy-apis">
    5.
    cuSPARSE Legacy APIs
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#naming-conventions">
      5.1. Naming Conventions
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-legacy-types-reference">
      5.2. cuSPARSE Legacy Types Reference
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseaction-t">
        5.2.1. cusparseAction_t
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsematdescr-t">
        5.2.2. cusparseMatDescr_t
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsematrixtype-t">
        5.2.3. cusparseMatrixType_t
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecolorinfo-t-deprecated">
        5.2.4. cusparseColorInfo_t [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsesolvepolicy-t-deprecated">
        5.2.5. cusparseSolvePolicy_t [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#bsric02info-t-deprecated">
        5.2.6. bsric02Info_t [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#bsrilu02info-t-deprecated">
        5.2.7. bsrilu02Info_t [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#bsrsm2info-t-deprecated">
        5.2.8. bsrsm2Info_t [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#bsrsv2info-t-deprecated">
        5.2.9. bsrsv2Info_t [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#csric02info-t-deprecated">
        5.2.10. csric02Info_t [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#csrilu02info-t-deprecated">
        5.2.11. csrilu02Info_t [DEPRECATED]
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-helper-function-reference">
      5.3. cuSPARSE Helper Function Reference
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatecolorinfo-deprecated">
        5.3.1. cusparseCreateColorInfo() [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatematdescr">
        5.3.2. cusparseCreateMatDescr()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedestroycolorinfo-deprecated">
        5.3.3. cusparseDestroyColorInfo() [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedestroymatdescr">
        5.3.4. cusparseDestroyMatDescr()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsegetmatdiagtype">
        5.3.5. cusparseGetMatDiagType()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsegetmatfillmode">
        5.3.6. cusparseGetMatFillMode()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsegetmatindexbase">
        5.3.7. cusparseGetMatIndexBase()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsegetmattype">
        5.3.8. cusparseGetMatType()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsesetmatdiagtype">
        5.3.9. cusparseSetMatDiagType()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsesetmatfillmode">
        5.3.10. cusparseSetMatFillMode()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsesetmatindexbase">
        5.3.11. cusparseSetMatIndexBase()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsesetmattype">
        5.3.12. cusparseSetMatType()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatecsric02info-deprecated">
        5.3.13. cusparseCreateCsric02Info() [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedestroycsric02info-deprecated">
        5.3.14. cusparseDestroyCsric02Info() [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatecsrilu02info-deprecated">
        5.3.15. cusparseCreateCsrilu02Info() [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedestroycsrilu02info-deprecated">
        5.3.16. cusparseDestroyCsrilu02Info() [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatebsrsv2info-deprecated">
        5.3.17. cusparseCreateBsrsv2Info() [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedestroybsrsv2info-deprecated">
        5.3.18. cusparseDestroyBsrsv2Info() [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatebsrsm2info-deprecated">
        5.3.19. cusparseCreateBsrsm2Info() [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedestroybsrsm2info-deprecated">
        5.3.20. cusparseDestroyBsrsm2Info() [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatebsric02info-deprecated">
        5.3.21. cusparseCreateBsric02Info() [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedestroybsric02info-deprecated">
        5.3.22. cusparseDestroyBsric02Info() [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatebsrilu02info-deprecated">
        5.3.23. cusparseCreateBsrilu02Info() [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedestroybsrilu02info-deprecated">
        5.3.24. cusparseDestroyBsrilu02Info() [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatepruneinfo-deprecated">
        5.3.25. cusparseCreatePruneInfo() [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedestroypruneinfo-deprecated">
        5.3.26. cusparseDestroyPruneInfo() [DEPRECATED]
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-level-2-function-reference">
      5.4. cuSPARSE Level 2 Function Reference
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsrmv">
        5.4.1. cusparse&lt;t&gt;bsrmv()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsrxmv-deprecated">
        5.4.2. cusparse&lt;t&gt;bsrxmv() [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsrsv2-buffersize-deprecated">
        5.4.3. cusparse&lt;t&gt;bsrsv2_bufferSize() [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsrsv2-analysis-deprecated">
        5.4.4. cusparse&lt;t&gt;bsrsv2_analysis() [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsrsv2-solve-deprecated">
        5.4.5. cusparse&lt;t&gt;bsrsv2_solve() [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsexbsrsv2-zeropivot-deprecated">
        5.4.6. cusparseXbsrsv2_zeroPivot() [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-gemvi">
        5.4.7. cusparse&lt;t&gt;gemvi()
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-level-3-function-reference">
      5.5. cuSPARSE Level 3 Function Reference
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsrmm">
        5.5.1. cusparse&lt;t&gt;bsrmm()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsrsm2-buffersize-deprecated">
        5.5.2. cusparse&lt;t&gt;bsrsm2_bufferSize() [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsrsm2-analysis-deprecated">
        5.5.3. cusparse&lt;t&gt;bsrsm2_analysis() [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsrsm2-solve-deprecated">
        5.5.4. cusparse&lt;t&gt;bsrsm2_solve() [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsexbsrsm2-zeropivot-deprecated">
        5.5.5. cusparseXbsrsm2_zeroPivot() [DEPRECATED]
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-extra-function-reference">
      5.6. cuSPARSE Extra Function Reference
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-csrgeam2">
        5.6.1. cusparse&lt;t&gt;csrgeam2()
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-preconditioners-reference">
      5.7. cuSPARSE Preconditioners Reference
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#incomplete-cholesky-factorization-level-0-deprecated">
        5.7.1. Incomplete Cholesky Factorization: level 0 [DEPRECATED]
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-csric02-buffersize-deprecated">
          5.7.1.1. cusparse&lt;t&gt;csric02_bufferSize() [DEPRECATED]
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-csric02-analysis-deprecated">
          5.7.1.2. cusparse&lt;t&gt;csric02_analysis() [DEPRECATED]
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-csric02-deprecated">
          5.7.1.3. cusparse&lt;t&gt;csric02() [DEPRECATED]
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsexcsric02-zeropivot-deprecated">
          5.7.1.4. cusparseXcsric02_zeroPivot()  [DEPRECATED]
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsric02-buffersize-deprecated">
          5.7.1.5. cusparse&lt;t&gt;bsric02_bufferSize()  [DEPRECATED]
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsric02-analysis-deprecated">
          5.7.1.6. cusparse&lt;t&gt;bsric02_analysis()  [DEPRECATED]
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsric02-deprecated">
          5.7.1.7. cusparse&lt;t&gt;bsric02()  [DEPRECATED]
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsexbsric02-zeropivot-deprecated">
          5.7.1.8. cusparseXbsric02_zeroPivot()  [DEPRECATED]
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#incomplete-lu-factorization-level-0-deprecated">
        5.7.2. Incomplete LU Factorization: level 0 [DEPRECATED]
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-csrilu02-numericboost-deprecated">
          5.7.2.1. cusparse&lt;t&gt;csrilu02_numericBoost() [DEPRECATED]
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-csrilu02-buffersize-deprecated">
          5.7.2.2. cusparse&lt;t&gt;csrilu02_bufferSize() [DEPRECATED]
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-csrilu02-analysis-deprecated">
          5.7.2.3. cusparse&lt;t&gt;csrilu02_analysis() [DEPRECATED]
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-csrilu02-deprecated">
          5.7.2.4. cusparse&lt;t&gt;csrilu02() [DEPRECATED]
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsexcsrilu02-zeropivot-deprecated">
          5.7.2.5. cusparseXcsrilu02_zeroPivot() [DEPRECATED]
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsrilu02-numericboost-deprecated">
          5.7.2.6. cusparse&lt;t&gt;bsrilu02_numericBoost() [DEPRECATED]
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsrilu02-buffersize-deprecated">
          5.7.2.7. cusparse&lt;t&gt;bsrilu02_bufferSize() [DEPRECATED]
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsrilu02-analysis-deprecated">
          5.7.2.8. cusparse&lt;t&gt;bsrilu02_analysis() [DEPRECATED]
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsrilu02-deprecated">
          5.7.2.9. cusparse&lt;t&gt;bsrilu02() [DEPRECATED]
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsexbsrilu02-zeropivot-deprecated">
          5.7.2.10. cusparseXbsrilu02_zeroPivot() [DEPRECATED]
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#tridiagonal-solve">
        5.7.3. Tridiagonal Solve
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-gtsv2-buffsizeext">
          5.7.3.1. cusparse&lt;t&gt;gtsv2_buffSizeExt()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-gtsv2">
          5.7.3.2. cusparse&lt;t&gt;gtsv2()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-gtsv2-nopivot-buffersizeext">
          5.7.3.3. cusparse&lt;t&gt;gtsv2_nopivot_bufferSizeExt()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-gtsv2-nopivot">
          5.7.3.4. cusparse&lt;t&gt;gtsv2_nopivot()
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#batched-tridiagonal-solve">
        5.7.4. Batched Tridiagonal Solve
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-gtsv2stridedbatch-buffersizeext">
          5.7.4.1. cusparse&lt;t&gt;gtsv2StridedBatch_bufferSizeExt()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-gtsv2stridedbatch">
          5.7.4.2. cusparse&lt;t&gt;gtsv2StridedBatch()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-gtsvinterleavedbatch">
          5.7.4.3. cusparse&lt;t&gt;gtsvInterleavedBatch()
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#batched-pentadiagonal-solve">
        5.7.5. Batched Pentadiagonal Solve
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-gpsvinterleavedbatch">
          5.7.5.1. cusparse&lt;t&gt;gpsvInterleavedBatch()
         </a>
        </li>
       </ul>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-reorderings-reference">
      5.8. cuSPARSE Reorderings Reference
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-csrcolor-deprecated">
        5.8.1. cusparse&lt;t&gt;csrcolor() [DEPRECATED]
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-format-conversion-reference">
      5.9. cuSPARSE Format Conversion Reference
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsr2csr">
        5.9.1. cusparse&lt;t&gt;bsr2csr()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-gebsr2gebsc">
        5.9.2. cusparse&lt;t&gt;gebsr2gebsc()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-gebsr2gebsr">
        5.9.3. cusparse&lt;t&gt;gebsr2gebsr()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-gebsr2csr">
        5.9.4. cusparse&lt;t&gt;gebsr2csr()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-csr2gebsr">
        5.9.5. cusparse&lt;t&gt;csr2gebsr()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-coo2csr">
        5.9.6. cusparse&lt;t&gt;coo2csr()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-csr2coo">
        5.9.7. cusparse&lt;t&gt;csr2coo()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecsr2cscex2">
        5.9.8. cusparseCsr2cscEx2()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-nnz">
        5.9.9. cusparse&lt;t&gt;nnz()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreateidentitypermutation-deprecated">
        5.9.10. cusparseCreateIdentityPermutation() [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsexcoosort">
        5.9.11. cusparseXcoosort()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsexcsrsort">
        5.9.12. cusparseXcsrsort()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsexcscsort">
        5.9.13. cusparseXcscsort()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsexcsru2csr-deprecated">
        5.9.14. cusparseXcsru2csr() [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsexprunedense2csr-deprecated">
        5.9.15. cusparseXpruneDense2csr() [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsexprunecsr2csr-deprecated">
        5.9.16. cusparseXpruneCsr2csr()  [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsexprunedense2csrpercentage-deprecated">
        5.9.17. cusparseXpruneDense2csrPercentage()  [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsexprunecsr2csrbypercentage-deprecated">
        5.9.18. cusparseXpruneCsr2csrByPercentage() [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-nnz-compress-deprecated">
        5.9.19. cusparse&lt;t&gt;nnz_compress()  [DEPRECATED]
       </a>
      </li>
     </ul>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-generic-apis">
    6.
    cuSPARSE Generic APIs
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#generic-types-reference">
      6.1. Generic Types Reference
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseformat-t">
        6.1.1. cusparseFormat_t
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseorder-t">
        6.1.2. cusparseOrder_t
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseindextype-t">
        6.1.3. cusparseIndexType_t
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#dense-vector-apis">
      6.2. Dense Vector APIs
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatednvec">
        6.2.1. cusparseCreateDnVec()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedestroydnvec">
        6.2.2. cusparseDestroyDnVec()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsednvecget">
        6.2.3. cusparseDnVecGet()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsednvecgetvalues">
        6.2.4. cusparseDnVecGetValues()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsednvecsetvalues">
        6.2.5. cusparseDnVecSetValues()
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#sparse-vector-apis">
      6.3. Sparse Vector APIs
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatespvec">
        6.3.1. cusparseCreateSpVec()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedestroyspvec">
        6.3.2. cusparseDestroySpVec()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespvecget">
        6.3.3. cusparseSpVecGet()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespvecgetindexbase">
        6.3.4. cusparseSpVecGetIndexBase()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespvecgetvalues">
        6.3.5. cusparseSpVecGetValues()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespvecsetvalues">
        6.3.6. cusparseSpVecSetValues()
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#dense-matrix-apis">
      6.4. Dense Matrix APIs
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatednmat">
        6.4.1. cusparseCreateDnMat()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedestroydnmat">
        6.4.2. cusparseDestroyDnMat()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsednmatget">
        6.4.3. cusparseDnMatGet()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsednmatgetvalues">
        6.4.4. cusparseDnMatGetValues()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsednmatsetvalues">
        6.4.5. cusparseDnMatSetValues()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsednmatgetstridedbatch">
        6.4.6. cusparseDnMatGetStridedBatch()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsednmatsetstridedbatch">
        6.4.7. cusparseDnMatSetStridedBatch()
       </a>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#sparse-matrix-apis">
      6.5. Sparse Matrix APIs
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#id1">
        6.5.1. Coordinate (COO)
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatecoo">
          6.5.1.1. cusparseCreateCoo()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecooget">
          6.5.1.2. cusparseCooGet()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecoosetpointers">
          6.5.1.3. cusparseCooSetPointers()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecoosetstridedbatch">
          6.5.1.4. cusparseCooSetStridedBatch()
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#id2">
        6.5.2. Compressed Sparse Row (CSR)
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatecsr">
          6.5.2.1. cusparseCreateCsr()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecsrget">
          6.5.2.2. cusparseCsrGet()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecsrsetpointers">
          6.5.2.3. cusparseCsrSetPointers()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecsrsetstridedbatch">
          6.5.2.4. cusparseCsrSetStridedBatch()
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#id3">
        6.5.3. Compressed Sparse Column (CSC)
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatecsc">
          6.5.3.1. cusparseCreateCsc()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecscget">
          6.5.3.2. cusparseCscGet()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecscsetpointers">
          6.5.3.3. cusparseCscSetPointers()
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#id4">
        6.5.4. Blocked-Ellpack (Blocked-ELL)
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreateblockedell">
          6.5.4.1. cusparseCreateBlockedEll()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseblockedellget">
          6.5.4.2. cusparseBlockedEllGet()
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#id5">
        6.5.5. Sliced-Ellpack (SELL)
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreateslicedell">
          6.5.5.1. cusparseCreateSlicedEll()
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#id6">
        6.5.6. Block Sparse Row (BSR)
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatebsr">
          6.5.6.1. cusparseCreateBsr()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsebsrsetstridedbatch">
          6.5.6.2. cusparseBsrSetStridedBatch()
         </a>
        </li>
       </ul>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#all-sparse-formats">
        6.5.7. All Sparse Formats
       </a>
       <ul>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedestroyspmat">
          6.5.7.1. cusparseDestroySpMat()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespmatgetsize">
          6.5.7.2. cusparseSpMatGetSize()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespmatgetformat">
          6.5.7.3. cusparseSpMatGetFormat()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespmatgetindexbase">
          6.5.7.4. cusparseSpMatGetIndexBase()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespmatgetvalues">
          6.5.7.5. cusparseSpMatGetValues()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespmatsetvalues">
          6.5.7.6. cusparseSpMatSetValues()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespmatgetstridedbatch">
          6.5.7.7. cusparseSpMatGetStridedBatch()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespmatgetattribute">
          6.5.7.8. cusparseSpMatGetAttribute()
         </a>
        </li>
        <li class="toctree-l4">
         <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespmatsetattribute">
          6.5.7.9. cusparseSpMatSetAttribute()
         </a>
        </li>
       </ul>
      </li>
     </ul>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#generic-api-functions">
      6.6. Generic API Functions
     </a>
     <ul>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseaxpby">
        6.6.1. cusparseAxpby()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsegather">
        6.6.2. cusparseGather()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsescatter">
        6.6.3. cusparseScatter()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparserot-deprecated">
        6.6.4. cusparseRot() [DEPRECATED]
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespvv">
        6.6.5. cusparseSpVV()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespmv">
        6.6.6. cusparseSpMV()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespsv">
        6.6.7. cusparseSpSV()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespmm">
        6.6.8. cusparseSpMM()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespmmop">
        6.6.9. cusparseSpMMOp()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespsm">
        6.6.10. cusparseSpSM()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsesddmm">
        6.6.11. cusparseSDDMM()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespgemm">
        6.6.12. cusparseSpGEMM()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespgemmreuse">
        6.6.13. cusparseSpGEMMreuse()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsesparsetodense">
        6.6.14. cusparseSparseToDense()
       </a>
      </li>
      <li class="toctree-l3">
       <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedensetosparse">
        6.6.15. cusparseDenseToSparse()
       </a>
      </li>
     </ul>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-fortran-bindings">
    7.
    cuSPARSE Fortran Bindings
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#fortran-application">
      7.1. Fortran Application
     </a>
    </li>
   </ul>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#acknowledgements">
    8. Acknowledgements
   </a>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#bibliography">
    9. Bibliography
   </a>
  </li>
  <li class="toctree-l1">
   <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#notices">
    10. Notices
   </a>
   <ul>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#notice">
      10.1. Notice
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#opencl">
      10.2. OpenCL
     </a>
    </li>
    <li class="toctree-l2">
     <a class="reference internal" href="https://docs.nvidia.com/cuda/cusparse/index.html#trademarks">
      10.3. Trademarks
     </a>
    </li>
   </ul>
  </li>
 </ul>
 <a href="https://docs.nvidia.com/cuda/cusparse/contents.html">
  cuSPARSE
 </a>
 <ul class="wy-breadcrumbs">
  <li>
   <a class="icon icon-home" href="https://docs.nvidia.com/cuda/index.html">
   </a>
   
  </li>
  <li>
   <span class="section-number">
    1.
   </span>
   Introduction
  </li>
  <li class="wy-breadcrumbs-aside">
   <span>
    v12.5 |
   </span>
   <a class="reference external" href="https://docs.nvidia.com/cuda/pdf/CUSPARSE_Library.pdf">
    PDF
   </a>
   <span>
    |
   </span>
   <a class="reference external" href="https://developer.nvidia.com/cuda-toolkit-archive">
    Archive
   </a>
   <span>
    
   </span>
  </li>
 </ul>
 <p class="rubric-h1 rubric">
  cuSPARSE
 </p>
 <p>
  The API reference guide for cuSPARSE, the CUDA sparse matrix library.
 </p>
 <h1>
  <span class="section-number">
   1.
  </span>
  Introduction
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#introduction" title="Permalink to this headline">
   
  </a>
 </h1>
 The cuSPARSE library contains a set of GPU-accelerated basic linear algebra subroutines used for handling sparse matrices that perform significantly faster than CPU-only alternatives. Depending on the specific operation, the library targets matrices with sparsity ratios in the range between 70%-99.9%.
 It is implemented on top of the NVIDIA CUDA runtime (which is part of the CUDA Toolkit) and is designed to be called from C and C++.
 see also
 <a class="reference external" href="https://docs.nvidia.com/cuda/cusparselt/index.html">
  cuSPARSELt: A High-Performance CUDA Library for Sparse Matrix-Matrix Multiplication
 </a>
 <p>
  cuSPARSE Release Notes
  :
  <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html#cusparse-library">
   cuda-toolkit-release-notes
  </a>
 </p>
 <p>
  cuSPARSE GitHub Samples
  :
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSPARSE">
   CUDALibrarySamples
  </a>
 </p>
 <p>
  Nvidia Developer Forum
  :
  <a class="reference external" href="https://forums.developer.nvidia.com/c/accelerated-computing/gpu-accelerated-libraries/12">
   GPU-Accelerated Libraries
  </a>
 </p>
 <p>
  Provide Feedback
  :
  <a class="reference external" href="mailto:Math-Libs-Feedback%40nvidia.com?subject=cuSPARSE-Feedback">
   Math-Libs-Feedback
   <span>
    @
   </span>
   nvidia
   <span>
    .
   </span>
   com
  </a>
 </p>
 <p>
  Recent cuSPARSE/cuSPARSELt Blog Posts and GTC presentations
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    <a class="reference external" href="https://developer.nvidia.com/blog/exploiting-ampere-structured-sparsity-with-cusparselt/">
     Exploiting NVIDIA Ampere Structured Sparsity with cuSPARSELt
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference external" href="https://developer.nvidia.com/blog/accelerating-matrix-multiplication-with-block-sparse-format-and-nvidia-tensor-cores/">
     Accelerating Matrix Multiplication with Block Sparse Format and NVIDIA Tensor Cores
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference external" href="https://www.nvidia.com/en-us/on-demand/session/gtcfall21-a31155/?playlistId=playList-ead11304-9931-4e91-9d5a-fb0e1ef27014">
     Just-In-Time Link-Time Optimization Adoption in cuSPARSE/cuFFT: Use Case Overview
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference external" href="https://developer.nvidia.com/blog/structured-sparsity-in-the-nvidia-ampere-architecture-and-applications-in-search-engines/">
     Structured Sparsity in the NVIDIA Ampere Architecture and Applications in Search Engines
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference external" href="https://www.nvidia.com/en-us/on-demand/session/gtcspring21-s31552/">
     Making the Most of Structured Sparsity in the NVIDIA Ampere Architecture
    </a>
   </p>
  </li>
 </ul>
 <p>
  The library routines provide the following functionalities:
 </p>
 <ul class="simple">
  <li>
   <p>
    Operations between a
    sparse vector
    and a
    dense vector
    : sum, dot product, scatter, gather
   </p>
  </li>
  <li>
   <p>
    Operations between a
    dense matrix
    and a
    sparse vector
    : multiplication
   </p>
  </li>
  <li>
   <p>
    Operations between a
    sparse matrix
    and a
    dense vector
    : multiplication, triangular solver, tridiagonal solver, pentadiagonal solver
   </p>
  </li>
  <li>
   <p>
    Operations between a
    sparse matrix
    and a
    dense matrix
    : multiplication, triangular solver, tridiagonal solver, pentadiagonal solver
   </p>
  </li>
  <li>
   <p>
    Operations between a
    sparse matrix
    and a
    sparse matrix
    : sum, multiplication
   </p>
  </li>
  <li>
   <p>
    Operations between
    dense matrices
    with output a
    sparse matrix
    : multiplication
   </p>
  </li>
  <li>
   <p>
    Sparse matrix preconditioners
    : Incomplete Cholesky Factorization (level 0),  Incomplete LU Factorization (level 0)
   </p>
  </li>
  <li>
   <p>
    Reordering and Conversion operations between different
    sparse matrix storage formats
   </p>
  </li>
 </ul>
 <h2>
  <span class="section-number">
   1.1.
  </span>
  Library Organization and Features
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#library-organization-and-features" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  The cuSPARSE library is organized in two set of APIs:
 </p>
 <ul>
  <li>
   <p>
    The
    Legacy APIs
    , inspired by the Sparse BLAS standard, provide a limited set of functionalities and
    will not be improved in future releases
    , even if standard maintenance is still ensured. Some routines in this category could be deprecated and removed in the short-term. A replacement will be provided for the most important of them during the deprecation process.
   </p>
  </li>
  <li>
   <p>
    The
    Generic APIs
    provide the
    standard interface layer of cuSPARSE
    . They allow computing the most common sparse linear algebra operations, such as sparse matrix-vector (SpMV) and sparse matrix-matrix multiplication (SpMM), in a flexible way. The new APIs have the following capabilities and features:
   </p>
   <ul class="simple">
    <li>
     <p>
      Set matrix data
      layouts
      , number of
      batches
      , and
      storage formats
      (for example, CSR, COO, and so on).
     </p>
    </li>
    <li>
     <p>
      Set input/output/compute data types. This also allows
      mixed data-type computation
      .
     </p>
    </li>
    <li>
     <p>
      Set types of sparse vector/matrix
      indices
      (e.g. 32-bit, 64-bit).
     </p>
    </li>
    <li>
     <p>
      Choose the
      algorithm
      for the computation.
     </p>
    </li>
    <li>
     <p>
      Guarantee external device memory for internal operations.
     </p>
    </li>
    <li>
     <p>
      Provide extensive
      consistency checks
      across input matrices and vectors. This includes the validation of sizes, data types, layout, allowed operations, etc.
     </p>
    </li>
    <li>
     <p>
      Provide constant descriptors for vector and matrix inputs to support const-safe interface and guarantee that the APIs do not modify their inputs.
     </p>
    </li>
   </ul>
  </li>
 </ul>
 <h2>
  <span class="section-number">
   1.2.
  </span>
  Static Library Support
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#static-library-support" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  Starting with CUDA 6.5, the cuSPARSE library is also delivered in a
  static
  form as
  <span class="pre">
   libcusparse_static.a
  </span>
  on Linux.
 </p>
 <p>
  For example, to compile a small application using cuSPARSE against the
  dynamic library
  , the following command can be used:
 </p>
 <pre><span class="n">nvcc</span><span class="n">my_cusparse_app</span><span class="p">.</span><span class="n">cu</span><span class="o">-</span><span class="n">lcusparse</span><span class="o">-</span><span class="n">o</span><span class="n">my_cusparse_app</span>
</pre>
 <p>
  Whereas to compile against the
  static library
  , the following command has to be used:
 </p>
 <pre><span class="n">nvcc</span><span class="n">my_cusparse_app</span><span class="p">.</span><span class="n">cu</span><span class="o">-</span><span class="n">lcusparse_static</span><span class="o">-</span><span class="n">o</span><span class="n">my_cusparse_app</span>
</pre>
 <p>
  It is also possible to use the native Host C++ compiler. Depending on the Host Operating system, some additional libraries like
  <span class="pre">
   pthread
  </span>
  or
  <span class="pre">
   dl
  </span>
  might be needed on the linking line. The following command on Linux is suggested:
 </p>
 <pre><span class="n">gcc</span><span class="n">my_cusparse_app</span><span class="p">.</span><span class="n">c</span><span class="o">-</span><span class="n">lcusparse_static</span><span class="o">-</span><span class="n">lcudart_static</span><span class="o">-</span><span class="n">lpthread</span><span class="o">-</span><span class="n">ldl</span><span class="o">-</span><span class="n">I</span><span class="o">&lt;</span><span class="n">cuda</span><span class="o">-</span><span class="n">toolkit</span><span class="o">-</span><span class="n">path</span><span class="o">&gt;/</span><span class="n">include</span><span class="o">-</span><span class="n">L</span><span class="o">&lt;</span><span class="n">cuda</span><span class="o">-</span><span class="n">toolkit</span><span class="o">-</span><span class="n">path</span><span class="o">&gt;/</span><span class="n">lib64</span><span class="o">-</span><span class="n">o</span><span class="n">my_cusparse_app</span>
</pre>
 <p>
  Note that in the latter case, the library
  <span class="pre">
   cuda
  </span>
  is not needed. The CUDA Runtime will try to open explicitly the
  <span class="pre">
   cuda
  </span>
  library if needed. In the case of a system which does not have the CUDA driver installed, this allows the application to gracefully manage this issue and potentially run if a CPU-only path is available.
 </p>
 <h2>
  <span class="section-number">
   1.3.
  </span>
  Library Dependencies
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#library-dependencies" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  Starting with CUDA 12.0, cuSPARSE will depend on
  nvJitLink
  library for JIT (Just-In-Time) LTO (Link-Time-Optimization) capabilities; refer to the
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespmmop">
   cusparseSpMMOp
  </a>
  APIs for more information.
 </p>
 <p>
  If the user links to the
  dynamic library
  , the environment variables for loading the libraries at run-time (such as
  <span class="pre">
   LD_LIBRARY_PATH
  </span>
  on Linux and
  <span class="pre">
   PATH
  </span>
  on Windows) must include the path where
  <span class="pre">
   libnvjitlink.so
  </span>
  is located. If it is in the same directory as cuSPARSE, the user doesnt need to take any action.
 </p>
 <p>
  If linking to the
  static library
  , the user needs to link with
  <span class="pre">
   -lnvjitlink
  </span>
  and set the environment variables for loading the libraries at compile-time
  <span class="pre">
   LIBRARY_PATH/PATH
  </span>
  accordingly.
 </p>
 <h1>
  <span class="section-number">
   2.
  </span>
  Using the cuSPARSE API
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#using-the-cusparse-api" title="Permalink to this headline">
   
  </a>
 </h1>
 <p>
  This chapter describes how to use the cuSPARSE library API. It is not a reference for the cuSPARSE API data types and functions; that is provided in subsequent chapters.
 </p>
 <h2>
  <span class="section-number">
   2.1.
  </span>
  APIs Usage Notes
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#apis-usage-notes" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  The cuSPARSE library allows developers to access the computational resources of the NVIDIA graphics processing unit (GPU).
 </p>
 <ul class="simple">
  <li>
   <p>
    The cuSPARSE APIs assume that input and output data (vectors and matrices) reside in GPU (device) memory
    .
   </p>
  </li>
  <li>
   <p>
    The input and output
    scalars
    (e.g.
    <span class="math notranslate nohighlight">
     \(\alpha\)
    </span>
    and
    <span class="math notranslate nohighlight">
     \(\beta\)
    </span>
    ) can be passed by reference on the host or the device, instead of only being allowed to be passed by value on the host. This allows library functions to execute asynchronously using streams even when they are generated by a previous kernel resulting in maximum parallelism.
   </p>
  </li>
  <li>
   <p>
    The handle to the
    cuSPARSE library context
    is initialized using the function and is explicitly passed to every subsequent library function call. This allows the user to have more control over the library setup when using multiple host threads and multiple GPUs.
   </p>
  </li>
  <li>
   <p>
    The error status
    <span class="pre">
     cusparseStatus_t
    </span>
    is returned by all cuSPARSE library function calls.
   </p>
  </li>
 </ul>
 <p>
  It is the responsibility of the developer to allocate memory and to copy data between GPU memory and CPU memory using standard CUDA runtime API routines, such as
  <span class="pre">
   cudaMalloc()
  </span>
  ,
  <span class="pre">
   cudaFree()
  </span>
  ,
  <span class="pre">
   cudaMemcpy()
  </span>
  , and
  <span class="pre">
   cudaMemcpyAsync()
  </span>
  .
 </p>
 <p>
  The cuSPARSE library functions are executed
  asynchronously
  with respect to the host and may return control to the application on the host before the result is ready. Developers can use the
  <span class="pre">
   cudaDeviceSynchronize()
  </span>
  function to ensure that the execution of a particular cuSPARSE library routine has completed.
 </p>
 <p>
  A developer can also use the
  <span class="pre">
   cudaMemcpy()
  </span>
  routine to copy data from the device to the host and vice versa, using the
  <span class="pre">
   cudaMemcpyDeviceToHost
  </span>
  and
  <span class="pre">
   cudaMemcpyHostToDevice
  </span>
  parameters, respectively. In this case there is no need to add a call to
  <span class="pre">
   cudaDeviceSynchronize()
  </span>
  because the call to
  <span class="pre">
   cudaMemcpy()
  </span>
  with the above parameters is blocking and completes only when the results are ready on the host.
 </p>
 <h2>
  <span class="section-number">
   2.2.
  </span>
  Deprecated APIs
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#deprecated-apis" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  The cuSPARSE library documentation explicitly indicates the set of APIs/enumerators/data structures that are deprecated. The library policy for deprecated APIs is the following:
 </p>
 <ol class="arabic">
  <li>
   <p>
    An API is marked
    <span class="pre">
     [[DEPRECATED]]
    </span>
    on a release X.Y (e.g. 11.2)
   </p>
   <ul class="simple">
    <li>
     <p>
      The documentation indices a replacement if available
     </p>
    </li>
    <li>
     <p>
      Otherwise, the functionality will not be maintained in the future
     </p>
    </li>
   </ul>
  </li>
  <li>
   <p>
    The API will be removed in the release X+1.0 (e.g. 12.0)
   </p>
  </li>
 </ol>
 <p>
  Correctness bugs are still addressed even for deprecated APIs, while performance issues are not always ensured.
 </p>
 <p>
  In addition to the documentation, deprecated APIs generate a
  compile-time
  warning for most platforms when used. Deprecation warnings can be disabled by defining the macro
  <span class="pre">
   DISABLE_CUSPARSE_DEPRECATED
  </span>
  before including
  <span class="pre">
   cusparse.h
  </span>
  or by passing the flag
  <span class="pre">
   -DDISABLE_CUSPARSE_DEPRECATED
  </span>
  to the compiler.
 </p>
 <h2>
  <span class="section-number">
   2.3.
  </span>
  Thread Safety
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#thread-safety" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  The library is thread safe and its functions can be called from multiple host threads, even with the same handle. When multiple threads share the same handle, extreme care needs to be taken when the handle configuration is changed because that change will affect potentially subsequent cuSPARSE calls in all threads. It is even more true for the destruction of the handle. So it is not recommended that multiple thread share the same cuSPARSE handle.
 </p>
 <h2>
  <span class="section-number">
   2.4.
  </span>
  Result Reproducibility
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#result-reproducibility" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  The design of cuSPARSE prioritizes performance over bit-wise reproducibility.
 </p>
 <p>
  Operations using transpose or conjugate-transpose
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseoperation-t">
   cusparseOperation_t
  </a>
  have no reproducibility guarantees.
 </p>
 <p>
  For the remaining operations,
performing the same API call twice with the exact same arguments,
on the same machine, with the same executable will produce bit-wise identical results.
This bit-wise reproducibility can be disrupted by changes to:
hardware, CUDA drivers, cuSPARSE version, memory alignment of the data, or algorithm selection.
 </p>
 <h2>
  <span class="section-number">
   2.5.
  </span>
  NaN and Inf Propagation
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#nan-and-inf-propagation" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  Floating-point numbers have special values for NaN (not-a-number) and Inf (infinity).
Functions in cuSPARSE make no guarantees about the propagation of NaN and Inf.
 </p>
 <p>
  The cuSPARSE algorithms evaluate assuming all finite floating-point values.
NaN and Inf appear in the output only if the algorithms happen to generate or propagate them.
Because the algorithms are subject to change based on toolkit version and runtime considerations,
so too are the propagation behaviours of NaN and Inf.
 </p>
 <p>
  NaN propagation is different in cuSPARSE than in
typical dense numerical linear algebra, such as cuBLAS.
The dot product between vectors
  <span class="pre">
   [0,
  </span>
  <span class="pre">
   1,
  </span>
  <span class="pre">
   0]
  </span>
  and
  <span class="pre">
   [1,
  </span>
  <span class="pre">
   1,
  </span>
  <span class="pre">
   NaN]
  </span>
  is NaN when using typical dense numerical algorithms,
but will be 1.0 with typical sparse numerical algorithms.
 </p>
 <h2>
  <span class="section-number">
   2.6.
  </span>
  Parallelism with Streams
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#parallelism-with-streams" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  If the application performs several small independent computations, or if it makes data transfers in parallel with the computation, CUDA streams can be used to overlap these tasks.
 </p>
 <p>
  The application can conceptually associate a stream with each task. To achieve the overlap of computation between the tasks, the developer should create CUDA streams using the function
  <span class="pre">
   cudaStreamCreate()
  </span>
  and set the stream to be used by each individual cuSPARSE library routine by calling
  <span class="pre">
   cusparseSetStream()
  </span>
  just before calling the actual cuSPARSE routine. Then, computations performed in separate streams would be overlapped automatically on the GPU, when possible. This approach is especially useful when the computation performed by a single task is relatively small and is not enough to fill the GPU with work, or when there is a data transfer that can be performed in parallel with the computation.
 </p>
 <p>
  When streams are used, we recommend using the new cuSPARSE API with scalar parameters and results passed by reference in the device memory to achieve maximum computational overlap.
 </p>
 <p>
  Although a developer can create many streams, in practice it is not possible to have more than 16 concurrent kernels executing at the same time.
 </p>
 <h2>
  <span class="section-number">
   2.7.
  </span>
  Compatibility and Versioning
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#compatibility-and-versioning" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  The cuSPARSE APIs are intended to be backward compatible at the source level with future releases (unless stated otherwise in the release notes of a specific future release). In other words, if a program uses cuSPARSE, it should continue to compile and work correctly with newer versions of cuSPARSE without source code changes. cuSPARSE is not guaranteed to be backward compatible at the binary level. Using different versions of the
  <span class="pre">
   cusparse.h
  </span>
  header file and shared library is not supported. Using different versions of cuSPARSE and the CUDA runtime is not supported.
 </p>
 <p>
  The library uses the standard
  version semantic
  convention for identify different releases.
 </p>
 <p>
  The
  version
  takes the form of four fields joined by periods:
  <span class="pre">
   MAJOR.MINOR.PATCH.BUILD
  </span>
 </p>
 <p>
  These
  version fields
  are incremented based on the following rules:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     MAJOR
    </span>
    : API breaking changes or new CUDA major version (breaking changes at lower level, e.g. drivers, compilers, libraries)
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     MINOR
    </span>
    : new APIs and functionalities
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     PATCH
    </span>
    : Bug fixes or performance improvements (or
    *
    new CUDA release)
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     BUILD
    </span>
    : Internal build number
   </p>
  </li>
 </ul>
 <p>
  *
  Different CUDA toolkit releases ensure distinct library versions even if there are no changes at library level.
 </p>
 <h2>
  <span class="section-number">
   2.8.
  </span>
  Optimization Notes
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#optimization-notes" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  Most of the cuSPARSE routines can be optimized by exploiting
  CUDA Graphs capture
  and
  Hardware Memory Compression
  features.
 </p>
 <p>
  More in details, a single cuSPARSE call or a sequence of calls can be captured by a
  <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#cuda-graphs">
   CUDA Graph
  </a>
  and executed in a second moment. This minimizes kernels launch overhead and allows the CUDA runtime to optimize the whole workflow. A full example of CUDA graphs capture applied to a cuSPARSE routine can be found in
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSPARSE/graph_capture">
   cuSPARSE Library Samples - CUDA Graph
  </a>
  .
 </p>
 <p>
  Secondly, the data types and functionalities involved in cuSPARSE are suitable for
  Hardware Memory Compression
  available in Ampere GPU devices (compute capability 8.0) or above. The feature allows memory compression for data with enough zero bytes without no loss of information. The device memory must be allocation with the
  <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__VA.html">
   CUDA driver APIs
  </a>
  . A full example of Hardware Memory Compression applied to a cuSPARSE routine can be found in
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSPARSE/compression">
   cuSPARSE Library Samples - Memory Compression
  </a>
  .
 </p>
 <h1>
  <span class="section-number">
   3.
  </span>
  cuSPARSE Storage Formats
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-storage-formats" title="Permalink to this headline">
   
  </a>
 </h1>
 <p>
  The cuSPARSE library supports dense and sparse vector, and dense and sparse matrix formats.
 </p>
 <h2>
  <span class="section-number">
   3.1.
  </span>
  Index Base
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#index-base" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  The library supports zero- and one-based indexing to ensure the compatibility with C/C++ and Fortran languages respectively. The index base is selected through the
  <span class="pre">
   cusparseIndexBase_t
  </span>
  type.
 </p>
 <h2>
  <span class="section-number">
   3.2.
  </span>
  Vector Formats
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#vector-formats" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  This section describes dense and sparse vector formats.
 </p>
 <h3>
  <span class="section-number">
   3.2.1.
  </span>
  Dense Vector Format
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#dense-vector-format" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  Dense vectors are represented with a single data array that is stored linearly in memory, such as the following
  <span class="math notranslate nohighlight">
   \(7 \times 1\)
  </span>
  dense vector.
 </p>
 <a class="image reference internal image-reference" href="https://docs.nvidia.com/cuda/cusparse/_images/dense_vector.png">
 </a>
 <p>
  <span class="caption-text">
   Dense vector representation
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#id7" title="Permalink to this image">
   
  </a>
 </p>
 <h3>
  <span class="section-number">
   3.2.2.
  </span>
  Sparse Vector Format
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#sparse-vector-format" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  Sparse vectors are represented with two arrays.
 </p>
 <ul class="simple">
  <li>
   <p>
    The
    values
    array stores the nonzero values from the equivalent array in dense format.
   </p>
  </li>
  <li>
   <p>
    The
    indices
    array represent the positions of the corresponding nonzero values in the equivalent array in dense format.
   </p>
  </li>
 </ul>
 <p>
  For example, the dense vector in section 3.2.1 can be stored as a sparse vector with zero-based or one-based indexing.
 </p>
 <a class="image reference internal image-reference" href="https://docs.nvidia.com/cuda/cusparse/_images/sparse_vector.png">
 </a>
 <p>
  <span class="caption-text">
   Sparse vector representation
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#id8" title="Permalink to this image">
   
  </a>
 </p>
 <p class="admonition-title">
  Note
 </p>
 <p>
  The cuSPARSE routines assume that the indices are provided in increasing order and that each index appears only once. In the opposite case, the correctness of the computation is not always ensured.
 </p>
 <h2>
  <span class="section-number">
   3.3.
  </span>
  Matrix Formats
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#matrix-formats" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  Dense and several sparse formats for matrices are discussed in this section.
 </p>
 <h3>
  <span class="section-number">
   3.3.1.
  </span>
  Dense Matrix Format
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#dense-matrix-format" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  A dense matrix can be stored in both
  row-major
  and
  column-major
  memory layout (ordering) and it is represented by the following parameters.
 </p>
 <ul>
  <li>
   <p>
    The
    number of rows
    in the matrix.
   </p>
  </li>
  <li>
   <p>
    The
    number of columns
    in the matrix.
   </p>
  </li>
  <li>
   <p>
    The
    leading dimension
    , which must be
   </p>
   <ul class="simple">
    <li>
     <p>
      Greater than or equal to the
      number of columns
      in the
      row-major
      layout
     </p>
    </li>
    <li>
     <p>
      Greater than or equal to the
      number of rows
      in the
      column-major
      layout
     </p>
    </li>
   </ul>
  </li>
  <li>
   <p>
    The pointers to the
    values
    array of length
   </p>
   <ul class="simple">
    <li>
     <p>
      <span class="math notranslate nohighlight">
       \(rows \times leading\; dimension\)
      </span>
      in the
      row-major
      layout
     </p>
    </li>
    <li>
     <p>
      <span class="math notranslate nohighlight">
       \(columns \times leading\; dimension\)
      </span>
      in the
      column-major
      layout
     </p>
    </li>
   </ul>
  </li>
 </ul>
 <p>
  The following figure represents a
  <span class="math notranslate nohighlight">
   \(5 \times 2\)
  </span>
  dense matrix with both memory layouts
 </p>
 <a class="image reference internal image-reference" href="https://docs.nvidia.com/cuda/cusparse/_images/dense_matrix.png">
 </a>
 <p>
  <span class="caption-text">
   Dense matrix representations
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#id9" title="Permalink to this image">
   
  </a>
 </p>
 <p>
  The indices within the matrix represents the contiguous locations in memory.
 </p>
 <p>
  The leading dimension is useful to represent a sub-matrix within the original one
 </p>
 <a class="image reference internal image-reference" href="https://docs.nvidia.com/cuda/cusparse/_images/sub_matrix.png">
 </a>
 <p>
  <span class="caption-text">
   Sub-matrix representations
  </span>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#id10" title="Permalink to this image">
   
  </a>
 </p>
 <h3>
  <span class="section-number">
   3.3.2.
  </span>
  Coordinate (COO)
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#coordinate-coo" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  A sparse matrix stored in
  COO
  format is represented by the following parameters.
 </p>
 <ul class="simple">
  <li>
   <p>
    The
    number of rows
    in the matrix.
   </p>
  </li>
  <li>
   <p>
    The
    number of columns
    in the matrix.
   </p>
  </li>
  <li>
   <p>
    The
    number of non-zero elements
    (
    <span class="pre">
     nnz
    </span>
    ) in the matrix.
   </p>
  </li>
  <li>
   <p>
    The pointers to the
    row indices
    array of length
    <span class="pre">
     nnz
    </span>
    that contains the row indices of the corresponding elements in the
    values array
    .
   </p>
  </li>
  <li>
   <p>
    The pointers to the
    column indices
    array of length
    <span class="pre">
     nnz
    </span>
    that contains the column indices of the corresponding elements in the
    values array
    .
   </p>
  </li>
  <li>
   <p>
    The pointers to the
    values
    array of length
    <span class="pre">
     nnz
    </span>
    that holds all nonzero values of the matrix in row-major ordering.
   </p>
  </li>
  <li>
   <p>
    Each entry of the COO representation consists of a
    <span class="pre">
     &lt;row,
    </span>
    <span class="pre">
     column&gt;
    </span>
    pair.
   </p>
  </li>
  <li>
   <p>
    The COO format is assumed to be sorted
    by row
    .
   </p>
  </li>
 </ul>
 <p>
  The following example shows a
  <span class="math notranslate nohighlight">
   \(5 \times 4\)
  </span>
  matrix represented in COO format.
 </p>
 <a class="image reference internal image-reference" href="https://docs.nvidia.com/cuda/cusparse/_images/coo.png">
 </a>
 <a class="image reference internal image-reference" href="https://docs.nvidia.com/cuda/cusparse/_images/coo_one_base.png">
 </a>
 <p class="admonition-title">
  Note
 </p>
 <p>
  cuSPARSE supports both
  sorted
  and
  unsorted
  column indices within a given row.
 </p>
 <p class="admonition-title">
  Note
 </p>
 <p>
  If the column indices within a given row are not unique, the correctness of the computation is not always ensured.
 </p>
 <p>
  Given an entry in the COO format (zero-base), the corresponding position in the dense matrix is computed as:
 </p>
 <pre><span class="c1">// row-major</span>
<span class="n">rows_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">leading_dimension</span><span class="o">+</span><span class="n">column_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="c1">// column-major</span>
<span class="n">column_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">leading_dimension</span><span class="o">+</span><span class="n">rows_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre>
 <h3>
  <span class="section-number">
   3.3.3.
  </span>
  Compressed Sparse Row (CSR)
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#compressed-sparse-row-csr" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  The
  CSR
  format is similar to COO, where the
  row indices
  are compressed and replaced by an array of
  offsets
  .
 </p>
 <p>
  A sparse matrix stored in CSR format is represented by the following parameters.
 </p>
 <ul class="simple">
  <li>
   <p>
    The
    number of rows
    in the matrix.
   </p>
  </li>
  <li>
   <p>
    The
    number of columns
    in the matrix.
   </p>
  </li>
  <li>
   <p>
    The
    number of non-zero elements
    (
    <span class="pre">
     nnz
    </span>
    ) in the matrix.
   </p>
  </li>
  <li>
   <p>
    The pointers to the
    row offsets
    array of length
    number of rows + 1
    that represents the starting position of each row in the
    columns and values arrays
    .
   </p>
  </li>
  <li>
   <p>
    The pointers to the
    column indices
    array of length
    <span class="pre">
     nnz
    </span>
    that contains the column indices of the corresponding elements in the
    values array
    .
   </p>
  </li>
  <li>
   <p>
    The pointers to the
    values
    array of length
    <span class="pre">
     nnz
    </span>
    that holds all nonzero values of the matrix in row-major ordering.
   </p>
  </li>
 </ul>
 <p>
  The following example shows a
  <span class="math notranslate nohighlight">
   \(5 \times 4\)
  </span>
  matrix represented in CSR format.
 </p>
 <a class="image reference internal image-reference" href="https://docs.nvidia.com/cuda/cusparse/_images/csr.png">
 </a>
 <a class="image reference internal image-reference" href="https://docs.nvidia.com/cuda/cusparse/_images/csr_one_base.png">
 </a>
 <p class="admonition-title">
  Note
 </p>
 <p>
  cuSPARSE supports both
  sorted
  and
  unsorted
  column indices within a given row.
 </p>
 <p class="admonition-title">
  Note
 </p>
 <p>
  If the
  column indices
  within a given
  row
  are not unique, the correctness of the computation is not always ensured.
 </p>
 <p>
  Given an entry in the CSR format (zero-base), the corresponding position in the dense matrix is computed as:
 </p>
 <pre><span class="c1">// row-major</span>
<span class="n">row</span><span class="o">*</span><span class="n">leading_dimension</span><span class="o">+</span><span class="n">column_indices</span><span class="p">[</span><span class="n">row_offsets</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="o">+</span><span class="n">k</span><span class="p">]</span>

<span class="c1">// column-major</span>
<span class="n">column_indices</span><span class="p">[</span><span class="n">row_offsets</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="o">+</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">leading_dimension</span><span class="o">+</span><span class="n">row</span>
</pre>
 <h3>
  <span class="section-number">
   3.3.4.
  </span>
  Compressed Sparse Column (CSC)
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#compressed-sparse-column-csc" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  The
  CSC
  format is similar to COO, where the
  column indices
  are compressed and replaced by an array of
  offsets
  .
 </p>
 <p>
  A sparse matrix stored in CSC format is represented by the following parameters.
 </p>
 <ul class="simple">
  <li>
   <p>
    The
    number of rows
    in the matrix.
   </p>
  </li>
  <li>
   <p>
    The
    number of columns
    in the matrix.
   </p>
  </li>
  <li>
   <p>
    The
    number of non-zero elements
    (
    <span class="pre">
     nnz
    </span>
    ) in the matrix.
   </p>
  </li>
  <li>
   <p>
    The pointers to the
    column offsets
    array of length
    number of column + 1
    that represents the starting position of each column in the
    columns and values arrays
    .
   </p>
  </li>
  <li>
   <p>
    The pointers to the
    row indices
    array of length
    <span class="pre">
     nnz
    </span>
    that contains row indices of the corresponding elements in the
    values array
    .
   </p>
  </li>
  <li>
   <p>
    The pointers to the
    values
    array of length
    <span class="pre">
     nnz
    </span>
    that holds all nonzero values of the matrix in column-major ordering.
   </p>
  </li>
 </ul>
 <p>
  The following example shows a
  <span class="math notranslate nohighlight">
   \(5 \times 4\)
  </span>
  matrix represented in CSC format.
 </p>
 <a class="image reference internal image-reference" href="https://docs.nvidia.com/cuda/cusparse/_images/csc.png">
 </a>
 <a class="image reference internal image-reference" href="https://docs.nvidia.com/cuda/cusparse/_images/csc_one_base.png">
 </a>
 <p class="admonition-title">
  Note
 </p>
 <p>
  The CSR format has exactly the same memory layout as its transpose in CSC format (and vice versa).
 </p>
 <p class="admonition-title">
  Note
 </p>
 <p>
  cuSPARSE supports both
  sorted
  and
  unsorted
  row indices within a given column.
 </p>
 <p class="admonition-title">
  Note
 </p>
 <p>
  If the
  row indices
  within a given
  column
  are not unique, the correctness of the computation is not always ensured.
 </p>
 <p>
  Given an entry in the CSC format (zero-base), the corresponding position in the dense matrix is computed as:
 </p>
 <pre><span class="c1">// row-major</span>
<span class="n">column</span><span class="o">*</span><span class="n">leading_dimension</span><span class="o">+</span><span class="n">row_indices</span><span class="p">[</span><span class="n">column_offsets</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">+</span><span class="n">k</span><span class="p">]</span>

<span class="c1">// column-major</span>
<span class="n">row_indices</span><span class="p">[</span><span class="n">column_offsets</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">+</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">leading_dimension</span><span class="o">+</span><span class="n">column</span>
</pre>
 <h3>
  <span class="section-number">
   3.3.5.
  </span>
  Sliced Ellpack (SELL)
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#sliced-ellpack-sell" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  The
  Sliced Ellpack
  format is standardized and well-known as the state of the art.
This format allows to significantly improve the performance of all problems that involve low variability in the number of nonzero elements per row.
 </p>
 <p>
  A matrix in the Sliced Ellpack format is divided into
  slices
  of an
  exact number of rows
  (
  <span class="math notranslate nohighlight">
   \(sliceSize\)
  </span>
  ), defined by the user.
The maximum row length (i.e.,  the maximum non-zeros per row) is found for each slice, and every row in the slice is padded to the maximum row length.
The value
  <span class="pre">
   -1
  </span>
  is used for padding.
 </p>
 <p>
  A
  <span class="math notranslate nohighlight">
   \(m \times n\)
  </span>
  sparse matrix
  <span class="math notranslate nohighlight">
   \(A\)
  </span>
  is equivalent to a
  sliced sparse matrix
  <span class="math notranslate nohighlight">
   \(A_{s}\)
  </span>
  with
  <span class="math notranslate nohighlight">
   \(nslices = \left \lceil{\frac{m}{sliceSize}}\right \rceil\)
  </span>
  slice rows and
  <span class="math notranslate nohighlight">
   \(n\)
  </span>
  columns.
To improve memory coalescing and memory utilization, each slice is stored in
  column-major
  order.
 </p>
 <p>
  A sparse matrix stored in SELL format is represented by the following parameters.
 </p>
 <ul class="simple">
  <li>
   <p>
    The
    number of slices
    .
   </p>
  </li>
  <li>
   <p>
    The
    number of rows
    in the matrix.
   </p>
  </li>
  <li>
   <p>
    The
    number of columns
    in the matrix.
   </p>
  </li>
  <li>
   <p>
    The
    number of non-zero elements
    (
    <span class="pre">
     nnz
    </span>
    ) in the matrix.
   </p>
  </li>
  <li>
   <p>
    The
    total number elements
    (
    <span class="pre">
     sellValuesSize
    </span>
    ), including non-zero values and padded elements.
   </p>
  </li>
  <li>
   <p>
    The pointer to the
    slice offsets
    of length
    <span class="math notranslate nohighlight">
     \(nslices + 1\)
    </span>
    that holds offsets of the slides corresponding to the columns and values arrays.
   </p>
  </li>
  <li>
   <p>
    The pointer to the
    column indices
    array of length
    <span class="pre">
     sellValuesSize
    </span>
    that contains column indices of the corresponding elements in the
    values
    array. The column indices are stored in
    column-major
    layout. Value
    <span class="pre">
     -1
    </span>
    refers to padding.
   </p>
  </li>
  <li>
   <p>
    The pointer to the
    values
    array of length
    <span class="pre">
     sellValuesSize
    </span>
    that holds all non-zero values and padding in
    column-major
    layout.
   </p>
  </li>
 </ul>
 <p>
  The following example shows a
  <span class="math notranslate nohighlight">
   \(5 \times 4\)
  </span>
  matrix represented in SELL format.
 </p>
 <a class="image reference internal image-reference" href="https://docs.nvidia.com/cuda/cusparse/_images/sell.png">
 </a>
 <a class="image reference internal image-reference" href="https://docs.nvidia.com/cuda/cusparse/_images/sell_one_base.png">
 </a>
 <h3>
  <span class="section-number">
   3.3.6.
  </span>
  Block Sparse Row (BSR)
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#block-sparse-row-bsr" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  The BSR format is similar to CSR, where the
  column indices
  represent two-dimensional blocks instead of a single matrix entry.
 </p>
 <p>
  A matrix in the Block Sparse Row format is organized into blocks of size
  <span class="math notranslate nohighlight">
   \(blockSize\)
  </span>
  , defined by the user.
 </p>
 <p>
  A
  <span class="math notranslate nohighlight">
   \(m \times n\)
  </span>
  sparse matrix
  <span class="math notranslate nohighlight">
   \(A\)
  </span>
  is equivalent to a
  block sparse matrix
  <span class="math notranslate nohighlight">
   \(A_{B}\)
  </span>
  :
  <span class="math notranslate nohighlight">
   \(mb \times nb\)
  </span>
  with
  <span class="math notranslate nohighlight">
   \(mb = \frac{m}{blockSize}\)
  </span>
  block rows
  and
  <span class="math notranslate nohighlight">
   \(nb = \frac{n}{blockSize}\)
  </span>
  block columns
  .
If
  <span class="math notranslate nohighlight">
   \(m\)
  </span>
  or
  <span class="math notranslate nohighlight">
   \(n\)
  </span>
  is not multiple of
  <span class="math notranslate nohighlight">
   \(blockSize\)
  </span>
  , the user needs to pad the matrix with zeros.
 </p>
 <p class="admonition-title">
  Note
 </p>
 <p>
  cuSPARSE currently supports only
  square
  blocks.
 </p>
 <p>
  The BSR format stores the blocks in row-major ordering. However, the internal storage format of blocks can be
  column-major
  (
  <span class="pre">
   cusparseDirection_t=CUSPARSE_DIRECTION_COLUMN
  </span>
  ) or
  row-major
  (
  <span class="pre">
   cusparseDirection_t=CUSPARSE_DIRECTION_ROW
  </span>
  ), independently of the base index.
 </p>
 <p>
  A sparse matrix stored in BSR format is represented by the following parameters.
 </p>
 <ul class="simple">
  <li>
   <p>
    The
    block size
    .
   </p>
  </li>
  <li>
   <p>
    The
    number of row blocks
    in the matrix.
   </p>
  </li>
  <li>
   <p>
    The
    number of column blocks
    in the matrix.
   </p>
  </li>
  <li>
   <p>
    The
    number of non-zero blocks
    (
    <span class="pre">
     nnzb
    </span>
    ) in the matrix.
   </p>
  </li>
  <li>
   <p>
    The pointers to the
    row block offsets
    array of length
    number of row blocks + 1
    that represents the starting position of each row block in the
    columns and values arrays
    .
   </p>
  </li>
  <li>
   <p>
    The pointers to the
    column block indices
    array of length
    <span class="pre">
     nnzb
    </span>
    that contains the location of the corresponding elements in the values array.
   </p>
  </li>
  <li>
   <p>
    The pointers to the
    values array
    of length
    <span class="pre">
     nnzb
    </span>
    that holds all nonzero values of the matrix.
   </p>
  </li>
 </ul>
 <p>
  The following example shows a
  <span class="math notranslate nohighlight">
   \(4 \times 7\)
  </span>
  matrix represented in BSR format.
 </p>
 <a class="image reference internal image-reference" href="https://docs.nvidia.com/cuda/cusparse/_images/bsr.png">
 </a>
 <a class="image reference internal image-reference" href="https://docs.nvidia.com/cuda/cusparse/_images/bsr_one_base.png">
 </a>
 <h3>
  <span class="section-number">
   3.3.7.
  </span>
  Blocked Ellpack (BLOCKED-ELL)
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#blocked-ellpack-blocked-ell" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  The Blocked Ellpack format is similar to the standard Ellpack, where the
  column indices
  represent two-dimensional blocks instead of a single matrix entry.
 </p>
 <p>
  A matrix in the Blocked Ellpack format is organized into blocks of size
  <span class="math notranslate nohighlight">
   \(blockSize\)
  </span>
  , defined by the user. The number of columns per row
  <span class="math notranslate nohighlight">
   \(nEllCols\)
  </span>
  is also defined by the user (
  <span class="math notranslate nohighlight">
   \(nEllCols \le n\)
  </span>
  ).
 </p>
 <p>
  A
  <span class="math notranslate nohighlight">
   \(m \times n\)
  </span>
  sparse matrix
  <span class="math notranslate nohighlight">
   \(A\)
  </span>
  is equivalent to a
  Blocked-ELL
  matrix
  <span class="math notranslate nohighlight">
   \(A_{B}\)
  </span>
  :
  <span class="math notranslate nohighlight">
   \(mb \times nb\)
  </span>
  with
  <span class="math notranslate nohighlight">
   \(mb = \left \lceil{\frac{m}{blockSize}}\right \rceil\)
  </span>
  block rows
  , and
  <span class="math notranslate nohighlight">
   \(nb = \left \lceil{\frac{nEllCols}{blockSize}}\right \rceil\)
  </span>
  block columns.
If
  <span class="math notranslate nohighlight">
   \(m\)
  </span>
  or
  <span class="math notranslate nohighlight">
   \(n\)
  </span>
  is not multiple of
  <span class="math notranslate nohighlight">
   \(blockSize\)
  </span>
  , then the remaining elements are zero.
 </p>
 <p>
  A sparse matrix stored in Blocked-ELL format is represented by the following parameters.
 </p>
 <ul class="simple">
  <li>
   <p>
    The
    block size
    .
   </p>
  </li>
  <li>
   <p>
    The
    number of rows
    in the matrix.
   </p>
  </li>
  <li>
   <p>
    The
    number of columns
    in the matrix.
   </p>
  </li>
  <li>
   <p>
    The
    number of columns per row
    (
    <span class="pre">
     nEllCols
    </span>
    ) in the matrix.
   </p>
  </li>
  <li>
   <p>
    The pointers to the
    column block indices
    array of length
    <span class="math notranslate nohighlight">
     \(mb \times nb\)
    </span>
    that contains the location of the corresponding elements in the values array. Empty blocks can be represented with
    <span class="pre">
     -1
    </span>
    index.
   </p>
  </li>
  <li>
   <p>
    The pointers to the
    values array
    of length
    <span class="math notranslate nohighlight">
     \(m \times nEllCols\)
    </span>
    that holds all nonzero values of the matrix in row-major ordering.
   </p>
  </li>
 </ul>
 <p>
  The following example shows a
  <span class="math notranslate nohighlight">
   \(9 \times 9\)
  </span>
  matrix represented in Blocked-ELL format.
 </p>
 <a class="image reference internal image-reference" href="https://docs.nvidia.com/cuda/cusparse/_images/blockedell.png">
 </a>
 <a class="image reference internal image-reference" href="https://docs.nvidia.com/cuda/cusparse/_images/blockedell_one_base.png">
 </a>
 <h3>
  <span class="section-number">
   3.3.8.
  </span>
  Extended BSR Format (BSRX) [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#extended-bsr-format-bsrx-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  BSRX is the same as the BSR format, but the array
  <span class="pre">
   bsrRowPtrA
  </span>
  is separated into two parts. The first nonzero block of each row is still specified by the array
  <span class="pre">
   bsrRowPtrA
  </span>
  , which is the same as in BSR, but the position next to the last nonzero block of each row is specified by the array
  <span class="pre">
   bsrEndPtrA
  </span>
  . Briefly, BSRX format is simply like a 4-vector variant of BSR format.
 </p>
 <p>
  Matrix
  <span class="pre">
   A
  </span>
  is represented in BSRX format by the following parameters.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      blockDim
     </span>
    </p>
   </td>
   <td>
    <p>
     (integer)
    </p>
   </td>
   <td>
    <p>
     Block dimension of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      mb
     </span>
    </p>
   </td>
   <td>
    <p>
     (integer)
    </p>
   </td>
   <td>
    <p>
     The number of block rows of
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nb
     </span>
    </p>
   </td>
   <td>
    <p>
     (integer)
    </p>
   </td>
   <td>
    <p>
     The number of block columns of
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzb
     </span>
    </p>
   </td>
   <td>
    <p>
     (integer)
    </p>
   </td>
   <td>
    <p>
     number of nonzero blocks in the matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     (pointer)
    </p>
   </td>
   <td>
    <p>
     Points to the data array of length
     <span class="math notranslate nohighlight">
      \(nnzb \ast blockDim^{2}\)
     </span>
     that holds all the elements of the nonzero blocks of
     <span class="pre">
      A
     </span>
     . The block elements are stored in either column-major order or row-major order.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     (pointer)
    </p>
   </td>
   <td>
    <p>
     Points to the integer array of length
     <span class="pre">
      mb
     </span>
     that holds indices into the arrays
     <span class="pre">
      bsrColIndA
     </span>
     and
     <span class="pre">
      bsrValA
     </span>
     ;
     <span class="pre">
      bsrRowPtrA(i)
     </span>
     is the position of the first nonzero block of the
     <span class="pre">
      i
     </span>
     th block row in
     <span class="pre">
      bsrColIndA
     </span>
     and
     <span class="pre">
      bsrValA
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrEndPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     (pointer)
    </p>
   </td>
   <td>
    <p>
     Points to the integer array of length
     <span class="pre">
      mb
     </span>
     that holds indices into the arrays
     <span class="pre">
      bsrColIndA
     </span>
     and
     <span class="pre">
      bsrValA
     </span>
     ;
     <span class="pre">
      bsrRowPtrA(i)
     </span>
     is the position next to the last nonzero block of the
     <span class="pre">
      i
     </span>
     th block row in
     <span class="pre">
      bsrColIndA
     </span>
     and
     <span class="pre">
      bsrValA
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     (pointer)
    </p>
   </td>
   <td>
    <p>
     Points to the integer array of length
     <span class="pre">
      nnzb
     </span>
     that contains the column indices of the corresponding blocks in array
     <span class="pre">
      bsrValA
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  A simple conversion between BSR and BSRX can be done as follows. Suppose the developer has a
  <span class="pre">
   23
  </span>
  block sparse matrix
  <span class="math notranslate nohighlight">
   \(A_{b}\)
  </span>
  represented as shown.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A_{b} = \begin{bmatrix}
A_{00} &amp; A_{01} &amp; A_{02} \\
A_{10} &amp; A_{11} &amp; A_{12} \\
\end{bmatrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Assume it has this BSR format.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\begin{matrix}
\text{bsrValA of BSR} &amp; = &amp; \begin{bmatrix}
A_{00} &amp; A_{01} &amp; A_{10} &amp; A_{11} &amp; A_{12} \\
\end{bmatrix} \\
\text{bsrRowPtrA of BSR} &amp; = &amp; \begin{bmatrix}
{0\phantom{.0}} &amp; {2\phantom{.0}} &amp; 5 \\
\end{bmatrix} \\
\text{bsrColIndA of BSR} &amp; = &amp; \begin{bmatrix}
{0\phantom{.0}} &amp; {1\phantom{.0}} &amp; {0\phantom{.0}} &amp; {1\phantom{.0}} &amp; 2 \\
\end{bmatrix} \\
\end{matrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The
  <span class="pre">
   bsrRowPtrA
  </span>
  of the BSRX format is simply the first two elements of the
  <span class="pre">
   bsrRowPtrA
  </span>
  BSR format. The
  <span class="pre">
   bsrEndPtrA
  </span>
  of BSRX format is the last two elements of the
  <span class="pre">
   bsrRowPtrA
  </span>
  of BSR format.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\begin{matrix}
\text{bsrRowPtrA of BSRX} &amp; = &amp; \begin{bmatrix}
{0\phantom{.0}} &amp; 2 \\
\end{bmatrix} \\
\text{bsrEndPtrA of BSRX} &amp; = &amp; \begin{bmatrix}
{2\phantom{.0}} &amp; 5 \\
\end{bmatrix} \\
\end{matrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The advantage of the BSRX format is that the developer can specify a submatrix in the original BSR format by modifying
  <span class="pre">
   bsrRowPtrA
  </span>
  and
  <span class="pre">
   bsrEndPtrA
  </span>
  while keeping
  <span class="pre">
   bsrColIndA
  </span>
  and
  <span class="pre">
   bsrValA
  </span>
  unchanged.
 </p>
 <p>
  For example, to create another block matrix
  <span class="math notranslate nohighlight">
   \(\widetilde{A} = \begin{bmatrix}
O &amp; O &amp; O \\
O &amp; A_{11} &amp; O \\
\end{bmatrix}\)
  </span>
  that is slightly different from
  <span class="math notranslate nohighlight">
   \(A\)
  </span>
  , the developer can keep
  <span class="pre">
   bsrColIndA
  </span>
  and
  <span class="pre">
   bsrValA
  </span>
  , but reconstruct
  <span class="math notranslate nohighlight">
   \(\widetilde{A}\)
  </span>
  by properly setting of
  <span class="pre">
   bsrRowPtrA
  </span>
  and
  <span class="pre">
   bsrEndPtrA
  </span>
  . The following 4-vector characterizes
  <span class="math notranslate nohighlight">
   \(\widetilde{A}\)
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\begin{matrix}
{\text{bsrValA of }\widetilde{A}} &amp; = &amp; \begin{bmatrix}
A_{00} &amp; A_{01} &amp; A_{10} &amp; A_{11} &amp; A_{12} \\
\end{bmatrix} \\
{\text{bsrColIndA of }\widetilde{A}} &amp; = &amp; \begin{bmatrix}
{0\phantom{.0}} &amp; {1\phantom{.0}} &amp; {0\phantom{.0}} &amp; {1\phantom{.0}} &amp; 2 \\
\end{bmatrix} \\
{\text{bsrRowPtrA of }\widetilde{A}} &amp; = &amp; \begin{bmatrix}
{0\phantom{.0}} &amp; 3 \\
\end{bmatrix} \\
{\text{bsrEndPtrA of }\widetilde{A}} &amp; = &amp; \begin{bmatrix}
{0\phantom{.0}} &amp; 4 \\
\end{bmatrix} \\
\end{matrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <h1>
  <span class="section-number">
   4.
  </span>
  cuSPARSE Basic APIs
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-basic-apis" title="Permalink to this headline">
   
  </a>
 </h1>
 <h2>
  <span class="section-number">
   4.1.
  </span>
  cuSPARSE Types Reference
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-types-reference" title="Permalink to this headline">
   
  </a>
 </h2>
 <h3>
  <span class="section-number">
   4.1.1.
  </span>
  cudaDataType_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cudadatatype-t" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  The section describes the types shared by multiple CUDA Libraries and defined in the header file
  <span class="pre">
   library_types.h
  </span>
  . The
  <span class="pre">
   cudaDataType
  </span>
  type is an enumerator to specify the data precision. It is used when the data reference does not carry the type itself (e.g.
  <span class="pre">
   void*
  </span>
  ). For example, it is used in the routine
  <span class="pre">
   cusparseSpMM()
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
   <th class="head">
    <p>
     Data Type
    </p>
   </th>
   <th class="head">
    <p>
     Header
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
    </p>
   </td>
   <td>
    <p>
     The data type is 16-bit IEEE-754 floating-point
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      __half
     </span>
    </p>
   </td>
   <td>
    <p>
     cuda_fp16.h
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_16F
     </span>
    </p>
   </td>
   <td>
    <p>
     The data type is 16-bit complex IEEE-754 floating-point
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      __half2
     </span>
    </p>
   </td>
   <td>
    <p>
     cuda_fp16.h
    </p>
   </td>
   <td>
    <p>
     [DEPRECATED]
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16BF
     </span>
    </p>
   </td>
   <td>
    <p>
     The data type is 16-bit bfloat floating-point
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      __nv_bfloat16
     </span>
    </p>
   </td>
   <td>
    <p>
     cuda_bf16.h
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_16BF
     </span>
    </p>
   </td>
   <td>
    <p>
     The data type is 16-bit complex bfloat floating-point
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      __nv_bfloat162
     </span>
    </p>
   </td>
   <td>
    <p>
     cuda_bf16.h
    </p>
   </td>
   <td>
    <p>
     [DEPRECATED]
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     The data type is 32-bit IEEE-754 floating-point
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      float
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     The data type is 32-bit complex IEEE-754 floating-point
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      cuComplex
     </span>
    </p>
   </td>
   <td>
    <p>
     cuComplex.h
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     The data type is 64-bit IEEE-754 floating-point
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      double
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     The data type is 64-bit complex IEEE-754 floating-point
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      cuDoubleComplex
     </span>
    </p>
   </td>
   <td>
    <p>
     cuComplex.h
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_8I
     </span>
    </p>
   </td>
   <td>
    <p>
     The data type is 8-bit integer
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      int8_t
     </span>
    </p>
   </td>
   <td>
    <p>
     stdint.h
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32I
     </span>
    </p>
   </td>
   <td>
    <p>
     The data type is 32-bit integer
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      int32_t
     </span>
    </p>
   </td>
   <td>
    <p>
     stdint.h
    </p>
   </td>
  </tr>
 </table>
 <p>
  IMPORTANT:
  The Generic API routines allow all data types reported in the respective section of the documentation only on GPU architectures with
  native
  support for them. If a specific GPU model does not provide
  native
  support for a given data type, the routine returns
  <span class="pre">
   CUSPARSE_STATUS_ARCH_MISMATCH
  </span>
  error.
 </p>
 <p>
  Unsupported data types and Compute Capability (CC):
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     __half
    </span>
    on GPUs with
    <span class="pre">
     CC
    </span>
    <span class="pre">
     &lt;
    </span>
    <span class="pre">
     53
    </span>
    (e.g. Kepler)
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     __nv_bfloat16
    </span>
    on GPUs with
    <span class="pre">
     CC
    </span>
    <span class="pre">
     &lt;
    </span>
    <span class="pre">
     80
    </span>
    (e.g. Kepler, Maxwell, Pascal, Volta, Turing)
   </p>
  </li>
 </ul>
 <p>
  see
  <a class="reference external" href="https://developer.nvidia.com/cuda-gpus">
   https://developer.nvidia.com/cuda-gpus
  </a>
 </p>
 <h3>
  <span class="section-number">
   4.1.2.
  </span>
  cusparseStatus_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  This data type represents the status returned by the library functions and it can have the following values
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Description
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation completed successfully
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     The cuSPARSE library was not initialized. This is usually caused by the lack of a prior call, an error in the CUDA Runtime API called by the cuSPARSE routine, or an error in the hardware setup
    </p>
    <p>
     To correct:
     call
     <span class="pre">
      cusparseCreate()
     </span>
     prior to the function call; and check that the hardware, an appropriate version of the driver, and the cuSPARSE library are correctly installed
    </p>
    <p>
     The error also applies to generic APIs (
     <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-generic-api-reference">
      Generic APIs reference
     </a>
     ) for indicating a matrix/vector descriptor not initialized
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     Resource allocation failed inside the cuSPARSE library. This is usually caused by a device memory allocation (
     <span class="pre">
      cudaMalloc()
     </span>
     ) or by a host memory allocation failure
    </p>
    <p>
     To correct:
     prior to the function call, deallocate previously allocated memory as much as possible
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     An unsupported value or parameter was passed to the function (a negative vector size, for example)
    </p>
    <p>
     To correct:
     ensure that all the parameters being passed have valid values
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     The function requires a feature absent from the device architecture
    </p>
    <p>
     To correct:
     compile and run the application on a device with appropriate compute capability
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_STATUS_EXECUTION_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     The GPU program failed to execute. This is often caused by a launch failure of the kernel on the GPU, which can be caused by multiple reasons
    </p>
    <p>
     To correct:
     check that the hardware, an appropriate version of the driver, and the cuSPARSE library are correctly installed
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     An internal cuSPARSE operation failed
    </p>
    <p>
     To correct:
     check that the hardware, an appropriate version of the driver, and the cuSPARSE library are correctly installed. Also, check that the memory passed as a parameter to the routine is not being deallocated prior to the routine completion
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_STATUS_MATRIX_TYPE_NOT_SUPPORTED
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix type is not supported by this function. This is usually caused by passing an invalid matrix descriptor to the function
    </p>
    <p>
     To correct:
     check that the fields in
     <span class="pre">
      cusparseMatDescr_t
     </span>
     <span class="pre">
      descrA
     </span>
     were set correctly
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_STATUS_NOT_SUPPORTED
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation or data type combination is currently not supported by the function
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_STATUS_INSUFFICIENT_RESOURCES
     </span>
    </p>
   </td>
   <td>
    <p>
     The resources for the computation, such as GPU global or shared memory, are not sufficient to complete the operation. The error can also indicate that the current computation mode (e.g. bit size of sparse matrix indices) does not allow to handle the given input
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   4.1.3.
  </span>
  cusparseHandle_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsehandle-t" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  This is a pointer type to an opaque cuSPARSE context, which the user must initialize by calling prior to calling
  <span class="pre">
   cusparseCreate()
  </span>
  any other library function. The handle created and returned by
  <span class="pre">
   cusparseCreate()
  </span>
  must be passed to every cuSPARSE function.
 </p>
 <h3>
  <span class="section-number">
   4.1.4.
  </span>
  cusparsePointerMode_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsepointermode-t" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  This type indicates whether the scalar values are passed by reference on the host or device. It is important to point out that if several scalar values are passed by reference in the function call, all of them will conform to the same single pointer mode. The pointer mode can be set and retrieved using
  <span class="pre">
   cusparseSetPointerMode()
  </span>
  and
  <span class="pre">
   cusparseGetPointerMode()
  </span>
  routines, respectively.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_POINTER_MODE_HOST
     </span>
    </p>
   </td>
   <td>
    <p>
     The scalars are passed by reference on the host.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_POINTER_MODE_DEVICE
     </span>
    </p>
   </td>
   <td>
    <p>
     The scalars are passed by reference on the device.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   4.1.5.
  </span>
  cusparseOperation_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseoperation-t" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  This type indicates which operations is applied to the related input (e.g. sparse matrix, or vector).
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_OPERATION_NON_TRANSPOSE
     </span>
    </p>
   </td>
   <td>
    <p>
     The non-transpose operation is selected.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_OPERATION_TRANSPOSE
     </span>
    </p>
   </td>
   <td>
    <p>
     The transpose operation is selected.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_OPERATION_CONJUGATE_TRANSPOSE
     </span>
    </p>
   </td>
   <td>
    <p>
     The conjugate transpose operation is selected.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   4.1.6.
  </span>
  cusparseDiagType_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsediagtype-t" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  This type indicates if the matrix diagonal entries are unity. The diagonal elements are always assumed to be present, but if
  <span class="pre">
   CUSPARSE_DIAG_TYPE_UNIT
  </span>
  is passed to an API routine, then the routine assumes that all diagonal entries are unity and will not read or modify those entries. Note that in this case the routine assumes the diagonal entries are equal to one, regardless of what those entries are actually set to in memory.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_DIAG_TYPE_NON_UNIT
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix diagonal has non-unit elements.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_DIAG_TYPE_UNIT
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix diagonal has unit elements.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   4.1.7.
  </span>
  cusparseFillMode_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsefillmode-t" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  This type indicates if the lower or upper part of a matrix is stored in sparse storage.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_FILL_MODE_LOWER
     </span>
    </p>
   </td>
   <td>
    <p>
     The lower triangular part is stored.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_FILL_MODE_UPPER
     </span>
    </p>
   </td>
   <td>
    <p>
     The upper triangular part is stored.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   4.1.8.
  </span>
  cusparseIndexBase_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseindexbase-t" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  This type indicates if the base of the matrix indices is zero or one.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
    </p>
   </td>
   <td>
    <p>
     The base index is zero (C compatibility).
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
    </p>
   </td>
   <td>
    <p>
     The base index is one  (Fortran compatibility).
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   4.1.9.
  </span>
  cusparseDirection_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedirection-t" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  This type indicates whether the elements of a dense matrix should be parsed by rows or by columns (assuming column-major storage in memory of the dense matrix) in function cusparse[S|D|C|Z]nnz. Besides storage format of blocks in BSR format is also controlled by this type.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_DIRECTION_ROW
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix should be parsed by rows.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_DIRECTION_COLUMN
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix should be parsed by columns.
    </p>
   </td>
  </tr>
 </table>
 <h2>
  <span class="section-number">
   4.2.
  </span>
  cuSPARSE Management API
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-management-api" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  The cuSPARSE functions for managing the library are described in this section.
 </p>
 <h3>
  <span class="section-number">
   4.2.1.
  </span>
  cusparseCreate()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreate" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseCreate</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="o">*</span><span class="n">handle</span><span class="p">)</span>
</pre>
 <p>
  This function initializes the cuSPARSE library and creates a handle on the cuSPARSE context. It must be called before any other cuSPARSE API function is invoked. It allocates hardware resources necessary for accessing the GPU.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     The pointer to the handle to the cuSPARSE context
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   4.2.2.
  </span>
  cusparseDestroy()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedestroy" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseDestroy</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">)</span>
</pre>
 <p>
  This function releases CPU-side resources used by the cuSPARSE library. The release of GPU-side resources may be deferred until the application shuts down.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSPARSE context
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   4.2.3.
  </span>
  cusparseGetErrorName()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsegeterrorname" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="k">const</span><span class="kt">char</span><span class="o">*</span>
<span class="n">cusparseGetErrorString</span><span class="p">(</span><span class="n">cusparseStatus_t</span><span class="n">status</span><span class="p">)</span>
</pre>
 <p>
  The function returns the string representation of an error code enum name. If the error code is not recognized, unrecognized error code is returned.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      status
     </span>
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Error code to convert to string
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      const
     </span>
     <span class="pre">
      char*
     </span>
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Pointer to a NULL-terminated string
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   4.2.4.
  </span>
  cusparseGetErrorString()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsegeterrorstring" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="k">const</span><span class="kt">char</span><span class="o">*</span>
<span class="n">cusparseGetErrorString</span><span class="p">(</span><span class="n">cusparseStatus_t</span><span class="n">status</span><span class="p">)</span>
</pre>
 <p>
  Returns the description string for an error code. If the error code is not recognized, unrecognized error code is returned.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      status
     </span>
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Error code to convert to string
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      const
     </span>
     <span class="pre">
      char*
     </span>
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Pointer to a NULL-terminated string
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   4.2.5.
  </span>
  cusparseGetProperty()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsegetproperty" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseGetProperty</span><span class="p">(</span><span class="n">libraryPropertyType</span><span class="n">type</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">value</span><span class="p">)</span>
</pre>
 <p>
  The function returns the value of the requested property. Refer to
  <span class="pre">
   libraryPropertyType
  </span>
  for supported types.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      type
     </span>
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Requested property
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      value
     </span>
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Value of the requested property
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   libraryPropertyType
  </span>
  (defined in
  <span class="pre">
   library_types.h
  </span>
  ):
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      MAJOR_VERSION
     </span>
    </p>
   </td>
   <td>
    <p>
     Enumerator to query the major version
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      MINOR_VERSION
     </span>
    </p>
   </td>
   <td>
    <p>
     Enumerator to query the minor version
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      PATCH_LEVEL
     </span>
    </p>
   </td>
   <td>
    <p>
     Number to identify the patch level
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   4.2.6.
  </span>
  cusparseGetVersion()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsegetversion" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseGetVersion</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">version</span><span class="p">)</span>
</pre>
 <p>
  This function returns the version number of the cuSPARSE library.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     cuSPARSE handle
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      version
     </span>
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     The version number of the library
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   4.2.7.
  </span>
  cusparseGetPointerMode()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsegetpointermode" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseGetPointerMode</span><span class="p">(</span><span class="n">cusparseHandlet</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparsePointerMode_t</span><span class="o">*</span><span class="n">mode</span><span class="p">)</span>
</pre>
 <p>
  This function obtains the pointer mode used by the cuSPARSE library. Please see the section on the
  <span class="pre">
   cusparsePointerMode_t
  </span>
  type for more details.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSPARSE context
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      mode
     </span>
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     One of the enumerated pointer mode types
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   4.2.8.
  </span>
  cusparseSetPointerMode()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsesetpointermode" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSetPointerMode</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparsePointerMode_t</span><span class="n">mode</span><span class="p">)</span>
</pre>
 <p>
  This function sets the pointer mode used by the cuSPARSE library. The
  default
  is for the values to be passed by reference on the host. Please see the section on the
  <span class="pre">
   cublasPointerMode_t
  </span>
  type for more details.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSPARSE context
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      mode
     </span>
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     One of the enumerated pointer mode types
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   4.2.9.
  </span>
  cusparseGetStream()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsegetstream" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseGetStream</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span><span class="n">cudaStream_t</span><span class="o">*</span><span class="n">streamId</span><span class="p">)</span>
</pre>
 <p>
  This function gets the cuSPARSE library stream, which is being used to to execute all calls to the cuSPARSE library functions. If the cuSPARSE library stream is not set, all kernels use the default NULL stream.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSPARSE context
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      streamId
     </span>
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     The stream used by the library
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   4.2.10.
  </span>
  cusparseSetStream()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsesetstream" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSetStream</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span><span class="n">cudaStream_t</span><span class="n">streamId</span><span class="p">)</span>
</pre>
 <p>
  This function sets the stream to be used by the cuSPARSE library to execute its routines.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     The handle to the cuSPARSE context
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      streamId
     </span>
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     The stream to be used by the library
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h2>
  <span class="section-number">
   4.3.
  </span>
  cuSPARSE Logging API
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-logging-api" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  cuSPARSE logging mechanism can be enabled by setting the following environment variables before launching the target application:
 </p>
 <p>
  <span class="pre">
   CUSPARSE_LOG_LEVEL=&lt;level&gt;
  </span>
  - while level is one of the following levels:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     0
    </span>
    -
    Off
    - logging is disabled (default)
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     1
    </span>
    -
    Error
    - only errors will be logged
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     2
    </span>
    -
    Trace
    - API calls that launch CUDA kernels will log their parameters and important information
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     3
    </span>
    -
    Hints
    - hints that can potentially improve the applications performance
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     4
    </span>
    -
    Info
    - provides general information about the library execution, may contain details about heuristic status
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     5
    </span>
    -
    API Trace
    - API calls will log their parameter and important information
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   CUSPARSE_LOG_MASK=&lt;mask&gt;
  </span>
  - while mask is a combination of the following masks:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     0
    </span>
    -
    Off
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     1
    </span>
    -
    Error
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     2
    </span>
    -
    Trace
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     4
    </span>
    -
    Hints
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     8
    </span>
    -
    Info
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     16
    </span>
    -
    API Trace
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   CUSPARSE_LOG_FILE=&lt;file_name&gt;
  </span>
  - while file name is a path to a logging file. File name may contain
  <span class="pre">
   %i
  </span>
  , that will be replaced with the process id. E.g
  <span class="pre">
   &lt;file_name&gt;_%i.log
  </span>
  .
 </p>
 <p>
  If
  <span class="pre">
   CUSPARSE_LOG_FILE
  </span>
  is not defined, the log messages are printed to
  <span class="pre">
   stdout
  </span>
  .
 </p>
 <p>
  Starting from CUDA 12.3, it is also possible to dump sparse matrices (CSR, CSC, COO, SELL, BSR) in binary files during the creation by setting the environment variable
  <span class="pre">
   CUSPARSE_STORE_INPUT_MATRIX
  </span>
  . Later on, the binary files can be send to
  <a class="reference external" href="mailto:Math-Libs-Feedback%40nvidia.com?subject=cuSPARSE-Feedback">
   Math-Libs-Feedback
   <span>
    @
   </span>
   nvidia
   <span>
    .
   </span>
   com
  </a>
  for debugging and reproducibility purposes of a specific correctness/performance issue.
 </p>
 <p>
  Another option is to use the experimental cuSPARSE logging API. See:
 </p>
 <ul class="simple">
  <li>
   <p>
    <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseloggersetcallback">
     cusparseLoggerSetCallback()
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseloggersetfile">
     cusparseLoggerSetFile()
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseloggeropenfile">
     cusparseLoggerOpenFile()
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseloggersetlevel">
     cusparseLoggerSetLevel()
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseloggersetmask">
     cusparseLoggerSetMask()
    </a>
   </p>
  </li>
  <li>
   <p>
    <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cublasltloggerforcedisable">
     cusparseLoggerForceDisable()
    </a>
   </p>
  </li>
 </ul>
 <p class="admonition-title">
  Note
 </p>
 <p>
  The logging mechanism is not available for the legacy APIs.
 </p>
 <h3>
  <span class="section-number">
   4.3.1.
  </span>
  cusparseLoggerSetCallback()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseloggersetcallback" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseLoggerSetCallback</span><span class="p">(</span><span class="n">cusparseLoggerCallback_t</span><span class="n">callback</span><span class="p">)</span>
</pre>
 <p>
  Experimental
  : The function sets the logging callback function.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      callback
     </span>
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Pointer to a callback function
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   cusparseLoggerCallback_t
  </span>
  has the following signature:
 </p>
 <pre><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">cusparseLoggerCallback_t</span><span class="p">)(</span><span class="kt">int</span><span class="n">logLevel</span><span class="p">,</span>
<span class="k">const</span><span class="kt">char</span><span class="o">*</span><span class="n">functionName</span><span class="p">,</span>
<span class="k">const</span><span class="kt">char</span><span class="o">*</span><span class="n">message</span><span class="p">)</span>
</pre>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      logLevel
     </span>
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Selected log level
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      functionName
     </span>
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     The name of the API that logged this message
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      message
     </span>
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     The log message
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   4.3.2.
  </span>
  cusparseLoggerSetFile()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseloggersetfile" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseLoggerSetFile</span><span class="p">(</span><span class="kt">FILE</span><span class="o">*</span><span class="n">file</span><span class="p">)</span>
</pre>
 <p>
  Experimental
  : The function sets the logging output file. Note: once registered using this function call, the provided file handle must not be closed unless the function is called again to switch to a different file handle.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      file
     </span>
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Pointer to an open file. File should have write permission
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   4.3.3.
  </span>
  cusparseLoggerOpenFile()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseloggeropenfile" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseLoggerOpenFile</span><span class="p">(</span><span class="k">const</span><span class="kt">char</span><span class="o">*</span><span class="n">logFile</span><span class="p">)</span>
</pre>
 <p>
  Experimental
  : The function opens a logging output file in the given path.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      logFile
     </span>
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Path of the logging output file
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   4.3.4.
  </span>
  cusparseLoggerSetLevel()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseloggersetlevel" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseLoggerSetLevel</span><span class="p">(</span><span class="kt">int</span><span class="n">level</span><span class="p">)</span>
</pre>
 <p>
  Experimental
  : The function sets the value of the logging level. path.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      level
     </span>
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Value of the logging level
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   4.3.5.
  </span>
  cusparseLoggerSetMask()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseloggersetmask" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseLoggerSetMask</span><span class="p">(</span><span class="kt">int</span><span class="n">mask</span><span class="p">)</span>
</pre>
 <p>
  Experimental
  : The function sets the value of the logging mask.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      mask
     </span>
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Value of the logging mask
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h1>
  <span class="section-number">
   5.
  </span>
  cuSPARSE Legacy APIs
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-legacy-apis" title="Permalink to this headline">
   
  </a>
 </h1>
 <h2>
  <span class="section-number">
   5.1.
  </span>
  Naming Conventions
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#naming-conventions" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  The cuSPARSE legacy functions are available for data types
  <span class="pre">
   float
  </span>
  ,
  <span class="pre">
   double
  </span>
  ,
  <span class="pre">
   cuComplex
  </span>
  , and
  <span class="pre">
   cuDoubleComplex
  </span>
  . The sparse Level 2, and Level 3 functions follow this naming convention:
 </p>
 <p>
  <span class="pre">
   cusparse
  </span>
  &lt;
  <span class="pre">
   t
  </span>
  &gt;[&lt;
  <span class="pre">
   matrix
  </span>
  <span class="pre">
   data
  </span>
  <span class="pre">
   format
  </span>
  &gt;]&lt;
  <span class="pre">
   operation
  </span>
  &gt;[&lt;
  <span class="pre">
   output
  </span>
  <span class="pre">
   matrix
  </span>
  <span class="pre">
   data
  </span>
  <span class="pre">
   format
  </span>
  &gt;]
 </p>
 <p>
  where &lt;
  <span class="pre">
   t
  </span>
  &gt; can be
  <span class="pre">
   S
  </span>
  ,
  <span class="pre">
   D
  </span>
  ,
  <span class="pre">
   C
  </span>
  ,
  <span class="pre">
   Z
  </span>
  , or
  <span class="pre">
   X
  </span>
  , corresponding to the data types
  <span class="pre">
   float
  </span>
  ,
  <span class="pre">
   double
  </span>
  ,
  <span class="pre">
   cuComplex
  </span>
  ,
  <span class="pre">
   cuDoubleComplex
  </span>
  , and the generic type, respectively.
 </p>
 <p>
  The &lt;
  <span class="pre">
   matrix
  </span>
  <span class="pre">
   data
  </span>
  <span class="pre">
   format
  </span>
  &gt; can be
  <span class="pre">
   dense
  </span>
  ,
  <span class="pre">
   coo
  </span>
  ,
  <span class="pre">
   csr
  </span>
  , or
  <span class="pre">
   csc
  </span>
  , corresponding to the dense, coordinate, compressed sparse row, and compressed sparse column formats, respectively.
 </p>
 <h2>
  <span class="section-number">
   5.2.
  </span>
  cuSPARSE Legacy Types Reference
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-legacy-types-reference" title="Permalink to this headline">
   
  </a>
 </h2>
 <h3>
  <span class="section-number">
   5.2.1.
  </span>
  cusparseAction_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseaction-t" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  This type indicates whether the operation is performed only on indices or on data and indices.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_ACTION_SYMBOLIC
     </span>
    </p>
   </td>
   <td>
    <p>
     the operation is performed only on indices.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_ACTION_NUMERIC
     </span>
    </p>
   </td>
   <td>
    <p>
     the operation is performed on data and indices.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   5.2.2.
  </span>
  cusparseMatDescr_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsematdescr-t" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  This structure is used to describe the shape and properties of a matrix.
 </p>
 <pre><span class="k">typedef</span><span class="k">struct</span><span class="p">{</span>
<span class="n">cusparseMatrixType_t</span><span class="n">MatrixType</span><span class="p">;</span>
<span class="n">cusparseFillMode_t</span><span class="n">FillMode</span><span class="p">;</span>
<span class="n">cusparseDiagType_t</span><span class="n">DiagType</span><span class="p">;</span>
<span class="n">cusparseIndexBase_t</span><span class="n">IndexBase</span><span class="p">;</span>
<span class="p">}</span><span class="n">cusparseMatDescr_t</span><span class="p">;</span>
</pre>
 <h3>
  <span class="section-number">
   5.2.3.
  </span>
  cusparseMatrixType_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsematrixtype-t" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  This type indicates the type of matrix stored in sparse storage. Notice that for symmetric, Hermitian and triangular matrices only their lower or upper part is assumed to be stored.
 </p>
 <p>
  The whole idea of matrix type and fill mode is to keep minimum storage for symmetric/Hermitian matrix, and also to take advantage of symmetric property on SpMV (Sparse Matrix Vector multiplication). To compute
  <span class="pre">
   y=A*x
  </span>
  when
  <span class="pre">
   A
  </span>
  is symmetric and only lower triangular part is stored, two steps are needed. First step is to compute
  <span class="pre">
   y=(L+D)*x
  </span>
  and second step is to compute
  <span class="pre">
   y=L^T*x
  </span>
  <span class="pre">
   +
  </span>
  <span class="pre">
   y
  </span>
  . Given the fact that the transpose operation
  <span class="pre">
   y=L^T*x
  </span>
  is 10x slower than non-transpose version
  <span class="pre">
   y=L*x
  </span>
  , the symmetric property does not show up any performance gain. It is better for the user to extend the symmetric matrix to a general matrix and apply
  <span class="pre">
   y=A*x
  </span>
  with matrix type
  <span class="pre">
   CUSPARSE_MATRIX_TYPE_GENERAL
  </span>
  .
 </p>
 <p>
  In general, SpMV, preconditioners (incomplete Cholesky or incomplete LU) and triangular solver are combined together in iterative solvers, for example PCG and GMRES. If the user always uses general matrix (instead of symmetric matrix), there is no need to support other than general matrix in preconditioners. Therefore the new routines,
  <span class="pre">
   [bsr|csr]sv2
  </span>
  (triangular solver),
  <span class="pre">
   [bsr|csr]ilu02
  </span>
  (incomplete LU) and
  <span class="pre">
   [bsr|csr]ic02
  </span>
  (incomplete Cholesky), only support matrix type
  <span class="pre">
   CUSPARSE_MATRIX_TYPE_GENERAL
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
    </p>
   </td>
   <td>
    <p>
     the matrix is general.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_SYMMETRIC
     </span>
    </p>
   </td>
   <td>
    <p>
     the matrix is symmetric.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_HERMITIAN
     </span>
    </p>
   </td>
   <td>
    <p>
     the matrix is Hermitian.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_TRIANGULAR
     </span>
    </p>
   </td>
   <td>
    <p>
     the matrix is triangular.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   5.2.4.
  </span>
  cusparseColorInfo_t [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecolorinfo-t-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  This is a pointer type to an opaque structure holding the information used in
  <span class="pre">
   csrcolor()
  </span>
  .
 </p>
 <h3>
  <span class="section-number">
   5.2.5.
  </span>
  cusparseSolvePolicy_t [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsesolvepolicy-t-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  This type indicates whether level information is generated and used in
  <span class="pre">
   csrsv2,
  </span>
  <span class="pre">
   csric02,
  </span>
  <span class="pre">
   csrilu02,
  </span>
  <span class="pre">
   bsrsv2,
  </span>
  <span class="pre">
   bsric02
  </span>
  <span class="pre">
   and
  </span>
  <span class="pre">
   bsrilu02
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SOLVE_POLICY_NO_LEVEL
     </span>
    </p>
   </td>
   <td>
    <p>
     no level information is generated and used.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SOLVE_POLICY_USE_LEVEL
     </span>
    </p>
   </td>
   <td>
    <p>
     generate and use level information.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   5.2.6.
  </span>
  bsric02Info_t [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#bsric02info-t-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  This is a pointer type to an opaque structure holding the information used in
  <span class="pre">
   bsric02_bufferSize()
  </span>
  ,
  <span class="pre">
   bsric02_analysis()
  </span>
  , and
  <span class="pre">
   bsric02()
  </span>
  .
 </p>
 <h3>
  <span class="section-number">
   5.2.7.
  </span>
  bsrilu02Info_t [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#bsrilu02info-t-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  This is a pointer type to an opaque structure holding the information used in
  <span class="pre">
   bsrilu02_bufferSize()
  </span>
  ,
  <span class="pre">
   bsrilu02_analysis()
  </span>
  , and
  <span class="pre">
   bsrilu02()
  </span>
  .
 </p>
 <h3>
  <span class="section-number">
   5.2.8.
  </span>
  bsrsm2Info_t [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#bsrsm2info-t-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  This is a pointer type to an opaque structure holding the information used in
  <span class="pre">
   bsrsm2_bufferSize()
  </span>
  ,
  <span class="pre">
   bsrsm2_analysis()
  </span>
  , and
  <span class="pre">
   bsrsm2_solve()
  </span>
  .
 </p>
 <h3>
  <span class="section-number">
   5.2.9.
  </span>
  bsrsv2Info_t [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#bsrsv2info-t-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  This is a pointer type to an opaque structure holding the information used in
  <span class="pre">
   bsrsv2_bufferSize()
  </span>
  ,
  <span class="pre">
   bsrsv2_analysis()
  </span>
  , and
  <span class="pre">
   bsrsv2_solve()
  </span>
  .
 </p>
 <h3>
  <span class="section-number">
   5.2.10.
  </span>
  csric02Info_t [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#csric02info-t-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  This is a pointer type to an opaque structure holding the information used in
  <span class="pre">
   csric02_bufferSize()
  </span>
  ,
  <span class="pre">
   csric02_analysis()
  </span>
  , and
  <span class="pre">
   csric02()
  </span>
  .
 </p>
 <h3>
  <span class="section-number">
   5.2.11.
  </span>
  csrilu02Info_t [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#csrilu02info-t-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  This is a pointer type to an opaque structure holding the information used in
  <span class="pre">
   csrilu02_bufferSize()
  </span>
  ,
  <span class="pre">
   csrilu02_analysis()
  </span>
  , and
  <span class="pre">
   csrilu02()
  </span>
  .
 </p>
 <h2>
  <span class="section-number">
   5.3.
  </span>
  cuSPARSE Helper Function Reference
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-helper-function-reference" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  The cuSPARSE helper functions are described in this section.
 </p>
 <h3>
  <span class="section-number">
   5.3.1.
  </span>
  cusparseCreateColorInfo() [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatecolorinfo-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseCreateColorInfo</span><span class="p">(</span><span class="n">cusparseColorInfo_t</span><span class="o">*</span><span class="n">info</span><span class="p">)</span>
</pre>
 <p>
  This function creates and initializes the
  <span class="pre">
   cusparseColorInfo_t
  </span>
  structure to
  default
  values.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     the pointer to the
     <span class="pre">
      cusparseColorInfo_t
     </span>
     structure
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   5.3.2.
  </span>
  cusparseCreateMatDescr()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatematdescr" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseCreateMatDescr</span><span class="p">(</span><span class="n">cusparseMatDescr_t</span><span class="o">*</span><span class="n">descrA</span><span class="p">)</span>
</pre>
 <p>
  This function initializes the matrix descriptor. It sets the fields
  <span class="pre">
   MatrixType
  </span>
  and
  <span class="pre">
   IndexBase
  </span>
  to the
  default
  values
  <span class="pre">
   CUSPARSE_MATRIX_TYPE_GENERAL
  </span>
  and
  <span class="pre">
   CUSPARSE_INDEX_BASE_ZERO
  </span>
  , respectively, while leaving other fields uninitialized.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the pointer to the matrix descriptor.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   5.3.3.
  </span>
  cusparseDestroyColorInfo() [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedestroycolorinfo-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseDestroyColorInfo</span><span class="p">(</span><span class="n">cusparseColorInfo_t</span><span class="n">info</span><span class="p">)</span>
</pre>
 <p>
  This function destroys and releases any memory required by the structure.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     the pointer to the structure of
     <span class="pre">
      csrcolor()
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   5.3.4.
  </span>
  cusparseDestroyMatDescr()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedestroymatdescr" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseDestroyMatDescr</span><span class="p">(</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">)</span>
</pre>
 <p>
  This function releases the memory allocated for the matrix descriptor.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the matrix descriptor.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   5.3.5.
  </span>
  cusparseGetMatDiagType()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsegetmatdiagtype" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseDiagType_t</span>
<span class="n">cusparseGetMatDiagType</span><span class="p">(</span><span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">)</span>
</pre>
 <p>
  This function returns the
  <span class="pre">
   DiagType
  </span>
  field of the matrix descriptor
  <span class="pre">
   descrA
  </span>
  .
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the matrix descriptor.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     
    </p>
   </td>
   <td>
    <p>
     One of the enumerated diagType types.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   5.3.6.
  </span>
  cusparseGetMatFillMode()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsegetmatfillmode" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseFillMode_t</span>
<span class="n">cusparseGetMatFillMode</span><span class="p">(</span><span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">)</span>
</pre>
 <p>
  This function returns the
  <span class="pre">
   FillMode
  </span>
  field of the matrix descriptor
  <span class="pre">
   descrA
  </span>
  .
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the matrix descriptor.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     
    </p>
   </td>
   <td>
    <p>
     One of the enumerated fillMode types.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   5.3.7.
  </span>
  cusparseGetMatIndexBase()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsegetmatindexbase" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseIndexBase_t</span>
<span class="n">cusparseGetMatIndexBase</span><span class="p">(</span><span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">)</span>
</pre>
 <p>
  This function returns the
  <span class="pre">
   IndexBase
  </span>
  field of the matrix descriptor
  <span class="pre">
   descrA
  </span>
  .
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the matrix descriptor.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     
    </p>
   </td>
   <td>
    <p>
     One of the enumerated indexBase types.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   5.3.8.
  </span>
  cusparseGetMatType()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsegetmattype" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseMatrixType_t</span>
<span class="n">cusparseGetMatType</span><span class="p">(</span><span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">)</span>
</pre>
 <p>
  This function returns the
  <span class="pre">
   MatrixType
  </span>
  field of the matrix descriptor
  <span class="pre">
   descrA
  </span>
  .
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the matrix descriptor.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     
    </p>
   </td>
   <td>
    <p>
     One of the enumerated matrix types.
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   5.3.9.
  </span>
  cusparseSetMatDiagType()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsesetmatdiagtype" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSetMatDiagType</span><span class="p">(</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cusparseDiagType_t</span><span class="n">diagType</span><span class="p">)</span>
</pre>
 <p>
  This function sets the
  <span class="pre">
   DiagType
  </span>
  field of the matrix descriptor
  <span class="pre">
   descrA
  </span>
  .
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      diagType
     </span>
    </p>
   </td>
   <td>
    <p>
     One of the enumerated diagType types.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the matrix descriptor.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   5.3.10.
  </span>
  cusparseSetMatFillMode()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsesetmatfillmode" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSetMatFillMode</span><span class="p">(</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cusparseFillMode_t</span><span class="n">fillMode</span><span class="p">)</span>
</pre>
 <p>
  This function sets the
  <span class="pre">
   FillMode
  </span>
  field of the matrix descriptor
  <span class="pre">
   descrA
  </span>
  .
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      fillMode
     </span>
    </p>
   </td>
   <td>
    <p>
     One of the enumerated fillMode types.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the matrix descriptor.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   5.3.11.
  </span>
  cusparseSetMatIndexBase()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsesetmatindexbase" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSetMatIndexBase</span><span class="p">(</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="n">base</span><span class="p">)</span>
</pre>
 <p>
  This function sets the
  <span class="pre">
   IndexBase
  </span>
  field of the matrix descriptor
  <span class="pre">
   descrA
  </span>
  .
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      base
     </span>
    </p>
   </td>
   <td>
    <p>
     One of the enumerated indexBase types.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the matrix descriptor.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   5.3.12.
  </span>
  cusparseSetMatType()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsesetmattype" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSetMatType</span><span class="p">(</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span><span class="n">cusparseMatrixType_t</span><span class="n">type</span><span class="p">)</span>
</pre>
 <p>
  This function sets the
  <span class="pre">
   MatrixType
  </span>
  field of the matrix descriptor
  <span class="pre">
   descrA
  </span>
  .
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      type
     </span>
    </p>
   </td>
   <td>
    <p>
     One of the enumerated matrix types.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the matrix descriptor.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   5.3.13.
  </span>
  cusparseCreateCsric02Info() [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatecsric02info-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="nf">cusparseCreateCsric02Info</span><span class="p">(</span><span class="n">csric02Info_t</span><span class="o">*</span><span class="n">info</span><span class="p">);</span>
</pre>
 <p>
  This function creates and initializes the solve and analysis structure of incomplete Cholesky to
  default
  values.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     the pointer to the solve and analysis structure of incomplete Cholesky.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   5.3.14.
  </span>
  cusparseDestroyCsric02Info() [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedestroycsric02info-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="nf">cusparseDestroyCsric02Info</span><span class="p">(</span><span class="n">csric02Info_t</span><span class="n">info</span><span class="p">);</span>
</pre>
 <p>
  This function destroys and releases any memory required by the structure.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     the solve
     <span class="pre">
      (csric02_solve)
     </span>
     and analysis
     <span class="pre">
      (csric02_analysis)
     </span>
     structure.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   5.3.15.
  </span>
  cusparseCreateCsrilu02Info() [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatecsrilu02info-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="nf">cusparseCreateCsrilu02Info</span><span class="p">(</span><span class="n">csrilu02Info_t</span><span class="o">*</span><span class="n">info</span><span class="p">);</span>
</pre>
 <p>
  This function creates and initializes the solve and analysis structure of incomplete LU to
  default
  values.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     the pointer to the solve and analysis structure of incomplete LU.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   5.3.16.
  </span>
  cusparseDestroyCsrilu02Info() [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedestroycsrilu02info-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="nf">cusparseDestroyCsrilu02Info</span><span class="p">(</span><span class="n">csrilu02Info_t</span><span class="n">info</span><span class="p">);</span>
</pre>
 <p>
  This function destroys and releases any memory required by the structure.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     the solve
     <span class="pre">
      (csrilu02_solve)
     </span>
     and analysis
     <span class="pre">
      (csrilu02_analysis)
     </span>
     structure.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   5.3.17.
  </span>
  cusparseCreateBsrsv2Info() [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatebsrsv2info-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="nf">cusparseCreateBsrsv2Info</span><span class="p">(</span><span class="n">bsrsv2Info_t</span><span class="o">*</span><span class="n">info</span><span class="p">);</span>
</pre>
 <p>
  This function creates and initializes the solve and analysis structure of bsrsv2 to
  default
  values.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     the pointer to the solve and analysis structure of bsrsv2.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   5.3.18.
  </span>
  cusparseDestroyBsrsv2Info() [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedestroybsrsv2info-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="nf">cusparseDestroyBsrsv2Info</span><span class="p">(</span><span class="n">bsrsv2Info_t</span><span class="n">info</span><span class="p">);</span>
</pre>
 <p>
  This function destroys and releases any memory required by the structure.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     the solve
     <span class="pre">
      (bsrsv2_solve)
     </span>
     and analysis
     <span class="pre">
      (bsrsv2_analysis)
     </span>
     structure.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   5.3.19.
  </span>
  cusparseCreateBsrsm2Info() [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatebsrsm2info-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="nf">cusparseCreateBsrsm2Info</span><span class="p">(</span><span class="n">bsrsm2Info_t</span><span class="o">*</span><span class="n">info</span><span class="p">);</span>
</pre>
 <p>
  This function creates and initializes the solve and analysis structure of bsrsm2 to
  default
  values.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     the pointer to the solve and analysis structure of bsrsm2.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   5.3.20.
  </span>
  cusparseDestroyBsrsm2Info() [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedestroybsrsm2info-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="nf">cusparseDestroyBsrsm2Info</span><span class="p">(</span><span class="n">bsrsm2Info_t</span><span class="n">info</span><span class="p">);</span>
</pre>
 <p>
  This function destroys and releases any memory required by the structure.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     the solve
     <span class="pre">
      (bsrsm2_solve)
     </span>
     and analysis
     <span class="pre">
      (bsrsm2_analysis)
     </span>
     structure.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   5.3.21.
  </span>
  cusparseCreateBsric02Info() [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatebsric02info-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="nf">cusparseCreateBsric02Info</span><span class="p">(</span><span class="n">bsric02Info_t</span><span class="o">*</span><span class="n">info</span><span class="p">);</span>
</pre>
 <p>
  This function creates and initializes the solve and analysis structure of block incomplete Cholesky to
  default
  values.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     the pointer to the solve and analysis structure of block incomplete Cholesky.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   5.3.22.
  </span>
  cusparseDestroyBsric02Info() [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedestroybsric02info-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="nf">cusparseDestroyBsric02Info</span><span class="p">(</span><span class="n">bsric02Info_t</span><span class="n">info</span><span class="p">);</span>
</pre>
 <p>
  This function destroys and releases any memory required by the structure.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     the solve
     <span class="pre">
      (bsric02_solve)
     </span>
     and analysis
     <span class="pre">
      (bsric02_analysis)
     </span>
     structure.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   5.3.23.
  </span>
  cusparseCreateBsrilu02Info() [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatebsrilu02info-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="nf">cusparseCreateBsrilu02Info</span><span class="p">(</span><span class="n">bsrilu02Info_t</span><span class="o">*</span><span class="n">info</span><span class="p">);</span>
</pre>
 <p>
  This function creates and initializes the solve and analysis structure of block incomplete LU to
  default
  values.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     the pointer to the solve and analysis structure of block incomplete LU.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   5.3.24.
  </span>
  cusparseDestroyBsrilu02Info() [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedestroybsrilu02info-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="nf">cusparseDestroyBsrilu02Info</span><span class="p">(</span><span class="n">bsrilu02Info_t</span><span class="n">info</span><span class="p">);</span>
</pre>
 <p>
  This function destroys and releases any memory required by the structure.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     the solve
     <span class="pre">
      (bsrilu02_solve)
     </span>
     and analysis
     <span class="pre">
      (bsrilu02_analysis)
     </span>
     structure.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   5.3.25.
  </span>
  cusparseCreatePruneInfo() [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatepruneinfo-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="nf">cusparseCreatePruneInfo</span><span class="p">(</span><span class="n">pruneInfo_t</span><span class="o">*</span><span class="n">info</span><span class="p">);</span>
</pre>
 <p>
  This function creates and initializes structure of
  <span class="pre">
   prune
  </span>
  to
  default
  values.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     the pointer to the structure of
     <span class="pre">
      prune
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   5.3.26.
  </span>
  cusparseDestroyPruneInfo() [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedestroypruneinfo-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="nf">cusparseDestroyPruneInfo</span><span class="p">(</span><span class="n">pruneInfo_t</span><span class="n">info</span><span class="p">);</span>
</pre>
 <p>
  This function destroys and releases any memory required by the structure.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     the structure of
     <span class="pre">
      prune
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h2>
  <span class="section-number">
   5.4.
  </span>
  cuSPARSE Level 2 Function Reference
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-level-2-function-reference" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  This chapter describes the sparse linear algebra functions that perform operations between sparse matrices and dense vectors.
 </p>
 <h3>
  <span class="section-number">
   5.4.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#bsrmv">
   cusparse&lt;t&gt;bsrmv()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsrmv" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSbsrmv</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">bsrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColInd</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDbsrmv</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">bsrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColInd</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCbsrmv</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descr</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">bsrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColInd</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZbsrmv</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descr</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">bsrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColInd</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
</pre>
 <p>
  This function performs the matrix-vector operation
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\text{y} = \alpha \ast \text{op}(A) \ast \text{x} + \beta \ast \text{y}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="math notranslate nohighlight">
   \(A\text{ is an }(mb \ast blockDim) \times (nb \ast blockDim)\)
  </span>
  sparse matrix that is defined in BSR storage format by the three arrays
  <span class="pre">
   bsrVal
  </span>
  ,
  <span class="pre">
   bsrRowPtr
  </span>
  , and
  <span class="pre">
   bsrColInd
  </span>
  );
  <span class="pre">
   x
  </span>
  and
  <span class="pre">
   y
  </span>
  are vectors;
  <span class="math notranslate nohighlight">
   \(\alpha\text{ and }\beta\)
  </span>
  are scalars; and
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(\text{op}(A) = \begin{cases}
A &amp; \text{if trans == CUSPARSE_OPERATION_NON_TRANSPOSE} \\
A^{T} &amp; \text{if trans == CUSPARSE_OPERATION_TRANSPOSE} \\
A^{H} &amp; \text{if trans == CUSPARSE_OPERATION_CONJUGATE_TRANSPOSE} \\
\end{cases}\)
  </span>
 </p>
 <p>
  <span class="pre">
   bsrmv()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Several comments on
  <span class="pre">
   bsrmv()
  </span>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    Only
    <span class="pre">
     blockDim
    </span>
    <span class="pre">
     &gt;
    </span>
    <span class="pre">
     1
    </span>
    is supported
   </p>
  </li>
  <li>
   <p>
    Only
    <span class="pre">
     CUSPARSE_OPERATION_NON_TRANSPOSE
    </span>
    is supported, that is
   </p>
  </li>
 </ul>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\text{y} = \alpha \ast A \ast \text{x} + \beta{} \ast \text{y}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <ul class="simple">
  <li>
   <p>
    Only
    <span class="pre">
     CUSPARSE_MATRIX_TYPE_GENERAL
    </span>
    is supported.
   </p>
  </li>
  <li>
   <p>
    The size of vector
    <span class="pre">
     x
    </span>
    should be
    <span class="math notranslate nohighlight">
     \((nb \ast blockDim)\)
    </span>
    at least, and the size of vector
    <span class="pre">
     y
    </span>
    should be
    <span class="math notranslate nohighlight">
     \((mb \ast blockDim)\)
    </span>
    at least; otherwise, the kernel may return
    <span class="pre">
     CUSPARSE_STATUS_EXECUTION_FAILED
    </span>
    because of an out-of-bounds array.
   </p>
  </li>
 </ul>
 <p>
  For example, suppose the user has a CSR format and wants to try
  <span class="pre">
   bsrmv()
  </span>
  , the following code demonstrates how to use
  <span class="pre">
   csr2bsr()
  </span>
  conversion and
  <span class="pre">
   bsrmv()
  </span>
  multiplication in single precision.
 </p>
 <pre><span class="c1">// Suppose that A is m x n sparse matrix represented by CSR format,</span>
<span class="c1">// hx is a host vector of size n, and hy is also a host vector of size m.</span>
<span class="c1">// m and n are not multiple of blockDim.</span>
<span class="c1">// step 1: transform CSR to BSR with column-major order</span>
<span class="kt">int</span><span class="n">base</span><span class="p">,</span><span class="n">nnz</span><span class="p">;</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">;</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="o">=</span><span class="n">CUSPARSE_DIRECTION_COLUMN</span><span class="p">;</span>
<span class="kt">int</span><span class="n">mb</span><span class="o">=</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="n">blockDim</span><span class="mi">-1</span><span class="p">)</span><span class="o">/</span><span class="n">blockDim</span><span class="p">;</span>
<span class="kt">int</span><span class="n">nb</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">blockDim</span><span class="mi">-1</span><span class="p">)</span><span class="o">/</span><span class="n">blockDim</span><span class="p">;</span>
<span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">bsrRowPtrC</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">mb</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
<span class="n">cusparseXcsr2bsrNnz</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dirA</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">,</span>
<span class="n">descrA</span><span class="p">,</span><span class="n">csrRowPtrA</span><span class="p">,</span><span class="n">csrColIndA</span><span class="p">,</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">descrC</span><span class="p">,</span><span class="n">bsrRowPtrC</span><span class="p">,</span><span class="o">&amp;</span><span class="n">nnzb</span><span class="p">);</span>
<span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">bsrColIndC</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">nnzb</span><span class="p">);</span>
<span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">bsrValC</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">blockDim</span><span class="o">*</span><span class="n">blockDim</span><span class="p">)</span><span class="o">*</span><span class="n">nnzb</span><span class="p">);</span>
<span class="n">cusparseScsr2bsr</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dirA</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">,</span>
<span class="n">descrA</span><span class="p">,</span><span class="n">csrValA</span><span class="p">,</span><span class="n">csrRowPtrA</span><span class="p">,</span><span class="n">csrColIndA</span><span class="p">,</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">descrC</span><span class="p">,</span><span class="n">bsrValC</span><span class="p">,</span><span class="n">bsrRowPtrC</span><span class="p">,</span><span class="n">bsrColIndC</span><span class="p">);</span>
<span class="c1">// step 2: allocate vector x and vector y large enough for bsrmv</span>
<span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">nb</span><span class="o">*</span><span class="n">blockDim</span><span class="p">));</span>
<span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">y</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">mb</span><span class="o">*</span><span class="n">blockDim</span><span class="p">));</span>
<span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">hx</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span>
<span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">hy</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="n">m</span><span class="p">,</span><span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span>
<span class="c1">// step 3: perform bsrmv</span>
<span class="n">cusparseSbsrmv</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dirA</span><span class="p">,</span><span class="n">transA</span><span class="p">,</span><span class="n">mb</span><span class="p">,</span><span class="n">nb</span><span class="p">,</span><span class="n">nnzb</span><span class="p">,</span><span class="o">&amp;</span><span class="n">alpha</span><span class="p">,</span>
<span class="n">descrC</span><span class="p">,</span><span class="n">bsrValC</span><span class="p">,</span><span class="n">bsrRowPtrC</span><span class="p">,</span><span class="n">bsrColIndC</span><span class="p">,</span><span class="n">blockDim</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="o">&amp;</span><span class="n">beta</span><span class="p">,</span><span class="n">y</span><span class="p">);</span>
</pre>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dir
     </span>
    </p>
   </td>
   <td>
    <p>
     storage format of blocks, either
     <span class="pre">
      CUSPARSE_DIRECTION_ROW
     </span>
     or
     <span class="pre">
      CUSPARSE_DIRECTION_COLUMN
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      trans
     </span>
    </p>
   </td>
   <td>
    <p>
     the operation
     <span class="math notranslate nohighlight">
      \(\text{op}(A)\)
     </span>
     . Only
     <span class="pre">
      CUSPARSE_OPERATION_NON_TRANSPOSE
     </span>
     is supported.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      mb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of block rows of matrix
     <span class="math notranslate nohighlight">
      \(A\)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of block columns of matrix
     <span class="math notranslate nohighlight">
      \(A\)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of nonzero blocks of matrix
     <span class="math notranslate nohighlight">
      \(A\)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      alpha
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; scalar used for multiplication.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descr
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="math notranslate nohighlight">
      \(A\)
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrVal
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnz
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(mb)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero blocks of matrix
     <span class="math notranslate nohighlight">
      \(A\)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrRowPtr
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      mb
     </span>
     <span class="math notranslate nohighlight">
      \(+ 1\)
     </span>
     elements that contains the start of every block row and the end of the last block row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrColInd
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnz
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(mb)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero blocks of matrix
     <span class="math notranslate nohighlight">
      \(A\)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      blockDim
     </span>
    </p>
   </td>
   <td>
    <p>
     block dimension of sparse matrix
     <span class="math notranslate nohighlight">
      \(A\)
     </span>
     , larger than zero.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      x
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; vector of
     <span class="math notranslate nohighlight">
      \(nb \ast blockDim\)
     </span>
     elements.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      beta
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; scalar used for multiplication. If
     <span class="pre">
      beta
     </span>
     is zero,
     <span class="pre">
      y
     </span>
     does not have to be a valid input.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      y
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; vector of
     <span class="math notranslate nohighlight">
      \(mb \ast blockDim\)
     </span>
     elements.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      y
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; updated vector.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   5.4.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#bsrxmv">
   cusparse&lt;t&gt;bsrxmv()
  </a>
  [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsrxmv-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSbsrxmv</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int</span><span class="n">sizeOfMask</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">bsrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrMaskPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrEndPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColInd</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDbsrxmv</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int</span><span class="n">sizeOfMask</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">bsrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrMaskPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrEndPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColInd</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCbsrxmv</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int</span><span class="n">sizeOfMask</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descr</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">bsrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrMaskPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrEndPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColInd</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZbsrxmv</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">trans</span><span class="p">,</span>
<span class="kt">int</span><span class="n">sizeOfMask</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descr</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">bsrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrMaskPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrEndPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColInd</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
</pre>
 <p>
  This function performs a
  <span class="pre">
   bsrmv
  </span>
  and a mask operation
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\text{y(mask)} = (\alpha \ast \text{op}(A) \ast \text{x} + \beta \ast \text{y})\text{(mask)}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="math notranslate nohighlight">
   \(A\text{ is an }(mb \ast blockDim) \times (nb \ast blockDim)\)
  </span>
  sparse matrix that is defined in BSRX storage format by the four arrays
  <span class="pre">
   bsrVal
  </span>
  ,
  <span class="pre">
   bsrRowPtr
  </span>
  ,
  <span class="pre">
   bsrEndPtr
  </span>
  , and
  <span class="pre">
   bsrColInd
  </span>
  );
  <span class="pre">
   x
  </span>
  and
  <span class="pre">
   y
  </span>
  are vectors;
  <span class="math notranslate nohighlight">
   \(\alpha\text{~and~}\beta\)
  </span>
  are scalars; and
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(\text{op}(A) = \begin{cases}
A &amp; \text{if trans == CUSPARSE_OPERATION_NON_TRANSPOSE} \\
A^{T} &amp; \text{if trans == CUSPARSE_OPERATION_TRANSPOSE} \\
A^{H} &amp; \text{if trans == CUSPARSE_OPERATION_CONJUGATE_TRANSPOSE} \\
\end{cases}\)
  </span>
 </p>
 <p>
  The mask operation is defined by array
  <span class="pre">
   bsrMaskPtr
  </span>
  which contains updated block row indices of
  <span class="math notranslate nohighlight">
   \(y\)
  </span>
  . If row
  <span class="math notranslate nohighlight">
   \(i\)
  </span>
  is not specified in
  <span class="pre">
   bsrMaskPtr
  </span>
  , then
  <span class="pre">
   bsrxmv()
  </span>
  does not touch row block
  <span class="math notranslate nohighlight">
   \(i\)
  </span>
  of
  <span class="math notranslate nohighlight">
   \(A\)
  </span>
  and
  <span class="math notranslate nohighlight">
   \(y\)
  </span>
  .
 </p>
 <p>
  For example, consider the
  <span class="math notranslate nohighlight">
   \(2 \times 3\)
  </span>
  block matrix
  <span class="math notranslate nohighlight">
   \(A\)
  </span>
  :
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\begin{matrix}
{A = \begin{bmatrix}
A_{11} &amp; A_{12} &amp; O \\
A_{21} &amp; A_{22} &amp; A_{23} \\
\end{bmatrix}} \\
\end{matrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  and its one-based BSR format (three vector form) is
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\begin{matrix}
\text{bsrVal} &amp; = &amp; \begin{bmatrix}
A_{11} &amp; A_{12} &amp; A_{21} &amp; A_{22} &amp; A_{23} \\
\end{bmatrix} \\
\text{bsrRowPtr} &amp; = &amp; \begin{bmatrix}
{1\phantom{.0}} &amp; {3\phantom{.0}} &amp; 6 \\
\end{bmatrix} \\
\text{bsrColInd} &amp; = &amp; \begin{bmatrix}
{1\phantom{.0}} &amp; {2\phantom{.0}} &amp; {1\phantom{.0}} &amp; {2\phantom{.0}} &amp; 3 \\
\end{bmatrix} \\
\end{matrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Suppose we want to do the following
  <span class="pre">
   bsrmv
  </span>
  operation on a matrix
  <span class="math notranslate nohighlight">
   \(\overset{}{A}\)
  </span>
  which is slightly different from
  <span class="math notranslate nohighlight">
   \(A\)
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\begin{bmatrix}
y_{1} \\
y_{2} \\
\end{bmatrix}:=alpha \ast (\widetilde{A} = \begin{bmatrix}
O &amp; O &amp; O \\
O &amp; A_{22} &amp; O \\
\end{bmatrix}) \ast \begin{bmatrix}
x_{1} \\
x_{2} \\
x_{3} \\
\end{bmatrix} + \begin{bmatrix}
y_{1} \\
{beta \ast y_{2}} \\
\end{bmatrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  We dont need to create another BSR format for the new matrix
  <span class="math notranslate nohighlight">
   \(\overset{}{A}\)
  </span>
  , all that we should do is to keep
  <span class="pre">
   bsrVal
  </span>
  and
  <span class="pre">
   bsrColInd
  </span>
  unchanged, but modify
  <span class="pre">
   bsrRowPtr
  </span>
  and add an additional array
  <span class="pre">
   bsrEndPtr
  </span>
  which points to the last nonzero elements per row of
  <span class="math notranslate nohighlight">
   \(\overset{}{A}\)
  </span>
  plus 1.
 </p>
 <p>
  For example, the following
  <span class="pre">
   bsrRowPtr
  </span>
  and
  <span class="pre">
   bsrEndPtr
  </span>
  can represent matrix
  <span class="math notranslate nohighlight">
   \(\overset{}{A}\)
  </span>
  :
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\begin{matrix}
\text{bsrRowPtr} &amp; = &amp; \begin{bmatrix}
{1\phantom{.0}} &amp; 4 \\
\end{bmatrix} \\
\text{bsrEndPtr} &amp; = &amp; \begin{bmatrix}
{1\phantom{.0}} &amp; 5 \\
\end{bmatrix} \\
\end{matrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Further we can use a mask operator (specified by array
  <span class="pre">
   bsrMaskPtr
  </span>
  ) to update particular block row indices of
  <span class="math notranslate nohighlight">
   \(y\)
  </span>
  only because
  <span class="math notranslate nohighlight">
   \(y_{1}\)
  </span>
  is never changed. In this case,
  <span class="pre">
   bsrMaskPtr
  </span>
  <span class="math notranslate nohighlight">
   \(=\)
  </span>
  [2] and
  <span class="pre">
   sizeOfMask
  </span>
  =1.
 </p>
 <p>
  The mask operator is equivalent to the following operation:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\begin{bmatrix}
? \\
y_{2} \\
\end{bmatrix}:=alpha \ast \begin{bmatrix}
? &amp; ? &amp; ? \\
O &amp; A_{22} &amp; O \\
\end{bmatrix} \ast \begin{bmatrix}
x_{1} \\
x_{2} \\
x_{3} \\
\end{bmatrix} + beta \ast \begin{bmatrix}
? \\
y_{2} \\
\end{bmatrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  If a block row is not present in the
  <span class="pre">
   bsrMaskPtr
  </span>
  , then no calculation is performed on that row, and the corresponding value in
  <span class="pre">
   y
  </span>
  is unmodified. The question mark ? is used to inidcate row blocks not in
  <span class="pre">
   bsrMaskPtr
  </span>
  .
 </p>
 <p>
  In this case, first row block is not present in
  <span class="pre">
   bsrMaskPtr
  </span>
  , so
  <span class="pre">
   bsrRowPtr[0]
  </span>
  and
  <span class="pre">
   bsrEndPtr[0]
  </span>
  are not touched also.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\begin{matrix}
\text{bsrRowPtr} &amp; = &amp; \begin{bmatrix}
{?\phantom{.0}} &amp; 4 \\
\end{bmatrix} \\
\text{bsrEndPtr} &amp; = &amp; \begin{bmatrix}
{?\phantom{.0}} &amp; 5 \\
\end{bmatrix} \\
\end{matrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   bsrxmv()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  A couple of comments on
  <span class="pre">
   bsrxmv()
  </span>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    Only
    <span class="pre">
     blockDim
    </span>
    <span class="pre">
     &gt;
    </span>
    <span class="pre">
     1
    </span>
    is supported
   </p>
  </li>
  <li>
   <p>
    Only
    <span class="pre">
     CUSPARSE_OPERATION_NON_TRANSPOSE
    </span>
    and
    <span class="pre">
     CUSPARSE_MATRIX_TYPE_GENERAL
    </span>
    are supported.
   </p>
  </li>
  <li>
   <p>
    Parameters
    <span class="pre">
     bsrMaskPtr
    </span>
    ,
    <span class="pre">
     bsrRowPtr
    </span>
    ,
    <span class="pre">
     bsrEndPtr
    </span>
    and
    <span class="pre">
     bsrColInd
    </span>
    are consistent with base index, either one-based or zero-based. The above example is one-based.
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dir
     </span>
    </p>
   </td>
   <td>
    <p>
     storage format of blocks, either
     <span class="pre">
      CUSPARSE_DIRECTION_ROW
     </span>
     or
     <span class="pre">
      CUSPARSE_DIRECTION_COLUMN
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      trans
     </span>
    </p>
   </td>
   <td>
    <p>
     the operation
     <span class="math notranslate nohighlight">
      \(\text{op}(A)\)
     </span>
     . Only
     <span class="pre">
      CUSPARSE_OPERATION_NON_TRANSPOSE
     </span>
     is supported.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      sizeOfMask
     </span>
    </p>
   </td>
   <td>
    <p>
     number of updated block rows of
     <span class="math notranslate nohighlight">
      \(y\)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      mb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of block rows of matrix
     <span class="math notranslate nohighlight">
      \(A\)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of block columns of matrix
     <span class="math notranslate nohighlight">
      \(A\)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnzb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of nonzero blocks of matrix
     <span class="math notranslate nohighlight">
      \(A\)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      alpha
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; scalar used for multiplication.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descr
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="math notranslate nohighlight">
      \(A\)
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrVal
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnz
     </span>
     nonzero blocks of matrix
     <span class="math notranslate nohighlight">
      \(A\)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrMaskPtr
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      sizeOfMask
     </span>
     elements that contains the indices corresponding to updated block rows.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrRowPtr
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      mb
     </span>
     elements that contains the start of every block row.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrEndPtr
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      mb
     </span>
     elements that contains the end of the every block row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrColInd
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzb
     </span>
     column indices of the nonzero blocks of matrix
     <span class="math notranslate nohighlight">
      \(A\)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      blockDim
     </span>
    </p>
   </td>
   <td>
    <p>
     block dimension of sparse matrix
     <span class="math notranslate nohighlight">
      \(A\)
     </span>
     , larger than zero.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      x
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; vector of
     <span class="math notranslate nohighlight">
      \(nb \ast blockDim\)
     </span>
     elements.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      beta
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; scalar used for multiplication. If
     <span class="pre">
      beta
     </span>
     is zero,
     <span class="pre">
      y
     </span>
     does not have to be a valid input.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      y
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; vector of
     <span class="math notranslate nohighlight">
      \(mb \ast blockDim\)
     </span>
     elements.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   5.4.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#bsrsv2_bufferSize">
   cusparse&lt;t&gt;bsrsv2_bufferSize()
  </a>
  [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsrsv2-buffersize-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSbsrsv2_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrsv2Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDbsrsv2_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrsv2Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCbsrsv2_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrsv2Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZbsrsv2_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrsv2Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>
</pre>
 <p>
  This function returns size of the buffer used in
  <span class="pre">
   bsrsv2
  </span>
  , a new sparse triangular linear system
  <span class="pre">
   op(A)*y
  </span>
  <span class="pre">
   =
  </span>
  <span class="math notranslate nohighlight">
   \(\alpha\)
  </span>
  <span class="pre">
   x
  </span>
  .
 </p>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   (mb*blockDim)x(mb*blockDim)
  </span>
  sparse matrix that is defined in BSR storage format by the three arrays
  <span class="pre">
   bsrValA
  </span>
  ,
  <span class="pre">
   bsrRowPtrA
  </span>
  , and
  <span class="pre">
   bsrColIndA
  </span>
  );
  <span class="pre">
   x
  </span>
  and
  <span class="pre">
   y
  </span>
  are the right-hand-side and the solution vectors;
  <span class="math notranslate nohighlight">
   \(\alpha\)
  </span>
  is a scalar; and
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(\text{op}(A) = \begin{cases}
A &amp; \text{if trans == CUSPARSE_OPERATION_NON_TRANSPOSE} \\
A^{T} &amp; \text{if trans == CUSPARSE_OPERATION_TRANSPOSE} \\
A^{H} &amp; \text{if trans == CUSPARSE_OPERATION_CONJUGATE_TRANSPOSE} \\
\end{cases}\)
  </span>
 </p>
 <p>
  Although there are six combinations in terms of parameter
  <span class="pre">
   trans
  </span>
  and the upper (lower) triangular part of
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   bsrsv2_bufferSize()
  </span>
  returns the maximum size buffer among these combinations. The buffer size depends on the dimensions
  <span class="pre">
   mb
  </span>
  ,
  <span class="pre">
   blockDim
  </span>
  , and the number of nonzero blocks of the matrix
  <span class="pre">
   nnzb
  </span>
  . If the user changes the matrix, it is necessary to call
  <span class="pre">
   bsrsv2_bufferSize()
  </span>
  again to have the correct buffer size; otherwise a segmentation fault may occur.
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dirA
     </span>
    </p>
   </td>
   <td>
    <p>
     storage format of blocks, either
     <span class="pre">
      CUSPARSE_DIRECTION_ROW
     </span>
     or
     <span class="pre">
      CUSPARSE_DIRECTION_COLUMN
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      transA
     </span>
    </p>
   </td>
   <td>
    <p>
     the operation
     <span class="math notranslate nohighlight">
      \(\text{op}(A)\)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      mb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of block rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnzb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     , while the supported diagonal types are
     <span class="pre">
      CUSPARSE_DIAG_TYPE_UNIT
     </span>
     and
     <span class="pre">
      CUSPARSE_DIAG_TYPE_NON_UNIT
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzb
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      bsrRowPtrA(mb)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      bsrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      mb
     </span>
     <span class="math notranslate nohighlight">
      \(+ 1\)
     </span>
     elements that contains the start of every block row and the end of the last block row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzb
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      bsrRowPtrA(mb)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      bsrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      blockDim
     </span>
    </p>
   </td>
   <td>
    <p>
     block dimension of sparse matrix A; must be larger than zero.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     record of internal states based on different algorithms.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBufferSizeInBytes
     </span>
    </p>
   </td>
   <td>
    <p>
     number of bytes of the buffer used in the
     <span class="pre">
      bsrsv2_analysis()
     </span>
     and
     <span class="pre">
      bsrsv2_solve()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   5.4.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#bsrsv2_analysis">
   cusparse&lt;t&gt;bsrsv2_analysis()
  </a>
  [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsrsv2-analysis-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSbsrsv2_analysis</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrsv2Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDbsrsv2_analysis</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrsv2Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDbsrsv2_analysis</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrsv2Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZbsrsv2_analysis</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrsv2Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function performs the analysis phase of
  <span class="pre">
   bsrsv2
  </span>
  , a new sparse triangular linear system
  <span class="pre">
   op(A)*y
  </span>
  <span class="pre">
   =
  </span>
  <span class="math notranslate nohighlight">
   \(\alpha\)
  </span>
  <span class="pre">
   x
  </span>
  .
 </p>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   (mb*blockDim)x(mb*blockDim)
  </span>
  sparse matrix that is defined in BSR storage format by the three arrays
  <span class="pre">
   bsrValA
  </span>
  ,
  <span class="pre">
   bsrRowPtrA
  </span>
  , and
  <span class="pre">
   bsrColIndA
  </span>
  );
  <span class="pre">
   x
  </span>
  and
  <span class="pre">
   y
  </span>
  are the right-hand side and the solution vectors;
  <span class="math notranslate nohighlight">
   \(\alpha\)
  </span>
  is a scalar; and
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(\text{op}(A) = \begin{cases}
A &amp; \text{if trans == CUSPARSE_OPERATION_NON_TRANSPOSE} \\
A^{T} &amp; \text{if trans == CUSPARSE_OPERATION_TRANSPOSE} \\
A^{H} &amp; \text{if trans == CUSPARSE_OPERATION_CONJUGATE_TRANSPOSE} \\
\end{cases}\)
  </span>
 </p>
 <p>
  The block of BSR format is of size
  <span class="pre">
   blockDim*blockDim
  </span>
  , stored as column-major or row-major as determined by parameter
  <span class="pre">
   dirA
  </span>
  , which is either
  <span class="pre">
   CUSPARSE_DIRECTION_COLUMN
  </span>
  or
  <span class="pre">
   CUSPARSE_DIRECTION_ROW
  </span>
  . The matrix type must be
  <span class="pre">
   CUSPARSE_MATRIX_TYPE_GENERAL
  </span>
  , and the fill mode and diagonal type are ignored.
 </p>
 <p>
  It is expected that this function will be executed only once for a given matrix and a particular operation type.
 </p>
 <p>
  This function requires a buffer size returned by
  <span class="pre">
   bsrsv2_bufferSize()
  </span>
  . The address of
  <span class="pre">
   pBuffer
  </span>
  must be multiple of 128 bytes. If it is not,
  <span class="pre">
   CUSPARSE_STATUS_INVALID_VALUE
  </span>
  is returned.
 </p>
 <p>
  Function
  <span class="pre">
   bsrsv2_analysis()
  </span>
  reports a structural zero and computes level information, which stored in the opaque structure
  <span class="pre">
   info
  </span>
  . The level information can extract more parallelism for a triangular solver. However
  <span class="pre">
   bsrsv2_solve()
  </span>
  can be done without level information. To disable level information, the user needs to specify the policy of the triangular solver as
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_NO_LEVEL
  </span>
  .
 </p>
 <p>
  Function
  <span class="pre">
   bsrsv2_analysis()
  </span>
  always reports the first structural zero, even when parameter
  <span class="pre">
   policy
  </span>
  is
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_NO_LEVEL
  </span>
  . No structural zero is reported if
  <span class="pre">
   CUSPARSE_DIAG_TYPE_UNIT
  </span>
  is specified, even if block
  <span class="pre">
   A(j,j)
  </span>
  is missing for some
  <span class="pre">
   j
  </span>
  . The user needs to call
  <span class="pre">
   cusparseXbsrsv2_zeroPivot()
  </span>
  to know where the structural zero is.
 </p>
 <p>
  It is the users choice whether to call
  <span class="pre">
   bsrsv2_solve()
  </span>
  if
  <span class="pre">
   bsrsv2_analysis()
  </span>
  reports a structural zero. In this case, the user can still call
  <span class="pre">
   bsrsv2_solve()
  </span>
  , which will return a numerical zero at the same position as a structural zero. However the result
  <span class="pre">
   x
  </span>
  is meaningless.
 </p>
 <ul class="simple">
  <li>
   <p>
    This function requires temporary extra storage that is allocated internally
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dirA
     </span>
    </p>
   </td>
   <td>
    <p>
     storage format of blocks, either
     <span class="pre">
      CUSPARSE_DIRECTION_ROW
     </span>
     or
     <span class="pre">
      CUSPARSE_DIRECTION_COLUMN
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      transA
     </span>
    </p>
   </td>
   <td>
    <p>
     the operation
     <span class="math notranslate nohighlight">
      \(\text{op}(A)\)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      mb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of block rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnzb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     , while the supported diagonal types are
     <span class="pre">
      CUSPARSE_DIAG_TYPE_UNIT
     </span>
     and
     <span class="pre">
      CUSPARSE_DIAG_TYPE_NON_UNIT
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzb
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      bsrRowPtrA(mb)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      bsrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      mb
     </span>
     <span class="math notranslate nohighlight">
      \(+ 1\)
     </span>
     elements that contains the start of every block row and the end of the last block row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzb
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      bsrRowPtrA(mb)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      bsrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      blockDim
     </span>
    </p>
   </td>
   <td>
    <p>
     block dimension of sparse matrix A, larger than zero.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     structure initialized using
     <span class="pre">
      cusparseCreateBsrsv2Info()
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      policy
     </span>
    </p>
   </td>
   <td>
    <p>
     the supported policies are
     <span class="pre">
      CUSPARSE_SOLVE_POLICY_NO_LEVEL
     </span>
     and
     <span class="pre">
      CUSPARSE_SOLVE_POLICY_USE_LEVEL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     buffer allocated by the user, the size is return by
     <span class="pre">
      bsrsv2_bufferSize()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   5.4.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#bsrsv2_solve">
   cusparse&lt;t&gt;bsrsv2_solve()
  </a>
  [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsrsv2-solve-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSbsrsv2_solve</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrsv2Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">y</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDbsrsv2_solve</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrsv2Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">y</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCbsrsv2_solve</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrsv2Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">y</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZbsrsv2_solve</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrsv2Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">y</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function performs the solve phase of
  <span class="pre">
   bsrsv2
  </span>
  , a new sparse triangular linear system
  <span class="pre">
   op(A)*y
  </span>
  <span class="pre">
   =
  </span>
  <span class="math notranslate nohighlight">
   \(\alpha\)
  </span>
  <span class="pre">
   x
  </span>
  .
 </p>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   (mb*blockDim)x(mb*blockDim)
  </span>
  sparse matrix that is defined in BSR storage format by the three arrays
  <span class="pre">
   bsrValA
  </span>
  ,
  <span class="pre">
   bsrRowPtrA
  </span>
  , and
  <span class="pre">
   bsrColIndA
  </span>
  );
  <span class="pre">
   x
  </span>
  and
  <span class="pre">
   y
  </span>
  are the right-hand-side and the solution vectors;
  <span class="math notranslate nohighlight">
   \(\alpha\)
  </span>
  is a scalar; and
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(\text{op}(A) = \begin{cases}
A &amp; \text{if trans == CUSPARSE_OPERATION_NON_TRANSPOSE} \\
A^{T} &amp; \text{if trans == CUSPARSE_OPERATION_TRANSPOSE} \\
A^{H} &amp; \text{if trans == CUSPARSE_OPERATION_CONJUGATE_TRANSPOSE} \\
\end{cases}\)
  </span>
 </p>
 <p>
  The block in BSR format is of size
  <span class="pre">
   blockDim*blockDim
  </span>
  , stored as column-major or row-major as determined by parameter
  <span class="pre">
   dirA
  </span>
  , which is either
  <span class="pre">
   CUSPARSE_DIRECTION_COLUMN
  </span>
  or
  <span class="pre">
   CUSPARSE_DIRECTION_ROW
  </span>
  . The matrix type must be
  <span class="pre">
   CUSPARSE_MATRIX_TYPE_GENERAL
  </span>
  , and the fill mode and diagonal type are ignored. Function
  <span class="pre">
   bsrsv02_solve()
  </span>
  can support an arbitrary
  <span class="pre">
   blockDim
  </span>
  .
 </p>
 <p>
  This function may be executed multiple times for a given matrix and a particular operation type.
 </p>
 <p>
  This function requires a buffer size returned by
  <span class="pre">
   bsrsv2_bufferSize()
  </span>
  . The address of
  <span class="pre">
   pBuffer
  </span>
  must be multiple of 128 bytes. If it is not,
  <span class="pre">
   CUSPARSE_STATUS_INVALID_VALUE
  </span>
  is returned.
 </p>
 <p>
  Although
  <span class="pre">
   bsrsv2_solve()
  </span>
  can be done without level information, the user still needs to be aware of consistency. If
  <span class="pre">
   bsrsv2_analysis()
  </span>
  is called with policy
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_USE_LEVEL
  </span>
  ,
  <span class="pre">
   bsrsv2_solve()
  </span>
  can be run with or without levels. On the other hand, if
  <span class="pre">
   bsrsv2_analysis()
  </span>
  is called with
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_NO_LEVEL
  </span>
  ,
  <span class="pre">
   bsrsv2_solve()
  </span>
  can only accept
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_NO_LEVEL
  </span>
  ; otherwise,
  <span class="pre">
   CUSPARSE_STATUS_INVALID_VALUE
  </span>
  is returned.
 </p>
 <p>
  The level information may not improve the performance, but may spend extra time doing analysis. For example, a tridiagonal matrix has no parallelism. In this case,
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_NO_LEVEL
  </span>
  performs better than
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_USE_LEVEL
  </span>
  . If the user has an iterative solver, the best approach is to do
  <span class="pre">
   bsrsv2_analysis()
  </span>
  with
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_USE_LEVEL
  </span>
  once. Then do
  <span class="pre">
   bsrsv2_solve()
  </span>
  with
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_NO_LEVEL
  </span>
  in the first run, and with
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_USE_LEVEL
  </span>
  in the second run, and pick the fastest one to perform the remaining iterations.
 </p>
 <p>
  Function
  <span class="pre">
   bsrsv02_solve()
  </span>
  has the same behavior as
  <span class="pre">
   csrsv02_solve()
  </span>
  . That is,
  <span class="pre">
   bsr2csr(bsrsv02(A))
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   csrsv02(bsr2csr(A))
  </span>
  . The numerical zero of
  <span class="pre">
   csrsv02_solve()
  </span>
  means there exists some zero
  <span class="pre">
   A(j,j)
  </span>
  . The numerical zero of
  <span class="pre">
   bsrsv02_solve()
  </span>
  means there exists some block
  <span class="pre">
   A(j,j)
  </span>
  that is not invertible.
 </p>
 <p>
  Function
  <span class="pre">
   bsrsv2_solve()
  </span>
  reports the first numerical zero, including a structural zero. No numerical zero is reported if
  <span class="pre">
   CUSPARSE_DIAG_TYPE_UNIT
  </span>
  is specified, even if
  <span class="pre">
   A(j,j)
  </span>
  is not invertible for some
  <span class="pre">
   j
  </span>
  . The user needs to call
  <span class="pre">
   cusparseXbsrsv2_zeroPivot()
  </span>
  to know where the numerical zero is.
 </p>
 <p>
  The function supports the following properties if
  <span class="pre">
   pBuffer
  </span>
  <span class="pre">
   !=
  </span>
  <span class="pre">
   NULL
  </span>
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  For example, suppose L is a lower triangular matrix with unit diagonal, then the following code solves
  <span class="pre">
   L*y=x
  </span>
  by level information.
 </p>
 <pre><span class="c1">// Suppose that L is m x m sparse matrix represented by BSR format,</span>
<span class="c1">// The number of block rows/columns is mb, and</span>
<span class="c1">// the number of nonzero blocks is nnzb.</span>
<span class="c1">// L is lower triangular with unit diagonal.</span>
<span class="c1">// Assumption:</span>
<span class="c1">// - dimension of matrix L is m(=mb*blockDim),</span>
<span class="c1">// - matrix L has nnz(=nnzb*blockDim*blockDim) nonzero elements,</span>
<span class="c1">// - handle is already created by cusparseCreate(),</span>
<span class="c1">// - (d_bsrRowPtr, d_bsrColInd, d_bsrVal) is BSR of L on device memory,</span>
<span class="c1">// - d_x is right hand side vector on device memory.</span>
<span class="c1">// - d_y is solution vector on device memory.</span>
<span class="c1">// - d_x and d_y are of size m.</span>
<span class="n">cusparseMatDescr_t</span><span class="n">descr</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">bsrsv2Info_t</span><span class="n">info</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span><span class="n">pBufferSize</span><span class="p">;</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span><span class="n">structural_zero</span><span class="p">;</span>
<span class="kt">int</span><span class="n">numerical_zero</span><span class="p">;</span>
<span class="k">const</span><span class="kt">double</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.</span><span class="p">;</span>
<span class="k">const</span><span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="o">=</span><span class="n">CUSPARSE_SOLVE_POLICY_USE_LEVEL</span><span class="p">;</span>
<span class="k">const</span><span class="n">cusparseOperation_t</span><span class="n">trans</span><span class="o">=</span><span class="n">CUSPARSE_OPERATION_NON_TRANSPOSE</span><span class="p">;</span>
<span class="k">const</span><span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="o">=</span><span class="n">CUSPARSE_DIRECTION_COLUMN</span><span class="p">;</span>

<span class="c1">// step 1: create a descriptor which contains</span>
<span class="c1">// - matrix L is base-1</span>
<span class="c1">// - matrix L is lower triangular</span>
<span class="c1">// - matrix L has unit diagonal, specified by parameter CUSPARSE_DIAG_TYPE_UNIT</span>
<span class="c1">//   (L may not have all diagonal elements.)</span>
<span class="n">cusparseCreateMatDescr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">descr</span><span class="p">);</span>
<span class="n">cusparseSetMatIndexBase</span><span class="p">(</span><span class="n">descr</span><span class="p">,</span><span class="n">CUSPARSE_INDEX_BASE_ONE</span><span class="p">);</span>
<span class="n">cusparseSetMatFillMode</span><span class="p">(</span><span class="n">descr</span><span class="p">,</span><span class="n">CUSPARSE_FILL_MODE_LOWER</span><span class="p">);</span>
<span class="n">cusparseSetMatDiagType</span><span class="p">(</span><span class="n">descr</span><span class="p">,</span><span class="n">CUSPARSE_DIAG_TYPE_UNIT</span><span class="p">);</span>

<span class="c1">// step 2: create a empty info structure</span>
<span class="n">cusparseCreateBsrsv2Info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>

<span class="c1">// step 3: query how much memory used in bsrsv2, and allocate the buffer</span>
<span class="n">cusparseDbsrsv2_bufferSize</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span><span class="n">trans</span><span class="p">,</span><span class="n">mb</span><span class="p">,</span><span class="n">nnzb</span><span class="p">,</span><span class="n">descr</span><span class="p">,</span>
<span class="n">d_bsrVal</span><span class="p">,</span><span class="n">d_bsrRowPtr</span><span class="p">,</span><span class="n">d_bsrColInd</span><span class="p">,</span><span class="n">blockDim</span><span class="p">,</span><span class="o">&amp;</span><span class="n">pBufferSize</span><span class="p">);</span>

<span class="c1">// pBuffer returned by cudaMalloc is automatically aligned to 128 bytes.</span>
<span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pBuffer</span><span class="p">,</span><span class="n">pBufferSize</span><span class="p">);</span>

<span class="c1">// step 4: perform analysis</span>
<span class="n">cusparseDbsrsv2_analysis</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span><span class="n">trans</span><span class="p">,</span><span class="n">mb</span><span class="p">,</span><span class="n">nnzb</span><span class="p">,</span><span class="n">descr</span><span class="p">,</span>
<span class="n">d_bsrVal</span><span class="p">,</span><span class="n">d_bsrRowPtr</span><span class="p">,</span><span class="n">d_bsrColInd</span><span class="p">,</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">info</span><span class="p">,</span><span class="n">policy</span><span class="p">,</span><span class="n">pBuffer</span><span class="p">);</span>
<span class="c1">// L has unit diagonal, so no structural zero is reported.</span>
<span class="n">status</span><span class="o">=</span><span class="n">cusparseXbsrsv2_zeroPivot</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">info</span><span class="p">,</span><span class="o">&amp;</span><span class="n">structural_zero</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">CUSPARSE_STATUS_ZERO_PIVOT</span><span class="o">==</span><span class="n">status</span><span class="p">){</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"L(%d,%d) is missing</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">structural_zero</span><span class="p">,</span><span class="n">structural_zero</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// step 5: solve L*y = x</span>
<span class="n">cusparseDbsrsv2_solve</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span><span class="n">trans</span><span class="p">,</span><span class="n">mb</span><span class="p">,</span><span class="n">nnzb</span><span class="p">,</span><span class="o">&amp;</span><span class="n">alpha</span><span class="p">,</span><span class="n">descr</span><span class="p">,</span>
<span class="n">d_bsrVal</span><span class="p">,</span><span class="n">d_bsrRowPtr</span><span class="p">,</span><span class="n">d_bsrColInd</span><span class="p">,</span><span class="n">blockDim</span><span class="p">,</span><span class="n">info</span><span class="p">,</span>
<span class="n">d_x</span><span class="p">,</span><span class="n">d_y</span><span class="p">,</span><span class="n">policy</span><span class="p">,</span><span class="n">pBuffer</span><span class="p">);</span>
<span class="c1">// L has unit diagonal, so no numerical zero is reported.</span>
<span class="n">status</span><span class="o">=</span><span class="n">cusparseXbsrsv2_zeroPivot</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">info</span><span class="p">,</span><span class="o">&amp;</span><span class="n">numerical_zero</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">CUSPARSE_STATUS_ZERO_PIVOT</span><span class="o">==</span><span class="n">status</span><span class="p">){</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"L(%d,%d) is zero</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">numerical_zero</span><span class="p">,</span><span class="n">numerical_zero</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// step 6: free resources</span>
<span class="n">cudaFree</span><span class="p">(</span><span class="n">pBuffer</span><span class="p">);</span>
<span class="n">cusparseDestroyBsrsv2Info</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
<span class="n">cusparseDestroyMatDescr</span><span class="p">(</span><span class="n">descr</span><span class="p">);</span>
<span class="n">cusparseDestroy</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
</pre>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dirA
     </span>
    </p>
   </td>
   <td>
    <p>
     storage format of blocks, either
     <span class="pre">
      CUSPARSE_DIRECTION_ROW
     </span>
     or
     <span class="pre">
      CUSPARSE_DIRECTION_COLUMN
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      transA
     </span>
    </p>
   </td>
   <td>
    <p>
     the operation
     <span class="math notranslate nohighlight">
      \(\text{op}(A)\)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      mb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of block rows and block columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      alpha
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; scalar used for multiplication.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     , while the supported diagonal types are
     <span class="pre">
      CUSPARSE_DIAG_TYPE_UNIT
     </span>
     and
     <span class="pre">
      CUSPARSE_DIAG_TYPE_NON_UNIT
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzb
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      bsrRowPtrA(mb)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      bsrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      mb
     </span>
     <span class="math notranslate nohighlight">
      \(+ 1\)
     </span>
     elements that contains the start of every block row and the end of the last block row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzb
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      bsrRowPtrA(mb)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      bsrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      blockDim
     </span>
    </p>
   </td>
   <td>
    <p>
     block dimension of sparse matrix
     <span class="pre">
      A
     </span>
     , larger than zero.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     structure with information collected during the analysis phase (that should have been passed to the solve phase unchanged).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      x
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; right-hand-side vector of size
     <span class="pre">
      m
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      policy
     </span>
    </p>
   </td>
   <td>
    <p>
     the supported policies are
     <span class="pre">
      CUSPARSE_SOLVE_POLICY_NO_LEVEL
     </span>
     and
     <span class="pre">
      CUSPARSE_SOLVE_POLICY_USE_LEVEL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     buffer allocated by the user, the size is returned by
     <span class="pre">
      bsrsv2_bufferSize()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      y
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; solution vector of size
     <span class="pre">
      m
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   5.4.6.
  </span>
  cusparseXbsrsv2_zeroPivot() [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsexbsrsv2-zeropivot-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseXbsrsv2_zeroPivot</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">bsrsv2Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">position</span><span class="p">)</span>
</pre>
 <p>
  If the returned error code is
  <span class="pre">
   CUSPARSE_STATUS_ZERO_PIVOT
  </span>
  ,
  <span class="pre">
   position=j
  </span>
  means
  <span class="pre">
   A(j,j)
  </span>
  is either structural zero or numerical zero (singular block). Otherwise
  <span class="pre">
   position=-1
  </span>
  .
 </p>
 <p>
  The
  <span class="pre">
   position
  </span>
  can be 0-based or 1-based, the same as the matrix.
 </p>
 <p>
  Function
  <span class="pre">
   cusparseXbsrsv2_zeroPivot()
  </span>
  is a blocking call. It calls
  <span class="pre">
   cudaDeviceSynchronize()
  </span>
  to make sure all previous kernels are done.
 </p>
 <p>
  The
  <span class="pre">
   position
  </span>
  can be in the host memory or device memory. The user can set the proper mode with
  <span class="pre">
   cusparseSetPointerMode()
  </span>
  .
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      info
     </span>
     contains a structural zero or numerical zero if the user already called
     <span class="pre">
      bsrsv2_analysis()
     </span>
     or
     <span class="pre">
      bsrsv2_solve()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      position
     </span>
    </p>
   </td>
   <td>
    <p>
     if no structural or numerical zero,
     <span class="pre">
      position
     </span>
     is -1; otherwise if
     <span class="pre">
      A(j,j)
     </span>
     is missing or
     <span class="pre">
      U(j,j)
     </span>
     is zero,
     <span class="pre">
      position=j
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   5.4.7.
  </span>
  cusparse&lt;t&gt;gemvi()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-gemvi" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSgemvi_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSize</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDgemvi_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSize</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCgemvi_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSize</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZgemvi_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSize</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSgemvi</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">xInd</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">y</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="n">idxBase</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDgemvi</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">xInd</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">y</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="n">idxBase</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCgemvi</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">xInd</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">y</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="n">idxBase</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZgemvi</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">xInd</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">y</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="n">idxBase</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function performs the matrix-vector operation
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\text{y} = \alpha \ast \text{op}(A) \ast \text{x} + \beta \ast \text{y}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   mn
  </span>
  dense matrix and a sparse vector
  <span class="pre">
   x
  </span>
  that is defined in a sparse storage format by the two arrays
  <span class="pre">
   xVal,
  </span>
  <span class="pre">
   xInd
  </span>
  of length
  <span class="pre">
   nnz
  </span>
  , and
  <span class="pre">
   y
  </span>
  is a dense vector;
  <span class="math notranslate nohighlight">
   \(\alpha\)
  </span>
  and
  <span class="math notranslate nohighlight">
   \(\beta\)
  </span>
  are scalars; and
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(\text{op}(A) = \begin{cases}
A &amp; \text{if trans == CUSPARSE_OPERATION_NON_TRANSPOSE} \\
A^{T} &amp; \text{if trans == CUSPARSE_OPERATION_TRANSPOSE} \\
\end{cases}\)
  </span>
 </p>
 <p>
  To simplify the implementation, we have not (yet) optimized the transpose multiple case. We recommend the following for users interested in this case.
 </p>
 <ol class="arabic simple">
  <li>
   <p>
    Convert the matrix from CSR to CSC format using one of the
    <span class="pre">
     csr2csc()
    </span>
    functions. Notice that by interchanging the rows and columns of the result you are implicitly transposing the matrix.
   </p>
  </li>
  <li>
   <p>
    Call the
    <span class="pre">
     gemvi()
    </span>
    function with the
    <span class="pre">
     cusparseOperation_t
    </span>
    parameter set to
    <span class="pre">
     CUSPARSE_OPERATION_NON_TRANSPOSE
    </span>
    and with the interchanged rows and columns of the matrix stored in CSC format. This (implicitly) multiplies the vector by the transpose of the matrix in the original CSR format.
   </p>
   <ul class="simple">
    <li>
     <p>
      The routine requires no extra storage
     </p>
    </li>
    <li>
     <p>
      The routine supports asynchronous execution
     </p>
    </li>
    <li>
     <p>
      The routine supports CUDA graph capture
     </p>
    </li>
   </ul>
  </li>
 </ol>
 <p>
  The function
  <span class="pre">
   cusparse&lt;t&gt;gemvi_bufferSize()
  </span>
  returns the size of buffer used in
  <span class="pre">
   cusparse&lt;t&gt;gemvi()
  </span>
  .
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      trans
     </span>
    </p>
   </td>
   <td>
    <p>
     The operation
     <span class="math notranslate nohighlight">
      \(\text{op}(A)\)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      alpha
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; scalar used for multiplication.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     The pointer to dense matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     Size of the leading dimension of
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of nonzero elements of vector
     <span class="pre">
      x
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      x
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; sparse vector of
     <span class="pre">
      nnz
     </span>
     elements of size
     <span class="pre">
      n
     </span>
     if
     <span class="math notranslate nohighlight">
      \(\text{op}(A)=A\)
     </span>
     , and size
     <span class="pre">
      m
     </span>
     if
     <span class="math notranslate nohighlight">
      \(\text{op}(A)=A^{T}\)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      xInd
     </span>
    </p>
   </td>
   <td>
    <p>
     Indices of non-zero values in
     <span class="pre">
      x
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      beta
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; scalar used for multiplication. If
     <span class="pre">
      beta
     </span>
     is zero,
     <span class="pre">
      y
     </span>
     does not have to be a valid input.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      y
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense vector of
     <span class="pre">
      m
     </span>
     elements if
     <span class="math notranslate nohighlight">
      \(\text{op}(A)=A\)
     </span>
     , and
     <span class="pre">
      n
     </span>
     elements if
     <span class="math notranslate nohighlight">
      \(\text{op}(A)=A^{T}\)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      idxBase
     </span>
    </p>
   </td>
   <td>
    <p>
     0 or 1, for 0 based or 1 based indexing, respectively.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBufferSize
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of elements needed the buffer used in
     <span class="pre">
      cusparse&lt;t&gt;gemvi()
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     Working space buffer.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      y
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; updated dense vector.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h2>
  <span class="section-number">
   5.5.
  </span>
  cuSPARSE Level 3 Function Reference
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-level-3-function-reference" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  This chapter describes sparse linear algebra functions that perform operations between sparse and (usually tall) dense matrices.
 </p>
 <h3>
  <span class="section-number">
   5.5.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#bsrmm">
   cusparse&lt;t&gt;bsrmm()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsrmm" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSbsrmm</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">kb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">C</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldc</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDbsrmm</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">kb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">C</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldc</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCbsrmm</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">kb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">C</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldc</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZbsrmm</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">kb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">C</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldc</span><span class="p">)</span>
</pre>
 <p>
  This function performs one of the following matrix-matrix operations:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(C = \alpha \ast \text{op}(A) \ast \text{op}(B) + \beta \ast C\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   mbkb
  </span>
  sparse matrix that is defined in BSR storage format by the three arrays
  <span class="pre">
   bsrValA
  </span>
  ,
  <span class="pre">
   bsrRowPtrA
  </span>
  , and
  <span class="pre">
   bsrColIndA
  </span>
  ;
  <span class="pre">
   B
  </span>
  and
  <span class="pre">
   C
  </span>
  are dense matrices;
  <span class="math notranslate nohighlight">
   \(\alpha\text{~and~}\beta\)
  </span>
  are scalars; and
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(\text{op}(A) = \begin{cases}
A &amp; \text{if transA == CUSPARSE_OPERATION_NON_TRANSPOSE} \\
A^{T} &amp; \text{if transA == CUSPARSE_OPERATION_TRANSPOSE (not\ supported)} \\
A^{H} &amp; \text{if transA == CUSPARSE_OPERATION_CONJUGATE_TRANSPOSE (not supported)} \\
\end{cases}\)
  </span>
 </p>
 <p>
  and
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(\text{op}(B) = \begin{cases}
B &amp; \text{if transB == CUSPARSE_OPERATION_NON_TRANSPOSE} \\
B^{T} &amp; \text{if transB == CUSPARSE_OPERATION_TRANSPOSE} \\
B^{H} &amp; \text{if transB == CUSPARSE_OPERATION_CONJUGATE_TRANSPOSE (not supported)} \\
\end{cases}\)
  </span>
 </p>
 <p>
  The function has the following limitations:
 </p>
 <ul class="simple">
  <li>
   <p>
    Only
    <span class="pre">
     CUSPARSE_MATRIX_TYPE_GENERAL
    </span>
    matrix type is supported
   </p>
  </li>
  <li>
   <p>
    Only
    <span class="pre">
     blockDim
    </span>
    <span class="pre">
     &gt;
    </span>
    <span class="pre">
     1
    </span>
    is supported
   </p>
  </li>
  <li>
   <p>
    if
    <span class="pre">
     blockDim
    </span>
     4, then max(mb)/max(n) = 524,272
   </p>
  </li>
  <li>
   <p>
    if 4 &lt;
    <span class="pre">
     blockDim
    </span>
     8, then max(mb) = 524,272, max(n) = 262,136
   </p>
  </li>
  <li>
   <p>
    if
    <span class="pre">
     blockDim
    </span>
    &gt; 8, then m &lt; 65,535 and max(n) = 262,136
   </p>
  </li>
 </ul>
 <p>
  The motivation of
  <span class="pre">
   transpose(B)
  </span>
  is to improve memory access of matrix
  <span class="pre">
   B
  </span>
  . The computational pattern of
  <span class="pre">
   A*transpose(B)
  </span>
  with matrix
  <span class="pre">
   B
  </span>
  in column-major order is equivalent to
  <span class="pre">
   A*B
  </span>
  with matrix
  <span class="pre">
   B
  </span>
  in row-major order.
 </p>
 <p>
  In practice, no operation in an iterative solver or eigenvalue solver uses
  <span class="pre">
   A*transpose(B)
  </span>
  . However, we can perform
  <span class="pre">
   A*transpose(transpose(B))
  </span>
  which is the same as
  <span class="pre">
   A*B
  </span>
  . For example, suppose
  <span class="pre">
   A
  </span>
  is
  <span class="pre">
   mb*kb
  </span>
  ,
  <span class="pre">
   B
  </span>
  is
  <span class="pre">
   k*n
  </span>
  and
  <span class="pre">
   C
  </span>
  is
  <span class="pre">
   m*n
  </span>
  , the following code shows usage of
  <span class="pre">
   cusparseDbsrmm()
  </span>
  .
 </p>
 <pre><span class="c1">// A is mb*kb, B is k*n and C is m*n</span>
<span class="k">const</span><span class="kt">int</span><span class="n">m</span><span class="o">=</span><span class="n">mb</span><span class="o">*</span><span class="n">blockSize</span><span class="p">;</span>
<span class="k">const</span><span class="kt">int</span><span class="n">k</span><span class="o">=</span><span class="n">kb</span><span class="o">*</span><span class="n">blockSize</span><span class="p">;</span>
<span class="k">const</span><span class="kt">int</span><span class="n">ldb_B</span><span class="o">=</span><span class="n">k</span><span class="p">;</span><span class="c1">// leading dimension of B</span>
<span class="k">const</span><span class="kt">int</span><span class="n">ldc</span><span class="o">=</span><span class="n">m</span><span class="p">;</span><span class="c1">// leading dimension of C</span>
<span class="c1">// perform C:=alpha*A*B + beta*C</span>
<span class="n">cusparseSetMatType</span><span class="p">(</span><span class="n">descrA</span><span class="p">,</span><span class="n">CUSPARSE_MATRIX_TYPE_GENERAL</span><span class="p">);</span>
<span class="n">cusparseDbsrmm</span><span class="p">(</span><span class="n">cusparse_handle</span><span class="p">,</span>
<span class="n">CUSPARSE_DIRECTION_COLUMN</span><span class="p">,</span>
<span class="n">CUSPARSE_OPERATION_NON_TRANSPOSE</span><span class="p">,</span>
<span class="n">CUSPARSE_OPERATION_NON_TRANSPOSE</span><span class="p">,</span>
<span class="n">mb</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">kb</span><span class="p">,</span><span class="n">nnzb</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span>
<span class="n">descrA</span><span class="p">,</span><span class="n">bsrValA</span><span class="p">,</span><span class="n">bsrRowPtrA</span><span class="p">,</span><span class="n">bsrColIndA</span><span class="p">,</span><span class="n">blockSize</span><span class="p">,</span>
<span class="n">B</span><span class="p">,</span><span class="n">ldb_B</span><span class="p">,</span>
<span class="n">beta</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="n">ldc</span><span class="p">);</span>
</pre>
 <p>
  Instead of using
  <span class="pre">
   A*B
  </span>
  , our proposal is to transpose
  <span class="pre">
   B
  </span>
  to
  <span class="pre">
   Bt
  </span>
  by first calling
  <span class="pre">
   cublas&lt;t&gt;geam()
  </span>
  , and then to perform
  <span class="pre">
   A*transpose(Bt)
  </span>
  .
 </p>
 <pre><span class="c1">// step 1: Bt := transpose(B)</span>
<span class="k">const</span><span class="kt">int</span><span class="n">m</span><span class="o">=</span><span class="n">mb</span><span class="o">*</span><span class="n">blockSize</span><span class="p">;</span>
<span class="k">const</span><span class="kt">int</span><span class="n">k</span><span class="o">=</span><span class="n">kb</span><span class="o">*</span><span class="n">blockSize</span><span class="p">;</span>
<span class="kt">double</span><span class="o">*</span><span class="n">Bt</span><span class="p">;</span>
<span class="k">const</span><span class="kt">int</span><span class="n">ldb_Bt</span><span class="o">=</span><span class="n">n</span><span class="p">;</span><span class="c1">// leading dimension of Bt</span>
<span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">Bt</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="o">*</span><span class="n">ldb_Bt</span><span class="o">*</span><span class="n">k</span><span class="p">);</span>
<span class="kt">double</span><span class="n">one</span><span class="o">=</span><span class="mf">1.0</span><span class="p">;</span>
<span class="kt">double</span><span class="n">zero</span><span class="o">=</span><span class="mf">0.0</span><span class="p">;</span>
<span class="n">cublasSetPointerMode</span><span class="p">(</span><span class="n">cublas_handle</span><span class="p">,</span><span class="n">CUBLAS_POINTER_MODE_HOST</span><span class="p">);</span>
<span class="n">cublasDgeam</span><span class="p">(</span><span class="n">cublas_handle</span><span class="p">,</span><span class="n">CUBLAS_OP_T</span><span class="p">,</span><span class="n">CUBLAS_OP_T</span><span class="p">,</span>
<span class="n">n</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="o">&amp;</span><span class="n">one</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="kt">int</span><span class="n">ldb_B</span><span class="p">,</span><span class="o">&amp;</span><span class="n">zero</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="kt">int</span><span class="n">ldb_B</span><span class="p">,</span><span class="n">Bt</span><span class="p">,</span><span class="n">ldb_Bt</span><span class="p">);</span>

<span class="c1">// step 2: perform C:=alpha*A*transpose(Bt) + beta*C</span>
<span class="n">cusparseDbsrmm</span><span class="p">(</span><span class="n">cusparse_handle</span><span class="p">,</span>
<span class="n">CUSPARSE_DIRECTION_COLUMN</span><span class="p">,</span>
<span class="n">CUSPARSE_OPERATION_NON_TRANSPOSE</span><span class="p">,</span>
<span class="n">CUSPARSE_OPERATION_TRANSPOSE</span><span class="p">,</span>
<span class="n">mb</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">kb</span><span class="p">,</span><span class="n">nnzb</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span>
<span class="n">descrA</span><span class="p">,</span><span class="n">bsrValA</span><span class="p">,</span><span class="n">bsrRowPtrA</span><span class="p">,</span><span class="n">bsrColIndA</span><span class="p">,</span><span class="n">blockSize</span><span class="p">,</span>
<span class="n">Bt</span><span class="p">,</span><span class="n">ldb_Bt</span><span class="p">,</span>
<span class="n">beta</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="n">ldc</span><span class="p">);</span>
</pre>
 <p>
  <span class="pre">
   bsrmm()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dir
     </span>
    </p>
   </td>
   <td>
    <p>
     storage format of blocks, either
     <span class="pre">
      CUSPARSE_DIRECTION_ROW
     </span>
     or
     <span class="pre">
      CUSPARSE_DIRECTION_COLUMN
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      transA
     </span>
    </p>
   </td>
   <td>
    <p>
     the operation
     <span class="pre">
      op(A)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      transB
     </span>
    </p>
   </td>
   <td>
    <p>
     the operation
     <span class="pre">
      op(B)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      mb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of block rows of sparse matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     number of columns of dense matrix
     <span class="pre">
      op(B)
     </span>
     and
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      kb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of block columns of sparse matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of non-zero blocks of sparse matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      alpha
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; scalar used for multiplication.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzb
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      bsrRowPtrA(mb)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      bsrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      mb
     </span>
     <span class="math notranslate nohighlight">
      \(+ 1\)
     </span>
     elements that contains the start of every block row and the end of the last block row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzb
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      bsrRowPtrA(mb)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      bsrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      blockDim
     </span>
    </p>
   </td>
   <td>
    <p>
     block dimension of sparse matrix
     <span class="pre">
      A
     </span>
     , larger than zero.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      B
     </span>
    </p>
   </td>
   <td>
    <p>
     array of dimensions
     <span class="pre">
      (ldb,
     </span>
     <span class="pre">
      n)
     </span>
     if
     <span class="pre">
      op(B)=B
     </span>
     and
     <span class="pre">
      (ldb,
     </span>
     
     <span class="pre">
      k)
     </span>
     otherwise.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ldb
     </span>
    </p>
   </td>
   <td>
    <p>
     leading dimension of
     <span class="pre">
      B
     </span>
     . If
     <span class="pre">
      op(B)=B
     </span>
     , it must be at least
     <span class="math notranslate nohighlight">
      \(\max\text{(1,\ k)}\)
     </span>
     If
     <span class="pre">
      op(B)
     </span>
     <span class="pre">
      !=
     </span>
     <span class="pre">
      B
     </span>
     , it must be at least
     <span class="pre">
      max(1,
     </span>
     
     <span class="pre">
      n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      beta
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; scalar used for multiplication. If
     <span class="pre">
      beta
     </span>
     is zero,
     <span class="pre">
      C
     </span>
     does not have to be a valid input.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      C
     </span>
    </p>
   </td>
   <td>
    <p>
     array of dimensions
     <span class="pre">
      (ldc,
     </span>
     <span class="pre">
      n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ldc
     </span>
    </p>
   </td>
   <td>
    <p>
     leading dimension of
     <span class="pre">
      C
     </span>
     . It must be at least
     <span class="math notranslate nohighlight">
      \(\max\text{(1,\ m)}\)
     </span>
     if
     <span class="pre">
      op(A)=A
     </span>
     and at least
     <span class="math notranslate nohighlight">
      \(\max\text{(1,\ k)}\)
     </span>
     otherwise.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      C
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; updated array of dimensions
     <span class="pre">
      (ldc,
     </span>
     <span class="pre">
      n)
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   5.5.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#bsrsm2_bufferSize">
   cusparse&lt;t&gt;bsrsm2_bufferSize()
  </a>
  [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsrsm2-buffersize-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSbsrsm2_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">bsrSortedValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrSortedRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrSortedColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrsm2Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDbsrsm2_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">bsrSortedValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrSortedRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrSortedColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrsm2Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCbsrsm2_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">bsrSortedValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrSortedRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrSortedColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrsm2Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZbsrsm2_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">bsrSortedValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrSortedRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrSortedColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrsm2Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>
</pre>
 <p>
  This function returns size of buffer used in
  <span class="pre">
   bsrsm2()
  </span>
  , a new sparse triangular linear system
  <span class="pre">
   op(A)*op(X)=
  </span>
  <span class="math notranslate nohighlight">
   \(\alpha\)
  </span>
  <span class="pre">
   op(B)
  </span>
  .
 </p>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   (mb*blockDim)x(mb*blockDim)
  </span>
  sparse matrix that is defined in BSR storage format by the three arrays
  <span class="pre">
   bsrValA
  </span>
  ,
  <span class="pre">
   bsrRowPtrA
  </span>
  , and
  <span class="pre">
   bsrColIndA
  </span>
  );
  <span class="pre">
   B
  </span>
  and
  <span class="pre">
   X
  </span>
  are the right-hand-side and the solution matrices;
  <span class="math notranslate nohighlight">
   \(\alpha\)
  </span>
  is a scalar; and
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(\text{op}(A) == \text{CUSPARSE_OPERATION_NON_TRANSPOSE}\)
  </span>
 </p>
 <p>
  Although there are six combinations in terms of parameter
  <span class="pre">
   trans
  </span>
  and the upper (and lower) triangular part of
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   bsrsm2_bufferSize()
  </span>
  returns the maximum size of the buffer among these combinations. The buffer size depends on dimension
  <span class="pre">
   mb,blockDim
  </span>
  and the number of nonzeros of the matrix,
  <span class="pre">
   nnzb
  </span>
  . If the user changes the matrix, it is necessary to call
  <span class="pre">
   bsrsm2_bufferSize()
  </span>
  again to get the correct buffer size, otherwise a segmentation fault may occur.
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dirA
     </span>
    </p>
   </td>
   <td>
    <p>
     storage format of blocks, either
     <span class="pre">
      CUSPARSE_DIRECTION_ROW
     </span>
     or
     <span class="pre">
      CUSPARSE_DIRECTION_COLUMN
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      transA
     </span>
    </p>
   </td>
   <td>
    <p>
     the operation
     <span class="pre">
      op(A)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      transX
     </span>
    </p>
   </td>
   <td>
    <p>
     the operation
     <span class="pre">
      op(X)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      mb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of block rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     number of columns of matrix
     <span class="pre">
      op(B)
     </span>
     and
     <span class="pre">
      op(X)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnzb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     , while the supported diagonal types are
     <span class="pre">
      CUSPARSE_DIAG_TYPE_UNIT
     </span>
     and
     <span class="pre">
      CUSPARSE_DIAG_TYPE_NON_UNIT
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzb
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      bsrRowPtrA(mb)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      bsrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      mb
     </span>
     <span class="math notranslate nohighlight">
      \(+ 1\)
     </span>
     elements that contains the start of every block row and the end of the last block row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzb
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      bsrRowPtrA(mb)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      bsrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      blockDim
     </span>
    </p>
   </td>
   <td>
    <p>
     block dimension of sparse matrix
     <span class="pre">
      A
     </span>
     ; larger than zero.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     record internal states based on different algorithms.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBufferSizeInBytes
     </span>
    </p>
   </td>
   <td>
    <p>
     number of bytes of the buffer used in
     <span class="pre">
      bsrsm2_analysis()
     </span>
     and
     <span class="pre">
      bsrsm2_solve()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   5.5.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#bsrsm2_analysis">
   cusparse&lt;t&gt;bsrsm2_analysis()
  </a>
  [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsrsm2-analysis-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSbsrsm2_analysis</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">bsrSortedVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrSortedRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrSortedColInd</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrsm2Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDbsrsm2_analysis</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">bsrSortedVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrSortedRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrSortedColInd</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrsm2Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCbsrsm2_analysis</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">bsrSortedVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrSortedRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrSortedColInd</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrsm2Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZbsrsm2_analysis</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">bsrSortedVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrSortedRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrSortedColInd</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrsm2Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function performs the analysis phase of
  <span class="pre">
   bsrsm2()
  </span>
  , a new sparse triangular linear system
  <span class="pre">
   op(A)*op(X)
  </span>
  <span class="pre">
   =
  </span>
  <span class="math notranslate nohighlight">
   \(\alpha\)
  </span>
  <span class="pre">
   op(B)
  </span>
  .
 </p>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   (mb*blockDim)x(mb*blockDim)
  </span>
  sparse matrix that is defined in BSR storage format by the three arrays
  <span class="pre">
   bsrValA
  </span>
  ,
  <span class="pre">
   bsrRowPtrA
  </span>
  , and
  <span class="pre">
   bsrColIndA
  </span>
  );
  <span class="pre">
   B
  </span>
  and
  <span class="pre">
   X
  </span>
  are the right-hand-side and the solution matrices;
  <span class="math notranslate nohighlight">
   \(\alpha\)
  </span>
  is a scalar; and
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(\text{op}(A) == \text{CUSPARSE_OPERATION_NON_TRANSPOSE}\)
  </span>
 </p>
 <p>
  and
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(\text{op}(X) = \begin{cases}
X &amp; \text{if transX == CUSPARSE_OPERATION_NON_TRANSPOSE} \\
X^{T} &amp; \text{if transX == CUSPARSE_OPERATION_TRANSPOSE} \\
X^{H} &amp; \text{if transX == CUSPARSE_OPERATION_CONJUGATE_TRANSPOSE (not supported)} \\
\end{cases}\)
  </span>
 </p>
 <p>
  and
  <span class="pre">
   op(B)
  </span>
  and
  <span class="pre">
   op(X)
  </span>
  are equal.
 </p>
 <p>
  The block of BSR format is of size
  <span class="pre">
   blockDim*blockDim
  </span>
  , stored in column-major or row-major as determined by parameter
  <span class="pre">
   dirA
  </span>
  , which is either
  <span class="pre">
   CUSPARSE_DIRECTION_ROW
  </span>
  or
  <span class="pre">
   CUSPARSE_DIRECTION_COLUMN
  </span>
  . The matrix type must be
  <span class="pre">
   CUSPARSE_MATRIX_TYPE_GENERAL
  </span>
  , and the fill mode and diagonal type are ignored.
 </p>
 <p>
  It is expected that this function will be executed only once for a given matrix and a particular operation type.
 </p>
 <p>
  This function requires the buffer size returned by
  <span class="pre">
   bsrsm2_bufferSize()
  </span>
  . The address of
  <span class="pre">
   pBuffer
  </span>
  must be multiple of 128 bytes. If not,
  <span class="pre">
   CUSPARSE_STATUS_INVALID_VALUE
  </span>
  is returned.
 </p>
 <p>
  Function
  <span class="pre">
   bsrsm2_analysis()
  </span>
  reports a structural zero and computes the level information stored in opaque structure
  <span class="pre">
   info
  </span>
  . The level information can extract more parallelism during a triangular solver. However
  <span class="pre">
   bsrsm2_solve()
  </span>
  can be done without level information. To disable level information, the user needs to specify the policy of the triangular solver as
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_NO_LEVEL
  </span>
  .
 </p>
 <p>
  Function
  <span class="pre">
   bsrsm2_analysis()
  </span>
  always reports the first structural zero, even if the parameter
  <span class="pre">
   policy
  </span>
  is
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_NO_LEVEL
  </span>
  . Besides, no structural zero is reported if
  <span class="pre">
   CUSPARSE_DIAG_TYPE_UNIT
  </span>
  is specified, even if block
  <span class="pre">
   A(j,j)
  </span>
  is missing for some
  <span class="pre">
   j
  </span>
  . The user must call
  <span class="pre">
   cusparseXbsrsm2_query_zero_pivot()
  </span>
  to know where the structural zero is.
 </p>
 <p>
  If
  <span class="pre">
   bsrsm2_analysis()
  </span>
  reports a structural zero, the solve will return a numerical zero in the same position as the structural zero but this result
  <span class="pre">
   X
  </span>
  is meaningless.
 </p>
 <ul class="simple">
  <li>
   <p>
    This function requires temporary extra storage that is allocated internally
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dirA
     </span>
    </p>
   </td>
   <td>
    <p>
     storage format of blocks, either
     <span class="pre">
      CUSPARSE_DIRECTION_ROW
     </span>
     or
     <span class="pre">
      CUSPARSE_DIRECTION_COLUMN
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      transA
     </span>
    </p>
   </td>
   <td>
    <p>
     the operation
     <span class="pre">
      op(A)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      transX
     </span>
    </p>
   </td>
   <td>
    <p>
     the operation
     <span class="pre">
      op(B)
     </span>
     and
     <span class="pre">
      op(X)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      mb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of block rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     number of columns of matrix
     <span class="pre">
      op(B)
     </span>
     and
     <span class="pre">
      op(X)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnzb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of non-zero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     , while the supported diagonal types are
     <span class="pre">
      CUSPARSE_DIAG_TYPE_UNIT
     </span>
     and
     <span class="pre">
      CUSPARSE_DIAG_TYPE_NON_UNIT
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzb
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      bsrRowPtrA(mb)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      bsrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      mb
     </span>
     <span class="math notranslate nohighlight">
      \(+ 1\)
     </span>
     elements that contains the start of every block row and the end of the last block row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzb
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      bsrRowPtrA(mb)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      bsrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      blockDim
     </span>
    </p>
   </td>
   <td>
    <p>
     block dimension of sparse matrix
     <span class="pre">
      A
     </span>
     ; larger than zero.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     structure initialized using
     <span class="pre">
      cusparseCreateBsrsm2Info
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      policy
     </span>
    </p>
   </td>
   <td>
    <p>
     The supported policies are
     <span class="pre">
      CUSPARSE_SOLVE_POLICY_NO_LEVEL
     </span>
     and
     <span class="pre">
      CUSPARSE_SOLVE_POLICY_USE_LEVEL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     buffer allocated by the user; the size is return by
     <span class="pre">
      bsrsm2_bufferSize()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h3>
  <span class="section-number">
   5.5.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#bsrsm2_solve">
   cusparse&lt;t&gt;bsrsm2_solve()
  </a>
  [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsrsm2-solve-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSbsrsm2_solve</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">bsrSortedVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrSortedRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrSortedColInd</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrsm2Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">X</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldx</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDbsrsm2_solve</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">bsrSortedVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrSortedRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrSortedColInd</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrsm2Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">X</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldx</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCbsrsm2_solve</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">bsrSortedVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrSortedRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrSortedColInd</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrsm2Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">X</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldx</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZbsrsm2_solve</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">transX</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">bsrSortedVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrSortedRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrSortedColInd</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrsm2Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">X</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldx</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function performs the solve phase of the solution of a sparse triangular linear system:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\text{op}(A) \ast \text{op(X)} = \alpha \ast \text{op(B)}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   (mb*blockDim)x(mb*blockDim)
  </span>
  sparse matrix that is defined in BSR storage format by the three arrays
  <span class="pre">
   bsrValA
  </span>
  ,
  <span class="pre">
   bsrRowPtrA
  </span>
  , and
  <span class="pre">
   bsrColIndA
  </span>
  );
  <span class="pre">
   B
  </span>
  and
  <span class="pre">
   X
  </span>
  are the right-hand-side and the solution matrices;
  <span class="math notranslate nohighlight">
   \(\alpha\)
  </span>
  is a scalar, and
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(\text{op}(A) == \text{CUSPARSE_OPERATION_NON_TRANSPOSE}\)
  </span>
 </p>
 <p>
  and
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(\text{op}(X) = \begin{cases}
X &amp; \text{if transX == CUSPARSE_OPERATION_NON_TRANSPOSE} \\
X^{T} &amp; \text{if transX == CUSPARSE_OPERATION_TRANSPOSE} \\
X^{H} &amp; \text{not supported} \\
\end{cases}\)
  </span>
 </p>
 <p>
  Only
  <span class="pre">
   op(A)=A
  </span>
  is supported.
 </p>
 <p>
  <span class="pre">
   op(B)
  </span>
  and
  <span class="pre">
   op(X)
  </span>
  must be performed in the same way. In other words, if
  <span class="pre">
   op(B)=B
  </span>
  ,
  <span class="pre">
   op(X)=X
  </span>
  .
 </p>
 <p>
  The block of BSR format is of size
  <span class="pre">
   blockDim*blockDim
  </span>
  , stored as column-major or row-major as determined by parameter
  <span class="pre">
   dirA
  </span>
  , which is either
  <span class="pre">
   CUSPARSE_DIRECTION_ROW
  </span>
  or
  <span class="pre">
   CUSPARSE_DIRECTION_COLUMN
  </span>
  . The matrix type must be
  <span class="pre">
   CUSPARSE_MATRIX_TYPE_GENERAL
  </span>
  , and the fill mode and diagonal type are ignored. Function
  <span class="pre">
   bsrsm02_solve()
  </span>
  can support an arbitrary
  <span class="pre">
   blockDim
  </span>
  .
 </p>
 <p>
  This function may be executed multiple times for a given matrix and a particular operation type.
 </p>
 <p>
  This function requires the buffer size returned by
  <span class="pre">
   bsrsm2_bufferSize()
  </span>
  . The address of
  <span class="pre">
   pBuffer
  </span>
  must be multiple of 128 bytes. If it is not,
  <span class="pre">
   CUSPARSE_STATUS_INVALID_VALUE
  </span>
  is returned.
 </p>
 <p>
  Although
  <span class="pre">
   bsrsm2_solve()
  </span>
  can be done without level information, the user still needs to be aware of consistency. If
  <span class="pre">
   bsrsm2_analysis()
  </span>
  is called with policy
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_USE_LEVEL
  </span>
  ,
  <span class="pre">
   bsrsm2_solve()
  </span>
  can be run with or without levels. On the other hand, if
  <span class="pre">
   bsrsm2_analysis()
  </span>
  is called with
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_NO_LEVEL
  </span>
  ,
  <span class="pre">
   bsrsm2_solve()
  </span>
  can only accept
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_NO_LEVEL
  </span>
  ; otherwise,
  <span class="pre">
   CUSPARSE_STATUS_INVALID_VALUE
  </span>
  is returned.
 </p>
 <p>
  Function
  <span class="pre">
   bsrsm02_solve()
  </span>
  has the same behavior as
  <span class="pre">
   bsrsv02_solve()
  </span>
  , reporting the first numerical zero, including a structural zero. The user must call
  <span class="pre">
   cusparseXbsrsm2_query_zero_pivot()
  </span>
  to know where the numerical zero is.
 </p>
 <p>
  The motivation of
  <span class="pre">
   transpose(X)
  </span>
  is to improve the memory access of matrix
  <span class="pre">
   X
  </span>
  . The computational pattern of
  <span class="pre">
   transpose(X)
  </span>
  with matrix
  <span class="pre">
   X
  </span>
  in column-major order is equivalent to
  <span class="pre">
   X
  </span>
  with matrix
  <span class="pre">
   X
  </span>
  in row-major order.
 </p>
 <p>
  In-place is supported and requires that
  <span class="pre">
   B
  </span>
  and
  <span class="pre">
   X
  </span>
  point to the same memory block, and
  <span class="pre">
   ldb=ldx
  </span>
  .
 </p>
 <p>
  The function supports the following properties if
  <span class="pre">
   pBuffer
  </span>
  <span class="pre">
   !=
  </span>
  <span class="pre">
   NULL
  </span>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dirA
     </span>
    </p>
   </td>
   <td>
    <p>
     storage format of blocks, either
     <span class="pre">
      CUSPARSE_DIRECTION_ROW
     </span>
     or
     <span class="pre">
      CUSPARSE_DIRECTION_COLUMN
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      transA
     </span>
    </p>
   </td>
   <td>
    <p>
     the operation
     <span class="pre">
      op(A)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      transX
     </span>
    </p>
   </td>
   <td>
    <p>
     the operation
     <span class="pre">
      op(B)
     </span>
     and
     <span class="pre">
      op(X)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      mb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of block rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     number of columns of matrix
     <span class="pre">
      op(B)
     </span>
     and
     <span class="pre">
      op(X)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnzb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of non-zero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      alpha
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; scalar used for multiplication.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     , while the supported diagonal types are
     <span class="pre">
      CUSPARSE_DIAG_TYPE_UNIT
     </span>
     and
     <span class="pre">
      CUSPARSE_DIAG_TYPE_NON_UNIT
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzb
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      bsrRowPtrA(mb)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      bsrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     non-zero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      mb
     </span>
     <span class="math notranslate nohighlight">
      \(+ 1\)
     </span>
     elements that contains the start of every block row and the end of the last block row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzb
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      bsrRowPtrA(mb)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      bsrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      blockDim
     </span>
    </p>
   </td>
   <td>
    <p>
     block dimension of sparse matrix
     <span class="pre">
      A
     </span>
     ; larger than zero.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     structure initialized using
     <span class="pre">
      cusparseCreateBsrsm2Info()
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      B
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; right-hand-side array.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ldb
     </span>
    </p>
   </td>
   <td>
    <p>
     leading dimension of
     <span class="pre">
      B
     </span>
     . If
     <span class="pre">
      op(B)=B
     </span>
     ,
     <span class="pre">
      ldb
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      (mb*blockDim)
     </span>
     ; otherwise,
     <span class="pre">
      ldb
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ldx
     </span>
    </p>
   </td>
   <td>
    <p>
     leading dimension of
     <span class="pre">
      X
     </span>
     . If
     <span class="pre">
      op(X)=X
     </span>
     , then
     <span class="pre">
      ldx
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      (mb*blockDim)
     </span>
     . otherwise
     <span class="pre">
      ldx
     </span>
     <span class="pre">
      &gt;=
     </span>
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      policy
     </span>
    </p>
   </td>
   <td>
    <p>
     the supported policies are
     <span class="pre">
      CUSPARSE_SOLVE_POLICY_NO_LEVEL
     </span>
     and
     <span class="pre">
      CUSPARSE_SOLVE_POLICY_USE_LEVEL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     buffer allocated by the user; the size is returned by
     <span class="pre">
      bsrsm2_bufferSize()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      X
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; solution array with leading dimensions
     <span class="pre">
      ldx
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   5.5.5.
  </span>
  cusparseXbsrsm2_zeroPivot() [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsexbsrsm2-zeropivot-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseXbsrsm2_zeroPivot</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">bsrsm2Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">position</span><span class="p">)</span>
</pre>
 <p>
  If the returned error code is
  <span class="pre">
   CUSPARSE_STATUS_ZERO_PIVOT
  </span>
  ,
  <span class="pre">
   position=j
  </span>
  means
  <span class="pre">
   A(j,j)
  </span>
  is either a structural zero or a numerical zero (singular block). Otherwise
  <span class="pre">
   position=-1
  </span>
  .
 </p>
 <p>
  The
  <span class="pre">
   position
  </span>
  can be 0-base or 1-base, the same as the matrix.
 </p>
 <p>
  Function
  <span class="pre">
   cusparseXbsrsm2_zeroPivot()
  </span>
  is a blocking call. It calls
  <span class="pre">
   cudaDeviceSynchronize()
  </span>
  to make sure all previous kernels are done.
 </p>
 <p>
  The
  <span class="pre">
   position
  </span>
  can be in the host memory or device memory. The user can set the proper mode with
  <span class="pre">
   cusparseSetPointerMode()
  </span>
  .
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      info
     </span>
     contains a structural zero or a numerical zero if the user already called
     <span class="pre">
      bsrsm2_analysis()
     </span>
     or
     <span class="pre">
      bsrsm2_solve()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      position
     </span>
    </p>
   </td>
   <td>
    <p>
     if no structural or numerical zero,
     <span class="pre">
      position
     </span>
     is -1; otherwise, if
     <span class="pre">
      A(j,j)
     </span>
     is missing or
     <span class="pre">
      U(j,j)
     </span>
     is zero,
     <span class="pre">
      position=j
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h2>
  <span class="section-number">
   5.6.
  </span>
  cuSPARSE Extra Function Reference
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-extra-function-reference" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  This chapter describes the extra routines used to manipulate sparse matrices.
 </p>
 <h3>
  <span class="section-number">
   5.6.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#csrgeam2">
   cusparse&lt;t&gt;csrgeam2()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-csrgeam2" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseScsrgeam2_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrSortedValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrSortedValB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedRowPtrB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedColIndB</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrSortedValC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedRowPtrC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedColIndC</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDcsrgeam2_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrSortedValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrSortedValB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedRowPtrB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedColIndB</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrSortedValC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedRowPtrC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedColIndC</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCcsrgeam2_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">csrSortedValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzB</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">csrSortedValB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedRowPtrB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedColIndB</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">csrSortedValC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedRowPtrC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedColIndC</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZcsrgeam2_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrSortedValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzB</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrSortedValB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedRowPtrB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedColIndB</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrSortedValC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedRowPtrC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedColIndC</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseXcsrgeam2Nnz</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedRowPtrB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedColIndB</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrSortedRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzTotalDevHostPtr</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">workspace</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseScsrgeam2</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrSortedValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrSortedValB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedRowPtrB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedColIndB</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">csrSortedValC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrSortedRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrSortedColIndC</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDcsrgeam2</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrSortedValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrSortedValB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedRowPtrB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedColIndB</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">csrSortedValC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrSortedRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrSortedColIndC</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCcsrgeam2</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">csrSortedValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzB</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">csrSortedValB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedRowPtrB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedColIndB</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">csrSortedValC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrSortedRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrSortedColIndC</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZcsrgeam2</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrSortedValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrB</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzB</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrSortedValB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedRowPtrB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrSortedColIndB</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrSortedValC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrSortedRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrSortedColIndC</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function performs following matrix-matrix operation
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(C = \alpha \ast A + \beta \ast B\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="pre">
   A
  </span>
  ,
  <span class="pre">
   B
  </span>
  , and
  <span class="pre">
   C
  </span>
  are
  <span class="pre">
   mn
  </span>
  sparse matrices (defined in CSR storage format by the three arrays
  <span class="pre">
   csrValA|csrValB|csrValC
  </span>
  ,
  <span class="pre">
   csrRowPtrA|csrRowPtrB|csrRowPtrC
  </span>
  , and
  <span class="pre">
   csrColIndA|csrColIndB|csrcolIndC
  </span>
  respectively), and
  <span class="math notranslate nohighlight">
   \(\alpha\text{~and~}\beta\)
  </span>
  are scalars. Since
  <span class="pre">
   A
  </span>
  and
  <span class="pre">
   B
  </span>
  have different sparsity patterns, cuSPARSE adopts a two-step approach to complete sparse matrix
  <span class="pre">
   C
  </span>
  . In the first step, the user allocates
  <span class="pre">
   csrRowPtrC
  </span>
  of
  <span class="pre">
   m+1
  </span>
  elements and uses function
  <span class="pre">
   cusparseXcsrgeam2Nnz()
  </span>
  to determine
  <span class="pre">
   csrRowPtrC
  </span>
  and the total number of nonzero elements. In the second step, the user gathers
  <span class="pre">
   nnzC
  </span>
  (number of nonzero elements of matrix
  <span class="pre">
   C
  </span>
  ) from either
  <span class="pre">
   (nnzC=*nnzTotalDevHostPtr)
  </span>
  or
  <span class="pre">
   (nnzC=csrRowPtrC(m)-csrRowPtrC(0))
  </span>
  and allocates
  <span class="pre">
   csrValC,
  </span>
  
  <span class="pre">
   csrColIndC
  </span>
  of
  <span class="pre">
   nnzC
  </span>
  elements respectively, then finally calls function
  <span class="pre">
   cusparse[S|D|C|Z]csrgeam2()
  </span>
  to complete matrix
  <span class="pre">
   C
  </span>
  .
 </p>
 <p>
  The general procedure is as follows:
 </p>
 <pre><span class="kt">int</span><span class="n">baseC</span><span class="p">,</span><span class="n">nnzC</span><span class="p">;</span>
<span class="cm">/* alpha, nnzTotalDevHostPtr points to host memory */</span>
<span class="kt">size_t</span><span class="n">BufferSizeInBytes</span><span class="p">;</span>
<span class="kt">char</span><span class="o">*</span><span class="n">buffer</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzTotalDevHostPtr</span><span class="o">=</span><span class="o">&amp;</span><span class="n">nnzC</span><span class="p">;</span>
<span class="n">cusparseSetPointerMode</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">CUSPARSE_POINTER_MODE_HOST</span><span class="p">);</span>
<span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">csrRowPtrC</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
<span class="cm">/* prepare buffer */</span>
<span class="n">cusparseScsrgeam2_bufferSizeExt</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">,</span>
<span class="n">alpha</span><span class="p">,</span>
<span class="n">descrA</span><span class="p">,</span><span class="n">nnzA</span><span class="p">,</span>
<span class="n">csrValA</span><span class="p">,</span><span class="n">csrRowPtrA</span><span class="p">,</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">beta</span><span class="p">,</span>
<span class="n">descrB</span><span class="p">,</span><span class="n">nnzB</span><span class="p">,</span>
<span class="n">csrValB</span><span class="p">,</span><span class="n">csrRowPtrB</span><span class="p">,</span><span class="n">csrColIndB</span><span class="p">,</span>
<span class="n">descrC</span><span class="p">,</span>
<span class="n">csrValC</span><span class="p">,</span><span class="n">csrRowPtrC</span><span class="p">,</span><span class="n">csrColIndC</span>
<span class="o">&amp;</span><span class="n">bufferSizeInBytes</span>
<span class="p">);</span>
<span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="o">*</span><span class="n">bufferSizeInBytes</span><span class="p">);</span>
<span class="n">cusparseXcsrgeam2Nnz</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">,</span>
<span class="n">descrA</span><span class="p">,</span><span class="n">nnzA</span><span class="p">,</span><span class="n">csrRowPtrA</span><span class="p">,</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">descrB</span><span class="p">,</span><span class="n">nnzB</span><span class="p">,</span><span class="n">csrRowPtrB</span><span class="p">,</span><span class="n">csrColIndB</span><span class="p">,</span>
<span class="n">descrC</span><span class="p">,</span><span class="n">csrRowPtrC</span><span class="p">,</span><span class="n">nnzTotalDevHostPtr</span><span class="p">,</span>
<span class="n">buffer</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="nb">NULL</span><span class="o">!=</span><span class="n">nnzTotalDevHostPtr</span><span class="p">){</span>
<span class="n">nnzC</span><span class="o">=</span><span class="o">*</span><span class="n">nnzTotalDevHostPtr</span><span class="p">;</span>
<span class="p">}</span><span class="k">else</span><span class="p">{</span>
<span class="n">cudaMemcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nnzC</span><span class="p">,</span><span class="n">csrRowPtrC</span><span class="o">+</span><span class="n">m</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span><span class="n">cudaMemcpyDeviceToHost</span><span class="p">);</span>
<span class="n">cudaMemcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">baseC</span><span class="p">,</span><span class="n">csrRowPtrC</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span><span class="n">cudaMemcpyDeviceToHost</span><span class="p">);</span>
<span class="n">nnzC</span><span class="o">-=</span><span class="n">baseC</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">csrColIndC</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">nnzC</span><span class="p">);</span>
<span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">csrValC</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="n">nnzC</span><span class="p">);</span>
<span class="n">cusparseScsrgeam2</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">,</span>
<span class="n">alpha</span><span class="p">,</span>
<span class="n">descrA</span><span class="p">,</span><span class="n">nnzA</span><span class="p">,</span>
<span class="n">csrValA</span><span class="p">,</span><span class="n">csrRowPtrA</span><span class="p">,</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">beta</span><span class="p">,</span>
<span class="n">descrB</span><span class="p">,</span><span class="n">nnzB</span><span class="p">,</span>
<span class="n">csrValB</span><span class="p">,</span><span class="n">csrRowPtrB</span><span class="p">,</span><span class="n">csrColIndB</span><span class="p">,</span>
<span class="n">descrC</span><span class="p">,</span>
<span class="n">csrValC</span><span class="p">,</span><span class="n">csrRowPtrC</span><span class="p">,</span><span class="n">csrColIndC</span>
<span class="n">buffer</span><span class="p">);</span>
</pre>
 <p>
  Several comments on
  <span class="pre">
   csrgeam2()
  </span>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    The other three combinations, NT, TN, and TT, are not supported by cuSPARSE. In order to do any one of the three, the user should use the routine
    <span class="pre">
     csr2csc()
    </span>
    to convert
    <span class="math notranslate nohighlight">
     \(A\)
    </span>
    |
    <span class="math notranslate nohighlight">
     \(B\)
    </span>
    to
    <span class="math notranslate nohighlight">
     \(A^{T}\)
    </span>
    |
    <span class="math notranslate nohighlight">
     \(B^{T}\)
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Only
    <span class="pre">
     CUSPARSE_MATRIX_TYPE_GENERAL
    </span>
    is supported. If either
    <span class="pre">
     A
    </span>
    or
    <span class="pre">
     B
    </span>
    is symmetric or Hermitian, then the user must extend the matrix to a full one and reconfigure the
    <span class="pre">
     MatrixType
    </span>
    field of the descriptor to
    <span class="pre">
     CUSPARSE_MATRIX_TYPE_GENERAL
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    If the sparsity pattern of matrix
    <span class="pre">
     C
    </span>
    is known, the user can skip the call to function
    <span class="pre">
     cusparseXcsrgeam2Nnz()
    </span>
    . For example, suppose that the user has an iterative algorithm which would update
    <span class="pre">
     A
    </span>
    and
    <span class="pre">
     B
    </span>
    iteratively but keep the sparsity patterns. The user can call function
    <span class="pre">
     cusparseXcsrgeam2Nnz()
    </span>
    once to set up the sparsity pattern of
    <span class="pre">
     C
    </span>
    , then call function
    <span class="pre">
     cusparse[S|D|C|Z]geam()
    </span>
    only for each iteration.
   </p>
  </li>
  <li>
   <p>
    The pointers
    <span class="pre">
     alpha
    </span>
    and
    <span class="pre">
     beta
    </span>
    must be valid.
   </p>
  </li>
  <li>
   <p>
    When
    <span class="pre">
     alpha
    </span>
    or
    <span class="pre">
     beta
    </span>
    is zero, it is not considered a special case by cuSPARSE. The sparsity pattern of
    <span class="pre">
     C
    </span>
    is independent of the value of
    <span class="pre">
     alpha
    </span>
    and
    <span class="pre">
     beta
    </span>
    . If the user wants
    <span class="math notranslate nohighlight">
     \(C = 0 \times A + 1 \times B^{T}\)
    </span>
    , then
    <span class="pre">
     csr2csc()
    </span>
    is better than
    <span class="pre">
     csrgeam2()
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     csrgeam2()
    </span>
    is the same as
    <span class="pre">
     csrgeam()
    </span>
    except
    <span class="pre">
     csrgeam2()
    </span>
    needs explicit buffer where
    <span class="pre">
     csrgeam()
    </span>
    allocates the buffer internally.
   </p>
  </li>
  <li>
   <p>
    This function requires temporary extra storage that is allocated internally
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     number of rows of sparse matrix
     <span class="pre">
      A,B,C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     number of columns of sparse matrix
     <span class="pre">
      A,B,C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      alpha
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; scalar used for multiplication.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     only.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzA
     </span>
    </p>
   </td>
   <td>
    <p>
     number of nonzero elements of sparse matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzA
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      m
     </span>
     <span class="math notranslate nohighlight">
      \(+ 1\)
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzA
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      beta
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; scalar used for multiplication. If
     <span class="pre">
      beta
     </span>
     is zero,
     <span class="pre">
      y
     </span>
     does not have to be a valid input.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrB
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      B
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     only.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzB
     </span>
    </p>
   </td>
   <td>
    <p>
     number of nonzero elements of sparse matrix
     <span class="pre">
      B
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrValB
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzB
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrB(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrB(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero elements of matrix
     <span class="pre">
      B
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowPtrB
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      m
     </span>
     <span class="math notranslate nohighlight">
      \(+ 1\)
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColIndB
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzB
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrB(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrB(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero elements of matrix
     <span class="pre">
      B
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descrC
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      C
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     only.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrValC
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzC
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrC(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrC(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero elements of matrix
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowPtrC
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      m
     </span>
     <span class="math notranslate nohighlight">
      \(+ 1\)
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColIndC
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzC
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrC(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrC(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero elements of matrix
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzTotalDevHostPtr
     </span>
    </p>
   </td>
   <td>
    <p>
     total number of nonzero elements in device or host memory. It is equal to
     <span class="pre">
      (csrRowPtrC(m)-csrRowPtrC(0))
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <h2>
  <span class="section-number">
   5.7.
  </span>
  cuSPARSE Preconditioners Reference
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-preconditioners-reference" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  This chapter describes the routines that implement different preconditioners.
 </p>
 <h3>
  <span class="section-number">
   5.7.1.
  </span>
  Incomplete Cholesky Factorization: level 0 [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#incomplete-cholesky-factorization-level-0-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  Different algorithms for ic0 are discussed in this section.
 </p>
 <h4>
  <span class="section-number">
   5.7.1.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#csric02_bufferSize">
   cusparse&lt;t&gt;csric02_bufferSize()
  </a>
  [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-csric02-buffersize-deprecated" title="Permalink to this headline">
   
  </a>
 </h4>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseScsric02_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">csric02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDcsric02_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">csric02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCcsric02_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">csric02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZcsric02_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">csric02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>
</pre>
 <p>
  This function returns size of buffer used in computing the incomplete-Cholesky factorization with
  <span class="math notranslate nohighlight">
   \(0\)
  </span>
  fill-in and no pivoting:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A \approx LL^{H}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   mm
  </span>
  sparse matrix that is defined in CSR storage format by the three arrays
  <span class="pre">
   csrValA
  </span>
  ,
  <span class="pre">
   csrRowPtrA
  </span>
  , and
  <span class="pre">
   csrColIndA
  </span>
  .
 </p>
 <p>
  The buffer size depends on dimension
  <span class="pre">
   m
  </span>
  and
  <span class="pre">
   nnz
  </span>
  , the number of nonzeros of the matrix. If the user changes the matrix, it is necessary to call
  <span class="pre">
   csric02_bufferSize()
  </span>
  again to have the correct buffer size; otherwise, a segmentation fault may occur.
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     number of nonzeros of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnz
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      m
     </span>
     <span class="math notranslate nohighlight">
      \(+ 1\)
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnz
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     record internal states based on different algorithms
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBufferSizeInBytes
     </span>
    </p>
   </td>
   <td>
    <p>
     number of bytes of the buffer used in
     <span class="pre">
      csric02_analysis()
     </span>
     and
     <span class="pre">
      csric02()
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   5.7.1.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#csric02_analysis">
   cusparse&lt;t&gt;csric02_analysis()
  </a>
  [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-csric02-analysis-deprecated" title="Permalink to this headline">
   
  </a>
 </h4>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseScsric02_analysis</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">csric02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDcsric02_analysis</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">csric02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCcsric02_analysis</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">csric02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZcsric02_analysis</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">csric02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function performs the analysis phase of the incomplete-Cholesky factorization with
  <span class="math notranslate nohighlight">
   \(0\)
  </span>
  fill-in and no pivoting:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A \approx LL^{H}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   mm
  </span>
  sparse matrix that is defined in CSR storage format by the three arrays
  <span class="pre">
   csrValA
  </span>
  ,
  <span class="pre">
   csrRowPtrA
  </span>
  , and
  <span class="pre">
   csrColIndA
  </span>
  .
 </p>
 <p>
  This function requires a buffer size returned by
  <span class="pre">
   csric02_bufferSize()
  </span>
  . The address of
  <span class="pre">
   pBuffer
  </span>
  must be multiple of 128 bytes. If not,
  <span class="pre">
   CUSPARSE_STATUS_INVALID_VALUE
  </span>
  is returned.
 </p>
 <p>
  Function
  <span class="pre">
   csric02_analysis()
  </span>
  reports a structural zero and computes level information stored in the opaque structure
  <span class="pre">
   info
  </span>
  . The level information can extract more parallelism during incomplete Cholesky factorization. However
  <span class="pre">
   csric02()
  </span>
  can be done without level information. To disable level information, the user must specify the policy of
  <span class="pre">
   csric02_analysis()
  </span>
  and
  <span class="pre">
   csric02()
  </span>
  as
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_NO_LEVEL
  </span>
  .
 </p>
 <p>
  Function
  <span class="pre">
   csric02_analysis()
  </span>
  always reports the first structural zero, even if the policy is
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_NO_LEVEL
  </span>
  . The user needs to call
  <span class="pre">
   cusparseXcsric02_zeroPivot()
  </span>
  to know where the structural zero is.
 </p>
 <p>
  It is the users choice whether to call
  <span class="pre">
   csric02()
  </span>
  if
  <span class="pre">
   csric02_analysis()
  </span>
  reports a structural zero. In this case, the user can still call
  <span class="pre">
   csric02()
  </span>
  , which will return a numerical zero at the same position as the structural zero. However the result is meaningless.
 </p>
 <ul class="simple">
  <li>
   <p>
    This function requires temporary extra storage that is allocated internally
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     number of nonzeros of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnz
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      m
     </span>
     <span class="math notranslate nohighlight">
      \(+ 1\)
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnz
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     structure initialized using
     <span class="pre">
      cusparseCreateCsric02Info()
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      policy
     </span>
    </p>
   </td>
   <td>
    <p>
     the supported policies are
     <span class="pre">
      CUSPARSE_SOLVE_POLICY_NO_LEVEL
     </span>
     and
     <span class="pre">
      CUSPARSE_SOLVE_POLICY_USE_LEVEL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     buffer allocated by the user; the size is returned by
     <span class="pre">
      csric02_bufferSize()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     number of bytes of the buffer used in
     <span class="pre">
      csric02_analysis()
     </span>
     and
     <span class="pre">
      csric02()
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   5.7.1.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#csric02_solve">
   cusparse&lt;t&gt;csric02()
  </a>
  [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-csric02-deprecated" title="Permalink to this headline">
   
  </a>
 </h4>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseScsric02</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">csrValA_valM</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">csric02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDcsric02</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">csrValA_valM</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">csric02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCcsric02</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">csrValA_valM</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">csric02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZcsric02</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrValA_valM</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">csric02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function performs the solve phase of the computing the incomplete-Cholesky factorization with
  <span class="math notranslate nohighlight">
   \(0\)
  </span>
  fill-in and no pivoting:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A \approx LL^{H}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  This function requires a buffer size returned by
  <span class="pre">
   csric02_bufferSize()
  </span>
  . The address of
  <span class="pre">
   pBuffer
  </span>
  must be a multiple of 128 bytes. If not,
  <span class="pre">
   CUSPARSE_STATUS_INVALID_VALUE
  </span>
  is returned.
 </p>
 <p>
  Although
  <span class="pre">
   csric02()
  </span>
  can be done without level information, the user still needs to be aware of consistency. If
  <span class="pre">
   csric02_analysis()
  </span>
  is called with policy
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_USE_LEVEL
  </span>
  ,
  <span class="pre">
   csric02()
  </span>
  can be run with or without levels. On the other hand, if
  <span class="pre">
   csric02_analysis()
  </span>
  is called with
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_NO_LEVEL
  </span>
  ,
  <span class="pre">
   csric02()
  </span>
  can only accept
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_NO_LEVEL
  </span>
  ; otherwise,
  <span class="pre">
   CUSPARSE_STATUS_INVALID_VALUE
  </span>
  is returned.
 </p>
 <p>
  Function
  <span class="pre">
   csric02()
  </span>
  reports the first numerical zero, including a structural zero. The user must call
  <span class="pre">
   cusparseXcsric02_zeroPivot()
  </span>
  to know where the numerical zero is.
 </p>
 <p>
  Function
  <span class="pre">
   csric02()
  </span>
  only takes the lower triangular part of matrix
  <span class="pre">
   A
  </span>
  to perform factorization. The matrix type must be
  <span class="pre">
   CUSPARSE_MATRIX_TYPE_GENERAL
  </span>
  , the fill mode and diagonal type are ignored, and the strictly upper triangular part is ignored and never touched. It does not matter if
  <span class="pre">
   A
  </span>
  is Hermitian or not. In other words, from the point of view of
  <span class="pre">
   csric02()
  </span>
  <span class="pre">
   A
  </span>
  is Hermitian and only the lower triangular part is provided.
 </p>
 <p class="admonition-title">
  Note
 </p>
 <p>
  In practice, a positive definite matrix may not have incomplete cholesky factorization. To the best of our knowledge, only matrix
  <span class="pre">
   M
  </span>
  can guarantee the existence of incomplete cholesky factorization. If
  <span class="pre">
   csric02()
  </span>
  failed cholesky factorization and reported a numerical zero, it is possible that incomplete cholesky factorization does not exist.
 </p>
 <p>
  For example, suppose
  <span class="pre">
   A
  </span>
  is a real
  <span class="pre">
   m
  </span>
  <span class="pre">
   
  </span>
  <span class="pre">
   m
  </span>
  matrix, the following code solves the precondition system
  <span class="pre">
   M*y
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   x
  </span>
  where
  <span class="pre">
   M
  </span>
  is the product of Cholesky factorization
  <span class="pre">
   L
  </span>
  and its transpose.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(M = LL^{H}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <pre><span class="c1">// Suppose that A is m x m sparse matrix represented by CSR format,</span>
<span class="c1">// Assumption:</span>
<span class="c1">// - handle is already created by cusparseCreate(),</span>
<span class="c1">// - (d_csrRowPtr, d_csrColInd, d_csrVal) is CSR of A on device memory,</span>
<span class="c1">// - d_x is right hand side vector on device memory,</span>
<span class="c1">// - d_y is solution vector on device memory.</span>
<span class="c1">// - d_z is intermediate result on device memory.</span>

<span class="n">cusparseMatDescr_t</span><span class="n">descr_M</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">cusparseMatDescr_t</span><span class="n">descr_L</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">csric02Info_t</span><span class="n">info_M</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">csrsv2Info_t</span><span class="n">info_L</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">csrsv2Info_t</span><span class="n">info_Lt</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span><span class="n">pBufferSize_M</span><span class="p">;</span>
<span class="kt">int</span><span class="n">pBufferSize_L</span><span class="p">;</span>
<span class="kt">int</span><span class="n">pBufferSize_Lt</span><span class="p">;</span>
<span class="kt">int</span><span class="n">pBufferSize</span><span class="p">;</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span><span class="n">structural_zero</span><span class="p">;</span>
<span class="kt">int</span><span class="n">numerical_zero</span><span class="p">;</span>
<span class="k">const</span><span class="kt">double</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.</span><span class="p">;</span>
<span class="k">const</span><span class="n">cusparseSolvePolicy_t</span><span class="n">policy_M</span><span class="o">=</span><span class="n">CUSPARSE_SOLVE_POLICY_NO_LEVEL</span><span class="p">;</span>
<span class="k">const</span><span class="n">cusparseSolvePolicy_t</span><span class="n">policy_L</span><span class="o">=</span><span class="n">CUSPARSE_SOLVE_POLICY_NO_LEVEL</span><span class="p">;</span>
<span class="k">const</span><span class="n">cusparseSolvePolicy_t</span><span class="n">policy_Lt</span><span class="o">=</span><span class="n">CUSPARSE_SOLVE_POLICY_USE_LEVEL</span><span class="p">;</span>
<span class="k">const</span><span class="n">cusparseOperation_t</span><span class="n">trans_L</span><span class="o">=</span><span class="n">CUSPARSE_OPERATION_NON_TRANSPOSE</span><span class="p">;</span>
<span class="k">const</span><span class="n">cusparseOperation_t</span><span class="n">trans_Lt</span><span class="o">=</span><span class="n">CUSPARSE_OPERATION_TRANSPOSE</span><span class="p">;</span>

<span class="c1">// step 1: create a descriptor which contains</span>
<span class="c1">// - matrix M is base-1</span>
<span class="c1">// - matrix L is base-1</span>
<span class="c1">// - matrix L is lower triangular</span>
<span class="c1">// - matrix L has non-unit diagonal</span>
<span class="n">cusparseCreateMatDescr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">descr_M</span><span class="p">);</span>
<span class="n">cusparseSetMatIndexBase</span><span class="p">(</span><span class="n">descr_M</span><span class="p">,</span><span class="n">CUSPARSE_INDEX_BASE_ONE</span><span class="p">);</span>
<span class="n">cusparseSetMatType</span><span class="p">(</span><span class="n">descr_M</span><span class="p">,</span><span class="n">CUSPARSE_MATRIX_TYPE_GENERAL</span><span class="p">);</span>

<span class="n">cusparseCreateMatDescr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">descr_L</span><span class="p">);</span>
<span class="n">cusparseSetMatIndexBase</span><span class="p">(</span><span class="n">descr_L</span><span class="p">,</span><span class="n">CUSPARSE_INDEX_BASE_ONE</span><span class="p">);</span>
<span class="n">cusparseSetMatType</span><span class="p">(</span><span class="n">descr_L</span><span class="p">,</span><span class="n">CUSPARSE_MATRIX_TYPE_GENERAL</span><span class="p">);</span>
<span class="n">cusparseSetMatFillMode</span><span class="p">(</span><span class="n">descr_L</span><span class="p">,</span><span class="n">CUSPARSE_FILL_MODE_LOWER</span><span class="p">);</span>
<span class="n">cusparseSetMatDiagType</span><span class="p">(</span><span class="n">descr_L</span><span class="p">,</span><span class="n">CUSPARSE_DIAG_TYPE_NON_UNIT</span><span class="p">);</span>

<span class="c1">// step 2: create a empty info structure</span>
<span class="c1">// we need one info for csric02 and two info's for csrsv2</span>
<span class="n">cusparseCreateCsric02Info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info_M</span><span class="p">);</span>
<span class="n">cusparseCreateCsrsv2Info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info_L</span><span class="p">);</span>
<span class="n">cusparseCreateCsrsv2Info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info_Lt</span><span class="p">);</span>

<span class="c1">// step 3: query how much memory used in csric02 and csrsv2, and allocate the buffer</span>
<span class="n">cusparseDcsric02_bufferSize</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">nnz</span><span class="p">,</span>
<span class="n">descr_M</span><span class="p">,</span><span class="n">d_csrVal</span><span class="p">,</span><span class="n">d_csrRowPtr</span><span class="p">,</span><span class="n">d_csrColInd</span><span class="p">,</span><span class="n">info_M</span><span class="p">,</span><span class="o">&amp;</span><span class="n">bufferSize_M</span><span class="p">);</span>
<span class="n">cusparseDcsrsv2_bufferSize</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">trans_L</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">nnz</span><span class="p">,</span>
<span class="n">descr_L</span><span class="p">,</span><span class="n">d_csrVal</span><span class="p">,</span><span class="n">d_csrRowPtr</span><span class="p">,</span><span class="n">d_csrColInd</span><span class="p">,</span><span class="n">info_L</span><span class="p">,</span><span class="o">&amp;</span><span class="n">pBufferSize_L</span><span class="p">);</span>
<span class="n">cusparseDcsrsv2_bufferSize</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">trans_Lt</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">nnz</span><span class="p">,</span>
<span class="n">descr_L</span><span class="p">,</span><span class="n">d_csrVal</span><span class="p">,</span><span class="n">d_csrRowPtr</span><span class="p">,</span><span class="n">d_csrColInd</span><span class="p">,</span><span class="n">info_Lt</span><span class="p">,</span><span class="o">&amp;</span><span class="n">pBufferSize_Lt</span><span class="p">);</span>

<span class="n">pBufferSize</span><span class="o">=</span><span class="n">max</span><span class="p">(</span><span class="n">bufferSize_M</span><span class="p">,</span><span class="n">max</span><span class="p">(</span><span class="n">pBufferSize_L</span><span class="p">,</span><span class="n">pBufferSize_Lt</span><span class="p">));</span>

<span class="c1">// pBuffer returned by cudaMalloc is automatically aligned to 128 bytes.</span>
<span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pBuffer</span><span class="p">,</span><span class="n">pBufferSize</span><span class="p">);</span>

<span class="c1">// step 4: perform analysis of incomplete Cholesky on M</span>
<span class="c1">//         perform analysis of triangular solve on L</span>
<span class="c1">//         perform analysis of triangular solve on L'</span>
<span class="c1">// The lower triangular part of M has the same sparsity pattern as L, so</span>
<span class="c1">// we can do analysis of csric02 and csrsv2 simultaneously.</span>

<span class="n">cusparseDcsric02_analysis</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">nnz</span><span class="p">,</span><span class="n">descr_M</span><span class="p">,</span>
<span class="n">d_csrVal</span><span class="p">,</span><span class="n">d_csrRowPtr</span><span class="p">,</span><span class="n">d_csrColInd</span><span class="p">,</span><span class="n">info_M</span><span class="p">,</span>
<span class="n">policy_M</span><span class="p">,</span><span class="n">pBuffer</span><span class="p">);</span>
<span class="n">status</span><span class="o">=</span><span class="n">cusparseXcsric02_zeroPivot</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">info_M</span><span class="p">,</span><span class="o">&amp;</span><span class="n">structural_zero</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">CUSPARSE_STATUS_ZERO_PIVOT</span><span class="o">==</span><span class="n">status</span><span class="p">){</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"A(%d,%d) is missing</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">structural_zero</span><span class="p">,</span><span class="n">structural_zero</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">cusparseDcsrsv2_analysis</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">trans_L</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">nnz</span><span class="p">,</span><span class="n">descr_L</span><span class="p">,</span>
<span class="n">d_csrVal</span><span class="p">,</span><span class="n">d_csrRowPtr</span><span class="p">,</span><span class="n">d_csrColInd</span><span class="p">,</span>
<span class="n">info_L</span><span class="p">,</span><span class="n">policy_L</span><span class="p">,</span><span class="n">pBuffer</span><span class="p">);</span>

<span class="n">cusparseDcsrsv2_analysis</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">trans_Lt</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">nnz</span><span class="p">,</span><span class="n">descr_L</span><span class="p">,</span>
<span class="n">d_csrVal</span><span class="p">,</span><span class="n">d_csrRowPtr</span><span class="p">,</span><span class="n">d_csrColInd</span><span class="p">,</span>
<span class="n">info_Lt</span><span class="p">,</span><span class="n">policy_Lt</span><span class="p">,</span><span class="n">pBuffer</span><span class="p">);</span>

<span class="c1">// step 5: M = L * L'</span>
<span class="n">cusparseDcsric02</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">nnz</span><span class="p">,</span><span class="n">descr_M</span><span class="p">,</span>
<span class="n">d_csrVal</span><span class="p">,</span><span class="n">d_csrRowPtr</span><span class="p">,</span><span class="n">d_csrColInd</span><span class="p">,</span><span class="n">info_M</span><span class="p">,</span><span class="n">policy_M</span><span class="p">,</span><span class="n">pBuffer</span><span class="p">);</span>
<span class="n">status</span><span class="o">=</span><span class="n">cusparseXcsric02_zeroPivot</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">info_M</span><span class="p">,</span><span class="o">&amp;</span><span class="n">numerical_zero</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">CUSPARSE_STATUS_ZERO_PIVOT</span><span class="o">==</span><span class="n">status</span><span class="p">){</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"L(%d,%d) is zero</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">numerical_zero</span><span class="p">,</span><span class="n">numerical_zero</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// step 6: solve L*z = x</span>
<span class="n">cusparseDcsrsv2_solve</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">trans_L</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">nnz</span><span class="p">,</span><span class="o">&amp;</span><span class="n">alpha</span><span class="p">,</span><span class="n">descr_L</span><span class="p">,</span><span class="c1">// replace with cusparseSpSV</span>
<span class="n">d_csrVal</span><span class="p">,</span><span class="n">d_csrRowPtr</span><span class="p">,</span><span class="n">d_csrColInd</span><span class="p">,</span><span class="n">info_L</span><span class="p">,</span>
<span class="n">d_x</span><span class="p">,</span><span class="n">d_z</span><span class="p">,</span><span class="n">policy_L</span><span class="p">,</span><span class="n">pBuffer</span><span class="p">);</span>

<span class="c1">// step 7: solve L'*y = z</span>
<span class="n">cusparseDcsrsv2_solve</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">trans_Lt</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">nnz</span><span class="p">,</span><span class="o">&amp;</span><span class="n">alpha</span><span class="p">,</span><span class="n">descr_L</span><span class="p">,</span><span class="c1">// replace with cusparseSpSV</span>
<span class="n">d_csrVal</span><span class="p">,</span><span class="n">d_csrRowPtr</span><span class="p">,</span><span class="n">d_csrColInd</span><span class="p">,</span><span class="n">info_Lt</span><span class="p">,</span>
<span class="n">d_z</span><span class="p">,</span><span class="n">d_y</span><span class="p">,</span><span class="n">policy_Lt</span><span class="p">,</span><span class="n">pBuffer</span><span class="p">);</span>

<span class="c1">// step 6: free resources</span>
<span class="n">cudaFree</span><span class="p">(</span><span class="n">pBuffer</span><span class="p">);</span>
<span class="n">cusparseDestroyMatDescr</span><span class="p">(</span><span class="n">descr_M</span><span class="p">);</span>
<span class="n">cusparseDestroyMatDescr</span><span class="p">(</span><span class="n">descr_L</span><span class="p">);</span>
<span class="n">cusparseDestroyCsric02Info</span><span class="p">(</span><span class="n">info_M</span><span class="p">);</span>
<span class="n">cusparseDestroyCsrsv2Info</span><span class="p">(</span><span class="n">info_L</span><span class="p">);</span>
<span class="n">cusparseDestroyCsrsv2Info</span><span class="p">(</span><span class="n">info_Lt</span><span class="p">);</span>
<span class="n">cusparseDestroy</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
</pre>
 <p>
  The function supports the following properties if
  <span class="pre">
   pBuffer
  </span>
  <span class="pre">
   !=
  </span>
  <span class="pre">
   NULL
  </span>
 </p>
 <ul class="simple">
  <li>
   <p>
    This function requires temporary extra storage that is allocated internally
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     number of nonzeros of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrValA_valM
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnz
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      m
     </span>
     <span class="math notranslate nohighlight">
      \(+ 1\)
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnz
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     structure with information collected during the analysis phase (that should have been passed to the solve phase unchanged).
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      policy
     </span>
    </p>
   </td>
   <td>
    <p>
     the supported policies are
     <span class="pre">
      CUSPARSE_SOLVE_POLICY_NO_LEVEL
     </span>
     and
     <span class="pre">
      CUSPARSE_SOLVE_POLICY_USE_LEVEL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     buffer allocated by the user; the size is returned by
     <span class="pre">
      csric02_bufferSize()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrValA_valM
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; matrix containing the incomplete-Cholesky lower triangular factor.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   5.7.1.4.
  </span>
  cusparseXcsric02_zeroPivot()  [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsexcsric02-zeropivot-deprecated" title="Permalink to this headline">
   
  </a>
 </h4>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseXcsric02_zeroPivot</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">csric02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">position</span><span class="p">)</span>
</pre>
 <p>
  If the returned error code is
  <span class="pre">
   CUSPARSE_STATUS_ZERO_PIVOT
  </span>
  ,
  <span class="pre">
   position=j
  </span>
  means
  <span class="pre">
   A(j,j)
  </span>
  has either a structural zero or a numerical zero; otherwise,
  <span class="pre">
   position=-1
  </span>
  .
 </p>
 <p>
  The
  <span class="pre">
   position
  </span>
  can be 0-based or 1-based, the same as the matrix.
 </p>
 <p>
  Function
  <span class="pre">
   cusparseXcsric02_zeroPivot()
  </span>
  is a blocking call. It calls
  <span class="pre">
   cudaDeviceSynchronize()
  </span>
  to make sure all previous kernels are done.
 </p>
 <p>
  The
  <span class="pre">
   position
  </span>
  can be in the host memory or device memory. The user can set proper mode with
  <span class="pre">
   cusparseSetPointerMode()
  </span>
  .
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      info
     </span>
     contains structural zero or numerical zero if the user already called
     <span class="pre">
      csric02_analysis()
     </span>
     or
     <span class="pre">
      csric02()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      position
     </span>
    </p>
   </td>
   <td>
    <p>
     if no structural or numerical zero,
     <span class="pre">
      position
     </span>
     is -1; otherwise, if
     <span class="pre">
      A(j,j)
     </span>
     is missing or
     <span class="pre">
      L(j,j)
     </span>
     is zero,
     <span class="pre">
      position=j
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   5.7.1.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#bsric02_bufferSize">
   cusparse&lt;t&gt;bsric02_bufferSize()
  </a>
  [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsric02-buffersize-deprecated" title="Permalink to this headline">
   
  </a>
 </h4>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSbsric02_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsric02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDbsric02_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsric02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCbsric02_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsric02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZbsric02_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsric02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>
</pre>
 <p>
  This function returns the size of a buffer used in computing the incomplete-Cholesky factorization with 0 fill-in and no pivoting
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A \approx LL^{H}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   (mb*blockDim)*(mb*blockDim)
  </span>
  sparse matrix that is defined in BSR storage format by the three arrays
  <span class="pre">
   bsrValA
  </span>
  ,
  <span class="pre">
   bsrRowPtrA
  </span>
  , and
  <span class="pre">
   bsrColIndA
  </span>
  .
 </p>
 <p>
  The buffer size depends on the dimensions of
  <span class="pre">
   mb
  </span>
  ,
  <span class="pre">
   blockDim
  </span>
  , and the number of nonzero blocks of the matrix
  <span class="pre">
   nnzb
  </span>
  . If the user changes the matrix, it is necessary to call
  <span class="pre">
   bsric02_bufferSize()
  </span>
  again to have the correct buffer size; otherwise, a segmentation fault may occur.
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dirA
     </span>
    </p>
   </td>
   <td>
    <p>
     storage format of blocks, either
     <span class="pre">
      CUSPARSE_DIRECTION_ROW
     </span>
     or
     <span class="pre">
      CUSPARSE_DIRECTION_COLUMN
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      mb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of block rows and block columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzb
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      bsrRowPtrA(mb)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      bsrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      mb
     </span>
     <span class="math notranslate nohighlight">
      \(+ 1\)
     </span>
     elements that contains the start of every block row and the end of the last block row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzb
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      bsrRowPtrA(mb)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      bsrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      blockDim
     </span>
    </p>
   </td>
   <td>
    <p>
     block dimension of sparse matrix A, larger than zero.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     record internal states based on different algorithms.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBufferSizeInBytes
     </span>
    </p>
   </td>
   <td>
    <p>
     number of bytes of the buffer used in
     <span class="pre">
      bsric02_analysis()
     </span>
     and
     <span class="pre">
      bsric02()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   5.7.1.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#bsric02_analysis">
   cusparse&lt;t&gt;bsric02_analysis()
  </a>
  [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsric02-analysis-deprecated" title="Permalink to this headline">
   
  </a>
 </h4>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSbsric02_analysis</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsric02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDbsric02_analysis</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsric02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCbsric02_analysis</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsric02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZbsric02_analysis</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsric02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function performs the analysis phase of the incomplete-Cholesky factorization with 0 fill-in and no pivoting
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A \approx LL^{H}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   (mb*blockDim)x(mb*blockDim)
  </span>
  sparse matrix that is defined in BSR storage format by the three arrays
  <span class="pre">
   bsrValA
  </span>
  ,
  <span class="pre">
   bsrRowPtrA
  </span>
  , and
  <span class="pre">
   bsrColIndA
  </span>
  . The block in BSR format is of size
  <span class="pre">
   blockDim*blockDim
  </span>
  , stored as column-major or row-major as determined by parameter
  <span class="pre">
   dirA
  </span>
  , which is either
  <span class="pre">
   CUSPARSE_DIRECTION_COLUMN
  </span>
  or
  <span class="pre">
   CUSPARSE_DIRECTION_ROW
  </span>
  . The matrix type must be
  <span class="pre">
   CUSPARSE_MATRIX_TYPE_GENERAL
  </span>
  , and the fill mode and diagonal type are ignored.
 </p>
 <p>
  This function requires a buffer size returned by
  <span class="pre">
   bsric02_bufferSize90
  </span>
  . The address of
  <span class="pre">
   pBuffer
  </span>
  must be a multiple of 128 bytes. If it is not,
  <span class="pre">
   CUSPARSE_STATUS_INVALID_VALUE
  </span>
  is returned.
 </p>
 <p>
  Function
  <span class="pre">
   bsric02_analysis()
  </span>
  reports structural zero and computes level information stored in the opaque structure
  <span class="pre">
   info
  </span>
  . The level information can extract more parallelism during incomplete Cholesky factorization. However
  <span class="pre">
   bsric02()
  </span>
  can be done without level information. To disable level information, the user needs to specify the parameter
  <span class="pre">
   policy
  </span>
  of
  <span class="pre">
   bsric02[_analysis|
  </span>
  <span class="pre">
   ]
  </span>
  as
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_NO_LEVEL
  </span>
  .
 </p>
 <p>
  Function
  <span class="pre">
   bsric02_analysis
  </span>
  always reports the first structural zero, even when parameter
  <span class="pre">
   policy
  </span>
  is
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_NO_LEVEL
  </span>
  . The user must call
  <span class="pre">
   cusparseXbsric02_zeroPivot()
  </span>
  to know where the structural zero is.
 </p>
 <p>
  It is the users choice whether to call
  <span class="pre">
   bsric02()
  </span>
  if
  <span class="pre">
   bsric02_analysis()
  </span>
  reports a structural zero. In this case, the user can still call
  <span class="pre">
   bsric02()
  </span>
  , which returns a numerical zero in the same position as the structural zero. However the result is meaningless.
 </p>
 <ul class="simple">
  <li>
   <p>
    This function requires temporary extra storage that is allocated internally
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dirA
     </span>
    </p>
   </td>
   <td>
    <p>
     storage format of blocks, either
     <span class="pre">
      CUSPARSE_DIRECTION_ROW
     </span>
     or
     <span class="pre">
      CUSPARSE_DIRECTION_COLUMN
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      mb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of block rows and block columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzb
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      bsrRowPtrA(mb)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      bsrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      mb
     </span>
     <span class="math notranslate nohighlight">
      \(+ 1\)
     </span>
     elements that contains the start of every block row and the end of the last block row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzb
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      bsrRowPtrA(mb)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      bsrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      blockDim
     </span>
    </p>
   </td>
   <td>
    <p>
     block dimension of sparse matrix A; must be larger than zero.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     structure initialized using
     <span class="pre">
      cusparseCreateBsric02Info()
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      policy
     </span>
    </p>
   </td>
   <td>
    <p>
     the supported policies are
     <span class="pre">
      CUSPARSE_SOLVE_POLICY_NO_LEVEL
     </span>
     and
     <span class="pre">
      CUSPARSE_SOLVE_POLICY_USE_LEVEL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     buffer allocated by the user; the size is returned by
     <span class="pre">
      bsric02_bufferSize()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     Structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   5.7.1.7.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#bsric02_solve">
   cusparse&lt;t&gt;bsric02()
  </a>
  [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsric02-deprecated" title="Permalink to this headline">
   
  </a>
 </h4>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSbsric02</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsric02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDbsric02</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsric02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCbsric02</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsric02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZbsric02</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsric02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function performs the solve phase of the incomplete-Cholesky factorization with 0 fill-in and no pivoting
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A \approx LL^{H}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   (mb*blockDim)(mb*blockDim)
  </span>
  sparse matrix that is defined in BSR storage format by the three arrays
  <span class="pre">
   bsrValA
  </span>
  ,
  <span class="pre">
   bsrRowPtrA
  </span>
  , and
  <span class="pre">
   bsrColIndA
  </span>
  . The block in BSR format is of size
  <span class="pre">
   blockDim*blockDim
  </span>
  , stored as column-major or row-major as determined by parameter
  <span class="pre">
   dirA
  </span>
  , which is either
  <span class="pre">
   CUSPARSE_DIRECTION_COLUMN
  </span>
  or
  <span class="pre">
   CUSPARSE_DIRECTION_ROW
  </span>
  . The matrix type must be
  <span class="pre">
   CUSPARSE_MATRIX_TYPE_GENERAL
  </span>
  , and the fill mode and diagonal type are ignored.
 </p>
 <p>
  This function requires a buffer size returned by
  <span class="pre">
   bsric02_bufferSize()
  </span>
  . The address of
  <span class="pre">
   pBuffer
  </span>
  must be a multiple of 128 bytes. If it is not,
  <span class="pre">
   CUSPARSE_STATUS_INVALID_VALUE
  </span>
  is returned.
 </p>
 <p>
  Although
  <span class="pre">
   bsric02()
  </span>
  can be done without level information, the user must be aware of consistency. If
  <span class="pre">
   bsric02_analysis()
  </span>
  is called with policy
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_USE_LEVEL
  </span>
  ,
  <span class="pre">
   bsric02()
  </span>
  can be run with or without levels. On the other hand, if
  <span class="pre">
   bsric02_analysis()
  </span>
  is called with
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_NO_LEVEL
  </span>
  ,
  <span class="pre">
   bsric02()
  </span>
  can only accept
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_NO_LEVEL
  </span>
  ; otherwise,
  <span class="pre">
   CUSPARSE_STATUS_INVALID_VALUE
  </span>
  is returned.
 </p>
 <p>
  Function
  <span class="pre">
   bsric02()
  </span>
  has the same behavior as
  <span class="pre">
   csric02()
  </span>
  . That is,
  <span class="pre">
   bsr2csr(bsric02(A))
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   csric02(bsr2csr(A))
  </span>
  . The numerical zero of
  <span class="pre">
   csric02()
  </span>
  means there exists some zero
  <span class="pre">
   L(j,j)
  </span>
  . The numerical zero of
  <span class="pre">
   bsric02()
  </span>
  means there exists some block
  <span class="pre">
   Lj,j)
  </span>
  that is not invertible.
 </p>
 <p>
  Function
  <span class="pre">
   bsric02
  </span>
  reports the first numerical zero, including a structural zero. The user must call
  <span class="pre">
   cusparseXbsric02_zeroPivot()
  </span>
  to know where the numerical zero is.
 </p>
 <p>
  The
  <span class="pre">
   bsric02()
  </span>
  function only takes the lower triangular part of matrix
  <span class="pre">
   A
  </span>
  to perform factorization. The strictly upper triangular part is ignored and never touched. It does not matter if
  <span class="pre">
   A
  </span>
  is Hermitian or not. In other words, from the point of view of
  <span class="pre">
   bsric02()
  </span>
  ,
  <span class="pre">
   A
  </span>
  is Hermitian and only the lower triangular part is provided. Moreover, the imaginary part of diagonal elements of diagonal blocks is ignored.
 </p>
 <p>
  For example, suppose
  <span class="pre">
   A
  </span>
  is a real m-by-m matrix, where
  <span class="pre">
   m=mb*blockDim
  </span>
  . The following code solves precondition system
  <span class="pre">
   M*y
  </span>
  <span class="pre">
   =
  </span>
  
  <span class="pre">
   x
  </span>
  , where
  <span class="pre">
   M
  </span>
  is the product of Cholesky factorization
  <span class="pre">
   L
  </span>
  and its transpose.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(M = LL^{H}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <pre><span class="c1">// Suppose that A is m x m sparse matrix represented by BSR format,</span>
<span class="c1">// The number of block rows/columns is mb, and</span>
<span class="c1">// the number of nonzero blocks is nnzb.</span>
<span class="c1">// Assumption:</span>
<span class="c1">// - handle is already created by cusparseCreate(),</span>
<span class="c1">// - (d_bsrRowPtr, d_bsrColInd, d_bsrVal) is BSR of A on device memory,</span>
<span class="c1">// - d_x is right hand side vector on device memory,</span>
<span class="c1">// - d_y is solution vector on device memory.</span>
<span class="c1">// - d_z is intermediate result on device memory.</span>
<span class="c1">// - d_x, d_y and d_z are of size m.</span>
<span class="n">cusparseMatDescr_t</span><span class="n">descr_M</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">cusparseMatDescr_t</span><span class="n">descr_L</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">bsric02Info_t</span><span class="n">info_M</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">bsrsv2Info_t</span><span class="n">info_L</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">bsrsv2Info_t</span><span class="n">info_Lt</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span><span class="n">pBufferSize_M</span><span class="p">;</span>
<span class="kt">int</span><span class="n">pBufferSize_L</span><span class="p">;</span>
<span class="kt">int</span><span class="n">pBufferSize_Lt</span><span class="p">;</span>
<span class="kt">int</span><span class="n">pBufferSize</span><span class="p">;</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span><span class="n">structural_zero</span><span class="p">;</span>
<span class="kt">int</span><span class="n">numerical_zero</span><span class="p">;</span>
<span class="k">const</span><span class="kt">double</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.</span><span class="p">;</span>
<span class="k">const</span><span class="n">cusparseSolvePolicy_t</span><span class="n">policy_M</span><span class="o">=</span><span class="n">CUSPARSE_SOLVE_POLICY_NO_LEVEL</span><span class="p">;</span>
<span class="k">const</span><span class="n">cusparseSolvePolicy_t</span><span class="n">policy_L</span><span class="o">=</span><span class="n">CUSPARSE_SOLVE_POLICY_NO_LEVEL</span><span class="p">;</span>
<span class="k">const</span><span class="n">cusparseSolvePolicy_t</span><span class="n">policy_Lt</span><span class="o">=</span><span class="n">CUSPARSE_SOLVE_POLICY_USE_LEVEL</span><span class="p">;</span>
<span class="k">const</span><span class="n">cusparseOperation_t</span><span class="n">trans_L</span><span class="o">=</span><span class="n">CUSPARSE_OPERATION_NON_TRANSPOSE</span><span class="p">;</span>
<span class="k">const</span><span class="n">cusparseOperation_t</span><span class="n">trans_Lt</span><span class="o">=</span><span class="n">CUSPARSE_OPERATION_TRANSPOSE</span><span class="p">;</span>
<span class="k">const</span><span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="o">=</span><span class="n">CUSPARSE_DIRECTION_COLUMN</span><span class="p">;</span>

<span class="c1">// step 1: create a descriptor which contains</span>
<span class="c1">// - matrix M is base-1</span>
<span class="c1">// - matrix L is base-1</span>
<span class="c1">// - matrix L is lower triangular</span>
<span class="c1">// - matrix L has non-unit diagonal</span>
<span class="n">cusparseCreateMatDescr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">descr_M</span><span class="p">);</span>
<span class="n">cusparseSetMatIndexBase</span><span class="p">(</span><span class="n">descr_M</span><span class="p">,</span><span class="n">CUSPARSE_INDEX_BASE_ONE</span><span class="p">);</span>
<span class="n">cusparseSetMatType</span><span class="p">(</span><span class="n">descr_M</span><span class="p">,</span><span class="n">CUSPARSE_MATRIX_TYPE_GENERAL</span><span class="p">);</span>

<span class="n">cusparseCreateMatDescr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">descr_L</span><span class="p">);</span>
<span class="n">cusparseSetMatIndexBase</span><span class="p">(</span><span class="n">descr_L</span><span class="p">,</span><span class="n">CUSPARSE_INDEX_BASE_ONE</span><span class="p">);</span>
<span class="n">cusparseSetMatType</span><span class="p">(</span><span class="n">descr_L</span><span class="p">,</span><span class="n">CUSPARSE_MATRIX_TYPE_GENERAL</span><span class="p">);</span>
<span class="n">cusparseSetMatFillMode</span><span class="p">(</span><span class="n">descr_L</span><span class="p">,</span><span class="n">CUSPARSE_FILL_MODE_LOWER</span><span class="p">);</span>
<span class="n">cusparseSetMatDiagType</span><span class="p">(</span><span class="n">descr_L</span><span class="p">,</span><span class="n">CUSPARSE_DIAG_TYPE_NON_UNIT</span><span class="p">);</span>

<span class="c1">// step 2: create a empty info structure</span>
<span class="c1">// we need one info for bsric02 and two info's for bsrsv2</span>
<span class="n">cusparseCreateBsric02Info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info_M</span><span class="p">);</span>
<span class="n">cusparseCreateBsrsv2Info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info_L</span><span class="p">);</span>
<span class="n">cusparseCreateBsrsv2Info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info_Lt</span><span class="p">);</span>

<span class="c1">// step 3: query how much memory used in bsric02 and bsrsv2, and allocate the buffer</span>
<span class="n">cusparseDbsric02_bufferSize</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span><span class="n">mb</span><span class="p">,</span><span class="n">nnzb</span><span class="p">,</span>
<span class="n">descr_M</span><span class="p">,</span><span class="n">d_bsrVal</span><span class="p">,</span><span class="n">d_bsrRowPtr</span><span class="p">,</span><span class="n">d_bsrColInd</span><span class="p">,</span><span class="n">blockDim</span><span class="p">,</span><span class="n">info_M</span><span class="p">,</span><span class="o">&amp;</span><span class="n">bufferSize_M</span><span class="p">);</span>
<span class="n">cusparseDbsrsv2_bufferSize</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span><span class="n">trans_L</span><span class="p">,</span><span class="n">mb</span><span class="p">,</span><span class="n">nnzb</span><span class="p">,</span>
<span class="n">descr_L</span><span class="p">,</span><span class="n">d_bsrVal</span><span class="p">,</span><span class="n">d_bsrRowPtr</span><span class="p">,</span><span class="n">d_bsrColInd</span><span class="p">,</span><span class="n">blockDim</span><span class="p">,</span><span class="n">info_L</span><span class="p">,</span><span class="o">&amp;</span><span class="n">pBufferSize_L</span><span class="p">);</span>
<span class="n">cusparseDbsrsv2_bufferSize</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span><span class="n">trans_Lt</span><span class="p">,</span><span class="n">mb</span><span class="p">,</span><span class="n">nnzb</span><span class="p">,</span>
<span class="n">descr_L</span><span class="p">,</span><span class="n">d_bsrVal</span><span class="p">,</span><span class="n">d_bsrRowPtr</span><span class="p">,</span><span class="n">d_bsrColInd</span><span class="p">,</span><span class="n">blockDim</span><span class="p">,</span><span class="n">info_Lt</span><span class="p">,</span><span class="o">&amp;</span><span class="n">pBufferSize_Lt</span><span class="p">);</span>

<span class="n">pBufferSize</span><span class="o">=</span><span class="n">max</span><span class="p">(</span><span class="n">bufferSize_M</span><span class="p">,</span><span class="n">max</span><span class="p">(</span><span class="n">pBufferSize_L</span><span class="p">,</span><span class="n">pBufferSize_Lt</span><span class="p">));</span>

<span class="c1">// pBuffer returned by cudaMalloc is automatically aligned to 128 bytes.</span>
<span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pBuffer</span><span class="p">,</span><span class="n">pBufferSize</span><span class="p">);</span>

<span class="c1">// step 4: perform analysis of incomplete Cholesky on M</span>
<span class="c1">//         perform analysis of triangular solve on L</span>
<span class="c1">//         perform analysis of triangular solve on L'</span>
<span class="c1">// The lower triangular part of M has the same sparsity pattern as L, so</span>
<span class="c1">// we can do analysis of bsric02 and bsrsv2 simultaneously.</span>

<span class="n">cusparseDbsric02_analysis</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span><span class="n">mb</span><span class="p">,</span><span class="n">nnzb</span><span class="p">,</span><span class="n">descr_M</span><span class="p">,</span>
<span class="n">d_bsrVal</span><span class="p">,</span><span class="n">d_bsrRowPtr</span><span class="p">,</span><span class="n">d_bsrColInd</span><span class="p">,</span><span class="n">blockDim</span><span class="p">,</span><span class="n">info_M</span><span class="p">,</span>
<span class="n">policy_M</span><span class="p">,</span><span class="n">pBuffer</span><span class="p">);</span>
<span class="n">status</span><span class="o">=</span><span class="n">cusparseXbsric02_zeroPivot</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">info_M</span><span class="p">,</span><span class="o">&amp;</span><span class="n">structural_zero</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">CUSPARSE_STATUS_ZERO_PIVOT</span><span class="o">==</span><span class="n">status</span><span class="p">){</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"A(%d,%d) is missing</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">structural_zero</span><span class="p">,</span><span class="n">structural_zero</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">cusparseDbsrsv2_analysis</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span><span class="n">trans_L</span><span class="p">,</span><span class="n">mb</span><span class="p">,</span><span class="n">nnzb</span><span class="p">,</span><span class="n">descr_L</span><span class="p">,</span>
<span class="n">d_bsrVal</span><span class="p">,</span><span class="n">d_bsrRowPtr</span><span class="p">,</span><span class="n">d_bsrColInd</span><span class="p">,</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">info_L</span><span class="p">,</span><span class="n">policy_L</span><span class="p">,</span><span class="n">pBuffer</span><span class="p">);</span>

<span class="n">cusparseDbsrsv2_analysis</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span><span class="n">trans_Lt</span><span class="p">,</span><span class="n">mb</span><span class="p">,</span><span class="n">nnzb</span><span class="p">,</span><span class="n">descr_L</span><span class="p">,</span>
<span class="n">d_bsrVal</span><span class="p">,</span><span class="n">d_bsrRowPtr</span><span class="p">,</span><span class="n">d_bsrColInd</span><span class="p">,</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">info_Lt</span><span class="p">,</span><span class="n">policy_Lt</span><span class="p">,</span><span class="n">pBuffer</span><span class="p">);</span>

<span class="c1">// step 5: M = L * L'</span>
<span class="n">cusparseDbsric02_solve</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span><span class="n">mb</span><span class="p">,</span><span class="n">nnzb</span><span class="p">,</span><span class="n">descr_M</span><span class="p">,</span>
<span class="n">d_bsrVal</span><span class="p">,</span><span class="n">d_bsrRowPtr</span><span class="p">,</span><span class="n">d_bsrColInd</span><span class="p">,</span><span class="n">blockDim</span><span class="p">,</span><span class="n">info_M</span><span class="p">,</span><span class="n">policy_M</span><span class="p">,</span><span class="n">pBuffer</span><span class="p">);</span>
<span class="n">status</span><span class="o">=</span><span class="n">cusparseXbsric02_zeroPivot</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">info_M</span><span class="p">,</span><span class="o">&amp;</span><span class="n">numerical_zero</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">CUSPARSE_STATUS_ZERO_PIVOT</span><span class="o">==</span><span class="n">status</span><span class="p">){</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"L(%d,%d) is not positive definite</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">numerical_zero</span><span class="p">,</span><span class="n">numerical_zero</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// step 6: solve L*z = x</span>
<span class="n">cusparseDbsrsv2_solve</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span><span class="n">trans_L</span><span class="p">,</span><span class="n">mb</span><span class="p">,</span><span class="n">nnzb</span><span class="p">,</span><span class="o">&amp;</span><span class="n">alpha</span><span class="p">,</span><span class="n">descr_L</span><span class="p">,</span>
<span class="n">d_bsrVal</span><span class="p">,</span><span class="n">d_bsrRowPtr</span><span class="p">,</span><span class="n">d_bsrColInd</span><span class="p">,</span><span class="n">blockDim</span><span class="p">,</span><span class="n">info_L</span><span class="p">,</span>
<span class="n">d_x</span><span class="p">,</span><span class="n">d_z</span><span class="p">,</span><span class="n">policy_L</span><span class="p">,</span><span class="n">pBuffer</span><span class="p">);</span>

<span class="c1">// step 7: solve L'*y = z</span>
<span class="n">cusparseDbsrsv2_solve</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span><span class="n">trans_Lt</span><span class="p">,</span><span class="n">mb</span><span class="p">,</span><span class="n">nnzb</span><span class="p">,</span><span class="o">&amp;</span><span class="n">alpha</span><span class="p">,</span><span class="n">descr_L</span><span class="p">,</span>
<span class="n">d_bsrVal</span><span class="p">,</span><span class="n">d_bsrRowPtr</span><span class="p">,</span><span class="n">d_bsrColInd</span><span class="p">,</span><span class="n">blockDim</span><span class="p">,</span><span class="n">info_Lt</span><span class="p">,</span>
<span class="n">d_z</span><span class="p">,</span><span class="n">d_y</span><span class="p">,</span><span class="n">policy_Lt</span><span class="p">,</span><span class="n">pBuffer</span><span class="p">);</span>

<span class="c1">// step 6: free resources</span>
<span class="n">cudaFree</span><span class="p">(</span><span class="n">pBuffer</span><span class="p">);</span>
<span class="n">cusparseDestroyMatDescr</span><span class="p">(</span><span class="n">descr_M</span><span class="p">);</span>
<span class="n">cusparseDestroyMatDescr</span><span class="p">(</span><span class="n">descr_L</span><span class="p">);</span>
<span class="n">cusparseDestroyBsric02Info</span><span class="p">(</span><span class="n">info_M</span><span class="p">);</span>
<span class="n">cusparseDestroyBsrsv2Info</span><span class="p">(</span><span class="n">info_L</span><span class="p">);</span>
<span class="n">cusparseDestroyBsrsv2Info</span><span class="p">(</span><span class="n">info_Lt</span><span class="p">);</span>
<span class="n">cusparseDestroy</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
</pre>
 <p>
  The function supports the following properties if
  <span class="pre">
   pBuffer
  </span>
  <span class="pre">
   !=
  </span>
  <span class="pre">
   NULL
  </span>
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dirA
     </span>
    </p>
   </td>
   <td>
    <p>
     storage format of blocks, either
     <span class="pre">
      CUSPARSE_DIRECTION_ROW
     </span>
     or
     <span class="pre">
      CUSPARSE_DIRECTION_COLUMN
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      mb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of block rows and block columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzb
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      bsrRowPtrA(mb)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      bsrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      mb
     </span>
     <span class="math notranslate nohighlight">
      \(+ 1\)
     </span>
     elements that contains the start of every block row and the end of the last block row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzb
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      bsrRowPtrA(mb)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      bsrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      blockDim
     </span>
    </p>
   </td>
   <td>
    <p>
     block dimension of sparse matrix A, larger than zero.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     structure with information collected during the analysis phase (that should have been passed to the solve phase unchanged).
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      policy
     </span>
    </p>
   </td>
   <td>
    <p>
     the supported policies are
     <span class="pre">
      CUSPARSE_SOLVE_POLICY_NO_LEVEL
     </span>
     and
     <span class="pre">
      CUSPARSE_SOLVE_POLICY_USE_LEVEL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     buffer allocated by the user, the size is returned by
     <span class="pre">
      bsric02_bufferSize()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; matrix containing the incomplete-Cholesky lower triangular factor.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   5.7.1.8.
  </span>
  cusparseXbsric02_zeroPivot()  [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsexbsric02-zeropivot-deprecated" title="Permalink to this headline">
   
  </a>
 </h4>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseXbsric02_zeroPivot</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">bsric02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">position</span><span class="p">)</span>
</pre>
 <p>
  If the returned error code is
  <span class="pre">
   CUSPARSE_STATUS_ZERO_PIVOT
  </span>
  ,
  <span class="pre">
   position=j
  </span>
  means
  <span class="pre">
   A(j,j)
  </span>
  has either a structural zero or a numerical zero (the block is not positive definite). Otherwise
  <span class="pre">
   position=-1
  </span>
  .
 </p>
 <p>
  The
  <span class="pre">
   position
  </span>
  can be 0-based or 1-based, the same as the matrix.
 </p>
 <p>
  Function
  <span class="pre">
   cusparseXbsric02_zeroPivot()
  </span>
  is a blocking call. It calls
  <span class="pre">
   cudaDeviceSynchronize()
  </span>
  to make sure all previous kernels are done.
 </p>
 <p>
  The
  <span class="pre">
   position
  </span>
  can be in the host memory or device memory. The user can set the proper mode with
  <span class="pre">
   cusparseSetPointerMode()
  </span>
  .
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      info
     </span>
     contains a structural zero or a numerical zero if the user already called
     <span class="pre">
      bsric02_analysis()
     </span>
     or
     <span class="pre">
      bsric02()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      position
     </span>
    </p>
   </td>
   <td>
    <p>
     If no structural or numerical zero,
     <span class="pre">
      position
     </span>
     is -1, otherwise if
     <span class="pre">
      A(j,j)
     </span>
     is missing or
     <span class="pre">
      L(j,j)
     </span>
     is not positive definite,
     <span class="pre">
      position=j
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   5.7.2.
  </span>
  Incomplete LU Factorization: level 0 [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#incomplete-lu-factorization-level-0-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  Different algorithms for ilu0 are discussed in this section.
 </p>
 <h4>
  <span class="section-number">
   5.7.2.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#csrilu02_numerical_boost">
   cusparse&lt;t&gt;csrilu02_numericBoost()
  </a>
  [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-csrilu02-numericboost-deprecated" title="Permalink to this headline">
   
  </a>
 </h4>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseScsrilu02_numericBoost</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">csrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="n">enable_boost</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">tol</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">boost_val</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDcsrilu02_numericBoost</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">csrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="n">enable_boost</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">tol</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">boost_val</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCcsrilu02_numericBoost</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">csrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="n">enable_boost</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">tol</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">boost_val</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZcsrilu02_numericBoost</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">csrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="n">enable_boost</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">tol</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">boost_val</span><span class="p">)</span>
</pre>
 <p>
  The user can use a boost value to replace a numerical value in incomplete LU factorization. The
  <span class="pre">
   tol
  </span>
  is used to determine a numerical zero, and the
  <span class="pre">
   boost_val
  </span>
  is used to replace a numerical zero. The behavior is
 </p>
 <p>
  if
  <span class="pre">
   tol
  </span>
  <span class="pre">
   &gt;=
  </span>
  <span class="pre">
   fabs(A(j,j))
  </span>
  , then
  <span class="pre">
   A(j,j)=boost_val
  </span>
  .
 </p>
 <p>
  To enable a boost value, the user has to set parameter
  <span class="pre">
   enable_boost
  </span>
  to 1 before calling
  <span class="pre">
   csrilu02()
  </span>
  . To disable a boost value, the user can call
  <span class="pre">
   csrilu02_numericBoost()
  </span>
  again with parameter
  <span class="pre">
   enable_boost=0
  </span>
  .
 </p>
 <p>
  If
  <span class="pre">
   enable_boost=0
  </span>
  ,
  <span class="pre">
   tol
  </span>
  and
  <span class="pre">
   boost_val
  </span>
  are ignored.
 </p>
 <p>
  Both
  <span class="pre">
   tol
  </span>
  and
  <span class="pre">
   boost_val
  </span>
  can be in the host memory or device memory. The user can set the proper mode with
  <span class="pre">
   cusparseSetPointerMode()
  </span>
  .
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     structure initialized using
     <span class="pre">
      cusparseCreateCsrilu02Info()
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      enable_boost
     </span>
    </p>
   </td>
   <td>
    <p>
     disable boost by
     <span class="pre">
      enable_boost=0
     </span>
     ; otherwise, boost is enabled
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      tol
     </span>
    </p>
   </td>
   <td>
    <p>
     tolerance to determine a numerical zero
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      boost_val
     </span>
    </p>
   </td>
   <td>
    <p>
     boost value to replace a numerical zero
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   5.7.2.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#csrilu02_bufferSize">
   cusparse&lt;t&gt;csrilu02_bufferSize()
  </a>
  [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-csrilu02-buffersize-deprecated" title="Permalink to this headline">
   
  </a>
 </h4>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseScsrilu02_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">csrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDcsrilu02_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">csrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCcsrilu02_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">csrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZcsrilu02_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">csrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>
</pre>
 <p>
  This function returns size of the buffer used in computing the incomplete-LU factorization with
  <span class="math notranslate nohighlight">
   \(0\)
  </span>
  fill-in and no pivoting:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A \approx LU\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   mm
  </span>
  sparse matrix that is defined in CSR storage format by the three arrays
  <span class="pre">
   csrValA
  </span>
  ,
  <span class="pre">
   csrRowPtrA
  </span>
  , and
  <span class="pre">
   csrColIndA
  </span>
  .
 </p>
 <p>
  The buffer size depends on the dimension
  <span class="pre">
   m
  </span>
  and
  <span class="pre">
   nnz
  </span>
  , the number of nonzeros of the matrix. If the user changes the matrix, it is necessary to call
  <span class="pre">
   csrilu02_bufferSize()
  </span>
  again to have the correct buffer size; otherwise, a segmentation fault may occur.
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     number of nonzeros of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnz
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      m
     </span>
     <span class="math notranslate nohighlight">
      \(+ 1\)
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnz
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     record internal states based on different algorithms
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBufferSizeInBytes
     </span>
    </p>
   </td>
   <td>
    <p>
     number of bytes of the buffer used in
     <span class="pre">
      csrilu02_analysis()
     </span>
     and
     <span class="pre">
      csrilu02()
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   5.7.2.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#csrilu02_analysis">
   cusparse&lt;t&gt;csrilu02_analysis()
  </a>
  [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-csrilu02-analysis-deprecated" title="Permalink to this headline">
   
  </a>
 </h4>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseScsrilu02_analysis</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">csrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDcsrilu02_analysis</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">csrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCcsrilu02_analysis</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">csrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZcsrilu02_analysis</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">csrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function performs the analysis phase of the incomplete-LU factorization with
  <span class="math notranslate nohighlight">
   \(0\)
  </span>
  fill-in and no pivoting:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A \approx LU\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   mm
  </span>
  sparse matrix that is defined in CSR storage format by the three arrays
  <span class="pre">
   csrValA
  </span>
  ,
  <span class="pre">
   csrRowPtrA
  </span>
  , and
  <span class="pre">
   csrColIndA
  </span>
  .
 </p>
 <p>
  This function requires the buffer size returned by
  <span class="pre">
   csrilu02_bufferSize()
  </span>
  . The address of
  <span class="pre">
   pBuffer
  </span>
  must be a multiple of 128 bytes. If not,
  <span class="pre">
   CUSPARSE_STATUS_INVALID_VALUE
  </span>
  is returned.
 </p>
 <p>
  Function
  <span class="pre">
   csrilu02_analysis()
  </span>
  reports a structural zero and computes level information stored in the opaque structure
  <span class="pre">
   info
  </span>
  . The level information can extract more parallelism during incomplete LU factorization; however
  <span class="pre">
   csrilu02()
  </span>
  can be done without level information. To disable level information, the user must specify the policy of
  <span class="pre">
   csrilu02()
  </span>
  as
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_NO_LEVEL
  </span>
  .
 </p>
 <p>
  It is the users choice whether to call
  <span class="pre">
   csrilu02()
  </span>
  if
  <span class="pre">
   csrilu02_analysis()
  </span>
  reports a structural zero. In this case, the user can still call
  <span class="pre">
   csrilu02()
  </span>
  , which will return a numerical zero at the same position as the structural zero. However the result is meaningless.
 </p>
 <ul class="simple">
  <li>
   <p>
    This function requires temporary extra storage that is allocated internally
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     number of nonzeros of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnz
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      m
     </span>
     <span class="math notranslate nohighlight">
      \(+ 1\)
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnz
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     structure initialized using
     <span class="pre">
      cusparseCreateCsrilu02Info()
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      policy
     </span>
    </p>
   </td>
   <td>
    <p>
     the supported policies are
     <span class="pre">
      CUSPARSE_SOLVE_POLICY_NO_LEVEL
     </span>
     and
     <span class="pre">
      CUSPARSE_SOLVE_POLICY_USE_LEVEL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     buffer allocated by the user, the size is returned by
     <span class="pre">
      csrilu02_bufferSize()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     Structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   5.7.2.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#csrilu02_solve">
   cusparse&lt;t&gt;csrilu02()
  </a>
  [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-csrilu02-deprecated" title="Permalink to this headline">
   
  </a>
 </h4>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseScsrilu02</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">csrValA_valM</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">csrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDcsrilu02</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">csrValA_valM</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">csrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCcsrilu02</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">csrValA_valM</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">csrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZcsrilu02</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrValA_valM</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">csrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function performs the solve phase of the incomplete-LU factorization with
  <span class="math notranslate nohighlight">
   \(0\)
  </span>
  fill-in and no pivoting:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A \approx LU\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   mm
  </span>
  sparse matrix that is defined in CSR storage format by the three arrays
  <span class="pre">
   csrValA_valM
  </span>
  ,
  <span class="pre">
   csrRowPtrA
  </span>
  , and
  <span class="pre">
   csrColIndA
  </span>
  .
 </p>
 <p>
  This function requires a buffer size returned by
  <span class="pre">
   csrilu02_bufferSize()
  </span>
  . The address of
  <span class="pre">
   pBuffer
  </span>
  must be a multiple of 128 bytes. If not,
  <span class="pre">
   CUSPARSE_STATUS_INVALID_VALUE
  </span>
  is returned.
 </p>
 <p>
  The matrix type must be
  <span class="pre">
   CUSPARSE_MATRIX_TYPE_GENERAL
  </span>
  . The fill mode and diagonal type are ignored.
 </p>
 <p>
  Although
  <span class="pre">
   csrilu02()
  </span>
  can be done without level information, the user still needs to be aware of consistency. If
  <span class="pre">
   csrilu02_analysis()
  </span>
  is called with policy
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_USE_LEVEL
  </span>
  ,
  <span class="pre">
   csrilu02()
  </span>
  can be run with or without levels. On the other hand, if
  <span class="pre">
   csrilu02_analysis()
  </span>
  is called with
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_NO_LEVEL
  </span>
  ,
  <span class="pre">
   csrilu02()
  </span>
  can only accept
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_NO_LEVEL
  </span>
  ; otherwise,
  <span class="pre">
   CUSPARSE_STATUS_INVALID_VALUE
  </span>
  is returned.
 </p>
 <p>
  Function
  <span class="pre">
   csrilu02()
  </span>
  reports the first numerical zero, including a structural zero. The user must call
  <span class="pre">
   cusparseXcsrilu02_zeroPivot()
  </span>
  to know where the numerical zero is.
 </p>
 <p>
  For example, suppose
  <span class="pre">
   A
  </span>
  is a real
  <span class="pre">
   m
  </span>
  <span class="pre">
   
  </span>
  <span class="pre">
   m
  </span>
  matrix, the following code solves precondition system
  <span class="pre">
   M*y
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   x
  </span>
  where
  <span class="pre">
   M
  </span>
  is the product of LU factors
  <span class="pre">
   L
  </span>
  and
  <span class="pre">
   U
  </span>
  .
 </p>
 <pre><span class="c1">// Suppose that A is m x m sparse matrix represented by CSR format,</span>
<span class="c1">// Assumption:</span>
<span class="c1">// - handle is already created by cusparseCreate(),</span>
<span class="c1">// - (d_csrRowPtr, d_csrColInd, d_csrVal) is CSR of A on device memory,</span>
<span class="c1">// - d_x is right hand side vector on device memory,</span>
<span class="c1">// - d_y is solution vector on device memory.</span>
<span class="c1">// - d_z is intermediate result on device memory.</span>

<span class="n">cusparseMatDescr_t</span><span class="n">descr_M</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">cusparseMatDescr_t</span><span class="n">descr_L</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">cusparseMatDescr_t</span><span class="n">descr_U</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">csrilu02Info_t</span><span class="n">info_M</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">csrsv2Info_t</span><span class="n">info_L</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">csrsv2Info_t</span><span class="n">info_U</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span><span class="n">pBufferSize_M</span><span class="p">;</span>
<span class="kt">int</span><span class="n">pBufferSize_L</span><span class="p">;</span>
<span class="kt">int</span><span class="n">pBufferSize_U</span><span class="p">;</span>
<span class="kt">int</span><span class="n">pBufferSize</span><span class="p">;</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span><span class="n">structural_zero</span><span class="p">;</span>
<span class="kt">int</span><span class="n">numerical_zero</span><span class="p">;</span>
<span class="k">const</span><span class="kt">double</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.</span><span class="p">;</span>
<span class="k">const</span><span class="n">cusparseSolvePolicy_t</span><span class="n">policy_M</span><span class="o">=</span><span class="n">CUSPARSE_SOLVE_POLICY_NO_LEVEL</span><span class="p">;</span>
<span class="k">const</span><span class="n">cusparseSolvePolicy_t</span><span class="n">policy_L</span><span class="o">=</span><span class="n">CUSPARSE_SOLVE_POLICY_NO_LEVEL</span><span class="p">;</span>
<span class="k">const</span><span class="n">cusparseSolvePolicy_t</span><span class="n">policy_U</span><span class="o">=</span><span class="n">CUSPARSE_SOLVE_POLICY_USE_LEVEL</span><span class="p">;</span>
<span class="k">const</span><span class="n">cusparseOperation_t</span><span class="n">trans_L</span><span class="o">=</span><span class="n">CUSPARSE_OPERATION_NON_TRANSPOSE</span><span class="p">;</span>
<span class="k">const</span><span class="n">cusparseOperation_t</span><span class="n">trans_U</span><span class="o">=</span><span class="n">CUSPARSE_OPERATION_NON_TRANSPOSE</span><span class="p">;</span>

<span class="c1">// step 1: create a descriptor which contains</span>
<span class="c1">// - matrix M is base-1</span>
<span class="c1">// - matrix L is base-1</span>
<span class="c1">// - matrix L is lower triangular</span>
<span class="c1">// - matrix L has unit diagonal</span>
<span class="c1">// - matrix U is base-1</span>
<span class="c1">// - matrix U is upper triangular</span>
<span class="c1">// - matrix U has non-unit diagonal</span>
<span class="n">cusparseCreateMatDescr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">descr_M</span><span class="p">);</span>
<span class="n">cusparseSetMatIndexBase</span><span class="p">(</span><span class="n">descr_M</span><span class="p">,</span><span class="n">CUSPARSE_INDEX_BASE_ONE</span><span class="p">);</span>
<span class="n">cusparseSetMatType</span><span class="p">(</span><span class="n">descr_M</span><span class="p">,</span><span class="n">CUSPARSE_MATRIX_TYPE_GENERAL</span><span class="p">);</span>

<span class="n">cusparseCreateMatDescr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">descr_L</span><span class="p">);</span>
<span class="n">cusparseSetMatIndexBase</span><span class="p">(</span><span class="n">descr_L</span><span class="p">,</span><span class="n">CUSPARSE_INDEX_BASE_ONE</span><span class="p">);</span>
<span class="n">cusparseSetMatType</span><span class="p">(</span><span class="n">descr_L</span><span class="p">,</span><span class="n">CUSPARSE_MATRIX_TYPE_GENERAL</span><span class="p">);</span>
<span class="n">cusparseSetMatFillMode</span><span class="p">(</span><span class="n">descr_L</span><span class="p">,</span><span class="n">CUSPARSE_FILL_MODE_LOWER</span><span class="p">);</span>
<span class="n">cusparseSetMatDiagType</span><span class="p">(</span><span class="n">descr_L</span><span class="p">,</span><span class="n">CUSPARSE_DIAG_TYPE_UNIT</span><span class="p">);</span>

<span class="n">cusparseCreateMatDescr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">descr_U</span><span class="p">);</span>
<span class="n">cusparseSetMatIndexBase</span><span class="p">(</span><span class="n">descr_U</span><span class="p">,</span><span class="n">CUSPARSE_INDEX_BASE_ONE</span><span class="p">);</span>
<span class="n">cusparseSetMatType</span><span class="p">(</span><span class="n">descr_U</span><span class="p">,</span><span class="n">CUSPARSE_MATRIX_TYPE_GENERAL</span><span class="p">);</span>
<span class="n">cusparseSetMatFillMode</span><span class="p">(</span><span class="n">descr_U</span><span class="p">,</span><span class="n">CUSPARSE_FILL_MODE_UPPER</span><span class="p">);</span>
<span class="n">cusparseSetMatDiagType</span><span class="p">(</span><span class="n">descr_U</span><span class="p">,</span><span class="n">CUSPARSE_DIAG_TYPE_NON_UNIT</span><span class="p">);</span>

<span class="c1">// step 2: create a empty info structure</span>
<span class="c1">// we need one info for csrilu02 and two info's for csrsv2</span>
<span class="n">cusparseCreateCsrilu02Info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info_M</span><span class="p">);</span>
<span class="n">cusparseCreateCsrsv2Info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info_L</span><span class="p">);</span>
<span class="n">cusparseCreateCsrsv2Info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info_U</span><span class="p">);</span>

<span class="c1">// step 3: query how much memory used in csrilu02 and csrsv2, and allocate the buffer</span>
<span class="n">cusparseDcsrilu02_bufferSize</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">nnz</span><span class="p">,</span>
<span class="n">descr_M</span><span class="p">,</span><span class="n">d_csrVal</span><span class="p">,</span><span class="n">d_csrRowPtr</span><span class="p">,</span><span class="n">d_csrColInd</span><span class="p">,</span><span class="n">info_M</span><span class="p">,</span><span class="o">&amp;</span><span class="n">pBufferSize_M</span><span class="p">);</span>
<span class="n">cusparseDcsrsv2_bufferSize</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">trans_L</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">nnz</span><span class="p">,</span>
<span class="n">descr_L</span><span class="p">,</span><span class="n">d_csrVal</span><span class="p">,</span><span class="n">d_csrRowPtr</span><span class="p">,</span><span class="n">d_csrColInd</span><span class="p">,</span><span class="n">info_L</span><span class="p">,</span><span class="o">&amp;</span><span class="n">pBufferSize_L</span><span class="p">);</span>
<span class="n">cusparseDcsrsv2_bufferSize</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">trans_U</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">nnz</span><span class="p">,</span>
<span class="n">descr_U</span><span class="p">,</span><span class="n">d_csrVal</span><span class="p">,</span><span class="n">d_csrRowPtr</span><span class="p">,</span><span class="n">d_csrColInd</span><span class="p">,</span><span class="n">info_U</span><span class="p">,</span><span class="o">&amp;</span><span class="n">pBufferSize_U</span><span class="p">);</span>

<span class="n">pBufferSize</span><span class="o">=</span><span class="n">max</span><span class="p">(</span><span class="n">pBufferSize_M</span><span class="p">,</span><span class="n">max</span><span class="p">(</span><span class="n">pBufferSize_L</span><span class="p">,</span><span class="n">pBufferSize_U</span><span class="p">));</span>

<span class="c1">// pBuffer returned by cudaMalloc is automatically aligned to 128 bytes.</span>
<span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pBuffer</span><span class="p">,</span><span class="n">pBufferSize</span><span class="p">);</span>

<span class="c1">// step 4: perform analysis of incomplete Cholesky on M</span>
<span class="c1">//         perform analysis of triangular solve on L</span>
<span class="c1">//         perform analysis of triangular solve on U</span>
<span class="c1">// The lower(upper) triangular part of M has the same sparsity pattern as L(U),</span>
<span class="c1">// we can do analysis of csrilu0 and csrsv2 simultaneously.</span>

<span class="n">cusparseDcsrilu02_analysis</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">nnz</span><span class="p">,</span><span class="n">descr_M</span><span class="p">,</span>
<span class="n">d_csrVal</span><span class="p">,</span><span class="n">d_csrRowPtr</span><span class="p">,</span><span class="n">d_csrColInd</span><span class="p">,</span><span class="n">info_M</span><span class="p">,</span>
<span class="n">policy_M</span><span class="p">,</span><span class="n">pBuffer</span><span class="p">);</span>
<span class="n">status</span><span class="o">=</span><span class="n">cusparseXcsrilu02_zeroPivot</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">info_M</span><span class="p">,</span><span class="o">&amp;</span><span class="n">structural_zero</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">CUSPARSE_STATUS_ZERO_PIVOT</span><span class="o">==</span><span class="n">status</span><span class="p">){</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"A(%d,%d) is missing</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">structural_zero</span><span class="p">,</span><span class="n">structural_zero</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">cusparseDcsrsv2_analysis</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">trans_L</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">nnz</span><span class="p">,</span><span class="n">descr_L</span><span class="p">,</span>
<span class="n">d_csrVal</span><span class="p">,</span><span class="n">d_csrRowPtr</span><span class="p">,</span><span class="n">d_csrColInd</span><span class="p">,</span>
<span class="n">info_L</span><span class="p">,</span><span class="n">policy_L</span><span class="p">,</span><span class="n">pBuffer</span><span class="p">);</span>

<span class="n">cusparseDcsrsv2_analysis</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">trans_U</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">nnz</span><span class="p">,</span><span class="n">descr_U</span><span class="p">,</span>
<span class="n">d_csrVal</span><span class="p">,</span><span class="n">d_csrRowPtr</span><span class="p">,</span><span class="n">d_csrColInd</span><span class="p">,</span>
<span class="n">info_U</span><span class="p">,</span><span class="n">policy_U</span><span class="p">,</span><span class="n">pBuffer</span><span class="p">);</span>

<span class="c1">// step 5: M = L * U</span>
<span class="n">cusparseDcsrilu02</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">nnz</span><span class="p">,</span><span class="n">descr_M</span><span class="p">,</span>
<span class="n">d_csrVal</span><span class="p">,</span><span class="n">d_csrRowPtr</span><span class="p">,</span><span class="n">d_csrColInd</span><span class="p">,</span><span class="n">info_M</span><span class="p">,</span><span class="n">policy_M</span><span class="p">,</span><span class="n">pBuffer</span><span class="p">);</span>
<span class="n">status</span><span class="o">=</span><span class="n">cusparseXcsrilu02_zeroPivot</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">info_M</span><span class="p">,</span><span class="o">&amp;</span><span class="n">numerical_zero</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">CUSPARSE_STATUS_ZERO_PIVOT</span><span class="o">==</span><span class="n">status</span><span class="p">){</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"U(%d,%d) is zero</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">numerical_zero</span><span class="p">,</span><span class="n">numerical_zero</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// step 6: solve L*z = x</span>
<span class="n">cusparseDcsrsv2_solve</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">trans_L</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">nnz</span><span class="p">,</span><span class="o">&amp;</span><span class="n">alpha</span><span class="p">,</span><span class="n">descr_L</span><span class="p">,</span><span class="c1">// replace with cusparseSpSV</span>
<span class="n">d_csrVal</span><span class="p">,</span><span class="n">d_csrRowPtr</span><span class="p">,</span><span class="n">d_csrColInd</span><span class="p">,</span><span class="n">info_L</span><span class="p">,</span>
<span class="n">d_x</span><span class="p">,</span><span class="n">d_z</span><span class="p">,</span><span class="n">policy_L</span><span class="p">,</span><span class="n">pBuffer</span><span class="p">);</span>

<span class="c1">// step 7: solve U*y = z</span>
<span class="n">cusparseDcsrsv2_solve</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">trans_U</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">nnz</span><span class="p">,</span><span class="o">&amp;</span><span class="n">alpha</span><span class="p">,</span><span class="n">descr_U</span><span class="p">,</span><span class="c1">// replace with cusparseSpSV</span>
<span class="n">d_csrVal</span><span class="p">,</span><span class="n">d_csrRowPtr</span><span class="p">,</span><span class="n">d_csrColInd</span><span class="p">,</span><span class="n">info_U</span><span class="p">,</span>
<span class="n">d_z</span><span class="p">,</span><span class="n">d_y</span><span class="p">,</span><span class="n">policy_U</span><span class="p">,</span><span class="n">pBuffer</span><span class="p">);</span>

<span class="c1">// step 6: free resources</span>
<span class="n">cudaFree</span><span class="p">(</span><span class="n">pBuffer</span><span class="p">);</span>
<span class="n">cusparseDestroyMatDescr</span><span class="p">(</span><span class="n">descr_M</span><span class="p">);</span>
<span class="n">cusparseDestroyMatDescr</span><span class="p">(</span><span class="n">descr_L</span><span class="p">);</span>
<span class="n">cusparseDestroyMatDescr</span><span class="p">(</span><span class="n">descr_U</span><span class="p">);</span>
<span class="n">cusparseDestroyCsrilu02Info</span><span class="p">(</span><span class="n">info_M</span><span class="p">);</span>
<span class="n">cusparseDestroyCsrsv2Info</span><span class="p">(</span><span class="n">info_L</span><span class="p">);</span>
<span class="n">cusparseDestroyCsrsv2Info</span><span class="p">(</span><span class="n">info_U</span><span class="p">);</span>
<span class="n">cusparseDestroy</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
</pre>
 <p>
  The function supports the following properties if
  <span class="pre">
   pBuffer
  </span>
  <span class="pre">
   !=
  </span>
  <span class="pre">
   NULL
  </span>
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     number of rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     number of nonzeros of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrValA_valM
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnz
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      m
     </span>
     <span class="math notranslate nohighlight">
      \(+ 1\)
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnz
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     structure with information collected during the analysis phase (that should have been passed to the solve phase unchanged).
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      policy
     </span>
    </p>
   </td>
   <td>
    <p>
     the supported policies are
     <span class="pre">
      CUSPARSE_SOLVE_POLICY_NO_LEVEL
     </span>
     and
     <span class="pre">
      CUSPARSE_SOLVE_POLICY_USE_LEVEL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     buffer allocated by the user; the size is returned by
     <span class="pre">
      csrilu02_bufferSize()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrValA_valM
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; matrix containing the incomplete-LU lower and upper triangular factors.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   5.7.2.5.
  </span>
  cusparseXcsrilu02_zeroPivot() [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsexcsrilu02-zeropivot-deprecated" title="Permalink to this headline">
   
  </a>
 </h4>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseXcsrilu02_zeroPivot</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">csrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">position</span><span class="p">)</span>
</pre>
 <p>
  If the returned error code is
  <span class="pre">
   CUSPARSE_STATUS_ZERO_PIVOT
  </span>
  ,
  <span class="pre">
   position=j
  </span>
  means
  <span class="pre">
   A(j,j)
  </span>
  has either a structural zero or a numerical zero; otherwise,
  <span class="pre">
   position=-1
  </span>
  .
 </p>
 <p>
  The
  <span class="pre">
   position
  </span>
  can be 0-based or 1-based, the same as the matrix.
 </p>
 <p>
  Function
  <span class="pre">
   cusparseXcsrilu02_zeroPivot()
  </span>
  is a blocking call. It calls
  <span class="pre">
   cudaDeviceSynchronize(
  </span>
  ) to make sure all previous kernels are done.
 </p>
 <p>
  The
  <span class="pre">
   position
  </span>
  can be in the host memory or device memory. The user can set proper mode with
  <span class="pre">
   cusparseSetPointerMode()
  </span>
  .
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      info
     </span>
     contains structural zero or numerical zero if the user already called
     <span class="pre">
      csrilu02_analysis()
     </span>
     or
     <span class="pre">
      csrilu02()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      position
     </span>
    </p>
   </td>
   <td>
    <p>
     If no structural or numerical zero,
     <span class="pre">
      position
     </span>
     is -1; otherwise if
     <span class="pre">
      A(j,j)
     </span>
     is missing or
     <span class="pre">
      U(j,j)
     </span>
     is zero,
     <span class="pre">
      position=j
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   5.7.2.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#bsrilu02_numerical_boost">
   cusparse&lt;t&gt;bsrilu02_numericBoost()
  </a>
  [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsrilu02-numericboost-deprecated" title="Permalink to this headline">
   
  </a>
 </h4>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSbsrilu02_numericBoost</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">bsrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="n">enable_boost</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">tol</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">boost_val</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDbsrilu02_numericBoost</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">bsrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="n">enable_boost</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">tol</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">boost_val</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCbsrilu02_numericBoost</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">bsrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="n">enable_boost</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">tol</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">boost_val</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZbsrilu02_numericBoost</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">bsrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="n">enable_boost</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">tol</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">boost_val</span><span class="p">)</span>
</pre>
 <p>
  The user can use a boost value to replace a numerical value in incomplete LU factorization. Parameter
  <span class="pre">
   tol
  </span>
  is used to determine a numerical zero, and
  <span class="pre">
   boost_val
  </span>
  is used to replace a numerical zero. The behavior is as follows:
 </p>
 <p>
  if
  <span class="pre">
   tol
  </span>
  <span class="pre">
   &gt;=
  </span>
  <span class="pre">
   fabs(A(j,j))
  </span>
  , then reset each diagonal element of block
  <span class="pre">
   A(j,j)
  </span>
  by
  <span class="pre">
   boost_val
  </span>
  .
 </p>
 <p>
  To enable a boost value, the user sets parameter
  <span class="pre">
   enable_boost
  </span>
  to 1 before calling
  <span class="pre">
   bsrilu02()
  </span>
  . To disable the boost value, the user can call
  <span class="pre">
   bsrilu02_numericBoost()
  </span>
  with parameter
  <span class="pre">
   enable_boost=0
  </span>
  .
 </p>
 <p>
  If
  <span class="pre">
   enable_boost=0
  </span>
  ,
  <span class="pre">
   tol
  </span>
  and
  <span class="pre">
   boost_val
  </span>
  are ignored.
 </p>
 <p>
  Both
  <span class="pre">
   tol
  </span>
  and
  <span class="pre">
   boost_val
  </span>
  can be in host memory or device memory. The user can set the proper mode with
  <span class="pre">
   cusparseSetPointerMode()
  </span>
  .
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     structure initialized using
     <span class="pre">
      cusparseCreateBsrilu02Info()
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      enable_boost
     </span>
    </p>
   </td>
   <td>
    <p>
     disable boost by setting
     <span class="pre">
      enable_boost=0
     </span>
     . Otherwise, boost is enabled.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      tol
     </span>
    </p>
   </td>
   <td>
    <p>
     tolerance to determine a numerical zero.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      boost_val
     </span>
    </p>
   </td>
   <td>
    <p>
     boost value to replace a numerical zero.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   5.7.2.7.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#bsrilu02_bufferSize">
   cusparse&lt;t&gt;bsrilu02_bufferSize()
  </a>
  [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsrilu02-buffersize-deprecated" title="Permalink to this headline">
   
  </a>
 </h4>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="nf">cusparseSbsrilu02_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">);</span>

<span class="n">cusparseStatus_t</span>
<span class="nf">cusparseDbsrilu02_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">);</span>

<span class="n">cusparseStatus_t</span>
<span class="nf">cusparseCbsrilu02_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">);</span>

<span class="n">cusparseStatus_t</span>
<span class="nf">cusparseZbsrilu02_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">);</span>
</pre>
 <p>
  This function returns the size of the buffer used in computing the incomplete-LU factorization with 0 fill-in and no pivoting.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A \approx LU\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   (mb*blockDim)*(mb*blockDim)
  </span>
  sparse matrix that is defined in BSR storage format by the three arrays
  <span class="pre">
   bsrValA
  </span>
  ,
  <span class="pre">
   bsrRowPtrA
  </span>
  , and
  <span class="pre">
   bsrColIndA
  </span>
  .
 </p>
 <p>
  The buffer size depends on the dimensions of
  <span class="pre">
   mb
  </span>
  ,
  <span class="pre">
   blockDim
  </span>
  , and the number of nonzero blocks of the matrix
  <span class="pre">
   nnzb
  </span>
  . If the user changes the matrix, it is necessary to call
  <span class="pre">
   bsrilu02_bufferSize()
  </span>
  again to have the correct buffer size; otherwise, a segmentation fault may occur.
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dirA
     </span>
    </p>
   </td>
   <td>
    <p>
     storage format of blocks, either
     <span class="pre">
      CUSPARSE_DIRECTION_ROW
     </span>
     or
     <span class="pre">
      CUSPARSE_DIRECTION_COLUMN
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      mb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of block rows and columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzb
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      bsrRowPtrA(mb)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      bsrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      mb
     </span>
     <span class="math notranslate nohighlight">
      \(+ 1\)
     </span>
     elements that contains the start of every block row and the end of the last block row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzb
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      bsrRowPtrA(mb)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      bsrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      blockDim
     </span>
    </p>
   </td>
   <td>
    <p>
     block dimension of sparse matrix A, larger than zero.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     record internal states based on different algorithms.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBufferSizeInBytes
     </span>
    </p>
   </td>
   <td>
    <p>
     number of bytes of the buffer used in
     <span class="pre">
      bsrilu02_analysis()
     </span>
     and
     <span class="pre">
      bsrilu02()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Status Returned
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_STATUS_SUCCESS
     </span>
    </p>
   </td>
   <td>
    <p>
     the operation completed successfully.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_STATUS_NOT_INITIALIZED
     </span>
    </p>
   </td>
   <td>
    <p>
     the library was not initialized.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_STATUS_ALLOC_FAILED
     </span>
    </p>
   </td>
   <td>
    <p>
     the resources could not be allocated.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_STATUS_INVALID_VALUE
     </span>
    </p>
   </td>
   <td>
    <p>
     invalid parameters were passed (
     <span class="pre">
      mb,nnzb&lt;=0
     </span>
     ), base index is not 0 or 1.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_STATUS_ARCH_MISMATCH
     </span>
    </p>
   </td>
   <td>
    <p>
     the device only supports compute capability 2.0 and above.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_STATUS_INTERNAL_ERROR
     </span>
    </p>
   </td>
   <td>
    <p>
     an internal operation failed.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_STATUS_MATRIX_TYPE_NOT_SUPPORTED
     </span>
    </p>
   </td>
   <td>
    <p>
     the matrix type is not supported.
    </p>
   </td>
  </tr>
 </table>
 <h4>
  <span class="section-number">
   5.7.2.8.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#bsrilu02_analysis">
   cusparse&lt;t&gt;bsrilu02_analysis()
  </a>
  [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsrilu02-analysis-deprecated" title="Permalink to this headline">
   
  </a>
 </h4>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSbsrilu02_analysis</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDbsrilu02_analysis</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCbsrilu02_analysis</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZbsrilu02_analysis</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function performs the analysis phase of the incomplete-LU factorization with 0 fill-in and no pivoting.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A \approx LU\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   (mb*blockDim)(mb*blockDim)
  </span>
  sparse matrix that is defined in BSR storage format by the three arrays
  <span class="pre">
   bsrValA
  </span>
  ,
  <span class="pre">
   bsrRowPtrA
  </span>
  , and
  <span class="pre">
   bsrColIndA
  </span>
  . The block in BSR format is of size
  <span class="pre">
   blockDim*blockDim
  </span>
  , stored as column-major or row-major as determined by parameter
  <span class="pre">
   dirA
  </span>
  , which is either
  <span class="pre">
   CUSPARSE_DIRECTION_COLUMN
  </span>
  or
  <span class="pre">
   CUSPARSE_DIRECTION_ROW
  </span>
  . The matrix type must be
  <span class="pre">
   CUSPARSE_MATRIX_TYPE_GENERAL
  </span>
  , and the fill mode and diagonal type are ignored.
 </p>
 <p>
  This function requires a buffer size returned by
  <span class="pre">
   bsrilu02_bufferSize()
  </span>
  . The address of
  <span class="pre">
   pBuffer
  </span>
  must be multiple of 128 bytes. If it is not,
  <span class="pre">
   CUSPARSE_STATUS_INVALID_VALUE
  </span>
  is returned.
 </p>
 <p>
  Function
  <span class="pre">
   bsrilu02_analysis()
  </span>
  reports a structural zero and computes level information stored in the opaque structure
  <span class="pre">
   info
  </span>
  . The level information can extract more parallelism during incomplete LU factorization. However
  <span class="pre">
   bsrilu02()
  </span>
  can be done without level information. To disable level information, the user needs to specify the parameter
  <span class="pre">
   policy
  </span>
  of
  <span class="pre">
   bsrilu02[_analysis|
  </span>
  <span class="pre">
   ]
  </span>
  as
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_NO_LEVEL
  </span>
  .
 </p>
 <p>
  Function
  <span class="pre">
   bsrilu02_analysis()
  </span>
  always reports the first structural zero, even with parameter
  <span class="pre">
   policy
  </span>
  is
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_NO_LEVEL
  </span>
  . The user must call
  <span class="pre">
   cusparseXbsrilu02_zeroPivot()
  </span>
  to know where the structural zero is.
 </p>
 <p>
  It is the users choice whether to call
  <span class="pre">
   bsrilu02()
  </span>
  if
  <span class="pre">
   bsrilu02_analysis()
  </span>
  reports a structural zero. In this case, the user can still call
  <span class="pre">
   bsrilu02()
  </span>
  , which will return a numerical zero at the same position as the structural zero. However the result is meaningless.
 </p>
 <ul class="simple">
  <li>
   <p>
    This function requires temporary extra storage that is allocated internally
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dirA
     </span>
    </p>
   </td>
   <td>
    <p>
     storage format of blocks, either
     <span class="pre">
      CUSPARSE_DIRECTION_ROW
     </span>
     or
     <span class="pre">
      CUSPARSE_DIRECTION_COLUMN
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      mb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of block rows and block columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzb
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      bsrRowPtrA(mb)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      bsrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      mb
     </span>
     <span class="math notranslate nohighlight">
      \(+ 1\)
     </span>
     elements that contains the start of every block row and the end of the last block row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzb
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      bsrRowPtrA(mb)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      bsrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      blockDim
     </span>
    </p>
   </td>
   <td>
    <p>
     block dimension of sparse matrix A, larger than zero.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     structure initialized using
     <span class="pre">
      cusparseCreateBsrilu02Info()
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      policy
     </span>
    </p>
   </td>
   <td>
    <p>
     the supported policies are
     <span class="pre">
      CUSPARSE_SOLVE_POLICY_NO_LEVEL
     </span>
     and
     <span class="pre">
      CUSPARSE_SOLVE_POLICY_USE_LEVEL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     buffer allocated by the user, the size is returned by
     <span class="pre">
      bsrilu02_bufferSize()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged)
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   5.7.2.9.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#bsrilu02_solve">
   cusparse&lt;t&gt;bsrilu02()
  </a>
  [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsrilu02-deprecated" title="Permalink to this headline">
   
  </a>
 </h4>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSbsrilu02</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descry</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDbsrilu02</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descry</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCbsrilu02</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descry</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZbsrilu02</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descry</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">bsrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="n">cusparseSolvePolicy_t</span><span class="n">policy</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function performs the solve phase of the incomplete-LU factorization with 0 fill-in and no pivoting.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A \approx LU\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   (mb*blockDim)(mb*blockDim)
  </span>
  sparse matrix that is defined in BSR storage format by the three arrays
  <span class="pre">
   bsrValA
  </span>
  ,
  <span class="pre">
   bsrRowPtrA
  </span>
  , and
  <span class="pre">
   bsrColIndA
  </span>
  . The block in BSR format is of size
  <span class="pre">
   blockDim*blockDim
  </span>
  , stored as column-major or row-major determined by parameter
  <span class="pre">
   dirA
  </span>
  , which is either
  <span class="pre">
   CUSPARSE_DIRECTION_COLUMN
  </span>
  or
  <span class="pre">
   CUSPARSE_DIRECTION_ROW
  </span>
  . The matrix type must be
  <span class="pre">
   CUSPARSE_MATRIX_TYPE_GENERAL
  </span>
  , and the fill mode and diagonal type are ignored. Function
  <span class="pre">
   bsrilu02()
  </span>
  supports an arbitrary
  <span class="pre">
   blockDim
  </span>
  .
 </p>
 <p>
  This function requires a buffer size returned by
  <span class="pre">
   bsrilu02_bufferSize()
  </span>
  . The address of
  <span class="pre">
   pBuffer
  </span>
  must be a multiple of 128 bytes. If it is not,
  <span class="pre">
   CUSPARSE_STATUS_INVALID_VALUE
  </span>
  is returned.
 </p>
 <p>
  Although
  <span class="pre">
   bsrilu02()
  </span>
  can be used without level information, the user must be aware of consistency. If
  <span class="pre">
   bsrilu02_analysis()
  </span>
  is called with policy
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_USE_LEVEL
  </span>
  ,
  <span class="pre">
   bsrilu02()
  </span>
  can be run with or without levels. On the other hand, if
  <span class="pre">
   bsrilu02_analysis()
  </span>
  is called with
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_NO_LEVEL
  </span>
  ,
  <span class="pre">
   bsrilu02()
  </span>
  can only accept
  <span class="pre">
   CUSPARSE_SOLVE_POLICY_NO_LEVEL
  </span>
  ; otherwise,
  <span class="pre">
   CUSPARSE_STATUS_INVALID_VALUE
  </span>
  is returned.
 </p>
 <p>
  Function
  <span class="pre">
   bsrilu02()
  </span>
  has the same behavior as
  <span class="pre">
   csrilu02()
  </span>
  . That is,
  <span class="pre">
   bsr2csr(bsrilu02(A))
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   csrilu02(bsr2csr(A))
  </span>
  . The numerical zero of
  <span class="pre">
   csrilu02()
  </span>
  means there exists some zero
  <span class="pre">
   U(j,j)
  </span>
  . The numerical zero of
  <span class="pre">
   bsrilu02()
  </span>
  means there exists some block
  <span class="pre">
   U(j,j)
  </span>
  that is not invertible.
 </p>
 <p>
  Function
  <span class="pre">
   bsrilu02
  </span>
  reports the first numerical zero, including a structural zero. The user must call
  <span class="pre">
   cusparseXbsrilu02_zeroPivot()
  </span>
  to know where the numerical zero is.
 </p>
 <p>
  For example, suppose
  <span class="pre">
   A
  </span>
  is a real m-by-m matrix where
  <span class="pre">
   m=mb*blockDim
  </span>
  . The following code solves precondition system
  <span class="pre">
   M*y
  </span>
  <span class="pre">
   =
  </span>
  
  <span class="pre">
   x
  </span>
  , where
  <span class="pre">
   M
  </span>
  is the product of LU factors
  <span class="pre">
   L
  </span>
  and
  <span class="pre">
   U
  </span>
  .
 </p>
 <pre><span class="c1">// Suppose that A is m x m sparse matrix represented by BSR format,</span>
<span class="c1">// The number of block rows/columns is mb, and</span>
<span class="c1">// the number of nonzero blocks is nnzb.</span>
<span class="c1">// Assumption:</span>
<span class="c1">// - handle is already created by cusparseCreate(),</span>
<span class="c1">// - (d_bsrRowPtr, d_bsrColInd, d_bsrVal) is BSR of A on device memory,</span>
<span class="c1">// - d_x is right hand side vector on device memory.</span>
<span class="c1">// - d_y is solution vector on device memory.</span>
<span class="c1">// - d_z is intermediate result on device memory.</span>
<span class="c1">// - d_x, d_y and d_z are of size m.</span>
<span class="n">cusparseMatDescr_t</span><span class="n">descr_M</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">cusparseMatDescr_t</span><span class="n">descr_L</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">cusparseMatDescr_t</span><span class="n">descr_U</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">bsrilu02Info_t</span><span class="n">info_M</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">bsrsv2Info_t</span><span class="n">info_L</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">bsrsv2Info_t</span><span class="n">info_U</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span><span class="n">pBufferSize_M</span><span class="p">;</span>
<span class="kt">int</span><span class="n">pBufferSize_L</span><span class="p">;</span>
<span class="kt">int</span><span class="n">pBufferSize_U</span><span class="p">;</span>
<span class="kt">int</span><span class="n">pBufferSize</span><span class="p">;</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span><span class="n">structural_zero</span><span class="p">;</span>
<span class="kt">int</span><span class="n">numerical_zero</span><span class="p">;</span>
<span class="k">const</span><span class="kt">double</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.</span><span class="p">;</span>
<span class="k">const</span><span class="n">cusparseSolvePolicy_t</span><span class="n">policy_M</span><span class="o">=</span><span class="n">CUSPARSE_SOLVE_POLICY_NO_LEVEL</span><span class="p">;</span>
<span class="k">const</span><span class="n">cusparseSolvePolicy_t</span><span class="n">policy_L</span><span class="o">=</span><span class="n">CUSPARSE_SOLVE_POLICY_NO_LEVEL</span><span class="p">;</span>
<span class="k">const</span><span class="n">cusparseSolvePolicy_t</span><span class="n">policy_U</span><span class="o">=</span><span class="n">CUSPARSE_SOLVE_POLICY_USE_LEVEL</span><span class="p">;</span>
<span class="k">const</span><span class="n">cusparseOperation_t</span><span class="n">trans_L</span><span class="o">=</span><span class="n">CUSPARSE_OPERATION_NON_TRANSPOSE</span><span class="p">;</span>
<span class="k">const</span><span class="n">cusparseOperation_t</span><span class="n">trans_U</span><span class="o">=</span><span class="n">CUSPARSE_OPERATION_NON_TRANSPOSE</span><span class="p">;</span>
<span class="k">const</span><span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="o">=</span><span class="n">CUSPARSE_DIRECTION_COLUMN</span><span class="p">;</span>

<span class="c1">// step 1: create a descriptor which contains</span>
<span class="c1">// - matrix M is base-1</span>
<span class="c1">// - matrix L is base-1</span>
<span class="c1">// - matrix L is lower triangular</span>
<span class="c1">// - matrix L has unit diagonal</span>
<span class="c1">// - matrix U is base-1</span>
<span class="c1">// - matrix U is upper triangular</span>
<span class="c1">// - matrix U has non-unit diagonal</span>
<span class="n">cusparseCreateMatDescr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">descr_M</span><span class="p">);</span>
<span class="n">cusparseSetMatIndexBase</span><span class="p">(</span><span class="n">descr_M</span><span class="p">,</span><span class="n">CUSPARSE_INDEX_BASE_ONE</span><span class="p">);</span>
<span class="n">cusparseSetMatType</span><span class="p">(</span><span class="n">descr_M</span><span class="p">,</span><span class="n">CUSPARSE_MATRIX_TYPE_GENERAL</span><span class="p">);</span>

<span class="n">cusparseCreateMatDescr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">descr_L</span><span class="p">);</span>
<span class="n">cusparseSetMatIndexBase</span><span class="p">(</span><span class="n">descr_L</span><span class="p">,</span><span class="n">CUSPARSE_INDEX_BASE_ONE</span><span class="p">);</span>
<span class="n">cusparseSetMatType</span><span class="p">(</span><span class="n">descr_L</span><span class="p">,</span><span class="n">CUSPARSE_MATRIX_TYPE_GENERAL</span><span class="p">);</span>
<span class="n">cusparseSetMatFillMode</span><span class="p">(</span><span class="n">descr_L</span><span class="p">,</span><span class="n">CUSPARSE_FILL_MODE_LOWER</span><span class="p">);</span>
<span class="n">cusparseSetMatDiagType</span><span class="p">(</span><span class="n">descr_L</span><span class="p">,</span><span class="n">CUSPARSE_DIAG_TYPE_UNIT</span><span class="p">);</span>

<span class="n">cusparseCreateMatDescr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">descr_U</span><span class="p">);</span>
<span class="n">cusparseSetMatIndexBase</span><span class="p">(</span><span class="n">descr_U</span><span class="p">,</span><span class="n">CUSPARSE_INDEX_BASE_ONE</span><span class="p">);</span>
<span class="n">cusparseSetMatType</span><span class="p">(</span><span class="n">descr_U</span><span class="p">,</span><span class="n">CUSPARSE_MATRIX_TYPE_GENERAL</span><span class="p">);</span>
<span class="n">cusparseSetMatFillMode</span><span class="p">(</span><span class="n">descr_U</span><span class="p">,</span><span class="n">CUSPARSE_FILL_MODE_UPPER</span><span class="p">);</span>
<span class="n">cusparseSetMatDiagType</span><span class="p">(</span><span class="n">descr_U</span><span class="p">,</span><span class="n">CUSPARSE_DIAG_TYPE_NON_UNIT</span><span class="p">);</span>

<span class="c1">// step 2: create a empty info structure</span>
<span class="c1">// we need one info for bsrilu02 and two info's for bsrsv2</span>
<span class="n">cusparseCreateBsrilu02Info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info_M</span><span class="p">);</span>
<span class="n">cusparseCreateBsrsv2Info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info_L</span><span class="p">);</span>
<span class="n">cusparseCreateBsrsv2Info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info_U</span><span class="p">);</span>

<span class="c1">// step 3: query how much memory used in bsrilu02 and bsrsv2, and allocate the buffer</span>
<span class="n">cusparseDbsrilu02_bufferSize</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span><span class="n">mb</span><span class="p">,</span><span class="n">nnzb</span><span class="p">,</span>
<span class="n">descr_M</span><span class="p">,</span><span class="n">d_bsrVal</span><span class="p">,</span><span class="n">d_bsrRowPtr</span><span class="p">,</span><span class="n">d_bsrColInd</span><span class="p">,</span><span class="n">blockDim</span><span class="p">,</span><span class="n">info_M</span><span class="p">,</span><span class="o">&amp;</span><span class="n">pBufferSize_M</span><span class="p">);</span>
<span class="n">cusparseDbsrsv2_bufferSize</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span><span class="n">trans_L</span><span class="p">,</span><span class="n">mb</span><span class="p">,</span><span class="n">nnzb</span><span class="p">,</span>
<span class="n">descr_L</span><span class="p">,</span><span class="n">d_bsrVal</span><span class="p">,</span><span class="n">d_bsrRowPtr</span><span class="p">,</span><span class="n">d_bsrColInd</span><span class="p">,</span><span class="n">blockDim</span><span class="p">,</span><span class="n">info_L</span><span class="p">,</span><span class="o">&amp;</span><span class="n">pBufferSize_L</span><span class="p">);</span>
<span class="n">cusparseDbsrsv2_bufferSize</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span><span class="n">trans_U</span><span class="p">,</span><span class="n">mb</span><span class="p">,</span><span class="n">nnzb</span><span class="p">,</span>
<span class="n">descr_U</span><span class="p">,</span><span class="n">d_bsrVal</span><span class="p">,</span><span class="n">d_bsrRowPtr</span><span class="p">,</span><span class="n">d_bsrColInd</span><span class="p">,</span><span class="n">blockDim</span><span class="p">,</span><span class="n">info_U</span><span class="p">,</span><span class="o">&amp;</span><span class="n">pBufferSize_U</span><span class="p">);</span>

<span class="n">pBufferSize</span><span class="o">=</span><span class="n">max</span><span class="p">(</span><span class="n">pBufferSize_M</span><span class="p">,</span><span class="n">max</span><span class="p">(</span><span class="n">pBufferSize_L</span><span class="p">,</span><span class="n">pBufferSize_U</span><span class="p">));</span>

<span class="c1">// pBuffer returned by cudaMalloc is automatically aligned to 128 bytes.</span>
<span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pBuffer</span><span class="p">,</span><span class="n">pBufferSize</span><span class="p">);</span>

<span class="c1">// step 4: perform analysis of incomplete LU factorization on M</span>
<span class="c1">//         perform analysis of triangular solve on L</span>
<span class="c1">//         perform analysis of triangular solve on U</span>
<span class="c1">// The lower(upper) triangular part of M has the same sparsity pattern as L(U),</span>
<span class="c1">// we can do analysis of bsrilu0 and bsrsv2 simultaneously.</span>

<span class="n">cusparseDbsrilu02_analysis</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span><span class="n">mb</span><span class="p">,</span><span class="n">nnzb</span><span class="p">,</span><span class="n">descr_M</span><span class="p">,</span>
<span class="n">d_bsrVal</span><span class="p">,</span><span class="n">d_bsrRowPtr</span><span class="p">,</span><span class="n">d_bsrColInd</span><span class="p">,</span><span class="n">blockDim</span><span class="p">,</span><span class="n">info_M</span><span class="p">,</span>
<span class="n">policy_M</span><span class="p">,</span><span class="n">pBuffer</span><span class="p">);</span>
<span class="n">status</span><span class="o">=</span><span class="n">cusparseXbsrilu02_zeroPivot</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">info_M</span><span class="p">,</span><span class="o">&amp;</span><span class="n">structural_zero</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">CUSPARSE_STATUS_ZERO_PIVOT</span><span class="o">==</span><span class="n">statuss</span><span class="p">){</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"A(%d,%d) is missing</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">structural_zero</span><span class="p">,</span><span class="n">structural_zero</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">cusparseDbsrsv2_analysis</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span><span class="n">trans_L</span><span class="p">,</span><span class="n">mb</span><span class="p">,</span><span class="n">nnzb</span><span class="p">,</span><span class="n">descr_L</span><span class="p">,</span>
<span class="n">d_bsrVal</span><span class="p">,</span><span class="n">d_bsrRowPtr</span><span class="p">,</span><span class="n">d_bsrColInd</span><span class="p">,</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">info_L</span><span class="p">,</span><span class="n">policy_L</span><span class="p">,</span><span class="n">pBuffer</span><span class="p">);</span>

<span class="n">cusparseDbsrsv2_analysis</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span><span class="n">trans_U</span><span class="p">,</span><span class="n">mb</span><span class="p">,</span><span class="n">nnzb</span><span class="p">,</span><span class="n">descr_U</span><span class="p">,</span>
<span class="n">d_bsrVal</span><span class="p">,</span><span class="n">d_bsrRowPtr</span><span class="p">,</span><span class="n">d_bsrColInd</span><span class="p">,</span><span class="n">blockDim</span><span class="p">,</span>
<span class="n">info_U</span><span class="p">,</span><span class="n">policy_U</span><span class="p">,</span><span class="n">pBuffer</span><span class="p">);</span>

<span class="c1">// step 5: M = L * U</span>
<span class="n">cusparseDbsrilu02</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span><span class="n">mb</span><span class="p">,</span><span class="n">nnzb</span><span class="p">,</span><span class="n">descr_M</span><span class="p">,</span>
<span class="n">d_bsrVal</span><span class="p">,</span><span class="n">d_bsrRowPtr</span><span class="p">,</span><span class="n">d_bsrColInd</span><span class="p">,</span><span class="n">blockDim</span><span class="p">,</span><span class="n">info_M</span><span class="p">,</span><span class="n">policy_M</span><span class="p">,</span><span class="n">pBuffer</span><span class="p">);</span>
<span class="n">status</span><span class="o">=</span><span class="n">cusparseXbsrilu02_zeroPivot</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">info_M</span><span class="p">,</span><span class="o">&amp;</span><span class="n">numerical_zero</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">CUSPARSE_STATUS_ZERO_PIVOT</span><span class="o">==</span><span class="n">statuss</span><span class="p">){</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"block U(%d,%d) is not invertible</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">numerical_zero</span><span class="p">,</span><span class="n">numerical_zero</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// step 6: solve L*z = x</span>
<span class="n">cusparseDbsrsv2_solve</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span><span class="n">trans_L</span><span class="p">,</span><span class="n">mb</span><span class="p">,</span><span class="n">nnzb</span><span class="p">,</span><span class="o">&amp;</span><span class="n">alpha</span><span class="p">,</span><span class="n">descr_L</span><span class="p">,</span>
<span class="n">d_bsrVal</span><span class="p">,</span><span class="n">d_bsrRowPtr</span><span class="p">,</span><span class="n">d_bsrColInd</span><span class="p">,</span><span class="n">blockDim</span><span class="p">,</span><span class="n">info_L</span><span class="p">,</span>
<span class="n">d_x</span><span class="p">,</span><span class="n">d_z</span><span class="p">,</span><span class="n">policy_L</span><span class="p">,</span><span class="n">pBuffer</span><span class="p">);</span>

<span class="c1">// step 7: solve U*y = z</span>
<span class="n">cusparseDbsrsv2_solve</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span><span class="n">trans_U</span><span class="p">,</span><span class="n">mb</span><span class="p">,</span><span class="n">nnzb</span><span class="p">,</span><span class="o">&amp;</span><span class="n">alpha</span><span class="p">,</span><span class="n">descr_U</span><span class="p">,</span>
<span class="n">d_bsrVal</span><span class="p">,</span><span class="n">d_bsrRowPtr</span><span class="p">,</span><span class="n">d_bsrColInd</span><span class="p">,</span><span class="n">blockDim</span><span class="p">,</span><span class="n">info_U</span><span class="p">,</span>
<span class="n">d_z</span><span class="p">,</span><span class="n">d_y</span><span class="p">,</span><span class="n">policy_U</span><span class="p">,</span><span class="n">pBuffer</span><span class="p">);</span>

<span class="c1">// step 6: free resources</span>
<span class="n">cudaFree</span><span class="p">(</span><span class="n">pBuffer</span><span class="p">);</span>
<span class="n">cusparseDestroyMatDescr</span><span class="p">(</span><span class="n">descr_M</span><span class="p">);</span>
<span class="n">cusparseDestroyMatDescr</span><span class="p">(</span><span class="n">descr_L</span><span class="p">);</span>
<span class="n">cusparseDestroyMatDescr</span><span class="p">(</span><span class="n">descr_U</span><span class="p">);</span>
<span class="n">cusparseDestroyBsrilu02Info</span><span class="p">(</span><span class="n">info_M</span><span class="p">);</span>
<span class="n">cusparseDestroyBsrsv2Info</span><span class="p">(</span><span class="n">info_L</span><span class="p">);</span>
<span class="n">cusparseDestroyBsrsv2Info</span><span class="p">(</span><span class="n">info_U</span><span class="p">);</span>
<span class="n">cusparseDestroy</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
</pre>
 <p>
  The function supports the following properties if
  <span class="pre">
   pBuffer
  </span>
  <span class="pre">
   !=
  </span>
  <span class="pre">
   NULL
  </span>
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dirA
     </span>
    </p>
   </td>
   <td>
    <p>
     storage format of blocks: either
     <span class="pre">
      CUSPARSE_DIRECTION_ROW
     </span>
     or
     <span class="pre">
      CUSPARSE_DIRECTION_COLUMN
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      mb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of block rows and block columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzb
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      bsrRowPtrA(mb)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      bsrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      mb
     </span>
     <span class="math notranslate nohighlight">
      \(+ 1\)
     </span>
     elements that contains the start of every block row and the end of the last block row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzb
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      bsrRowPtrA(mb)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      bsrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      blockDim
     </span>
    </p>
   </td>
   <td>
    <p>
     block dimension of sparse matrix A; must be larger than zero.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     structure with information collected during the analysis phase (that should have been passed to the solve phase unchanged).
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      policy
     </span>
    </p>
   </td>
   <td>
    <p>
     the supported policies are
     <span class="pre">
      CUSPARSE_SOLVE_POLICY_NO_LEVEL
     </span>
     and
     <span class="pre">
      CUSPARSE_SOLVE_POLICY_USE_LEVEL
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     buffer allocated by the user; the size is returned by
     <span class="pre">
      bsrilu02_bufferSize()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; matrix containing the incomplete-LU lower and upper triangular factors
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   5.7.2.10.
  </span>
  cusparseXbsrilu02_zeroPivot() [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsexbsrilu02-zeropivot-deprecated" title="Permalink to this headline">
   
  </a>
 </h4>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseXbsrilu02_zeroPivot</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">bsrilu02Info_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">position</span><span class="p">)</span>
</pre>
 <p>
  If the returned error code is
  <span class="pre">
   CUSPARSE_STATUS_ZERO_PIVOT
  </span>
  ,
  <span class="pre">
   position=j
  </span>
  means
  <span class="pre">
   A(j,j)
  </span>
  has either a structural zero or a numerical zero (the block is not invertible). Otherwise
  <span class="pre">
   position=-1
  </span>
  .
 </p>
 <p>
  The
  <span class="pre">
   position
  </span>
  can be 0-based or 1-based, the same as the matrix.
 </p>
 <p>
  Function
  <span class="pre">
   cusparseXbsrilu02_zeroPivot()
  </span>
  is a blocking call. It calls
  <span class="pre">
   cudaDeviceSynchronize()
  </span>
  to make sure all previous kernels are done.
 </p>
 <p>
  The
  <span class="pre">
   position
  </span>
  can be in the host memory or device memory. The user can set proper the mode with
  <span class="pre">
   cusparseSetPointerMode()
  </span>
  .
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      info
     </span>
     contains structural zero or numerical zero if the user already called
     <span class="pre">
      bsrilu02_analysis()
     </span>
     or
     <span class="pre">
      bsrilu02()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      position
     </span>
    </p>
   </td>
   <td>
    <p>
     if no structural or numerical zero,
     <span class="pre">
      position
     </span>
     is -1; otherwise if
     <span class="pre">
      A(j,j)
     </span>
     is missing or
     <span class="pre">
      U(j,j)
     </span>
     is not invertible,
     <span class="pre">
      position=j
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   5.7.3.
  </span>
  Tridiagonal Solve
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#tridiagonal-solve" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  Different algorithms for tridiagonal solve are discussed in this section.
 </p>
 <h4>
  <span class="section-number">
   5.7.3.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#gtsv2_bufferSize">
   cusparse&lt;t&gt;gtsv2_buffSizeExt()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-gtsv2-buffsizeext" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSgtsv2_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDgtsv2_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCgtsv2_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZgtsv2_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSizeInBytes</span><span class="p">)</span>
</pre>
 <p>
  This function returns the size of the buffer used in
  <span class="pre">
   gtsv2
  </span>
  which computes the solution of a tridiagonal linear system with multiple right-hand sides.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A \ast X = B\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The coefficient matrix
  <span class="pre">
   A
  </span>
  of each of these tri-diagonal linear system is defined with three vectors corresponding to its lower (
  <span class="pre">
   dl
  </span>
  ), main (
  <span class="pre">
   d
  </span>
  ), and upper (
  <span class="pre">
   du
  </span>
  ) matrix diagonals; the right-hand sides are stored in the dense matrix
  <span class="pre">
   B
  </span>
  . Notice that solution
  <span class="pre">
   X
  </span>
  overwrites right-hand-side matrix
  <span class="pre">
   B
  </span>
  on exit.
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     the size of the linear system (must be  3).
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     number of right-hand sides, columns of matrix
     <span class="pre">
      B
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dl
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense array containing the lower diagonal of the tri-diagonal linear system. The first element of each lower diagonal must be zero.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      d
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense array containing the main diagonal of the tri-diagonal linear system.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      du
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense array containing the upper diagonal of the tri-diagonal linear system. The last element of each upper diagonal must be zero.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      B
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense right-hand-side array of dimensions
     <span class="pre">
      (ldb,
     </span>
     <span class="pre">
      n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ldb
     </span>
    </p>
   </td>
   <td>
    <p>
     leading dimension of
     <span class="pre">
      B
     </span>
     (that is 
     <span class="math notranslate nohighlight">
      \(\max\text{(1,\ m))}\)
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      pBufferSizeInBytes
     </span>
    </p>
   </td>
   <td>
    <p>
     number of bytes of the buffer used in the
     <span class="pre">
      gtsv2
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   5.7.3.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#gtsv2">
   cusparse&lt;t&gt;gtsv2()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-gtsv2" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSgtsv2</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDgtsv2</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCgtsv2</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZgtsv2</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function computes the solution of a tridiagonal linear system with multiple right-hand sides:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A \ast X = B\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The coefficient matrix
  <span class="pre">
   A
  </span>
  of each of these tri-diagonal linear system is defined with three vectors corresponding to its lower (
  <span class="pre">
   dl
  </span>
  ), main (
  <span class="pre">
   d
  </span>
  ), and upper (
  <span class="pre">
   du
  </span>
  ) matrix diagonals; the right-hand sides are stored in the dense matrix
  <span class="pre">
   B
  </span>
  . Notice that solution
  <span class="pre">
   X
  </span>
  overwrites right-hand-side matrix
  <span class="pre">
   B
  </span>
  on exit.
 </p>
 <p>
  Assuming
  <span class="pre">
   A
  </span>
  is of size
  <span class="pre">
   m
  </span>
  and base-1,
  <span class="pre">
   dl
  </span>
  ,
  <span class="pre">
   d
  </span>
  and
  <span class="pre">
   du
  </span>
  are defined by the following formula:
 </p>
 <p>
  <span class="pre">
   dl(i)
  </span>
  <span class="pre">
   :=
  </span>
  <span class="pre">
   A(i,
  </span>
  <span class="pre">
   i-1)
  </span>
  for
  <span class="pre">
   i=1,2,...,m
  </span>
 </p>
 <p>
  The first element of dl is out-of-bound (
  <span class="pre">
   dl(1)
  </span>
  <span class="pre">
   :=
  </span>
  <span class="pre">
   A(1,0)
  </span>
  ), so
  <span class="pre">
   dl(1)
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   0
  </span>
  .
 </p>
 <p>
  <span class="pre">
   d(i)
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   A(i,i)
  </span>
  for
  <span class="pre">
   i=1,2,...,m
  </span>
 </p>
 <p>
  <span class="pre">
   du(i)
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   A(i,i+1)
  </span>
  for
  <span class="pre">
   i=1,2,...,m
  </span>
 </p>
 <p>
  The last element of du is out-of-bound (
  <span class="pre">
   du(m)
  </span>
  <span class="pre">
   :=
  </span>
  <span class="pre">
   A(m,m+1)
  </span>
  ), so
  <span class="pre">
   du(m)
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   0
  </span>
  .
 </p>
 <p>
  The routine does perform pivoting, which usually results in more accurate and more stable results than
  <span class="pre">
   cusparse&lt;t&gt;gtsv_nopivot()
  </span>
  or
  <span class="pre">
   cusparse&lt;t&gt;gtsv2_nopivot()
  </span>
  at the expense of some execution time.
 </p>
 <p>
  This function requires a buffer size returned by
  <span class="pre">
   gtsv2_bufferSizeExt()
  </span>
  . The address of
  <span class="pre">
   pBuffer
  </span>
  must be multiple of 128 bytes. If it is not,
  <span class="pre">
   CUSPARSE_STATUS_INVALID_VALUE
  </span>
  is returned.
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     the size of the linear system (must be  3).
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     number of right-hand sides, columns of matrix
     <span class="pre">
      B
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dl
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense array containing the lower diagonal of the tri-diagonal linear system. The first element of each lower diagonal must be zero.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      d
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense array containing the main diagonal of the tri-diagonal linear system.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      du
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense array containing the upper diagonal of the tri-diagonal linear system. The last element of each upper diagonal must be zero.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      B
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense right-hand-side array of dimensions
     <span class="pre">
      (ldb,
     </span>
     <span class="pre">
      n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ldb
     </span>
    </p>
   </td>
   <td>
    <p>
     leading dimension of
     <span class="pre">
      B
     </span>
     (that is 
     <span class="math notranslate nohighlight">
      \(\max\text{(1,\ m))}\)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     buffer allocated by the user, the size is return by
     <span class="pre">
      gtsv2_bufferSizeExt
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      B
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense solution array of dimensions
     <span class="pre">
      (ldb,
     </span>
     <span class="pre">
      n)
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   5.7.3.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#gtsv2_nopivot_bufferSize">
   cusparse&lt;t&gt;gtsv2_nopivot_bufferSizeExt()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-gtsv2-nopivot-buffersizeext" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSgtsv2_nopivot_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDgtsv2_nopivot_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCgtsv2_nopivot_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZgtsv2_nopivot_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSizeInBytes</span><span class="p">)</span>
</pre>
 <p>
  This function returns the size of the buffer used in
  <span class="pre">
   gtsv2_nopivot
  </span>
  which computes the solution of a tridiagonal linear system with multiple right-hand sides.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A \ast X = B\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The coefficient matrix
  <span class="pre">
   A
  </span>
  of each of these tri-diagonal linear system is defined with three vectors corresponding to its lower (
  <span class="pre">
   dl
  </span>
  ), main (
  <span class="pre">
   d
  </span>
  ), and upper (
  <span class="pre">
   du
  </span>
  ) matrix diagonals; the right-hand sides are stored in the dense matrix
  <span class="pre">
   B
  </span>
  . Notice that solution
  <span class="pre">
   X
  </span>
  overwrites right-hand-side matrix
  <span class="pre">
   B
  </span>
  on exit.
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     the size of the linear system (must be  3).
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     number of right-hand sides, columns of matrix
     <span class="pre">
      B
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dl
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense array containing the lower diagonal of the tri-diagonal linear system. The first element of each lower diagonal must be zero.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      d
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense array containing the main diagonal of the tri-diagonal linear system.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      du
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense array containing the upper diagonal of the tri-diagonal linear system. The last element of each upper diagonal must be zero.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      B
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense right-hand-side array of dimensions
     <span class="pre">
      (ldb,
     </span>
     <span class="pre">
      n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ldb
     </span>
    </p>
   </td>
   <td>
    <p>
     leading dimension of
     <span class="pre">
      B
     </span>
     . (that is 
     <span class="math notranslate nohighlight">
      \(\max\text{(1,\ m))}\)
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      pBufferSizeInBytes
     </span>
    </p>
   </td>
   <td>
    <p>
     number of bytes of the buffer used in the
     <span class="pre">
      gtsv2_nopivot
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   5.7.3.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#gtsv2_nopivot">
   cusparse&lt;t&gt;gtsv2_nopivot()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-gtsv2-nopivot" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSgtsv2_nopivot</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDgtsv2_nopivot</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCgtsv2_nopivot</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZgtsv2_nopivot</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">B</span><span class="p">,</span>
<span class="kt">int</span><span class="n">ldb</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function computes the solution of a tridiagonal linear system with multiple right-hand sides:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A \ast X = B\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The coefficient matrix
  <span class="pre">
   A
  </span>
  of each of these tri-diagonal linear system is defined with three vectors corresponding to its lower (
  <span class="pre">
   dl
  </span>
  ), main (
  <span class="pre">
   d
  </span>
  ), and upper (
  <span class="pre">
   du
  </span>
  ) matrix diagonals; the right-hand sides are stored in the dense matrix
  <span class="pre">
   B
  </span>
  . Notice that solution
  <span class="pre">
   X
  </span>
  overwrites right-hand-side matrix
  <span class="pre">
   B
  </span>
  on exit.
 </p>
 <p>
  The routine does not perform any pivoting and uses a combination of the Cyclic Reduction (CR) and the Parallel Cyclic Reduction (PCR) algorithms to find the solution. It achieves better performance when
  <span class="pre">
   m
  </span>
  is a power of 2.
 </p>
 <p>
  This function requires a buffer size returned by
  <span class="pre">
   gtsv2_nopivot_bufferSizeExt()
  </span>
  . The address of
  <span class="pre">
   pBuffer
  </span>
  must be multiple of 128 bytes. If it is not,
  <span class="pre">
   CUSPARSE_STATUS_INVALID_VALUE
  </span>
  is returned.
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     the size of the linear system (must be  3).
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     number of right-hand sides, columns of matrix
     <span class="pre">
      B
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dl
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense array containing the lower diagonal of the tri-diagonal linear system. The first element of each lower diagonal must be zero.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      d
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense array containing the main diagonal of the tri-diagonal linear system.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      du
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense array containing the upper diagonal of the tri-diagonal linear system. The last element of each upper diagonal must be zero.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      B
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense right-hand-side array of dimensions
     <span class="pre">
      (ldb,
     </span>
     <span class="pre">
      n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ldb
     </span>
    </p>
   </td>
   <td>
    <p>
     leading dimension of
     <span class="pre">
      B
     </span>
     . (that is 
     <span class="math notranslate nohighlight">
      \(\max\text{(1,\ m))}\)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     buffer allocated by the user, the size is return by
     <span class="pre">
      gtsv2_nopivot_bufferSizeExt
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      B
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense solution array of dimensions
     <span class="pre">
      (ldb,
     </span>
     <span class="pre">
      n)
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   5.7.4.
  </span>
  Batched Tridiagonal Solve
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#batched-tridiagonal-solve" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  Different algorithms for batched tridiagonal solve are discussed in this section.
 </p>
 <h4>
  <span class="section-number">
   5.7.4.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#gtsv2stridedbatch_bufferSize">
   cusparse&lt;t&gt;gtsv2StridedBatch_bufferSizeExt()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-gtsv2stridedbatch-buffersizeext" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSgtsv2StridedBatch_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchCount</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchStride</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDgtsv2StridedBatch_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchCount</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchStride</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCgtsv2StridedBatch_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchCount</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchStride</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZgtsv2StridedBatch_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchCount</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchStride</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSizeInBytes</span><span class="p">)</span>
</pre>
 <p>
  This function returns the size of the buffer used in
  <span class="pre">
   gtsv2StridedBatch
  </span>
  which computes the solution of multiple tridiagonal linear systems for
  i
  =0,,
  <span class="pre">
   batchCount
  </span>
  :
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A^{(i)} \ast \text{y}^{(i)} = \text{x}^{(i)}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The coefficient matrix
  <span class="pre">
   A
  </span>
  of each of these tri-diagonal linear system is defined with three vectors corresponding to its lower (
  <span class="pre">
   dl
  </span>
  ), main (
  <span class="pre">
   d
  </span>
  ), and upper (
  <span class="pre">
   du
  </span>
  ) matrix diagonals; the right-hand sides are stored in the dense matrix
  <span class="pre">
   X
  </span>
  . Notice that solution
  <span class="pre">
   Y
  </span>
  overwrites right-hand-side matrix
  <span class="pre">
   X
  </span>
  on exit. The different matrices are assumed to be of the same size and are stored with a fixed
  <span class="pre">
   batchStride
  </span>
  in memory.
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     the size of the linear system (must be  3).
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dl
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense array containing the lower diagonal of the tri-diagonal linear system. The lower diagonal
     <span class="math notranslate nohighlight">
      \(dl^{(i)}\)
     </span>
     that corresponds to the
     i
     th
     linear system starts at location
     <span class="pre">
      dl+batchStridei
     </span>
     in memory. Also, the first element of each lower diagonal must be zero.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      d
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense array containing the main diagonal of the tri-diagonal linear system. The main diagonal
     <span class="math notranslate nohighlight">
      \(d^{(i)}\)
     </span>
     that corresponds to the
     i
     th
     linear system starts at location
     <span class="pre">
      d+batchStridei
     </span>
     in memory.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      du
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense array containing the upper diagonal of the tri-diagonal linear system. The upper diagonal
     <span class="math notranslate nohighlight">
      \(du^{(i)}\)
     </span>
     that corresponds to the
     i
     th
     linear system starts at location
     <span class="pre">
      du+batchStridei
     </span>
     in memory. Also, the last element of each upper diagonal must be zero.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      x
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense array that contains the right-hand-side of the tri-diagonal linear system. The right-hand-side
     <span class="math notranslate nohighlight">
      \(x^{(i)}\)
     </span>
     that corresponds to the
     i
     th
     linear system starts at location
     <span class="pre">
      x+batchStridei
     </span>
     in memory.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      batchCount
     </span>
    </p>
   </td>
   <td>
    <p>
     number of systems to solve.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      batchStride
     </span>
    </p>
   </td>
   <td>
    <p>
     stride (number of elements) that separates the vectors of every system (must be at least
     <span class="pre">
      m
     </span>
     ).
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      pBufferSizeInBytes
     </span>
    </p>
   </td>
   <td>
    <p>
     number of bytes of the buffer used in the
     <span class="pre">
      gtsv2StridedBatch
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   5.7.4.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#gtsv2stridedbatch">
   cusparse&lt;t&gt;gtsv2StridedBatch()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-gtsv2stridedbatch" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSgtsv2StridedBatch</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchCount</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchStride</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDgtsv2StridedBatch</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchCount</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchStride</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCgtsv2StridedBatch</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchCount</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchStride</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZgtsv2StridedBatch</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchCount</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchStride</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function computes the solution of multiple tridiagonal linear systems for
  i
  =0,,
  <span class="pre">
   batchCount
  </span>
  :
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A^{(i)} \ast \text{y}^{(i)} = \text{x}^{(i)}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The coefficient matrix
  <span class="pre">
   A
  </span>
  of each of these tri-diagonal linear system is defined with three vectors corresponding to its lower (
  <span class="pre">
   dl
  </span>
  ), main (
  <span class="pre">
   d
  </span>
  ), and upper (
  <span class="pre">
   du
  </span>
  ) matrix diagonals; the right-hand sides are stored in the dense matrix
  <span class="pre">
   X
  </span>
  . Notice that solution
  <span class="pre">
   Y
  </span>
  overwrites right-hand-side matrix
  <span class="pre">
   X
  </span>
  on exit. The different matrices are assumed to be of the same size and are stored with a fixed
  <span class="pre">
   batchStride
  </span>
  in memory.
 </p>
 <p>
  The routine does not perform any pivoting and uses a combination of the Cyclic Reduction (CR) and the Parallel Cyclic Reduction (PCR) algorithms to find the solution. It achieves better performance when
  <span class="pre">
   m
  </span>
  is a power of 2.
 </p>
 <p>
  This function requires a buffer size returned by
  <span class="pre">
   gtsv2StridedBatch_bufferSizeExt()
  </span>
  . The address of
  <span class="pre">
   pBuffer
  </span>
  must be multiple of 128 bytes. If it is not,
  <span class="pre">
   CUSPARSE_STATUS_INVALID_VALUE
  </span>
  is returned.
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     the size of the linear system (must be  3).
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dl
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense array containing the lower diagonal of the tri-diagonal linear system. The lower diagonal
     <span class="math notranslate nohighlight">
      \(dl^{(i)}\)
     </span>
     that corresponds to the
     i
     th
     linear system starts at location
     <span class="pre">
      dl+batchStridei
     </span>
     in memory. Also, the first element of each lower diagonal must be zero.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      d
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense array containing the main diagonal of the tri-diagonal linear system. The main diagonal
     <span class="math notranslate nohighlight">
      \(d^{(i)}\)
     </span>
     that corresponds to the
     i
     th
     linear system starts at location
     <span class="pre">
      d+batchStridei
     </span>
     in memory.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      du
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense array containing the upper diagonal of the tri-diagonal linear system. The upper diagonal
     <span class="math notranslate nohighlight">
      \(du^{(i)}\)
     </span>
     that corresponds to the
     i
     th
     linear system starts at location
     <span class="pre">
      du+batchStridei
     </span>
     in memory. Also, the last element of each upper diagonal must be zero.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      x
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense array that contains the right-hand-side of the tri-diagonal linear system. The right-hand-side
     <span class="math notranslate nohighlight">
      \(x^{(i)}\)
     </span>
     that corresponds to the
     i
     th
     linear system starts at location
     <span class="pre">
      x+batchStridei
     </span>
     in memory.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      batchCount
     </span>
    </p>
   </td>
   <td>
    <p>
     number of systems to solve.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      batchStride
     </span>
    </p>
   </td>
   <td>
    <p>
     stride (number of elements) that separates the vectors of every system (must be at least
     <span class="pre">
      n
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     buffer allocated by the user, the size is return by
     <span class="pre">
      gtsv2StridedBatch_bufferSizeExt
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      x
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense array that contains the solution of the tri-diagonal linear system. The solution
     <span class="math notranslate nohighlight">
      \(x^{(i)}\)
     </span>
     that corresponds to the
     i
     th
     linear system starts at location
     <span class="pre">
      x+batchStridei
     </span>
     in memory.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   5.7.4.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#gtsvInterleavedBatch">
   cusparse&lt;t&gt;gtsvInterleavedBatch()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-gtsvinterleavedbatch" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSgtsvInterleavedBatch_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">algo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchCount</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDgtsvInterleavedBatch_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">algo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchCount</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCgtsvInterleavedBatch_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">algo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchCount</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZgtsvInterleavedBatch_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">algo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchCount</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSgtsvInterleavedBatch</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">algo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchCount</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDgtsvInterleavedBatch</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">algo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchCount</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCgtsvInterleavedBatch</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">algo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchCount</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZgtsvInterleavedBatch</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">algo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchCount</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function computes the solution of multiple tridiagonal linear systems for
  i
  =0,,
  <span class="pre">
   batchCount
  </span>
  :
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A^{(i)} \ast \text{x}^{(i)} = \text{b}^{(i)}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The coefficient matrix
  <span class="pre">
   A
  </span>
  of each of these tri-diagonal linear system is defined with three vectors corresponding to its lower (
  <span class="pre">
   dl
  </span>
  ), main (
  <span class="pre">
   d
  </span>
  ), and upper (
  <span class="pre">
   du
  </span>
  ) matrix diagonals; the right-hand sides are stored in the dense matrix
  <span class="pre">
   B
  </span>
  . Notice that solution
  <span class="pre">
   X
  </span>
  overwrites right-hand-side matrix
  <span class="pre">
   B
  </span>
  on exit.
 </p>
 <p>
  Assuming
  <span class="pre">
   A
  </span>
  is of size
  <span class="pre">
   m
  </span>
  and base-1,
  <span class="pre">
   dl
  </span>
  ,
  <span class="pre">
   d
  </span>
  and
  <span class="pre">
   du
  </span>
  are defined by the following formula:
 </p>
 <p>
  <span class="pre">
   dl(i)
  </span>
  <span class="pre">
   :=
  </span>
  <span class="pre">
   A(i,
  </span>
  <span class="pre">
   i-1)
  </span>
  for
  <span class="pre">
   i=1,2,...,m
  </span>
 </p>
 <p>
  The first element of dl is out-of-bound (
  <span class="pre">
   dl(1)
  </span>
  <span class="pre">
   :=
  </span>
  <span class="pre">
   A(1,0)
  </span>
  ), so
  <span class="pre">
   dl(1)
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   0
  </span>
  .
 </p>
 <p>
  <span class="pre">
   d(i)
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   A(i,i)
  </span>
  for
  <span class="pre">
   i=1,2,...,m
  </span>
 </p>
 <p>
  <span class="pre">
   du(i)
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   A(i,i+1)
  </span>
  for
  <span class="pre">
   i=1,2,...,m
  </span>
 </p>
 <p>
  The last element of du is out-of-bound (
  <span class="pre">
   du(m)
  </span>
  <span class="pre">
   :=
  </span>
  <span class="pre">
   A(m,m+1)
  </span>
  ), so
  <span class="pre">
   du(m)
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   0
  </span>
  .
 </p>
 <p>
  The data layout is different from
  <span class="pre">
   gtsvStridedBatch
  </span>
  which aggregates all matrices one after another. Instead,
  <span class="pre">
   gtsvInterleavedBatch
  </span>
  gathers different matrices of the same element in a continous manner. If
  <span class="pre">
   dl
  </span>
  is regarded as a 2-D array of size
  <span class="pre">
   m-by-batchCount
  </span>
  ,
  <span class="pre">
   dl(:,j)
  </span>
  to store
  <span class="pre">
   j-th
  </span>
  matrix.
  <span class="pre">
   gtsvStridedBatch
  </span>
  uses column-major while
  <span class="pre">
   gtsvInterleavedBatch
  </span>
  uses row-major.
 </p>
 <p>
  The routine provides three different algorithms, selected by parameter
  <span class="pre">
   algo
  </span>
  . The first algorithm is
  <span class="pre">
   cuThomas
  </span>
  provided by
  <span class="pre">
   Barcelona
  </span>
  <span class="pre">
   Supercomputing
  </span>
  <span class="pre">
   Center
  </span>
  . The second algorithm is LU with partial pivoting and last algorithm is QR. From stability perspective, cuThomas is not numerically stable because it does not have pivoting. LU with partial pivoting and QR are stable. From performance perspective, LU with partial pivoting and QR is about 10% to 20% slower than cuThomas.
 </p>
 <p>
  This function requires a buffer size returned by
  <span class="pre">
   gtsvInterleavedBatch_bufferSizeExt()
  </span>
  . The address of
  <span class="pre">
   pBuffer
  </span>
  must be multiple of 128 bytes. If it is not,
  <span class="pre">
   CUSPARSE_STATUS_INVALID_VALUE
  </span>
  is returned.
 </p>
 <p>
  If the user prepares aggregate format, one can use
  <span class="pre">
   cublasXgeam
  </span>
  to get interleaved format. However such transformation takes time comparable to solver itself. To reach best performance, the user must prepare interleaved format explicitly.
 </p>
 <ul class="simple">
  <li>
   <p>
    This function requires temporary extra storage that is allocated internally
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      algo
     </span>
    </p>
   </td>
   <td>
    <p>
     algo = 0: cuThomas (unstable algorithm); algo = 1: LU with pivoting (stable algorithm); algo = 2: QR (stable algorithm)
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     the size of the linear system.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dl
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense array containing the lower diagonal of the tri-diagonal linear system. The first element of each lower diagonal must be zero.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      d
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense array containing the main diagonal of the tri-diagonal linear system.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      du
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense array containing the upper diagonal of the tri-diagonal linear system. The last element of each upper diagonal must be zero.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      x
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense right-hand-side array of dimensions
     <span class="pre">
      (batchCount,
     </span>
     <span class="pre">
      n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     buffer allocated by the user, the size is return by
     <span class="pre">
      gtsvInterleavedBatch_bufferSizeExt
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      x
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense solution array of dimensions
     <span class="pre">
      (batchCount,
     </span>
     <span class="pre">
      n)
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   5.7.5.
  </span>
  Batched Pentadiagonal Solve
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#batched-pentadiagonal-solve" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  Different algorithms for batched pentadiagonal solve are discussed in this section.
 </p>
 <h4>
  <span class="section-number">
   5.7.5.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#gpsvInterleavedBatch">
   cusparse&lt;t&gt;gpsvInterleavedBatch()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-gpsvinterleavedbatch" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSgpsvInterleavedBatch_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">algo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">ds</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">dw</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchCount</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDgpsvInterleavedBatch_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">algo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">ds</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">dw</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchCount</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCgpsvInterleavedBatch_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">algo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">ds</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">dw</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchCount</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZgpsvInterleavedBatch_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">algo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">ds</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dw</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchCount</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSgpsvInterleavedBatch</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">algo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">ds</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">dw</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchCount</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDgpsvInterleavedBatch</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">algo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">ds</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">dw</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchCount</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCgpsvInterleavedBatch</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">algo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">ds</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">dw</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchCount</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZgpsvInterleavedBatch</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">algo</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">ds</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dl</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">d</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">du</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">dw</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchCount</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function computes the solution of multiple penta-diagonal linear systems for
  i
  =0,,
  <span class="pre">
   batchCount
  </span>
  :
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(A^{(i)} \ast \text{x}^{(i)} = \text{b}^{(i)}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The coefficient matrix
  <span class="pre">
   A
  </span>
  of each of these penta-diagonal linear system is defined with five vectors corresponding to its lower (
  <span class="pre">
   ds,
  </span>
  <span class="pre">
   dl
  </span>
  ), main (
  <span class="pre">
   d
  </span>
  ), and upper (
  <span class="pre">
   du,
  </span>
  <span class="pre">
   dw
  </span>
  ) matrix diagonals; the right-hand sides are stored in the dense matrix
  <span class="pre">
   B
  </span>
  . Notice that solution
  <span class="pre">
   X
  </span>
  overwrites right-hand-side matrix
  <span class="pre">
   B
  </span>
  on exit.
 </p>
 <p>
  Assuming
  <span class="pre">
   A
  </span>
  is of size
  <span class="pre">
   m
  </span>
  and base-1,
  <span class="pre">
   ds
  </span>
  ,
  <span class="pre">
   dl
  </span>
  ,
  <span class="pre">
   d
  </span>
  ,
  <span class="pre">
   du
  </span>
  and
  <span class="pre">
   dw
  </span>
  are defined by the following formula:
 </p>
 <p>
  <span class="pre">
   ds(i)
  </span>
  <span class="pre">
   :=
  </span>
  <span class="pre">
   A(i,
  </span>
  <span class="pre">
   i-2)
  </span>
  for
  <span class="pre">
   i=1,2,...,m
  </span>
 </p>
 <p>
  The first two elements of ds is out-of-bound (
  <span class="pre">
   ds(1)
  </span>
  <span class="pre">
   :=
  </span>
  <span class="pre">
   A(1,-1)
  </span>
  ,
  <span class="pre">
   ds(2)
  </span>
  <span class="pre">
   :=
  </span>
  <span class="pre">
   A(2,0)
  </span>
  ), so
  <span class="pre">
   ds(1)
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   0
  </span>
  and
  <span class="pre">
   ds(2)
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   0
  </span>
  .
 </p>
 <p>
  <span class="pre">
   dl(i)
  </span>
  <span class="pre">
   :=
  </span>
  <span class="pre">
   A(i,
  </span>
  <span class="pre">
   i-1)
  </span>
  for
  <span class="pre">
   i=1,2,...,m
  </span>
 </p>
 <p>
  The first element of dl is out-of-bound (
  <span class="pre">
   dl(1)
  </span>
  <span class="pre">
   :=
  </span>
  <span class="pre">
   A(1,0)
  </span>
  ), so
  <span class="pre">
   dl(1)
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   0
  </span>
  .
 </p>
 <p>
  <span class="pre">
   d(i)
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   A(i,i)
  </span>
  for
  <span class="pre">
   i=1,2,...,m
  </span>
 </p>
 <p>
  <span class="pre">
   du(i)
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   A(i,i+1)
  </span>
  for
  <span class="pre">
   i=1,2,...,m
  </span>
 </p>
 <p>
  The last element of du is out-of-bound (
  <span class="pre">
   du(m)
  </span>
  <span class="pre">
   :=
  </span>
  <span class="pre">
   A(m,m+1)
  </span>
  ), so
  <span class="pre">
   du(m)
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   0
  </span>
  .
 </p>
 <p>
  <span class="pre">
   dw(i)
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   A(i,i+2)
  </span>
  for
  <span class="pre">
   i=1,2,...,m
  </span>
 </p>
 <p>
  The last two elements of dw is out-of-bound (
  <span class="pre">
   dw(m-1)
  </span>
  <span class="pre">
   :=
  </span>
  <span class="pre">
   A(m-1,m+1)
  </span>
  ,
  <span class="pre">
   dw(m)
  </span>
  <span class="pre">
   :=
  </span>
  <span class="pre">
   A(m,m+2)
  </span>
  ), so
  <span class="pre">
   dw(m-1)
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   0
  </span>
  and
  <span class="pre">
   dw(m)
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   0
  </span>
  .
 </p>
 <p>
  The data layout is the same as
  <span class="pre">
   gtsvStridedBatch
  </span>
  .
 </p>
 <p>
  The routine is numerically stable because it uses QR to solve the linear system.
 </p>
 <p>
  This function requires a buffer size returned by
  <span class="pre">
   gpsvInterleavedBatch_bufferSizeExt()
  </span>
  . The address of
  <span class="pre">
   pBuffer
  </span>
  must be multiple of 128 bytes. If it is not,
  <span class="pre">
   CUSPARSE_STATUS_INVALID_VALUE
  </span>
  is returned.
 </p>
 <p>
  The function supports the following properties if
  <span class="pre">
   pBuffer
  </span>
  <span class="pre">
   !=
  </span>
  <span class="pre">
   NULL
  </span>
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      algo
     </span>
    </p>
   </td>
   <td>
    <p>
     only support algo = 0 (QR)
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     the size of the linear system.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ds
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense array containing the lower diagonal (distance 2 to the diagonal) of the penta-diagonal linear system. The first two elements must be zero.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dl
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense array containing the lower diagonal (distance 1 to the diagonal) of the penta-diagonal linear system. The first element must be zero.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      d
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense array containing the main diagonal of the penta-diagonal linear system.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      du
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense array containing the upper diagonal (distance 1 to the diagonal) of the penta-diagonal linear system. The last element must be zero.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dw
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense array containing the upper diagonal (distance 2 to the diagonal) of the penta-diagonal linear system. The last two elements must be zero.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      x
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense right-hand-side array of dimensions
     <span class="pre">
      (batchCount,
     </span>
     <span class="pre">
      n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     buffer allocated by the user, the size is return by
     <span class="pre">
      gpsvInterleavedBatch_bufferSizeExt
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      x
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; dense solution array of dimensions
     <span class="pre">
      (batchCount,
     </span>
     <span class="pre">
      n)
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSPARSE/gpsvInterleavedBatch">
   cuSPARSE Library Samples - cusparseSgpsvInterleavedBatch
  </a>
  for a code example.
 </p>
 <h2>
  <span class="section-number">
   5.8.
  </span>
  cuSPARSE Reorderings Reference
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-reorderings-reference" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  This chapter describes the reordering routines used to manipulate sparse matrices.
 </p>
 <h3>
  <span class="section-number">
   5.8.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#csrcol">
   cusparse&lt;t&gt;csrcolor()
  </a>
  [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-csrcolor-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseScsrcolor</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">fractionToColor</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">ncolors</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">coloring</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">reordering</span><span class="p">,</span>
<span class="n">cusparseColorInfo_t</span><span class="n">info</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDcsrcolor</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">fractionToColor</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">ncolors</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">coloring</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">reordering</span><span class="p">,</span>
<span class="n">cusparseColorInfo_t</span><span class="n">info</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCcsrcolor</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">fractionToColor</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">ncolors</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">coloring</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">reordering</span><span class="p">,</span>
<span class="n">cusparseColorInfo_t</span><span class="n">info</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZcsrcolor</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">fractionToColor</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">ncolors</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">coloring</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">reordering</span><span class="p">,</span>
<span class="n">cusparseColorInfo_t</span><span class="n">info</span><span class="p">)</span>
</pre>
 <p>
  This function performs the coloring of the adjacency graph associated with the matrix A stored in CSR format. The coloring is an assignment of colors (integer numbers) to nodes, such that neighboring nodes have distinct colors. An approximate coloring algorithm is used in this routine, and is stopped when a certain percentage of nodes has been colored. The rest of the nodes are assigned distinct colors (an increasing sequence of integers numbers, starting from the last integer used previously). The last two auxiliary routines can be used to extract the resulting number of colors, their assignment and the associated reordering. The reordering is such that nodes that have been assigned the same color are reordered to be next to each other.
 </p>
 <p>
  The matrix A passed to this routine, must be stored as a general matrix and have a symmetric sparsity pattern. If the matrix is nonsymmetric the user should pass A+A^T as a parameter to this routine.
 </p>
 <ul class="simple">
  <li>
   <p>
    This function requires temporary extra storage that is allocated internally
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     number of rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     number of nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnz
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      m+1
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnz
     </span>
     <span class="math notranslate nohighlight">
      \(( =\)
     </span>
     <span class="pre">
      csrRowPtrA(m)
     </span>
     <span class="math notranslate nohighlight">
      \(-\)
     </span>
     <span class="pre">
      csrRowPtrA(0)
     </span>
     <span class="math notranslate nohighlight">
      \()\)
     </span>
     column indices of the nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      fractionToColor
     </span>
    </p>
   </td>
   <td>
    <p>
     fraction of nodes to be colored, which should be in the interval [0.0,1.0], for example 0.8 implies that 80 percent of nodes will be colored.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     structure with information to be passed to the coloring.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ncolors
     </span>
    </p>
   </td>
   <td>
    <p>
     The number of distinct colors used (at most the size of the matrix, but likely much smaller).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      coloring
     </span>
    </p>
   </td>
   <td>
    <p>
     The resulting coloring permutation
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      reordering
     </span>
    </p>
   </td>
   <td>
    <p>
     The resulting reordering permutation (untouched if NULL)
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h2>
  <span class="section-number">
   5.9.
  </span>
  cuSPARSE Format Conversion Reference
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-format-conversion-reference" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  This chapter describes the conversion routines between different sparse and dense storage formats.
 </p>
 <p>
  <span class="pre">
   coosort
  </span>
  ,
  <span class="pre">
   csrsort
  </span>
  ,
  <span class="pre">
   cscsort
  </span>
  , and
  <span class="pre">
   csru2csr
  </span>
  are sorting routines without malloc inside, the following table estimates the buffer size.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      routine
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      buffer
     </span>
     <span class="pre">
      size
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      maximum
     </span>
     <span class="pre">
      problem
     </span>
     <span class="pre">
      size
     </span>
     <span class="pre">
      if
     </span>
     <span class="pre">
      buffer
     </span>
     <span class="pre">
      is
     </span>
     <span class="pre">
      limited
     </span>
     <span class="pre">
      by
     </span>
     <span class="pre">
      2GB
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      coosort
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      &gt;
     </span>
     <span class="pre">
      16*n
     </span>
     <span class="pre">
      bytes
     </span>
    </p>
   </td>
   <td>
    <p>
     125M
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrsort
     </span>
     <span class="pre">
      or
     </span>
     <span class="pre">
      cscsort
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      &gt;
     </span>
     <span class="pre">
      20*n
     </span>
     <span class="pre">
      bytes
     </span>
    </p>
   </td>
   <td>
    <p>
     100M
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csru2csr
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      'd'
     </span>
     <span class="pre">
      &gt;
     </span>
     <span class="pre">
      28*n
     </span>
     <span class="pre">
      bytes
     </span>
     <span class="pre">
      ;
     </span>
     <span class="pre">
      'z'
     </span>
     <span class="pre">
      &gt;
     </span>
     <span class="pre">
      36*n
     </span>
     <span class="pre">
      bytes
     </span>
    </p>
   </td>
   <td>
    <p>
     71M for d and 55M for z
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   5.9.1.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#bsr2csr">
   cusparse&lt;t&gt;bsr2csr()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-bsr2csr" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSbsr2csr</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDbsr2csr</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCbsr2csr</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZbsr2csr</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">blockDim</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">)</span>
</pre>
 <p>
  This function converts a sparse matrix in BSR format that is defined by the three arrays
  <span class="pre">
   bsrValA
  </span>
  ,
  <span class="pre">
   bsrRowPtrA
  </span>
  , and
  <span class="pre">
   bsrColIndA
  </span>
  ) into a sparse matrix in CSR format that is defined by arrays
  <span class="pre">
   csrValC
  </span>
  ,
  <span class="pre">
   csrRowPtrC
  </span>
  , and
  <span class="pre">
   csrColIndC
  </span>
  .
 </p>
 <p>
  Let
  <span class="pre">
   m(=mb*blockDim)
  </span>
  be the number of rows of
  <span class="pre">
   A
  </span>
  and
  <span class="pre">
   n(=nb*blockDim)
  </span>
  be number of columns of
  <span class="pre">
   A
  </span>
  , then
  <span class="pre">
   A
  </span>
  and
  <span class="pre">
   C
  </span>
  are
  <span class="pre">
   m*n
  </span>
  sparse matrices. The BSR format of
  <span class="pre">
   A
  </span>
  contains
  <span class="pre">
   nnzb(=bsrRowPtrA[mb]
  </span>
  <span class="pre">
   -
  </span>
  <span class="pre">
   bsrRowPtrA[0])
  </span>
  nonzero blocks, whereas the sparse matrix
  <span class="pre">
   A
  </span>
  contains
  <span class="pre">
   nnz(=nnzb*blockDim*blockDim)
  </span>
  elements. The user must allocate enough space for arrays
  <span class="pre">
   csrRowPtrC
  </span>
  ,
  <span class="pre">
   csrColIndC
  </span>
  , and
  <span class="pre">
   csrValC
  </span>
  . The requirements are as follows:
 </p>
 <p>
  <span class="pre">
   csrRowPtrC
  </span>
  of
  <span class="pre">
   m+1
  </span>
  elements
 </p>
 <p>
  <span class="pre">
   csrValC
  </span>
  of
  <span class="pre">
   nnz
  </span>
  elements
 </p>
 <p>
  <span class="pre">
   csrColIndC
  </span>
  of
  <span class="pre">
   nnz
  </span>
  elements
 </p>
 <p>
  The general procedure is as follows:
 </p>
 <pre><span class="c1">// Given BSR format (bsrRowPtrA, bsrcolIndA, bsrValA) and</span>
<span class="c1">// blocks of BSR format are stored in column-major order.</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="o">=</span><span class="n">CUSPARSE_DIRECTION_COLUMN</span><span class="p">;</span>
<span class="kt">int</span><span class="n">m</span><span class="o">=</span><span class="n">mb</span><span class="o">*</span><span class="n">blockDim</span><span class="p">;</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="o">=</span><span class="n">bsrRowPtrA</span><span class="p">[</span><span class="n">mb</span><span class="p">]</span><span class="o">-</span><span class="n">bsrRowPtrA</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="c1">// number of blocks</span>
<span class="kt">int</span><span class="n">nnz</span><span class="o">=</span><span class="n">nnzb</span><span class="o">*</span><span class="n">blockDim</span><span class="o">*</span><span class="n">blockDim</span><span class="p">;</span><span class="c1">// number of elements</span>
<span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">csrRowPtrC</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
<span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">csrColIndC</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">nnz</span><span class="p">);</span>
<span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">csrValC</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="n">nnz</span><span class="p">);</span>
<span class="n">cusparseSbsr2csr</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span><span class="n">mb</span><span class="p">,</span><span class="n">nb</span><span class="p">,</span>
<span class="n">descrA</span><span class="p">,</span>
<span class="n">bsrValA</span><span class="p">,</span><span class="n">bsrRowPtrA</span><span class="p">,</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="n">blockDim</span><span class="p">,</span>
<span class="n">descrC</span><span class="p">,</span>
<span class="n">csrValC</span><span class="p">,</span><span class="n">csrRowPtrC</span><span class="p">,</span><span class="n">csrColIndC</span><span class="p">);</span>
</pre>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if
    <span class="pre">
     blockDim
    </span>
    <span class="pre">
     !=
    </span>
    <span class="pre">
     1
    </span>
    or the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture if
    <span class="pre">
     blockDim
    </span>
    <span class="pre">
     !=
    </span>
    <span class="pre">
     1
    </span>
    or the Stream Ordered Memory Allocator is available
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dir
     </span>
    </p>
   </td>
   <td>
    <p>
     storage format of blocks, either
     <span class="pre">
      CUSPARSE_DIRECTION_ROW
     </span>
     or
     <span class="pre">
      CUSPARSE_DIRECTION_COLUMN
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      mb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of block rows of sparse matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of block columns of sparse matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzb*blockDim*blockDim
     </span>
     nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      mb+1
     </span>
     elements that contains the start of every block row and the end of the last block row plus one of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzb
     </span>
     column indices of the nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      blockDim
     </span>
    </p>
   </td>
   <td>
    <p>
     block dimension of sparse matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descrC
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrValC
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnz(=csrRowPtrC[m]-csrRowPtrC[0])
     </span>
     nonzero elements of matrix
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowPtrC
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      m+1
     </span>
     elements that contains the start of every row and the end of the last row plus one of matrix
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColIndC
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnz
     </span>
     column indices of the nonzero elements of matrix
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   5.9.2.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#gebsr2gebsc">
   cusparse&lt;t&gt;gebsr2gebsc()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-gebsr2gebsc" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSgebsr2gebsc_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">bsrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColInd</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSize</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDgebsr2gebsc_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">bsrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColInd</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSize</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCgebsr2gebsc_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">bsrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColInd</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSize</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZgebsr2gebsc_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">bsrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColInd</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSize</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSgebsr2gebsc</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">bsrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColInd</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDim</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">bscVal</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">bscRowInd</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">bscColPtr</span><span class="p">,</span>
<span class="n">cusparseAction_t</span><span class="n">copyValues</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="n">baseIdx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDgebsr2gebsc</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">bsrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColInd</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDim</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">bscVal</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">bscRowInd</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">bscColPtr</span><span class="p">,</span>
<span class="n">cusparseAction_t</span><span class="n">copyValues</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="n">baseIdx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCgebsr2gebsc</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">bsrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColInd</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDim</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">bscVal</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">bscRowInd</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">bscColPtr</span><span class="p">,</span>
<span class="n">cusparseAction_t</span><span class="n">copyValues</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="n">baseIdx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZgebsr2gebsc</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">bsrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColInd</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDim</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">bscVal</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">bscRowInd</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">bscColPtr</span><span class="p">,</span>
<span class="n">cusparseAction_t</span><span class="n">copyValues</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="n">baseIdx</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function can be seen as the same as
  <span class="pre">
   csr2csc()
  </span>
  when each block of size
  <span class="pre">
   rowBlockDim*colBlockDim
  </span>
  is regarded as a scalar.
 </p>
 <p>
  This sparsity pattern of the result matrix can also be seen as the transpose of the original sparse matrix, but the memory layout of a block does not change.
 </p>
 <p>
  The user must call
  <span class="pre">
   gebsr2gebsc_bufferSize()
  </span>
  to determine the size of the buffer required by
  <span class="pre">
   gebsr2gebsc()
  </span>
  , allocate the buffer, and pass the buffer pointer to
  <span class="pre">
   gebsr2gebsc()
  </span>
  .
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage if
    <span class="pre">
     pBuffer
    </span>
    <span class="pre">
     !=
    </span>
    <span class="pre">
     NULL
    </span>
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      mb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of block rows of sparse matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of block columns of sparse matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrVal
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzb*rowBlockDim*colBlockDim
     </span>
     nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrRowPtr
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      mb+1
     </span>
     elements that contains the start of every block row and the end of the last block row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrColInd
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzb
     </span>
     column indices of the non-zero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      rowBlockDim
     </span>
    </p>
   </td>
   <td>
    <p>
     number of rows within a block of
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      colBlockDim
     </span>
    </p>
   </td>
   <td>
    <p>
     number of columns within a block of
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      copyValues
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUSPARSE_ACTION_SYMBOLIC
     </span>
     or
     <span class="pre">
      CUSPARSE_ACTION_NUMERIC
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      baseIdx
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     or
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBufferSize
     </span>
    </p>
   </td>
   <td>
    <p>
     host pointer containing number of bytes of the buffer used in
     <span class="pre">
      gebsr2gebsc()
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     buffer allocated by the user; the size is return by
     <span class="pre">
      gebsr2gebsc_bufferSize()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bscVal
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzb*rowBlockDim*colBlockDim
     </span>
     non-zero elements of matrix
     <span class="pre">
      A
     </span>
     . It is only filled-in if
     <span class="pre">
      copyValues
     </span>
     is set to
     <span class="pre">
      CUSPARSE_ACTION_NUMERIC
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bscRowInd
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzb
     </span>
     row indices of the non-zero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bscColPtr
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nb+1
     </span>
     elements that contains the start of every block column and the end of the last block column plus one.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   5.9.3.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#gebsr2gebsr">
   cusparse&lt;t&gt;gebsr2gebsr()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-gebsr2gebsr" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSgebsr2gebsr_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDimA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDimA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDimC</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDimC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSize</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDgebsr2gebsr_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDimA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDimA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDimC</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDimC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSize</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCgebsr2gebsr_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDimA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDimA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDimC</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDimC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSize</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZgebsr2gebsr_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDimA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDimA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDimC</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDimC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSize</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseXgebsr2gebsrNnz</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDimA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDimA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDimC</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDimC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzTotalDevHostPtr</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseSgebsr2gebsr</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDimA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDimA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">bsrValC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndC</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDimC</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDimC</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDgebsr2gebsr</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDimA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDimA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">bsrValC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndC</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDimC</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDimC</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCgebsr2gebsr</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDimA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDimA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">bsrValC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndC</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDimC</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDimC</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZgebsr2gebsr</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDimA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDimA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">bsrValC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndC</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDimC</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDimC</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function converts a sparse matrix in general BSR format that is defined by the three arrays
  <span class="pre">
   bsrValA
  </span>
  ,
  <span class="pre">
   bsrRowPtrA
  </span>
  , and
  <span class="pre">
   bsrColIndA
  </span>
  into a sparse matrix in another general BSR format that is defined by arrays
  <span class="pre">
   bsrValC
  </span>
  ,
  <span class="pre">
   bsrRowPtrC
  </span>
  , and
  <span class="pre">
   bsrColIndC
  </span>
  .
 </p>
 <p>
  If
  <span class="pre">
   rowBlockDimA=1
  </span>
  and
  <span class="pre">
   colBlockDimA=1
  </span>
  ,
  <span class="pre">
   cusparse[S|D|C|Z]gebsr2gebsr()
  </span>
  is the same as
  <span class="pre">
   cusparse[S|D|C|Z]csr2gebsr()
  </span>
  .
 </p>
 <p>
  If
  <span class="pre">
   rowBlockDimC=1
  </span>
  and
  <span class="pre">
   colBlockDimC=1
  </span>
  ,
  <span class="pre">
   cusparse[S|D|C|Z]gebsr2gebsr()
  </span>
  is the same as
  <span class="pre">
   cusparse[S|D|C|Z]gebsr2csr()
  </span>
  .
 </p>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   m*n
  </span>
  sparse matrix where
  <span class="pre">
   m(=mb*rowBlockDim)
  </span>
  is the number of rows of
  <span class="pre">
   A
  </span>
  , and
  <span class="pre">
   n(=nb*colBlockDim)
  </span>
  is the number of columns of
  <span class="pre">
   A
  </span>
  . The general BSR format of
  <span class="pre">
   A
  </span>
  contains
  <span class="pre">
   nnzb(=bsrRowPtrA[mb]
  </span>
  <span class="pre">
   -
  </span>
  
  <span class="pre">
   bsrRowPtrA[0])
  </span>
  nonzero blocks. The matrix
  <span class="pre">
   C
  </span>
  is also general BSR format with a different block size,
  <span class="pre">
   rowBlockDimC*colBlockDimC
  </span>
  . If
  <span class="pre">
   m
  </span>
  is not a multiple of
  <span class="pre">
   rowBlockDimC
  </span>
  , or
  <span class="pre">
   n
  </span>
  is not a multiple of
  <span class="pre">
   colBlockDimC
  </span>
  , zeros are filled in. The number of block rows of
  <span class="pre">
   C
  </span>
  is
  <span class="pre">
   mc(=(m+rowBlockDimC-1)/rowBlockDimC)
  </span>
  . The number of block rows of
  <span class="pre">
   C
  </span>
  is
  <span class="pre">
   nc(=(n+colBlockDimC-1)/colBlockDimC)
  </span>
  . The number of nonzero blocks of
  <span class="pre">
   C
  </span>
  is
  <span class="pre">
   nnzc
  </span>
  .
 </p>
 <p>
  The implementation adopts a two-step approach to do the conversion. First, the user allocates
  <span class="pre">
   bsrRowPtrC
  </span>
  of
  <span class="pre">
   mc+1
  </span>
  elements and uses function
  <span class="pre">
   cusparseXgebsr2gebsrNnz()
  </span>
  to determine the number of nonzero block columns per block row of matrix
  <span class="pre">
   C
  </span>
  . Second, the user gathers
  <span class="pre">
   nnzc
  </span>
  (number of non-zero block columns of matrix
  <span class="pre">
   C
  </span>
  ) from either
  <span class="pre">
   (nnzc=*nnzTotalDevHostPtr)
  </span>
  or
  <span class="pre">
   (nnzc=bsrRowPtrC[mc]-bsrRowPtrC[0])
  </span>
  and allocates
  <span class="pre">
   bsrValC
  </span>
  of
  <span class="pre">
   nnzc*rowBlockDimC*colBlockDimC
  </span>
  elements and
  <span class="pre">
   bsrColIndC
  </span>
  of
  <span class="pre">
   nnzc
  </span>
  integers. Finally the function
  <span class="pre">
   cusparse[S|D|C|Z]gebsr2gebsr()
  </span>
  is called to complete the conversion.
 </p>
 <p>
  The user must call
  <span class="pre">
   gebsr2gebsr_bufferSize()
  </span>
  to know the size of the buffer required by
  <span class="pre">
   gebsr2gebsr()
  </span>
  , allocate the buffer, and pass the buffer pointer to
  <span class="pre">
   gebsr2gebsr()
  </span>
  .
 </p>
 <p>
  The general procedure is as follows:
 </p>
 <pre><span class="c1">// Given general BSR format (bsrRowPtrA, bsrColIndA, bsrValA) and</span>
<span class="c1">// blocks of BSR format are stored in column-major order.</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="o">=</span><span class="n">CUSPARSE_DIRECTION_COLUMN</span><span class="p">;</span>
<span class="kt">int</span><span class="n">base</span><span class="p">,</span><span class="n">nnzc</span><span class="p">;</span>
<span class="kt">int</span><span class="n">m</span><span class="o">=</span><span class="n">mb</span><span class="o">*</span><span class="n">rowBlockDimA</span><span class="p">;</span>
<span class="kt">int</span><span class="n">n</span><span class="o">=</span><span class="n">nb</span><span class="o">*</span><span class="n">colBlockDimA</span><span class="p">;</span>
<span class="kt">int</span><span class="n">mc</span><span class="o">=</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="n">rowBlockDimC</span><span class="mi">-1</span><span class="p">)</span><span class="o">/</span><span class="n">rowBlockDimC</span><span class="p">;</span>
<span class="kt">int</span><span class="n">nc</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">colBlockDimC</span><span class="mi">-1</span><span class="p">)</span><span class="o">/</span><span class="n">colBlockDimC</span><span class="p">;</span>
<span class="kt">int</span><span class="n">bufferSize</span><span class="p">;</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">;</span>
<span class="n">cusparseSgebsr2gebsr_bufferSize</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span><span class="n">mb</span><span class="p">,</span><span class="n">nb</span><span class="p">,</span><span class="n">nnzb</span><span class="p">,</span>
<span class="n">descrA</span><span class="p">,</span><span class="n">bsrValA</span><span class="p">,</span><span class="n">bsrRowPtrA</span><span class="p">,</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="n">rowBlockDimA</span><span class="p">,</span><span class="n">colBlockDimA</span><span class="p">,</span>
<span class="n">rowBlockDimC</span><span class="p">,</span><span class="n">colBlockDimC</span><span class="p">,</span>
<span class="o">&amp;</span><span class="n">bufferSize</span><span class="p">);</span>
<span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pBuffer</span><span class="p">,</span><span class="n">bufferSize</span><span class="p">);</span>
<span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">bsrRowPtrC</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">mc</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
<span class="c1">// nnzTotalDevHostPtr points to host memory</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzTotalDevHostPtr</span><span class="o">=</span><span class="o">&amp;</span><span class="n">nnzc</span><span class="p">;</span>
<span class="n">cusparseXgebsr2gebsrNnz</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span><span class="n">mb</span><span class="p">,</span><span class="n">nb</span><span class="p">,</span><span class="n">nnzb</span><span class="p">,</span>
<span class="n">descrA</span><span class="p">,</span><span class="n">bsrRowPtrA</span><span class="p">,</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="n">rowBlockDimA</span><span class="p">,</span><span class="n">colBlockDimA</span><span class="p">,</span>
<span class="n">descrC</span><span class="p">,</span><span class="n">bsrRowPtrC</span><span class="p">,</span>
<span class="n">rowBlockDimC</span><span class="p">,</span><span class="n">colBlockDimC</span><span class="p">,</span>
<span class="n">nnzTotalDevHostPtr</span><span class="p">,</span>
<span class="n">pBuffer</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="nb">NULL</span><span class="o">!=</span><span class="n">nnzTotalDevHostPtr</span><span class="p">){</span>
<span class="n">nnzc</span><span class="o">=</span><span class="o">*</span><span class="n">nnzTotalDevHostPtr</span><span class="p">;</span>
<span class="p">}</span><span class="k">else</span><span class="p">{</span>
<span class="n">cudaMemcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nnzc</span><span class="p">,</span><span class="n">bsrRowPtrC</span><span class="o">+</span><span class="n">mc</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span><span class="n">cudaMemcpyDeviceToHost</span><span class="p">);</span>
<span class="n">cudaMemcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="p">,</span><span class="n">bsrRowPtrC</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span><span class="n">cudaMemcpyDeviceToHost</span><span class="p">);</span>
<span class="n">nnzc</span><span class="o">-=</span><span class="n">base</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">bsrColIndC</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">nnzc</span><span class="p">);</span>
<span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">bsrValC</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">rowBlockDimC</span><span class="o">*</span><span class="n">colBlockDimC</span><span class="p">)</span><span class="o">*</span><span class="n">nnzc</span><span class="p">);</span>
<span class="n">cusparseSgebsr2gebsr</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span><span class="n">mb</span><span class="p">,</span><span class="n">nb</span><span class="p">,</span><span class="n">nnzb</span><span class="p">,</span>
<span class="n">descrA</span><span class="p">,</span><span class="n">bsrValA</span><span class="p">,</span><span class="n">bsrRowPtrA</span><span class="p">,</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="n">rowBlockDimA</span><span class="p">,</span><span class="n">colBlockDimA</span><span class="p">,</span>
<span class="n">descrC</span><span class="p">,</span><span class="n">bsrValC</span><span class="p">,</span><span class="n">bsrRowPtrC</span><span class="p">,</span><span class="n">bsrColIndC</span><span class="p">,</span>
<span class="n">rowBlockDimC</span><span class="p">,</span><span class="n">colBlockDimC</span><span class="p">,</span>
<span class="n">pBuffer</span><span class="p">);</span>
</pre>
 <ul class="simple">
  <li>
   <p>
    The routines require no extra storage if
    <span class="pre">
     pBuffer
    </span>
    <span class="pre">
     !=
    </span>
    <span class="pre">
     NULL
    </span>
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routines do
    not
    support CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dir
     </span>
    </p>
   </td>
   <td>
    <p>
     storage format of blocks, either
     <span class="pre">
      CUSPARSE_DIRECTION_ROW
     </span>
     or
     <span class="pre">
      CUSPARSE_DIRECTION_COLUMN
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      mb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of block rows of sparse matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of block columns of sparse matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnzb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of nonzero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzb*rowBlockDimA*colBlockDimA
     </span>
     non-zero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      mb+1
     </span>
     elements that contains the start of every block row and the end of the last block row plus one of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzb
     </span>
     column indices of the non-zero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      rowBlockDimA
     </span>
    </p>
   </td>
   <td>
    <p>
     number of rows within a block of
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      colBlockDimA
     </span>
    </p>
   </td>
   <td>
    <p>
     number of columns within a block of
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descrC
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      C
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      rowBlockDimC
     </span>
    </p>
   </td>
   <td>
    <p>
     number of rows within a block of
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      colBlockDimC
     </span>
    </p>
   </td>
   <td>
    <p>
     number of columns within a block of
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      pBufferSize
     </span>
    </p>
   </td>
   <td>
    <p>
     host pointer containing number of bytes of the buffer used in
     <span class="pre">
      gebsr2gebsr()
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     buffer allocated by the user; the size is return by
     <span class="pre">
      gebsr2gebsr_bufferSize()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrValC
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzc*rowBlockDimC*colBlockDimC
     </span>
     non-zero elements of matrix
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrRowPtrC
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      mc+1
     </span>
     elements that contains the start of every block row and the end of the last block row plus one of matrix
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrColIndC
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzc
     </span>
     block column indices of the nonzero blocks of matrix
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzTotalDevHostPtr
     </span>
    </p>
   </td>
   <td>
    <p>
     total number of nonzero blocks of
     <span class="pre">
      C
     </span>
     .
     <span class="pre">
      *nnzTotalDevHostPtr
     </span>
     is the same as
     <span class="pre">
      bsrRowPtrC[mc]-bsrRowPtrC[0]
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   5.9.4.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#gebsr2csr">
   cusparse&lt;t&gt;gebsr2csr()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-gebsr2csr" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSgebsr2csr</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDim</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDgebsr2csr</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDim</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCgebsr2csr</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDim</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZgebsr2csr</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="kt">int</span><span class="n">mb</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nb</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">bsrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDim</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">)</span>
</pre>
 <p>
  This function converts a sparse matrix in general BSR format that is defined by the three arrays
  <span class="pre">
   bsrValA
  </span>
  ,
  <span class="pre">
   bsrRowPtrA
  </span>
  , and
  <span class="pre">
   bsrColIndA
  </span>
  into a sparse matrix in CSR format that is defined by arrays
  <span class="pre">
   csrValC
  </span>
  ,
  <span class="pre">
   csrRowPtrC
  </span>
  , and
  <span class="pre">
   csrColIndC
  </span>
  .
 </p>
 <p>
  Let
  <span class="pre">
   m(=mb*rowBlockDim)
  </span>
  be number of rows of
  <span class="pre">
   A
  </span>
  and
  <span class="pre">
   n(=nb*colBlockDim)
  </span>
  be number of columns of
  <span class="pre">
   A
  </span>
  , then
  <span class="pre">
   A
  </span>
  and
  <span class="pre">
   C
  </span>
  are
  <span class="pre">
   m*n
  </span>
  sparse matrices. The general BSR format of
  <span class="pre">
   A
  </span>
  contains
  <span class="pre">
   nnzb(=bsrRowPtrA[mb]
  </span>
  <span class="pre">
   -
  </span>
  
  <span class="pre">
   bsrRowPtrA[0])
  </span>
  non-zero blocks, whereas sparse matrix
  <span class="pre">
   A
  </span>
  contains
  <span class="pre">
   nnz(=nnzb*rowBlockDim*colBlockDim)
  </span>
  elements. The user must allocate enough space for arrays
  <span class="pre">
   csrRowPtrC
  </span>
  ,
  <span class="pre">
   csrColIndC
  </span>
  , and
  <span class="pre">
   csrValC
  </span>
  . The requirements are as follows:
 </p>
 <p>
  <span class="pre">
   csrRowPtrC
  </span>
  of
  <span class="pre">
   m+1
  </span>
  elements
 </p>
 <p>
  <span class="pre">
   csrValC
  </span>
  of
  <span class="pre">
   nnz
  </span>
  elements
 </p>
 <p>
  <span class="pre">
   csrColIndC
  </span>
  of
  <span class="pre">
   nnz
  </span>
  elements
 </p>
 <p>
  The general procedure is as follows:
 </p>
 <pre><span class="c1">// Given general BSR format (bsrRowPtrA, bsrColIndA, bsrValA) and</span>
<span class="c1">// blocks of BSR format are stored in column-major order.</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="o">=</span><span class="n">CUSPARSE_DIRECTION_COLUMN</span><span class="p">;</span>
<span class="kt">int</span><span class="n">m</span><span class="o">=</span><span class="n">mb</span><span class="o">*</span><span class="n">rowBlockDim</span><span class="p">;</span>
<span class="kt">int</span><span class="n">n</span><span class="o">=</span><span class="n">nb</span><span class="o">*</span><span class="n">colBlockDim</span><span class="p">;</span>
<span class="kt">int</span><span class="n">nnzb</span><span class="o">=</span><span class="n">bsrRowPtrA</span><span class="p">[</span><span class="n">mb</span><span class="p">]</span><span class="o">-</span><span class="n">bsrRowPtrA</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="c1">// number of blocks</span>
<span class="kt">int</span><span class="n">nnz</span><span class="o">=</span><span class="n">nnzb</span><span class="o">*</span><span class="n">rowBlockDim</span><span class="o">*</span><span class="n">colBlockDim</span><span class="p">;</span><span class="c1">// number of elements</span>
<span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">csrRowPtrC</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
<span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">csrColIndC</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">nnz</span><span class="p">);</span>
<span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">csrValC</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="n">nnz</span><span class="p">);</span>
<span class="n">cusparseSgebsr2csr</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span><span class="n">mb</span><span class="p">,</span><span class="n">nb</span><span class="p">,</span>
<span class="n">descrA</span><span class="p">,</span>
<span class="n">bsrValA</span><span class="p">,</span><span class="n">bsrRowPtrA</span><span class="p">,</span><span class="n">bsrColIndA</span><span class="p">,</span>
<span class="n">rowBlockDim</span><span class="p">,</span><span class="n">colBlockDim</span><span class="p">,</span>
<span class="n">descrC</span><span class="p">,</span>
<span class="n">csrValC</span><span class="p">,</span><span class="n">csrRowPtrC</span><span class="p">,</span><span class="n">csrColIndC</span><span class="p">);</span>
</pre>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dir
     </span>
    </p>
   </td>
   <td>
    <p>
     storage format of blocks, either
     <span class="pre">
      CUSPARSE_DIRECTION_ROW
     </span>
     or
     <span class="pre">
      CUSPARSE_DIRECTION_COLUMN
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      mb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of block rows of sparse matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nb
     </span>
    </p>
   </td>
   <td>
    <p>
     number of block columns of sparse matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzb*rowBlockDim*colBlockDim
     </span>
     non-zero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      mb+1
     </span>
     elements that contains the start of every block row and the end of the last block row plus one of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzb
     </span>
     column indices of the non-zero blocks of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      rowBlockDim
     </span>
    </p>
   </td>
   <td>
    <p>
     number of rows within a block of
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      colBlockDim
     </span>
    </p>
   </td>
   <td>
    <p>
     number of columns within a block of
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrC
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      C
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrValC
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnz
     </span>
     non-zero elements of matrix
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowPtrC
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      m+1
     </span>
     elements that contains the start of every row and the end of the last row plus one of matrix
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColIndC
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnz
     </span>
     column indices of the non-zero elements of matrix
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   5.9.5.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#csr2gebsr">
   cusparse&lt;t&gt;csr2gebsr()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-csr2gebsr" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseScsr2gebsr_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSize</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDcsr2gebsr_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSize</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCcsr2gebsr_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSize</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZcsr2gebsr_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">pBufferSize</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseXcsr2gebsrNnz</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzTotalDevHostPtr</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseScsr2gebsr</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">bsrValC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndC</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDim</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDcsr2gebsr</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">bsrValC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndC</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDim</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCcsr2gebsr</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">bsrValC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndC</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDim</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZcsr2gebsr</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">bsrValC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">bsrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">bsrColIndC</span><span class="p">,</span>
<span class="kt">int</span><span class="n">rowBlockDim</span><span class="p">,</span>
<span class="kt">int</span><span class="n">colBlockDim</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function converts a sparse matrix
  <span class="pre">
   A
  </span>
  in CSR format (that is defined by arrays
  <span class="pre">
   csrValA
  </span>
  ,
  <span class="pre">
   csrRowPtrA
  </span>
  , and
  <span class="pre">
   csrColIndA
  </span>
  ) into a sparse matrix
  <span class="pre">
   C
  </span>
  in general BSR format (that is defined by the three arrays
  <span class="pre">
   bsrValC
  </span>
  ,
  <span class="pre">
   bsrRowPtrC
  </span>
  , and
  <span class="pre">
   bsrColIndC
  </span>
  ).
 </p>
 <p>
  The matrix A is a
  <span class="pre">
   m*n
  </span>
  sparse matrix and matrix
  <span class="pre">
   C
  </span>
  is a
  <span class="pre">
   (mb*rowBlockDim)*(nb*colBlockDim)
  </span>
  sparse matrix, where
  <span class="pre">
   mb(=(m+rowBlockDim-1)/rowBlockDim)
  </span>
  is the number of block rows of
  <span class="pre">
   C
  </span>
  , and
  <span class="pre">
   nb(=(n+colBlockDim-1)/colBlockDim)
  </span>
  is the number of block columns of
  <span class="pre">
   C
  </span>
  .
 </p>
 <p>
  The block of
  <span class="pre">
   C
  </span>
  is of size
  <span class="pre">
   rowBlockDim*colBlockDim
  </span>
  . If
  <span class="pre">
   m
  </span>
  is not multiple of
  <span class="pre">
   rowBlockDim
  </span>
  or
  <span class="pre">
   n
  </span>
  is not multiple of
  <span class="pre">
   colBlockDim
  </span>
  , zeros are filled in.
 </p>
 <p>
  The implementation adopts a two-step approach to do the conversion. First, the user allocates
  <span class="pre">
   bsrRowPtrC
  </span>
  of
  <span class="pre">
   mb+1
  </span>
  elements and uses function
  <span class="pre">
   cusparseXcsr2gebsrNnz()
  </span>
  to determine the number of nonzero block columns per block row. Second, the user gathers
  <span class="pre">
   nnzb
  </span>
  (number of nonzero block columns of matrix
  <span class="pre">
   C
  </span>
  ) from either
  <span class="pre">
   (nnzb=*nnzTotalDevHostPtr)
  </span>
  or
  <span class="pre">
   (nnzb=bsrRowPtrC[mb]-bsrRowPtrC[0])
  </span>
  and allocates
  <span class="pre">
   bsrValC
  </span>
  of
  <span class="pre">
   nnzb*rowBlockDim*colBlockDim
  </span>
  elements and
  <span class="pre">
   bsrColIndC
  </span>
  of
  <span class="pre">
   nnzb
  </span>
  integers. Finally function
  <span class="pre">
   cusparse[S|D|C|Z]csr2gebsr()
  </span>
  is called to complete the conversion.
 </p>
 <p>
  The user must obtain the size of the buffer required by
  <span class="pre">
   csr2gebsr()
  </span>
  by calling
  <span class="pre">
   csr2gebsr_bufferSize()
  </span>
  , allocate the buffer, and pass the buffer pointer to
  <span class="pre">
   csr2gebsr()
  </span>
  .
 </p>
 <p>
  The general procedure is as follows:
 </p>
 <pre><span class="c1">// Given CSR format (csrRowPtrA, csrColIndA, csrValA) and</span>
<span class="c1">// blocks of BSR format are stored in column-major order.</span>
<span class="n">cusparseDirection_t</span><span class="n">dir</span><span class="o">=</span><span class="n">CUSPARSE_DIRECTION_COLUMN</span><span class="p">;</span>
<span class="kt">int</span><span class="n">base</span><span class="p">,</span><span class="n">nnzb</span><span class="p">;</span>
<span class="kt">int</span><span class="n">mb</span><span class="o">=</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="n">rowBlockDim</span><span class="mi">-1</span><span class="p">)</span><span class="o">/</span><span class="n">rowBlockDim</span><span class="p">;</span>
<span class="kt">int</span><span class="n">nb</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">colBlockDim</span><span class="mi">-1</span><span class="p">)</span><span class="o">/</span><span class="n">colBlockDim</span><span class="p">;</span>
<span class="kt">int</span><span class="n">bufferSize</span><span class="p">;</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">;</span>
<span class="n">cusparseScsr2gebsr_bufferSize</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">,</span>
<span class="n">descrA</span><span class="p">,</span><span class="n">csrValA</span><span class="p">,</span><span class="n">csrRowPtrA</span><span class="p">,</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">rowBlockDim</span><span class="p">,</span><span class="n">colBlockDim</span><span class="p">,</span>
<span class="o">&amp;</span><span class="n">bufferSize</span><span class="p">);</span>
<span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pBuffer</span><span class="p">,</span><span class="n">bufferSize</span><span class="p">);</span>
<span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">bsrRowPtrC</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">mb</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
<span class="c1">// nnzTotalDevHostPtr points to host memory</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzTotalDevHostPtr</span><span class="o">=</span><span class="o">&amp;</span><span class="n">nnzb</span><span class="p">;</span>
<span class="n">cusparseXcsr2gebsrNnz</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">,</span>
<span class="n">descrA</span><span class="p">,</span><span class="n">csrRowPtrA</span><span class="p">,</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">descrC</span><span class="p">,</span><span class="n">bsrRowPtrC</span><span class="p">,</span><span class="n">rowBlockDim</span><span class="p">,</span><span class="n">colBlockDim</span><span class="p">,</span>
<span class="n">nnzTotalDevHostPtr</span><span class="p">,</span>
<span class="n">pBuffer</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="nb">NULL</span><span class="o">!=</span><span class="n">nnzTotalDevHostPtr</span><span class="p">){</span>
<span class="n">nnzb</span><span class="o">=</span><span class="o">*</span><span class="n">nnzTotalDevHostPtr</span><span class="p">;</span>
<span class="p">}</span><span class="k">else</span><span class="p">{</span>
<span class="n">cudaMemcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nnzb</span><span class="p">,</span><span class="n">bsrRowPtrC</span><span class="o">+</span><span class="n">mb</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span><span class="n">cudaMemcpyDeviceToHost</span><span class="p">);</span>
<span class="n">cudaMemcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="p">,</span><span class="n">bsrRowPtrC</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span><span class="n">cudaMemcpyDeviceToHost</span><span class="p">);</span>
<span class="n">nnzb</span><span class="o">-=</span><span class="n">base</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">bsrColIndC</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">nnzb</span><span class="p">);</span>
<span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">bsrValC</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">rowBlockDim</span><span class="o">*</span><span class="n">colBlockDim</span><span class="p">)</span><span class="o">*</span><span class="n">nnzb</span><span class="p">);</span>
<span class="n">cusparseScsr2gebsr</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">,</span>
<span class="n">descrA</span><span class="p">,</span>
<span class="n">csrValA</span><span class="p">,</span><span class="n">csrRowPtrA</span><span class="p">,</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="n">descrC</span><span class="p">,</span>
<span class="n">bsrValC</span><span class="p">,</span><span class="n">bsrRowPtrC</span><span class="p">,</span><span class="n">bsrColIndC</span><span class="p">,</span>
<span class="n">rowBlockDim</span><span class="p">,</span><span class="n">colBlockDim</span><span class="p">,</span>
<span class="n">pBuffer</span><span class="p">);</span>
</pre>
 <p>
  The routine
  <span class="pre">
   cusparseXcsr2gebsrNnz()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available
   </p>
  </li>
 </ul>
 <p>
  The routine
  <span class="pre">
   cusparse&lt;t&gt;csr2gebsr()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage if
    <span class="pre">
     pBuffer
    </span>
    <span class="pre">
     !=
    </span>
    <span class="pre">
     NULL
    </span>
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dir
     </span>
    </p>
   </td>
   <td>
    <p>
     storage format of blocks, either
     <span class="pre">
      CUSPARSE_DIRECTION_ROW
     </span>
     or
     <span class="pre">
      CUSPARSE_DIRECTION_COLUMN
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     number of rows of sparse matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     number of columns of sparse matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnz
     </span>
     nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      m+1
     </span>
     elements that contains the start of every row and the end of the last row plus one of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnz
     </span>
     column indices of the nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrC
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      C
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      rowBlockDim
     </span>
    </p>
   </td>
   <td>
    <p>
     number of rows within a block of
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      colBlockDim
     </span>
    </p>
   </td>
   <td>
    <p>
     number of columns within a block of
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     buffer allocated by the user, the size is return by
     <span class="pre">
      csr2gebsr_bufferSize()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrValC
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzb*rowBlockDim*colBlockDim
     </span>
     nonzero elements of matrix
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrRowPtrC
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      mb+1
     </span>
     elements that contains the start of every block row and the end of the last block row plus one of matrix
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrColIndC
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzb
     </span>
     column indices of the nonzero blocks of matrix
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzTotalDevHostPtr
     </span>
    </p>
   </td>
   <td>
    <p>
     total number of nonzero blocks of matrix
     <span class="pre">
      C
     </span>
     . Pointer
     <span class="pre">
      nnzTotalDevHostPtr
     </span>
     can point to a device memory or host memory.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   5.9.6.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#coo2csr">
   cusparse&lt;t&gt;coo2csr()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-coo2csr" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseXcoo2csr</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">cooRowInd</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtr</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="n">idxBase</span><span class="p">)</span>
</pre>
 <p>
  This function converts the array containing the uncompressed row indices (corresponding to COO format) into an array of compressed row pointers (corresponding to CSR format).
 </p>
 <p>
  It can also be used to convert the array containing the uncompressed column indices (corresponding to COO format) into an array of column pointers (corresponding to CSC format).
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cooRowInd
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnz
     </span>
     uncompressed row indices.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     number of non-zeros of the sparse matrix (that is also the length of array
     <span class="pre">
      cooRowInd
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     number of rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      idxBase
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     or
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrRowPtr
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      m+1
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   5.9.7.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#csr2coo">
   cusparse&lt;t&gt;csr2coo()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-csr2coo" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseXcsr2coo</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtr</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">cooRowInd</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="n">idxBase</span><span class="p">)</span>
</pre>
 <p>
  This function converts the array containing the compressed row pointers (corresponding to CSR format) into an array of uncompressed row indices (corresponding to COO format).
 </p>
 <p>
  It can also be used to convert the array containing the compressed column indices (corresponding to CSC format) into an array of uncompressed column indices (corresponding to COO format).
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowPtr
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      m+1
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     number of nonzeros of the sparse matrix (that is also the length of array
     <span class="pre">
      cooRowInd
     </span>
     ).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     number of rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      idxBase
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     or
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cooRowInd
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnz
     </span>
     uncompressed row indices.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   5.9.8.
  </span>
  cusparseCsr2cscEx2()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecsr2cscex2" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseCsr2cscEx2_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">csrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColInd</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">cscVal</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">cscColPtr</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">cscRowInd</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">valType</span><span class="p">,</span>
<span class="n">cusparseAction_t</span><span class="n">copyValues</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="n">idxBase</span><span class="p">,</span>
<span class="n">cusparseCsr2CscAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSize</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseCsr2cscEx2</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">csrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColInd</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">cscVal</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">cscColPtr</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">cscRowInd</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">valType</span><span class="p">,</span>
<span class="n">cusparseAction_t</span><span class="n">copyValues</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="n">idxBase</span><span class="p">,</span>
<span class="n">cusparseCsr2CscAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
</pre>
 <p>
  This function converts a sparse matrix in CSR format (that is defined by the three arrays
  <span class="pre">
   csrVal
  </span>
  ,
  <span class="pre">
   csrRowPtr
  </span>
  , and
  <span class="pre">
   csrColInd
  </span>
  ) into a sparse matrix in CSC format (that is defined by arrays
  <span class="pre">
   cscVal
  </span>
  ,
  <span class="pre">
   cscRowInd
  </span>
  , and
  <span class="pre">
   cscColPtr
  </span>
  ). The resulting matrix can also be seen as the transpose of the original sparse matrix. Notice that this routine can also be used to convert a matrix in CSC format into a matrix in CSR format.
 </p>
 <p>
  The routine requires extra storage proportional to the number of nonzero values
  <span class="pre">
   nnz
  </span>
  . It provides in output always the same matrix.
 </p>
 <p>
  It is executed asynchronously with respect to the host, and it may return control to the application on the host before the result is ready.
 </p>
 <p>
  The function
  <span class="pre">
   cusparseCsr2cscEx2_bufferSize()
  </span>
  returns the size of the workspace needed by
  <span class="pre">
   cusparseCsr2cscEx2()
  </span>
  . User needs to allocate a buffer of this size and give that buffer to
  <span class="pre">
   cusparseCsr2cscEx2()
  </span>
  as an argument.
 </p>
 <p>
  If
  <span class="pre">
   nnz
  </span>
  <span class="pre">
   ==
  </span>
  <span class="pre">
   0
  </span>
  , then
  <span class="pre">
   csrColInd
  </span>
  ,
  <span class="pre">
   csrVal
  </span>
  ,
  <span class="pre">
   cscVal
  </span>
  , and
  <span class="pre">
   cscRowInd
  </span>
  could have
  <span class="pre">
   NULL
  </span>
  value. In this case,
  <span class="pre">
   cscColPtr
  </span>
  is set to
  <span class="pre">
   idxBase
  </span>
  for all values.
 </p>
 <p>
  If
  <span class="pre">
   m
  </span>
  <span class="pre">
   ==
  </span>
  <span class="pre">
   0
  </span>
  or
  <span class="pre">
   n
  </span>
  <span class="pre">
   ==
  </span>
  <span class="pre">
   0
  </span>
  , the pointers are not checked and the routine returns
  <span class="pre">
   CUSPARSE_STATUS_SUCCESS
  </span>
  .
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSPARSE library context
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of rows of the CSR input matrix; number of columns of the CSC ouput matrix
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of columns of the CSR input matrix; number of rows of the CSC ouput matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of nonzero elements of the CSR and CSC matrices
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrVal
     </span>
    </p>
   </td>
   <td>
    <p>
     Value array of size
     <span class="pre">
      nnz
     </span>
     of the CSR matrix; of same type as
     <span class="pre">
      valType
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowPtr
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of size
     <span class="pre">
      m
     </span>
     <span class="pre">
      +
     </span>
     <span class="pre">
      1
     </span>
     that containes the CSR row offsets
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColInd
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of size
     <span class="pre">
      nnz
     </span>
     that containes the CSR column indices
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cscVal
     </span>
    </p>
   </td>
   <td>
    <p>
     Value array of size
     <span class="pre">
      nnz
     </span>
     of the CSC matrix; of same type as
     <span class="pre">
      valType
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cscColPtr
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of size
     <span class="pre">
      n
     </span>
     <span class="pre">
      +
     </span>
     <span class="pre">
      1
     </span>
     that containes the CSC column offsets
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cscRowInd
     </span>
    </p>
   </td>
   <td>
    <p>
     Integer array of size
     <span class="pre">
      nnz
     </span>
     that containes the CSC row indices
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      valType
     </span>
    </p>
   </td>
   <td>
    <p>
     Value type for both CSR and CSC matrices
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      copyValues
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUSPARSE_ACTION_SYMBOLIC
     </span>
     or
     <span class="pre">
      CUSPARSE_ACTION_NUMERIC
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      idxBase
     </span>
    </p>
   </td>
   <td>
    <p>
     Index base
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     or
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      alg
     </span>
    </p>
   </td>
   <td>
    <p>
     Algorithm implementation. see
     <span class="pre">
      cusparseCsr2CscAlg_t
     </span>
     for possible values.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bufferSize
     </span>
    </p>
   </td>
   <td>
    <p>
     Number of bytes of workspace needed by
     <span class="pre">
      cusparseCsr2cscEx2()
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      buffer
     </span>
    </p>
   </td>
   <td>
    <p>
     Pointer to workspace buffer
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseCsr2cscEx2()
  </span>
  supports the following data types:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      X
     </span>
     /
     <span class="pre">
      Y
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_8I
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16BF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_16F
     </span>
     [DEPRECATED]
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_16BF
     </span>
     [DEPRECATED]
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseCsr2cscEx2()
  </span>
  supports the following algorithms (
  <span class="pre">
   cusparseCsr2CscAlg_t
  </span>
  ):
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Algorithm
    </p>
   </th>
   <th class="head">
    <p>
     Notes
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_CSR2CSC_ALG_DEFAULT
     </span>
     ,
     <span class="pre">
      CUSPARSE_CSR2CSC_ALG1
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm
    </p>
   </td>
  </tr>
 </table>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Action
    </p>
   </th>
   <th class="head">
    <p>
     Notes
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_ACTION_SYMBOLIC
     </span>
    </p>
   </td>
   <td>
    <p>
     Compute the structure of the CSC output matrix (offset, row indices)
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_ACTION_NUMERIC
     </span>
    </p>
   </td>
   <td>
    <p>
     Compute the structure of the CSC output matrix and copy the values
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseCsr2cscEx2()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseCsr2cscEx2()
  </span>
  supports the following
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#optimization-notes">
   optimizations
  </a>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    CUDA graph capture
   </p>
  </li>
  <li>
   <p>
    Hardware Memory Compression
   </p>
  </li>
 </ul>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   5.9.9.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#nnz">
   cusparse&lt;t&gt;nnz()
  </a>
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-nnz" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSnnz</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzPerRowColumn</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzTotalDevHostPtr</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDnnz</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzPerRowColumn</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzTotalDevHostPtr</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCnnz</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzPerRowColumn</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzTotalDevHostPtr</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZnnz</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseDirection_t</span><span class="n">dirA</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzPerRowColumn</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzTotalDevHostPtr</span><span class="p">)</span>
</pre>
 <p>
  This function computes the number of nonzero elements per row or column and the total number of nonzero elements in a dense matrix.
 </p>
 <ul class="simple">
  <li>
   <p>
    This function requires temporary extra storage that is allocated internally
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dirA
     </span>
    </p>
   </td>
   <td>
    <p>
     direction that specifies whether to count nonzero elements by
     <span class="pre">
      CUSPARSE_DIRECTION_ROW
     </span>
     or by
     <span class="pre">
      CUSPARSE_DIRECTION_COLUMN
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     number of rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     number of columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     array of dimensions
     <span class="pre">
      (lda,
     </span>
     <span class="pre">
      n)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     leading dimension of dense array
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnzPerRowColumn
     </span>
    </p>
   </td>
   <td>
    <p>
     array of size
     <span class="pre">
      m
     </span>
     or
     <span class="pre">
      n
     </span>
     containing the number of nonzero elements per row or column, respectively.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzTotalDevHostPtr
     </span>
    </p>
   </td>
   <td>
    <p>
     total number of nonzero elements in device or host memory.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   5.9.10.
  </span>
  cusparseCreateIdentityPermutation() [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreateidentitypermutation-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="nf">cusparseCreateIdentityPermutation</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
</pre>
 <p>
  This function creates an identity map. The output parameter
  <span class="pre">
   p
  </span>
  represents such map by
  <span class="pre">
   p
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   0:1:(n-1)
  </span>
  .
 </p>
 <p>
  This function is typically used with
  <span class="pre">
   coosort
  </span>
  ,
  <span class="pre">
   csrsort
  </span>
  ,
  <span class="pre">
   cscsort
  </span>
  .
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      parameter
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
     <span class="pre">
      or
     </span>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      description
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     size of the map.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      parameter
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
     <span class="pre">
      or
     </span>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      description
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      p
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of dimensions
     <span class="pre">
      n
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   5.9.11.
  </span>
  cusparseXcoosort()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsexcoosort" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseXcoosort_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">cooRows</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">cooCols</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="nf">cusparseXcoosortByRow</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">cooRows</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">cooCols</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">P</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseXcoosortByColumn</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">cooRows</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">cooCols</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">P</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">);</span>
</pre>
 <p>
  This function sorts COO format. The sorting is in-place. Also the user can sort by row or sort by column.
 </p>
 <p>
  <span class="pre">
   A
  </span>
  is an
  <span class="pre">
   mn
  </span>
  sparse matrix that is defined in COO storage format by the three arrays
  <span class="pre">
   cooVals
  </span>
  ,
  <span class="pre">
   cooRows
  </span>
  , and
  <span class="pre">
   cooCols
  </span>
  .
 </p>
 <p>
  There is no assumption for the base index of the matrix.
  <span class="pre">
   coosort
  </span>
  uses stable sort on signed integer, so the value of
  <span class="pre">
   cooRows
  </span>
  or
  <span class="pre">
   cooCols
  </span>
  can be negative.
 </p>
 <p>
  This function
  <span class="pre">
   coosort()
  </span>
  requires buffer size returned by
  <span class="pre">
   coosort_bufferSizeExt()
  </span>
  . The address of
  <span class="pre">
   pBuffer
  </span>
  must be multiple of 128 bytes. If not,
  <span class="pre">
   CUSPARSE_STATUS_INVALID_VALUE
  </span>
  is returned.
 </p>
 <p>
  The parameter
  <span class="pre">
   P
  </span>
  is both input and output. If the user wants to compute sorted
  <span class="pre">
   cooVal
  </span>
  ,
  <span class="pre">
   P
  </span>
  must be set as 0:1:(nnz-1) before
  <span class="pre">
   coosort()
  </span>
  , and after
  <span class="pre">
   coosort()
  </span>
  , new sorted value array satisfies
  <span class="pre">
   cooVal_sorted
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   cooVal(P)
  </span>
  .
 </p>
 <p>
  Remark: the dimension
  <span class="pre">
   m
  </span>
  and
  <span class="pre">
   n
  </span>
  are not used. If the user does not know the value of
  <span class="pre">
   m
  </span>
  or
  <span class="pre">
   n
  </span>
  , just passes a value positive. This usually happens if the user only reads a COO array first and needs to decide the dimension
  <span class="pre">
   m
  </span>
  or
  <span class="pre">
   n
  </span>
  later.
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage if
    <span class="pre">
     pBuffer
    </span>
    <span class="pre">
     !=
    </span>
    <span class="pre">
     NULL
    </span>
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      parameter
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
     <span class="pre">
      or
     </span>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      description
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cooRows
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnz
     </span>
     unsorted row indices of
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cooCols
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnz
     </span>
     unsorted column indices of
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      P
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnz
     </span>
     unsorted map indices. To construct
     <span class="pre">
      cooVal
     </span>
     , the user has to set
     <span class="pre">
      P=0:1:(nnz-1)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     buffer allocated by the user; the size is returned by
     <span class="pre">
      coosort_bufferSizeExt()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      parameter
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
     <span class="pre">
      or
     </span>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      description
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cooRows
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnz
     </span>
     sorted row indices of
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cooCols
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnz
     </span>
     sorted column indices of
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      P
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnz
     </span>
     sorted map indices.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      pBufferSizeInBytes
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of bytes of the buffer.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSPARSE/coosort">
   cuSPARSE Library Samples - cusparseXcoosortByRow
  </a>
  for a code example.
 </p>
 <h3>
  <span class="section-number">
   5.9.12.
  </span>
  cusparseXcsrsort()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsexcsrsort" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseXcsrsort_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColInd</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseXcsrsort</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtr</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColInd</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">P</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function sorts CSR format. The stable sorting is in-place.
 </p>
 <p>
  The matrix type is regarded as
  <span class="pre">
   CUSPARSE_MATRIX_TYPE_GENERAL
  </span>
  implicitly. In other words, any symmetric property is ignored.
 </p>
 <p>
  This function
  <span class="pre">
   csrsort()
  </span>
  requires buffer size returned by
  <span class="pre">
   csrsort_bufferSizeExt()
  </span>
  . The address of
  <span class="pre">
   pBuffer
  </span>
  must be multiple of 128 bytes. If not,
  <span class="pre">
   CUSPARSE_STATUS_INVALID_VALUE
  </span>
  is returned.
 </p>
 <p>
  The parameter
  <span class="pre">
   P
  </span>
  is both input and output. If the user wants to compute sorted
  <span class="pre">
   csrVal
  </span>
  ,
  <span class="pre">
   P
  </span>
  must be set as 0:1:(nnz-1) before
  <span class="pre">
   csrsort()
  </span>
  , and after
  <span class="pre">
   csrsort()
  </span>
  , new sorted value array satisfies
  <span class="pre">
   csrVal_sorted
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   csrVal(P)
  </span>
  .
 </p>
 <p>
  The general procedure is as follows:
 </p>
 <pre><span class="c1">// A is a 3x3 sparse matrix, base-0</span>
<span class="c1">//     | 1 2 3 |</span>
<span class="c1">// A = | 4 5 6 |</span>
<span class="c1">//     | 7 8 9 |</span>
<span class="k">const</span><span class="kt">int</span><span class="n">m</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span>
<span class="k">const</span><span class="kt">int</span><span class="n">n</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span>
<span class="k">const</span><span class="kt">int</span><span class="n">nnz</span><span class="o">=</span><span class="mi">9</span><span class="p">;</span>
<span class="n">csrRowPtr</span><span class="p">[</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span><span class="c1">// on device</span>
<span class="n">csrColInd</span><span class="p">[</span><span class="n">nnz</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span><span class="c1">// on device</span>
<span class="n">csrVal</span><span class="p">[</span><span class="n">nnz</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">7</span><span class="p">};</span><span class="c1">// on device</span>
<span class="kt">size_t</span><span class="n">pBufferSizeInBytes</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span><span class="n">P</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>

<span class="c1">// step 1: allocate buffer</span>
<span class="n">cusparseXcsrsort_bufferSizeExt</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">nnz</span><span class="p">,</span><span class="n">csrRowPtr</span><span class="p">,</span><span class="n">csrColInd</span><span class="p">,</span><span class="o">&amp;</span><span class="n">pBufferSizeInBytes</span><span class="p">);</span>
<span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pBuffer</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">);</span>

<span class="c1">// step 2: setup permutation vector P to identity</span>
<span class="n">cudaMalloc</span><span class="p">(</span><span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">P</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">nnz</span><span class="p">);</span>
<span class="n">cusparseCreateIdentityPermutation</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">nnz</span><span class="p">,</span><span class="n">P</span><span class="p">);</span>

<span class="c1">// step 3: sort CSR format</span>
<span class="n">cusparseXcsrsort</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">nnz</span><span class="p">,</span><span class="n">descrA</span><span class="p">,</span><span class="n">csrRowPtr</span><span class="p">,</span><span class="n">csrColInd</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">pBuffer</span><span class="p">);</span>

<span class="c1">// step 4: gather sorted csrVal</span>
<span class="n">cusparseDgthr</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">nnz</span><span class="p">,</span><span class="n">csrVal</span><span class="p">,</span><span class="n">csrVal_sorted</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">CUSPARSE_INDEX_BASE_ZERO</span><span class="p">);</span>
</pre>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage if
    <span class="pre">
     pBuffer
    </span>
    <span class="pre">
     !=
    </span>
    <span class="pre">
     NULL
    </span>
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      parameter
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
     <span class="pre">
      or
     </span>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      description
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowsPtr
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      m+1
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColInd
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnz
     </span>
     unsorted column indices of
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      P
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnz
     </span>
     unsorted map indices. To construct
     <span class="pre">
      csrVal
     </span>
     , the user has to set
     <span class="pre">
      P=0:1:(nnz-1)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     buffer allocated by the user; the size is returned by
     <span class="pre">
      csrsort_bufferSizeExt()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      parameter
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
     <span class="pre">
      or
     </span>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      description
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrColInd
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnz
     </span>
     sorted column indices of
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      P
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnz
     </span>
     sorted map indices.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBufferSizeInBytes
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of bytes of the buffer.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   5.9.13.
  </span>
  cusparseXcscsort()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsexcscsort" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseXcscsort_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">cscColPtr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">cscRowInd</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseXcscsort</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">cscColPtr</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">cscRowInd</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">P</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function sorts CSC format. The stable sorting is in-place.
 </p>
 <p>
  The matrix type is regarded as
  <span class="pre">
   CUSPARSE_MATRIX_TYPE_GENERAL
  </span>
  implicitly. In other words, any symmetric property is ignored.
 </p>
 <p>
  This function
  <span class="pre">
   cscsort()
  </span>
  requires buffer size returned by
  <span class="pre">
   cscsort_bufferSizeExt()
  </span>
  . The address of
  <span class="pre">
   pBuffer
  </span>
  must be multiple of 128 bytes. If not,
  <span class="pre">
   CUSPARSE_STATUS_INVALID_VALUE
  </span>
  is returned.
 </p>
 <p>
  The parameter
  <span class="pre">
   P
  </span>
  is both input and output. If the user wants to compute sorted
  <span class="pre">
   cscVal
  </span>
  ,
  <span class="pre">
   P
  </span>
  must be set as 0:1:(nnz-1) before
  <span class="pre">
   cscsort()
  </span>
  , and after
  <span class="pre">
   cscsort()
  </span>
  , new sorted value array satisfies
  <span class="pre">
   cscVal_sorted
  </span>
  <span class="pre">
   =
  </span>
  <span class="pre">
   cscVal(P)
  </span>
  .
 </p>
 <p>
  The general procedure is as follows:
 </p>
 <pre><span class="c1">// A is a 3x3 sparse matrix, base-0</span>
<span class="c1">//     | 1 2  |</span>
<span class="c1">// A = | 4 0  |</span>
<span class="c1">//     | 0 8  |</span>
<span class="k">const</span><span class="kt">int</span><span class="n">m</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span>
<span class="k">const</span><span class="kt">int</span><span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span>
<span class="k">const</span><span class="kt">int</span><span class="n">nnz</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span>
<span class="n">cscColPtr</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span><span class="c1">// on device</span>
<span class="n">cscRowInd</span><span class="p">[</span><span class="n">nnz</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span><span class="c1">// on device</span>
<span class="n">cscVal</span><span class="p">[</span><span class="n">nnz</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mf">4.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">8.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">};</span><span class="c1">// on device</span>
<span class="kt">size_t</span><span class="n">pBufferSizeInBytes</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span><span class="n">P</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>

<span class="c1">// step 1: allocate buffer</span>
<span class="n">cusparseXcscsort_bufferSizeExt</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">nnz</span><span class="p">,</span><span class="n">cscColPtr</span><span class="p">,</span><span class="n">cscRowInd</span><span class="p">,</span><span class="o">&amp;</span><span class="n">pBufferSizeInBytes</span><span class="p">);</span>
<span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pBuffer</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">);</span>

<span class="c1">// step 2: setup permutation vector P to identity</span>
<span class="n">cudaMalloc</span><span class="p">(</span><span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">P</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">nnz</span><span class="p">);</span>
<span class="n">cusparseCreateIdentityPermutation</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">nnz</span><span class="p">,</span><span class="n">P</span><span class="p">);</span>

<span class="c1">// step 3: sort CSC format</span>
<span class="n">cusparseXcscsort</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">nnz</span><span class="p">,</span><span class="n">descrA</span><span class="p">,</span><span class="n">cscColPtr</span><span class="p">,</span><span class="n">cscRowInd</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">pBuffer</span><span class="p">);</span>

<span class="c1">// step 4: gather sorted cscVal</span>
<span class="n">cusparseDgthr</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">nnz</span><span class="p">,</span><span class="n">cscVal</span><span class="p">,</span><span class="n">cscVal_sorted</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">CUSPARSE_INDEX_BASE_ZERO</span><span class="p">);</span>
</pre>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage if
    <span class="pre">
     pBuffer
    </span>
    <span class="pre">
     !=
    </span>
    <span class="pre">
     NULL
    </span>
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      parameter
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
     <span class="pre">
      or
     </span>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      description
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cscColPtr
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      n+1
     </span>
     elements that contains the start of every column and the end of the last column plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cscRowInd
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnz
     </span>
     unsorted row indices of
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      P
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnz
     </span>
     unsorted map indices. To construct
     <span class="pre">
      cscVal
     </span>
     , the user has to set
     <span class="pre">
      P=0:1:(nnz-1)
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     buffer allocated by the user; the size is returned by
     <span class="pre">
      cscsort_bufferSizeExt()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      parameter
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
     <span class="pre">
      or
     </span>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      description
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cscRowInd
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnz
     </span>
     sorted row indices of
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      P
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnz
     </span>
     sorted map indices.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBufferSizeInBytes
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of bytes of the buffer.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   5.9.14.
  </span>
  cusparseXcsru2csr() [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsexcsru2csr-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="nf">cusparseCreateCsru2csrInfo</span><span class="p">(</span><span class="n">csru2csrInfo_t</span><span class="o">*</span><span class="n">info</span><span class="p">);</span>

<span class="n">cusparseStatus_t</span>
<span class="nf">cusparseDestroyCsru2csrInfo</span><span class="p">(</span><span class="n">csru2csrInfo_t</span><span class="n">info</span><span class="p">);</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseScsru2csr_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">csrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtr</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColInd</span><span class="p">,</span>
<span class="n">csru2csrInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDcsru2csr_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">csrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtr</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColInd</span><span class="p">,</span>
<span class="n">csru2csrInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCcsru2csr_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">csrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtr</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColInd</span><span class="p">,</span>
<span class="n">csru2csrInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZcsru2csr_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtr</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColInd</span><span class="p">,</span>
<span class="n">csru2csrInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseScsru2csr</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">csrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtr</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColInd</span><span class="p">,</span>
<span class="n">csru2csrInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDcsru2csr</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">csrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtr</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColInd</span><span class="p">,</span>
<span class="n">csru2csrInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCcsru2csr</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">csrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtr</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColInd</span><span class="p">,</span>
<span class="n">csru2csrInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZcsru2csr</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtr</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColInd</span><span class="p">,</span>
<span class="n">csru2csrInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseScsr2csru</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">csrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtr</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColInd</span><span class="p">,</span>
<span class="n">csru2csrInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDcsr2csru</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">csrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtr</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColInd</span><span class="p">,</span>
<span class="n">csru2csrInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCcsr2csru</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="o">*</span><span class="n">csrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtr</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColInd</span><span class="p">,</span>
<span class="n">csru2csrInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZcsr2csru</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrVal</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtr</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColInd</span><span class="p">,</span>
<span class="n">csru2csrInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function transfers unsorted CSR format to CSR format, and vice versa. The operation is in-place.
 </p>
 <p>
  This function is a wrapper of
  <span class="pre">
   csrsort
  </span>
  and
  <span class="pre">
   gthr
  </span>
  . The usecase is the following scenario.
 </p>
 <p>
  If the user has a matrix
  <span class="pre">
   A
  </span>
  of CSR format which is unsorted, and implements his own code (which can be CPU or GPU kernel) based on this special order (for example, diagonal first, then lower triangle, then upper triangle), and wants to convert it to CSR format when calling CUSPARSE library, and then convert it back when doing something else on his/her kernel. For example, suppose the user wants to solve a linear system
  <span class="pre">
   Ax=b
  </span>
  by the following iterative scheme
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(x^{(k+1)} = x^{(k)} + L^{(-1)}*(b - Ax^{(k)})\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The code heavily uses SpMV and triangular solve. Assume that the user has an in-house design of SpMV (Sparse Matrix-Vector multiplication) based on special order of
  <span class="pre">
   A
  </span>
  . However the user wants to use the cuSPARSE library for triangular solver. Then the following code can work.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     do   step 1: compute residual vector r = b - A x (k) by in-house SpMV   step 2: B := sort(A), and L is lower triangular part of B   (only sort A once and keep the permutation vector)   step 3: solve z = L (-1) * ( b - A x (k) ) by cusparseXcsrsv   step 4: add correction x (k+1) = x (k) + z   step 5: A := unsort(B)   (use permutation vector to get back the unsorted CSR) until convergence
    </p>
   </td>
  </tr>
 </table>
 <p>
  The requirements of step 2 and step 5 are
 </p>
 <ol class="arabic simple">
  <li>
   <p>
    In-place operation.
   </p>
  </li>
  <li>
   <p>
    The permutation vector
    <span class="pre">
     P
    </span>
    is hidden in an opaque structure.
   </p>
  </li>
  <li>
   <p>
    No
    <span class="pre">
     cudaMalloc
    </span>
    inside the conversion routine. Instead, the user has to provide the buffer explicitly.
   </p>
  </li>
  <li>
   <p>
    The conversion between unsorted CSR and sorted CSR may needs several times, but the function only generates the permutation vector
    <span class="pre">
     P
    </span>
    once.
   </p>
  </li>
  <li>
   <p>
    The function is based on
    <span class="pre">
     csrsort
    </span>
    ,
    <span class="pre">
     gather
    </span>
    and
    <span class="pre">
     scatter
    </span>
    operations.
   </p>
  </li>
 </ol>
 <p>
  The operation is called
  <span class="pre">
   csru2csr
  </span>
  , which means unsorted CSR to sorted CSR. Also we provide the inverse operation, called
  <span class="pre">
   csr2csru
  </span>
  .
 </p>
 <p>
  In order to keep the permutation vector invisible, we need an opaque structure called
  <span class="pre">
   csru2csrInfo
  </span>
  . Then two functions (
  <span class="pre">
   cusparseCreateCsru2csrInfo
  </span>
  ,
  <span class="pre">
   cusparseDestroyCsru2csrInfo
  </span>
  ) are used to initialize and to destroy the opaque structure.
 </p>
 <p>
  <span class="pre">
   cusparse[S|D|C|Z]csru2csr_bufferSizeExt
  </span>
  returns the size of the buffer. The permutation vector
  <span class="pre">
   P
  </span>
  is also allcated inside
  <span class="pre">
   csru2csrInfo
  </span>
  . The lifetime of the permutation vector is the same as the lifetime of
  <span class="pre">
   csru2csrInfo
  </span>
  .
 </p>
 <p>
  <span class="pre">
   cusparse[S|D|C|Z]csru2csr
  </span>
  performs forward transformation from unsorted CSR to sorted CSR. First call uses csrsort to generate the permutation vector
  <span class="pre">
   P
  </span>
  , and subsequent call uses
  <span class="pre">
   P
  </span>
  to do transformation.
 </p>
 <p>
  <span class="pre">
   cusparse[S|D|C|Z]csr2csru
  </span>
  performs backward transformation from sorted CSR to unsorted CSR.
  <span class="pre">
   P
  </span>
  is used to get unsorted form back.
 </p>
 <p>
  The routine
  <span class="pre">
   cusparse&lt;t&gt;csru2csr()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage if
    <span class="pre">
     pBuffer
    </span>
    <span class="pre">
     !=
    </span>
    <span class="pre">
     NULL
    </span>
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available
   </p>
  </li>
 </ul>
 <p>
  The routine
  <span class="pre">
   cusparse&lt;t&gt;csr2csru()
  </span>
  has the following properties if
  <span class="pre">
   pBuffer
  </span>
  <span class="pre">
   !=
  </span>
  <span class="pre">
   NULL
  </span>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  The following tables describe parameters of
  <span class="pre">
   csr2csru_bufferSizeExt
  </span>
  and
  <span class="pre">
   csr2csru
  </span>
  .
 </p>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      parameter
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
     <span class="pre">
      or
     </span>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      description
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     , Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrVal
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of nnz unsorted nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowsPtr
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      m+1
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColInd
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnz
     </span>
     unsorted column indices of
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      info
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     opaque structure initialized using
     <span class="pre">
      cusparseCreateCsru2csrInfo()
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     buffer allocated by the user; the size is returned by
     <span class="pre">
      csru2csr_bufferSizeExt()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      parameter
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
     <span class="pre">
      or
     </span>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      description
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrVal
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of nnz sorted nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColInd
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnz
     </span>
     sorted column indices of
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBufferSizeInBytes
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of bytes of the buffer.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   5.9.15.
  </span>
  cusparseXpruneDense2csr() [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsexprunedense2csr-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseHpruneDense2csr_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">__half</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="n">__half</span><span class="o">*</span><span class="n">threshold</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="k">const</span><span class="n">__half</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpruneDense2csr_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">threshold</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDpruneDense2csr_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">threshold</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseHpruneDense2csrNnz</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">__half</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="n">__half</span><span class="o">*</span><span class="n">threshold</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzTotalDevHostPtr</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpruneDense2csrNnz</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">threshold</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzTotalDevHostPtr</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDpruneDense2csrNnz</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">threshold</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzTotalDevHostPtr</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseHpruneDense2csr</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">__half</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="n">__half</span><span class="o">*</span><span class="n">threshold</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="n">__half</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpruneDense2csr</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">threshold</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDpruneDense2csr</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">threshold</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function prunes a dense matrix to a sparse matrix with CSR format.
 </p>
 <p>
  Given a dense matrix
  <span class="pre">
   A
  </span>
  and a non-negative value
  <span class="pre">
   threshold
  </span>
  , the function returns a sparse matrix
  <span class="pre">
   C
  </span>
  , defined by
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\begin{matrix}
{{C(i,j)} = {A(i,j)}} &amp; \text{if\ |A(i,j)|\ &gt;\ threshold} \\
\end{matrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The implementation adopts a two-step approach to do the conversion. First, the user allocates
  <span class="pre">
   csrRowPtrC
  </span>
  of
  <span class="pre">
   m+1
  </span>
  elements and uses function
  <span class="pre">
   pruneDense2csrNnz()
  </span>
  to determine the number of nonzeros columns per row. Second, the user gathers
  <span class="pre">
   nnzC
  </span>
  (number of nonzeros of matrix
  <span class="pre">
   C
  </span>
  ) from either
  <span class="pre">
   (nnzC=*nnzTotalDevHostPtr)
  </span>
  or
  <span class="pre">
   (nnzC=csrRowPtrC[m]-csrRowPtrC[0])
  </span>
  and allocates
  <span class="pre">
   csrValC
  </span>
  of
  <span class="pre">
   nnzC
  </span>
  elements and
  <span class="pre">
   csrColIndC
  </span>
  of
  <span class="pre">
   nnzC
  </span>
  integers. Finally function
  <span class="pre">
   pruneDense2csr()
  </span>
  is called to complete the conversion.
 </p>
 <p>
  The user must obtain the size of the buffer required by
  <span class="pre">
   pruneDense2csr()
  </span>
  by calling
  <span class="pre">
   pruneDense2csr_bufferSizeExt()
  </span>
  , allocate the buffer, and pass the buffer pointer to
  <span class="pre">
   pruneDense2csr()
  </span>
  .
 </p>
 <p>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#examples-of-prune">
   Examples of prune
  </a>
  chapter provides a simple example of
  <span class="pre">
   pruneDense2csr()
  </span>
  .
 </p>
 <p>
  The routine
  <span class="pre">
   cusparse&lt;t&gt;pruneDense2csrNnz()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    This function requires temporary extra storage that is allocated internally
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available
   </p>
  </li>
 </ul>
 <p>
  The routine
  <span class="pre">
   cusparse&lt;t&gt;DpruneDense2csr()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      parameter
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
     <span class="pre">
      or
     </span>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      description
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     array of dimension (lda, n).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     leading dimension of
     <span class="pre">
      A
     </span>
     . It must be at least max(1, m).
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      threshold
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
     <span class="pre">
      or
     </span>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     a value to drop the entries of A.
     <span class="pre">
      threshold
     </span>
     can point to a device memory or host memory.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descrC
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      C
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     , Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     buffer allocated by the user; the size is returned by
     <span class="pre">
      pruneDense2csr_bufferSizeExt()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      parameter
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
     <span class="pre">
      or
     </span>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      description
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzTotalDevHostPtr
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
     <span class="pre">
      or
     </span>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     total number of nonzero of matrix
     <span class="pre">
      C
     </span>
     .
     <span class="pre">
      nnzTotalDevHostPtr
     </span>
     can point to a device memory or host memory.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrValC
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzC
     </span>
     nonzero elements of matrix
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowsPtrC
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      m+1
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColIndC
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzC
     </span>
     column indices of
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBufferSizeInBytes
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of bytes of the buffer.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   5.9.16.
  </span>
  cusparseXpruneCsr2csr()  [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsexprunecsr2csr-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseHpruneCsr2csr_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">__half</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="n">__half</span><span class="o">*</span><span class="n">threshold</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="k">const</span><span class="n">__half</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpruneCsr2csr_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">threshold</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDpruneCsr2csr_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">threshold</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseHpruneCsr2csrNnz</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">__half</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="n">__half</span><span class="o">*</span><span class="n">threshold</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzTotalDevHostPtr</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpruneCsr2csrNnz</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">threshold</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzTotalDevHostPtr</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDpruneCsr2csrNnz</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">threshold</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzTotalDevHostPtr</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseHpruneCsr2csr</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">__half</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="n">__half</span><span class="o">*</span><span class="n">threshold</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="n">__half</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpruneCsr2csr</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">threshold</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDpruneCsr2csr</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">threshold</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function prunes a sparse matrix to a sparse matrix with CSR format.
 </p>
 <p>
  Given a sparse matrix
  <span class="pre">
   A
  </span>
  and a non-negative value
  <span class="pre">
   threshold
  </span>
  , the function returns a sparse matrix
  <span class="pre">
   C
  </span>
  , defined by
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\begin{matrix}
{{C(i,j)} = {A(i,j)}} &amp; \text{if\ |A(i,j)|\ &gt;\ threshold} \\
\end{matrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The implementation adopts a two-step approach to do the conversion. First, the user allocates
  <span class="pre">
   csrRowPtrC
  </span>
  of
  <span class="pre">
   m+1
  </span>
  elements and uses function
  <span class="pre">
   pruneCsr2csrNnz()
  </span>
  to determine the number of nonzeros columns per row. Second, the user gathers
  <span class="pre">
   nnzC
  </span>
  (number of nonzeros of matrix
  <span class="pre">
   C
  </span>
  ) from either
  <span class="pre">
   (nnzC=*nnzTotalDevHostPtr)
  </span>
  or
  <span class="pre">
   (nnzC=csrRowPtrC[m]-csrRowPtrC[0])
  </span>
  and allocates
  <span class="pre">
   csrValC
  </span>
  of
  <span class="pre">
   nnzC
  </span>
  elements and
  <span class="pre">
   csrColIndC
  </span>
  of
  <span class="pre">
   nnzC
  </span>
  integers. Finally function
  <span class="pre">
   pruneCsr2csr()
  </span>
  is called to complete the conversion.
 </p>
 <p>
  The user must obtain the size of the buffer required by
  <span class="pre">
   pruneCsr2csr()
  </span>
  by calling
  <span class="pre">
   pruneCsr2csr_bufferSizeExt()
  </span>
  , allocate the buffer, and pass the buffer pointer to
  <span class="pre">
   pruneCsr2csr()
  </span>
  .
 </p>
 <p>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#examples-of-prune">
   Examples of prune
  </a>
  chapter provides a simple example of
  <span class="pre">
   pruneCsr2csr()
  </span>
  .
 </p>
 <p>
  The routine
  <span class="pre">
   cusparse&lt;t&gt;pruneCsr2csrNnz()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    This function requires temporary extra storage that is allocated internally
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available
   </p>
  </li>
 </ul>
 <p>
  The routine
  <span class="pre">
   cusparse&lt;t&gt;pruneCsr2csr()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      parameter
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
     <span class="pre">
      or
     </span>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      description
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnzA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of nonzeros of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     , Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzA
     </span>
     nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowsPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      m+1
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzA
     </span>
     column indices of
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      threshold
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
     <span class="pre">
      or
     </span>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     a value to drop the entries of A.
     <span class="pre">
      threshold
     </span>
     can point to a device memory or host memory.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrC
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      C
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     , Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     buffer allocated by the user; the size is returned by
     <span class="pre">
      pruneCsr2csr_bufferSizeExt()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      parameter
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
     <span class="pre">
      or
     </span>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      description
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzTotalDevHostPtr
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
     <span class="pre">
      or
     </span>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     total number of nonzero of matrix
     <span class="pre">
      C
     </span>
     .
     <span class="pre">
      nnzTotalDevHostPtr
     </span>
     can point to a device memory or host memory.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrValC
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzC
     </span>
     nonzero elements of matrix
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowsPtrC
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      m+1
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColIndC
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzC
     </span>
     column indices of
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBufferSizeInBytes
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of bytes of the buffer.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   5.9.17.
  </span>
  cusparseXpruneDense2csrPercentage()  [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsexprunedense2csrpercentage-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseHpruneDense2csrByPercentage_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">__half</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="n">percentage</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="k">const</span><span class="n">__half</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">,</span>
<span class="n">pruneInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpruneDense2csrByPercentage_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="n">percentage</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">,</span>
<span class="n">pruneInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDpruneDense2csrByPercentage_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="n">percentage</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">,</span>
<span class="n">pruneInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseHpruneDense2csrNnzByPercentage</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">__half</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="n">percentage</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzTotalDevHostPtr</span><span class="p">,</span>
<span class="n">pruneInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpruneDense2csrNnzByPercentage</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="n">percentage</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzTotalDevHostPtr</span><span class="p">,</span>
<span class="n">pruneInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDpruneDense2csrNnzByPercentage</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="n">percentage</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzTotalDevHostPtr</span><span class="p">,</span>
<span class="n">pruneInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseHpruneDense2csrByPercentage</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="n">__half</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="n">percentage</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="n">__half</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">,</span>
<span class="n">pruneInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpruneDense2csrByPercentage</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="n">percentage</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">,</span>
<span class="n">pruneInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDpruneDense2csrByPercentage</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">A</span><span class="p">,</span>
<span class="kt">int</span><span class="n">lda</span><span class="p">,</span>
<span class="kt">float</span><span class="n">percentage</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">,</span>
<span class="n">pruneInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function prunes a dense matrix to a sparse matrix by percentage.
 </p>
 <p>
  Given a dense matrix
  <span class="pre">
   A
  </span>
  and a non-negative value
  <span class="pre">
   percentage
  </span>
  , the function computes sparse matrix
  <span class="pre">
   C
  </span>
  by the following three steps:
 </p>
 <p>
  Step 1: sort absolute value of
  <span class="pre">
   A
  </span>
  in ascending order.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\begin{matrix}
{key\ :=\ sort(\ |A|\ )} \\
\end{matrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Step 2: choose threshold by the parameter
  <span class="pre">
   percentage
  </span>
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\begin{matrix}
{pos\ =\ ceil(m*n*(percentage/100))\ -\ 1} \\
{pos\ =\ min(pos,\ m*n-1)} \\
{pos\ =\ max(pos,\ 0)} \\
{threshold\ =\ key\lbrack pos\rbrack} \\
\end{matrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Step 3: call
  <span class="pre">
   pruneDense2csr()
  </span>
  by with the parameter
  <span class="pre">
   threshold
  </span>
  .
 </p>
 <p>
  The implementation adopts a two-step approach to do the conversion. First, the user allocates
  <span class="pre">
   csrRowPtrC
  </span>
  of
  <span class="pre">
   m+1
  </span>
  elements and uses function
  <span class="pre">
   pruneDense2csrNnzByPercentage()
  </span>
  to determine the number of nonzeros columns per row. Second, the user gathers
  <span class="pre">
   nnzC
  </span>
  (number of nonzeros of matrix
  <span class="pre">
   C
  </span>
  ) from either
  <span class="pre">
   (nnzC=*nnzTotalDevHostPtr)
  </span>
  or
  <span class="pre">
   (nnzC=csrRowPtrC[m]-csrRowPtrC[0])
  </span>
  and allocates
  <span class="pre">
   csrValC
  </span>
  of
  <span class="pre">
   nnzC
  </span>
  elements and
  <span class="pre">
   csrColIndC
  </span>
  of
  <span class="pre">
   nnzC
  </span>
  integers. Finally function
  <span class="pre">
   pruneDense2csrByPercentage()
  </span>
  is called to complete the conversion.
 </p>
 <p>
  The user must obtain the size of the buffer required by
  <span class="pre">
   pruneDense2csrByPercentage()
  </span>
  by calling
  <span class="pre">
   pruneDense2csrByPercentage_bufferSizeExt()
  </span>
  , allocate the buffer, and pass the buffer pointer to
  <span class="pre">
   pruneDense2csrByPercentage()
  </span>
  .
 </p>
 <p>
  Remark 1: the value of
  <span class="pre">
   percentage
  </span>
  must be not greater than 100. Otherwise,
  <span class="pre">
   CUSPARSE_STATUS_INVALID_VALUE
  </span>
  is returned.
 </p>
 <p>
  Remark 2: the zeros of
  <span class="pre">
   A
  </span>
  are not ignored. All entries are sorted, including zeros. This is different from
  <span class="pre">
   pruneCsr2csrByPercentage()
  </span>
 </p>
 <p>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#examples-of-prune">
   Examples of prune
  </a>
  chapter provides a simple example of
  <span class="pre">
   pruneDense2csrNnzByPercentage()
  </span>
  .
 </p>
 <p>
  The routine
  <span class="pre">
   cusparse&lt;t&gt;pruneDense2csrNnzByPercentage()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    This function requires temporary extra storage that is allocated internally
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available
   </p>
  </li>
 </ul>
 <p>
  The routine
  <span class="pre">
   cusparse&lt;t&gt;pruneDense2csrByPercentage()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      parameter
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
     <span class="pre">
      or
     </span>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      description
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     array of dimension (lda, n).
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      lda
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     leading dimension of
     <span class="pre">
      A
     </span>
     . It must be at least max(1, m).
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      percentage
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     percentage &lt;=100 and percentage &gt;= 0
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descrC
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      C
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     , Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     buffer allocated by the user; the size is returned by
     <span class="pre">
      pruneDense2csrByPercentage_bufferSizeExt()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      parameter
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
     <span class="pre">
      or
     </span>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      description
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzTotalDevHostPtr
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
     <span class="pre">
      or
     </span>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     total number of nonzero of matrix
     <span class="pre">
      C
     </span>
     .
     <span class="pre">
      nnzTotalDevHostPtr
     </span>
     can point to a device memory or host memory.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrValC
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzC
     </span>
     nonzero elements of matrix
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowsPtrC
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      m+1
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColIndC
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzC
     </span>
     column indices of
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBufferSizeInBytes
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of bytes of the buffer.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   5.9.18.
  </span>
  cusparseXpruneCsr2csrByPercentage() [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsexprunecsr2csrbypercentage-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseHpruneCsr2csrByPercentage_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">__half</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">float</span><span class="n">percentage</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="k">const</span><span class="n">__half</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">,</span>
<span class="n">pruneInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpruneCsr2csrByPercentage_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">float</span><span class="n">percentage</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">,</span>
<span class="n">pruneInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDpruneCsr2csrByPercentage_bufferSizeExt</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">float</span><span class="n">percentage</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">,</span>
<span class="n">pruneInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">pBufferSizeInBytes</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseHpruneCsr2csrNnzByPercentage</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">__half</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">float</span><span class="n">percentage</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzTotalDevHostPtr</span><span class="p">,</span>
<span class="n">pruneInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpruneCsr2csrNnzByPercentage</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">float</span><span class="n">percentage</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzTotalDevHostPtr</span><span class="p">,</span>
<span class="n">pruneInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDpruneCsr2csrNnzByPercentage</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">float</span><span class="n">percentage</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzTotalDevHostPtr</span><span class="p">,</span>
<span class="n">pruneInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseHpruneCsr2csrByPercentage</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="n">__half</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">float</span><span class="n">percentage</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="n">__half</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">,</span>
<span class="n">pruneInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpruneCsr2csrByPercentage</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">float</span><span class="n">percentage</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">float</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">,</span>
<span class="n">pruneInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDpruneCsr2csrByPercentage</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="kt">int</span><span class="n">n</span><span class="p">,</span>
<span class="kt">int</span><span class="n">nnzA</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrColIndA</span><span class="p">,</span>
<span class="kt">float</span><span class="n">percentage</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descrC</span><span class="p">,</span>
<span class="kt">double</span><span class="o">*</span><span class="n">csrValC</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrC</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">csrColIndC</span><span class="p">,</span>
<span class="n">pruneInfo_t</span><span class="n">info</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">pBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function prunes a sparse matrix to a sparse matrix by percentage.
 </p>
 <p>
  Given a sparse matrix
  <span class="pre">
   A
  </span>
  and a non-negative value
  <span class="pre">
   percentage
  </span>
  , the function computes sparse matrix
  <span class="pre">
   C
  </span>
  by the following three steps:
 </p>
 <p>
  Step 1: sort absolute value of
  <span class="pre">
   A
  </span>
  in ascending order.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\begin{matrix}
{key\ :=\ sort(\ |csrValA|\ )} \\
\end{matrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Step 2: choose threshold by the parameter
  <span class="pre">
   percentage
  </span>
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\begin{matrix}
{pos\ =\ ceil(nnzA*(percentage/100))\ -\ 1} \\
{pos\ =\ min(pos,\ nnzA-1)} \\
{pos\ =\ max(pos,\ 0)} \\
{threshold\ =\ key\lbrack pos\rbrack} \\
\end{matrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Step 3: call
  <span class="pre">
   pruneCsr2csr()
  </span>
  by with the parameter
  <span class="pre">
   threshold
  </span>
  .
 </p>
 <p>
  The implementation adopts a two-step approach to do the conversion. First, the user allocates
  <span class="pre">
   csrRowPtrC
  </span>
  of
  <span class="pre">
   m+1
  </span>
  elements and uses function
  <span class="pre">
   pruneCsr2csrNnzByPercentage()
  </span>
  to determine the number of nonzeros columns per row. Second, the user gathers
  <span class="pre">
   nnzC
  </span>
  (number of nonzeros of matrix
  <span class="pre">
   C
  </span>
  ) from either
  <span class="pre">
   (nnzC=*nnzTotalDevHostPtr)
  </span>
  or
  <span class="pre">
   (nnzC=csrRowPtrC[m]-csrRowPtrC[0])
  </span>
  and allocates
  <span class="pre">
   csrValC
  </span>
  of
  <span class="pre">
   nnzC
  </span>
  elements and
  <span class="pre">
   csrColIndC
  </span>
  of
  <span class="pre">
   nnzC
  </span>
  integers. Finally function
  <span class="pre">
   pruneCsr2csrByPercentage()
  </span>
  is called to complete the conversion.
 </p>
 <p>
  The user must obtain the size of the buffer required by
  <span class="pre">
   pruneCsr2csrByPercentage()
  </span>
  by calling
  <span class="pre">
   pruneCsr2csrByPercentage_bufferSizeExt()
  </span>
  , allocate the buffer, and pass the buffer pointer to
  <span class="pre">
   pruneCsr2csrByPercentage()
  </span>
  .
 </p>
 <p>
  Remark 1: the value of
  <span class="pre">
   percentage
  </span>
  must be not greater than 100. Otherwise,
  <span class="pre">
   CUSPARSE_STATUS_INVALID_VALUE
  </span>
  is returned.
 </p>
 <p>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#examples-of-prune">
   Examples of prune
  </a>
  chapter provides a simple example of
  <span class="pre">
   pruneCsr2csrByPercentage()
  </span>
  .
 </p>
 <p>
  The routine
  <span class="pre">
   cusparse&lt;t&gt;pruneCsr2csrNnzByPercentage()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    This function requires temporary extra storage that is allocated internally
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available
   </p>
  </li>
 </ul>
 <p>
  The routine
  <span class="pre">
   cusparse&lt;t&gt;pruneCsr2csrByPercentage()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      parameter
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
     <span class="pre">
      or
     </span>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      description
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      n
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of columns of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnzA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of nonzeros of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     , Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzA
     </span>
     nonzero elements of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowsPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      m+1
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColIndA
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzA
     </span>
     column indices of
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      percentage
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     percentage &lt;=100 and percentage &gt;= 0
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrC
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      C
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     , Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     buffer allocated by the user; the size is returned by
     <span class="pre">
      pruneCsr2csrByPercentage_bufferSizeExt()
     </span>
     .
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      parameter
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
     <span class="pre">
      or
     </span>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      description
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzTotalDevHostPtr
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
     <span class="pre">
      or
     </span>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     total number of nonzero of matrix
     <span class="pre">
      C
     </span>
     .
     <span class="pre">
      nnzTotalDevHostPtr
     </span>
     can point to a device memory or host memory.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrValC
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     &lt;type&gt; array of
     <span class="pre">
      nnzC
     </span>
     nonzero elements of matrix
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowsPtrC
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      m+1
     </span>
     elements that contains the start of every row and the end of the last row plus one.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColIndC
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      device
     </span>
    </p>
   </td>
   <td>
    <p>
     integer array of
     <span class="pre">
      nnzC
     </span>
     column indices of
     <span class="pre">
      C
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      pBufferSizeInBytes
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      host
     </span>
    </p>
   </td>
   <td>
    <p>
     number of bytes of the buffer.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   5.9.19.
  </span>
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#nnz_compress">
   cusparse&lt;t&gt;nnz_compress()
  </a>
  [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-t-nnz-compress-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSnnz_compress</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzPerRow</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzC</span><span class="p">,</span>
<span class="kt">float</span><span class="n">tol</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseDnnz_compress</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">double</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzPerRow</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzC</span><span class="p">,</span>
<span class="kt">double</span><span class="n">tol</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCnnz_compress</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descr</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzPerRow</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzC</span><span class="p">,</span>
<span class="n">cuComplex</span><span class="n">tol</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseZnnz_compress</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="kt">int</span><span class="n">m</span><span class="p">,</span>
<span class="k">const</span><span class="n">cusparseMatDescr_t</span><span class="n">descr</span><span class="p">,</span>
<span class="k">const</span><span class="n">cuDoubleComplex</span><span class="o">*</span><span class="n">csrValA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">int</span><span class="o">*</span><span class="n">csrRowPtrA</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzPerRow</span><span class="p">,</span>
<span class="kt">int</span><span class="o">*</span><span class="n">nnzC</span><span class="p">,</span>
<span class="n">cuDoubleComplex</span><span class="n">tol</span><span class="p">)</span>
</pre>
 <p>
  This function is the step one to convert from csr format to compressed csr format.
 </p>
 <p>
  Given a sparse matrix A and a non-negative value threshold, the function returns nnzPerRow(the number of nonzeros columns per row) and nnzC(the total number of nonzeros) of a sparse matrix C, defined by
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\begin{matrix}
{{C(i,j)} = {A(i,j)}} &amp; \text{if\ |A(i,j)|\ &gt;\ threshold} \\
\end{matrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  A key assumption for the cuComplex and cuDoubleComplex case is that this tolerance is given as the real part. For example tol = 1e-8 + 0*i and we extract cureal, that is the x component of this struct.
 </p>
 <ul class="simple">
  <li>
   <p>
    This function requires temporary extra storage that is allocated internally
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution if the Stream Ordered Memory Allocator is available
   </p>
  </li>
  <li>
   <p>
    The routine supports CUDA graph capture if the Stream Ordered Memory Allocator is available
   </p>
  </li>
 </ul>
 <p>
  Input
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     handle to the cuSPARSE library context.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      m
     </span>
    </p>
   </td>
   <td>
    <p>
     number of rows of matrix
     <span class="pre">
      A
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      descrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the descriptor of matrix
     <span class="pre">
      A
     </span>
     . The supported matrix type is
     <span class="pre">
      CUSPARSE_MATRIX_TYPE_GENERAL
     </span>
     . Also, the supported index bases are
     <span class="pre">
      CUSPARSE_INDEX_BASE_ZERO
     </span>
     and
     <span class="pre">
      CUSPARSE_INDEX_BASE_ONE
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrValA
     </span>
    </p>
   </td>
   <td>
    <p>
     csr noncompressed values array
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrRowPtrA
     </span>
    </p>
   </td>
   <td>
    <p>
     the corresponding input noncompressed row pointer.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      tol
     </span>
    </p>
   </td>
   <td>
    <p>
     non-negative tolerance to determine if a number less than or equal to it.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Output
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnzPerRow
     </span>
    </p>
   </td>
   <td>
    <p>
     this array contains the number of elements whose absolute values are greater than tol per row.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnzC
     </span>
    </p>
   </td>
   <td>
    <p>
     host/device pointer of the total number of elements whose absolute values are greater than tol.
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h1>
  <span class="section-number">
   6.
  </span>
  cuSPARSE Generic APIs
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-generic-apis" title="Permalink to this headline">
   
  </a>
 </h1>
 <p>
  The cuSPARSE Generic APIs allow computing the most common sparse linear algebra operations, such as sparse matrix-vector (SpMV) and sparse matrix-matrix multiplication (SpMM), in a flexible way. The new APIs have the following capabilities and features:
 </p>
 <ul class="simple">
  <li>
   <p>
    Set matrix data layouts, number of batches, and storage formats (for example, CSR, COO, and so on).
   </p>
  </li>
  <li>
   <p>
    Set input/output/compute data types. This also allows mixed data-type computation.
   </p>
  </li>
  <li>
   <p>
    Set types of sparse vector/matrix indices (e.g. 32-bit, 64-bit).
   </p>
  </li>
  <li>
   <p>
    Choose the algorithm for the computation.
   </p>
  </li>
  <li>
   <p>
    Guarantee external device memory for internal operations.
   </p>
  </li>
  <li>
   <p>
    Provide extensive consistency checks across input matrices and vectors. This includes the validation of sizes, data types, layout, allowed operations, etc.
   </p>
  </li>
  <li>
   <p>
    Provide constant descriptors for vector and matrix inputs to support const-safe interface and guarantee that the APIs do not modify their inputs.
   </p>
  </li>
 </ul>
 <h2>
  <span class="section-number">
   6.1.
  </span>
  Generic Types Reference
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#generic-types-reference" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  The cuSPARSE generic type references are described in this section.
 </p>
 <h3>
  <span class="section-number">
   6.1.1.
  </span>
  cusparseFormat_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseformat-t" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  This type indicates the format of the sparse matrix.
See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-storage-formats">
   cuSPARSE Storage Format
  </a>
  for their description.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_FORMAT_COO
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix is stored in Coordinate (COO) format organized in
     Structure of Arrays (SoA)
     layout
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_FORMAT_CSR
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix is stored in Compressed Sparse Row (CSR) format
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_FORMAT_CSC
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix is stored in Compressed Sparse Column (CSC) format
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_FORMAT_BLOCKED_ELL
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix is stored in Blocked-Ellpack (Blocked-ELL) format
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_FORMAT_SLICED_ELL
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix is stored in Sliced-Ellpack (Sliced-ELL) format
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_FORMAT_BSR
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix is stored in Block Sparse Row (BSR) format
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   6.1.2.
  </span>
  cusparseOrder_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseorder-t" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  This type indicates the memory layout of a dense matrix.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_ORDER_ROW
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix is stored in row-major
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_ORDER_COL
     </span>
    </p>
   </td>
   <td>
    <p>
     The matrix is stored in column-major
    </p>
   </td>
  </tr>
 </table>
 <h3>
  <span class="section-number">
   6.1.3.
  </span>
  cusparseIndexType_t
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseindextype-t" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  This type indicates the index type for representing the sparse matrix indices.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Value
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_INDEX_32I
     </span>
    </p>
   </td>
   <td>
    <p>
     32-bit signed integer [1, 2^31 - 1]
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_INDEX_64I
     </span>
    </p>
   </td>
   <td>
    <p>
     64-bit signed integer [1, 2^63 - 1]
    </p>
   </td>
  </tr>
 </table>
 <h2>
  <span class="section-number">
   6.2.
  </span>
  Dense Vector APIs
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#dense-vector-apis" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  The cuSPARSE helper functions for dense vector descriptor are described in this section.
 </p>
 <p>
  See the
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#dense-vector-format">
   Dense Vector Format
  </a>
  section for the detailed description of the storage format.
 </p>
 <h3>
  <span class="section-number">
   6.2.1.
  </span>
  cusparseCreateDnVec()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatednvec" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseCreateDnVec</span><span class="p">(</span><span class="n">cusparseDnVecDescr_t</span><span class="o">*</span><span class="n">dnVecDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">size</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">values</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">valueType</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCreateConstDnVec</span><span class="p">(</span><span class="n">cusparseConstDnVecDescr_t</span><span class="o">*</span><span class="n">dnVecDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">size</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">values</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">valueType</span><span class="p">)</span>
</pre>
 <p>
  This function initializes the dense vector descriptor
  <span class="pre">
   dnVecDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dnVecDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Dense vector descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      size
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Size of the dense vector
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      values
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Values of the dense vector. Array with
     <span class="pre">
      size
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      valueType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Enumerator specifying the datatype of
     <span class="pre">
      values
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseCreateDnVec()
  </span>
  has the following constraints:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     values
    </span>
    must be aligned to the size of the datatype specified by
    <span class="pre">
     valueType
    </span>
    . See
    <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cudadatatype-t">
     cudaDataType_t
    </a>
    for the description of the datatypes.
   </p>
  </li>
 </ul>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   6.2.2.
  </span>
  cusparseDestroyDnVec()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedestroydnvec" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseDestroyDnVec</span><span class="p">(</span><span class="n">cusparseConstDnVecDescr_t</span><span class="n">dnVecDescr</span><span class="p">)</span><span class="c1">// non-const descriptor supported</span>
</pre>
 <p>
  This function releases the host memory allocated for the dense vector descriptor
  <span class="pre">
   dnVecDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dnVecDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Dense vector descriptor
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   6.2.3.
  </span>
  cusparseDnVecGet()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsednvecget" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseDnVecGet</span><span class="p">(</span><span class="n">cusparseDnVecDescr_t</span><span class="n">dnVecDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">size</span><span class="p">,</span>
<span class="kt">void</span><span class="o">**</span><span class="n">values</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="o">*</span><span class="n">valueType</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseConstDnVecGet</span><span class="p">(</span><span class="n">cusparseConstDnVecDescr_t</span><span class="n">dnVecDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">size</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">**</span><span class="n">values</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="o">*</span><span class="n">valueType</span><span class="p">)</span>
</pre>
 <p>
  This function returns the fields of the dense vector descriptor
  <span class="pre">
   dnVecDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dnVecDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Dense vector descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      size
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Size of the dense vector
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      values
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Values of the dense vector. Array with
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      valueType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Enumerator specifying the datatype of
     <span class="pre">
      values
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   6.2.4.
  </span>
  cusparseDnVecGetValues()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsednvecgetvalues" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseDnVecGetValues</span><span class="p">(</span><span class="n">cusparseDnVecDescr_t</span><span class="n">dnVecDescr</span><span class="p">,</span>
<span class="kt">void</span><span class="o">**</span><span class="n">values</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseConstDnVecGetValues</span><span class="p">(</span><span class="n">cusparseConstDnVecDescr_t</span><span class="n">dnVecDescr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">**</span><span class="n">values</span><span class="p">)</span>
</pre>
 <p>
  This function returns the
  <span class="pre">
   values
  </span>
  field of the dense vector descriptor
  <span class="pre">
   dnVecDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dnVecDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Dense vector descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      values
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Values of the dense vector
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   6.2.5.
  </span>
  cusparseDnVecSetValues()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsednvecsetvalues" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseDnVecSetValues</span><span class="p">(</span><span class="n">cusparseDnVecDescr_t</span><span class="n">dnVecDescr</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">values</span><span class="p">)</span>
</pre>
 <p>
  This function set the
  <span class="pre">
   values
  </span>
  field of the dense vector descriptor
  <span class="pre">
   dnVecDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dnVecDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Dense vector descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      values
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Values of the dense vector. Array with
     <span class="pre">
      size
     </span>
     elements
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseDnVecSetValues()
  </span>
  has the following constraints:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     values
    </span>
    must be aligned to the size of the datatype specified in
    <span class="pre">
     dnVecDescr
    </span>
    . See
    <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cudadatatype-t">
     cudaDataType_t
    </a>
    for the description of the datatypes.
   </p>
  </li>
 </ul>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h2>
  <span class="section-number">
   6.3.
  </span>
  Sparse Vector APIs
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#sparse-vector-apis" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  The cuSPARSE helper functions for sparse vector descriptor are described in this section.
 </p>
 <p>
  See the
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#sparse-vector-format">
   Sparse Vector Format
  </a>
  section for the detailed description of the storage format.
 </p>
 <h3>
  <span class="section-number">
   6.3.1.
  </span>
  cusparseCreateSpVec()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatespvec" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseCreateSpVec</span><span class="p">(</span><span class="n">cusparseSpVecDescr_t</span><span class="o">*</span><span class="n">spVecDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">size</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">nnz</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">indices</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">values</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="n">idxType</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="n">idxBase</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">valueType</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCreateConstSpVec</span><span class="p">(</span><span class="n">cusparseConstSpVecDescr_t</span><span class="o">*</span><span class="n">spVecDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">size</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">indices</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">values</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="n">idxType</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="n">idxBase</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">valueType</span><span class="p">)</span>
</pre>
 <p>
  This function initializes the sparse matrix descriptor
  <span class="pre">
   spVecDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spVecDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Sparse vector descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      size
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Size of the sparse vector
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Number of non-zero entries of the sparse vector
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      indices
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Indices of the sparse vector. Array with
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      values
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Values of the sparse vector. Array with
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      idxType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Enumerator specifying the data type of
     <span class="pre">
      indices
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      idxBase
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Enumerator specifying the the index base of
     <span class="pre">
      indices
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      valueType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Enumerator specifying the datatype of
     <span class="pre">
      values
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseCreateSpVec()
  </span>
  has the following constraints:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     indices
    </span>
    and
    <span class="pre">
     values
    </span>
    must be aligned to the size of the datatypes specified by
    <span class="pre">
     idxType
    </span>
    and
    <span class="pre">
     valueType
    </span>
    , respectively. See
    <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cudadatatype-t">
     cudaDataType_t
    </a>
    for the description of the datatypes.
   </p>
  </li>
 </ul>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   6.3.2.
  </span>
  cusparseDestroySpVec()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedestroyspvec" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseDestroySpVec</span><span class="p">(</span><span class="n">cusparseConstSpVecDescr_t</span><span class="n">spVecDescr</span><span class="p">)</span><span class="c1">// non-const descriptor supported</span>
</pre>
 <p>
  This function releases the host memory allocated for the sparse vector descriptor
  <span class="pre">
   spVecDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spVecDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse vector descriptor
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   6.3.3.
  </span>
  cusparseSpVecGet()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespvecget" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpVecGet</span><span class="p">(</span><span class="n">cusparseSpVecDescr_t</span><span class="n">spVecDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">size</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">nnz</span><span class="p">,</span>
<span class="kt">void</span><span class="o">**</span><span class="n">indices</span><span class="p">,</span>
<span class="kt">void</span><span class="o">**</span><span class="n">values</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="o">*</span><span class="n">idxType</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="o">*</span><span class="n">idxBase</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="o">*</span><span class="n">valueType</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseConstSpVecGet</span><span class="p">(</span><span class="n">cusparseConstSpVecDescr_t</span><span class="n">spVecDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">size</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">**</span><span class="n">indices</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">**</span><span class="n">values</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="o">*</span><span class="n">idxType</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="o">*</span><span class="n">idxBase</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="o">*</span><span class="n">valueType</span><span class="p">)</span>
</pre>
 <p>
  This function returns the fields of the sparse vector descriptor
  <span class="pre">
   spVecDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spVecDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse vector descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      size
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Size of the sparse vector
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Number of non-zero entries of the sparse vector
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      indices
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Indices of the sparse vector. Array with
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      values
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Values of the sparse vector. Array with
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      idxType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Enumerator specifying the data type of
     <span class="pre">
      indices
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      idxBase
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Enumerator specifying the the index base of
     <span class="pre">
      indices
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      valueType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Enumerator specifying the datatype of
     <span class="pre">
      values
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   6.3.4.
  </span>
  cusparseSpVecGetIndexBase()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespvecgetindexbase" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpVecGetIndexBase</span><span class="p">(</span><span class="n">cusparseConstSpVecDescr_t</span><span class="n">spVecDescr</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseIndexBase_t</span><span class="o">*</span><span class="n">idxBase</span><span class="p">)</span>
</pre>
 <p>
  This function returns the
  <span class="pre">
   idxBase
  </span>
  field of the sparse vector descriptor
  <span class="pre">
   spVecDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spVecDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse vector descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      idxBase
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Enumerator specifying the the index base of
     <span class="pre">
      indices
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   6.3.5.
  </span>
  cusparseSpVecGetValues()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespvecgetvalues" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpVecGetValues</span><span class="p">(</span><span class="n">cusparseSpVecDescr_t</span><span class="n">spVecDescr</span><span class="p">,</span>
<span class="kt">void</span><span class="o">**</span><span class="n">values</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseConstSpVecGetValues</span><span class="p">(</span><span class="n">cusparseConstSpVecDescr_t</span><span class="n">spVecDescr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">**</span><span class="n">values</span><span class="p">)</span>
</pre>
 <p>
  This function returns the
  <span class="pre">
   values
  </span>
  field of the sparse vector descriptor
  <span class="pre">
   spVecDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spVecDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse vector descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      values
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Values of the sparse vector. Array with
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   6.3.6.
  </span>
  cusparseSpVecSetValues()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespvecsetvalues" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpVecSetValues</span><span class="p">(</span><span class="n">cusparseSpVecDescr_t</span><span class="n">spVecDescr</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">values</span><span class="p">)</span>
</pre>
 <p>
  This function set the
  <span class="pre">
   values
  </span>
  field of the sparse vector descriptor
  <span class="pre">
   spVecDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spVecDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse vector descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      values
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Values of the sparse vector. Array with
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseDnVecSetValues()
  </span>
  has the following constraints:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     values
    </span>
    must be aligned to the size of the datatype specified in
    <span class="pre">
     spVecDescr
    </span>
    . See
    <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cudadatatype-t">
     cudaDataType_t
    </a>
    for the description of the datatypes.
   </p>
  </li>
 </ul>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h2>
  <span class="section-number">
   6.4.
  </span>
  Dense Matrix APIs
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#dense-matrix-apis" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  The cuSPARSE helper functions for dense matrix descriptor are described in this section.
 </p>
 <p>
  See the
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#dense-matrix-format">
   Dense Matrix Format
  </a>
  section for the detailed description of the storage format.
 </p>
 <h3>
  <span class="section-number">
   6.4.1.
  </span>
  cusparseCreateDnMat()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatednmat" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseCreateDnMat</span><span class="p">(</span><span class="n">cusparseDnMatDescr_t</span><span class="o">*</span><span class="n">dnMatDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">rows</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">cols</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ld</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">values</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">valueType</span><span class="p">,</span>
<span class="n">cusparseOrder_t</span><span class="n">order</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCreateConstDnMat</span><span class="p">(</span><span class="n">cusparseConstDnMatDescr_t</span><span class="o">*</span><span class="n">dnMatDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">rows</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">cols</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ld</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">values</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">valueType</span><span class="p">,</span>
<span class="n">cusparseOrder_t</span><span class="n">order</span><span class="p">)</span>
</pre>
 <p>
  The function initializes the dense matrix descriptor
  <span class="pre">
   dnMatDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dnMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Dense matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      rows
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Number of rows of the dense matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cols
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Number of columns of the dense matrix
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ld
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Leading dimension of the dense matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      values
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Values of the dense matrix. Array with
     <span class="pre">
      size
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      valueType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Enumerator specifying the datatype of
     <span class="pre">
      values
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      order
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Enumerator specifying the memory layout of the dense matrix
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseCreateDnMat()
  </span>
  has the following constraints:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     values
    </span>
    must be aligned to the size of the datatype specified by
    <span class="pre">
     valueType
    </span>
    . See
    <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cudadatatype-t">
     cudaDataType_t
    </a>
    for the description of the datatypes.
   </p>
  </li>
 </ul>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   6.4.2.
  </span>
  cusparseDestroyDnMat()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedestroydnmat" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseDestroyDnMat</span><span class="p">(</span><span class="n">cusparseConstDnMatDescr_t</span><span class="n">dnMatDescr</span><span class="p">)</span><span class="c1">// non-const descriptor supported</span>
</pre>
 <p>
  This function releases the host memory allocated for the dense matrix descriptor
  <span class="pre">
   dnMatDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dnMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Dense matrix descriptor
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   6.4.3.
  </span>
  cusparseDnMatGet()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsednmatget" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseDnMatGet</span><span class="p">(</span><span class="n">cusparseDnMatDescr_t</span><span class="n">dnMatDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">rows</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">cols</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">ld</span><span class="p">,</span>
<span class="kt">void</span><span class="o">**</span><span class="n">values</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="o">*</span><span class="n">type</span><span class="p">,</span>
<span class="n">cusparseOrder_t</span><span class="o">*</span><span class="n">order</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseConstDnMatGet</span><span class="p">(</span><span class="n">cusparseConstDnMatDescr_t</span><span class="n">dnMatDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">rows</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">cols</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">ld</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">**</span><span class="n">values</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="o">*</span><span class="n">type</span><span class="p">,</span>
<span class="n">cusparseOrder_t</span><span class="o">*</span><span class="n">order</span><span class="p">)</span>
</pre>
 <p>
  This function returns the fields of the dense matrix descriptor
  <span class="pre">
   dnMatDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dnMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Dense matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      rows
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Number of rows of the dense matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cols
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Number of columns of the dense matrix
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ld
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Leading dimension of the dense matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      values
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Values of the dense matrix. Array with
     <span class="pre">
      ld
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      cols
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      valueType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Enumerator specifying the datatype of
     <span class="pre">
      values
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      order
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Enumerator specifying the memory layout of the dense matrix
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   6.4.4.
  </span>
  cusparseDnMatGetValues()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsednmatgetvalues" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseDnMatGetValues</span><span class="p">(</span><span class="n">cusparseDnMatDescr_t</span><span class="n">dnMatDescr</span><span class="p">,</span>
<span class="kt">void</span><span class="o">**</span><span class="n">values</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseConstDnMatGetValues</span><span class="p">(</span><span class="n">cusparseConstDnMatDescr_t</span><span class="n">dnMatDescr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">**</span><span class="n">values</span><span class="p">)</span>
</pre>
 <p>
  This function returns the
  <span class="pre">
   values
  </span>
  field of the dense matrix descriptor
  <span class="pre">
   dnMatDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dnMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Dense matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      values
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Values of the dense matrix. Array with
     <span class="pre">
      ld
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      cols
     </span>
     elements
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   6.4.5.
  </span>
  cusparseDnMatSetValues()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsednmatsetvalues" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseDnMatSetValues</span><span class="p">(</span><span class="n">cusparseDnMatDescr_t</span><span class="n">dnMatDescr</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">values</span><span class="p">)</span>
</pre>
 <p>
  This function sets the
  <span class="pre">
   values
  </span>
  field of the dense matrix descriptor
  <span class="pre">
   dnMatDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dnMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Dense matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      values
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Values of the dense matrix. Array with
     <span class="pre">
      ld
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      cols
     </span>
     elements
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseDnMatSetValues()
  </span>
  has the following constraints:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     values
    </span>
    must be aligned to the size of the datatype specified in
    <span class="pre">
     dnMatDescr
    </span>
    . See
    <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cudadatatype-t">
     cudaDataType_t
    </a>
    for the description of the datatypes.
   </p>
  </li>
 </ul>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   6.4.6.
  </span>
  cusparseDnMatGetStridedBatch()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsednmatgetstridedbatch" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseDnMatGetStridedBatch</span><span class="p">(</span><span class="n">cusparseConstDnMatDescr_t</span><span class="n">dnMatDescr</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="kt">int</span><span class="o">*</span><span class="n">batchCount</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">batchStride</span><span class="p">)</span>
</pre>
 <p>
  The function returns the number of batches and the batch stride of the dense matrix descriptor
  <span class="pre">
   dnMatDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dnMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Dense matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      batchCount
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Number of batches of the dense matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      batchStride
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Address offset between a matrix and the next one in the batch
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   6.4.7.
  </span>
  cusparseDnMatSetStridedBatch()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsednmatsetstridedbatch" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseDnMatSetStridedBatch</span><span class="p">(</span><span class="n">cusparseDnMatDescr_t</span><span class="n">dnMatDescr</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchCount</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">batchStride</span><span class="p">)</span>
</pre>
 <p>
  The function sets the number of batches and the batch stride of the dense matrix descriptor
  <span class="pre">
   dnMatDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      dnMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Dense matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      batchCount
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Number of batches of the dense matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      batchStride
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Address offset between a matrix and the next one in the batch.
     <span class="pre">
      batchStride
     </span>
     <span class="pre">
      
     </span>
     <span class="pre">
      ld
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      cols
     </span>
     if the matrix uses column-major layout,
     <span class="pre">
      batchStride
     </span>
     <span class="pre">
      
     </span>
     <span class="pre">
      ld
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      rows
     </span>
     otherwise
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h2>
  <span class="section-number">
   6.5.
  </span>
  Sparse Matrix APIs
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#sparse-matrix-apis" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  The cuSPARSE helper functions for sparse matrix descriptor are described in this section.
 </p>
 <p>
  See the
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#coordinate-format-coo">
   COO
  </a>
  ,
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#compressed-sparse-row-format-csr">
   CSR
  </a>
  ,
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#compressed-sparse-column-format-csc">
   CSC
  </a>
  ,
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#sliced-ellpack-format-sell">
   SELL
  </a>
  ,
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#block-sparse-row-format-bsr">
   BSR
  </a>
  ,
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html##blocked-ellpack-block-ell">
   Blocked-Ell
  </a>
  sections for the detailed description of the storage formats.
 </p>
 <h3>
  <span class="section-number">
   6.5.1.
  </span>
  Coordinate (COO)
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#id1" title="Permalink to this headline">
   
  </a>
 </h3>
 <h4>
  <span class="section-number">
   6.5.1.1.
  </span>
  cusparseCreateCoo()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatecoo" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseCreateCoo</span><span class="p">(</span><span class="n">cusparseSpMatDescr_t</span><span class="o">*</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">rows</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">cols</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">nnz</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">cooRowInd</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">cooColInd</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">cooValues</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="n">cooIdxType</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="n">idxBase</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">valueType</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCreateConstCoo</span><span class="p">(</span><span class="n">cusparseConstSpMatDescr_t</span><span class="o">*</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">rows</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">cols</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">cooRowInd</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">cooColInd</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">cooValues</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="n">cooIdxType</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="n">idxBase</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">valueType</span><span class="p">)</span>
</pre>
 <p>
  This function initializes the sparse matrix descriptor
  <span class="pre">
   spMatDescr
  </span>
  in the COO format (Structure of Arrays layout).
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Sparse matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      rows
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Number of rows of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cols
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Number of columns of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Number of non-zero entries of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cooRowInd
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Row indices of the sparse matrix. Array with
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cooColInd
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Column indices of the sparse matrix. Array with
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cooValues
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Values of the sparse matrix. Array with
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cooIdxType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Data type of
     <span class="pre">
      cooRowInd
     </span>
     and
     <span class="pre">
      cooColInd
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      idxBase
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Index base of
     <span class="pre">
      cooRowInd
     </span>
     and
     <span class="pre">
      cooColInd
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      valueType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Datatype of
     <span class="pre">
      cooValues
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseCreateCoo()
  </span>
  has the following constraints:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     cooRowInd
    </span>
    ,
    <span class="pre">
     cooColInd
    </span>
    , and
    <span class="pre">
     cooValues
    </span>
    must be aligned to the size of the datatypes specified by
    <span class="pre">
     cooIdxType
    </span>
    ,
    <span class="pre">
     cooIdxType
    </span>
    , and
    <span class="pre">
     valueType
    </span>
    . respectively. See
    <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cudadatatype-t">
     cudaDataType_t
    </a>
    for the description of the datatypes.
   </p>
  </li>
 </ul>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   6.5.1.2.
  </span>
  cusparseCooGet()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecooget" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseCooGet</span><span class="p">(</span><span class="n">cusparseSpMatDescr_t</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">rows</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">cols</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">nnz</span><span class="p">,</span>
<span class="kt">void</span><span class="o">**</span><span class="n">cooRowInd</span><span class="p">,</span>
<span class="kt">void</span><span class="o">**</span><span class="n">cooColInd</span><span class="p">,</span>
<span class="kt">void</span><span class="o">**</span><span class="n">cooValues</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="o">*</span><span class="n">idxType</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="o">*</span><span class="n">idxBase</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="o">*</span><span class="n">valueType</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseConstCooGet</span><span class="p">(</span><span class="n">cusparseConstSpMatDescr_t</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">rows</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">cols</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">**</span><span class="n">cooRowInd</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">**</span><span class="n">cooColInd</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">**</span><span class="n">cooValues</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="o">*</span><span class="n">idxType</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="o">*</span><span class="n">idxBase</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="o">*</span><span class="n">valueType</span><span class="p">)</span>
</pre>
 <p>
  This function returns the fields of the sparse matrix descriptor
  <span class="pre">
   spMatDescr
  </span>
  stored in COO format (Array of Structures layout).
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      rows
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Number of rows of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cols
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Number of columns of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Number of non-zero entries of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cooRowInd
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Row indices of the sparse matrix. Array
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cooColInd
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Column indices of the sparse matrix. Array
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cooValues
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Values of the sparse matrix. Array
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cooIdxType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Data type of
     <span class="pre">
      cooRowInd
     </span>
     and
     <span class="pre">
      cooColInd
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      idxBase
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Index base of
     <span class="pre">
      cooRowInd
     </span>
     and
     <span class="pre">
      cooColInd
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      valueType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Datatype of
     <span class="pre">
      cooValues
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   6.5.1.3.
  </span>
  cusparseCooSetPointers()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecoosetpointers" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseCooSetPointers</span><span class="p">(</span><span class="n">cusparseSpMatDescr_t</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">cooRows</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">cooColumns</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">cooValues</span><span class="p">)</span>
</pre>
 <p>
  This function sets the pointers of the sparse matrix descriptor
  <span class="pre">
   spMatDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cooRows
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Row indices of the sparse matrix. Array with
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cooColumns
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Column indices of the sparse matrix. Array with
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cooValues
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Values of the sparse matrix. Array with
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseCooSetPointers()
  </span>
  has the following constraints:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     cooRows
    </span>
    ,
    <span class="pre">
     cooColumns
    </span>
    , and
    <span class="pre">
     cooValues
    </span>
    must be aligned to the size of their corresponding datatypes specified in
    <span class="pre">
     spMatDescr
    </span>
    . See
    <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cudadatatype-t">
     cudaDataType_t
    </a>
    for the description of the datatypes.
   </p>
  </li>
 </ul>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   6.5.1.4.
  </span>
  cusparseCooSetStridedBatch()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecoosetstridedbatch" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseCooSetStridedBatch</span><span class="p">(</span><span class="n">cusparseSpMatDescr_t</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchCount</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">batchStride</span><span class="p">)</span>
</pre>
 <p>
  This function sets the
  <span class="pre">
   batchCount
  </span>
  and the
  <span class="pre">
   batchStride
  </span>
  fields of the sparse matrix descriptor
  <span class="pre">
   spMatDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      batchCount
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Number of batches of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      batchStride
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     address offset between consecutive batches
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   6.5.2.
  </span>
  Compressed Sparse Row (CSR)
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#id2" title="Permalink to this headline">
   
  </a>
 </h3>
 <h4>
  <span class="section-number">
   6.5.2.1.
  </span>
  cusparseCreateCsr()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatecsr" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseCreateCsr</span><span class="p">(</span><span class="n">cusparseSpMatDescr_t</span><span class="o">*</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">rows</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">cols</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">nnz</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">csrRowOffsets</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">csrColInd</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">csrValues</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="n">csrRowOffsetsType</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="n">csrColIndType</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="n">idxBase</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">valueType</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCreateConstCsr</span><span class="p">(</span><span class="n">cusparseConstSpMatDescr_t</span><span class="o">*</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">rows</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">cols</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">csrRowOffsets</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">csrColInd</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">csrValues</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="n">csrRowOffsetsType</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="n">csrColIndType</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="n">idxBase</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">valueType</span><span class="p">)</span>
</pre>
 <p>
  This function initializes the sparse matrix descriptor
  <span class="pre">
   spMatDescr
  </span>
  in the CSR format.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Sparse matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      rows
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Number of rows of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cols
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Number of columns of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Number of non-zero entries of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowOffsets
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Row offsets of the sparse matrix. Array with
     <span class="pre">
      rows
     </span>
     <span class="pre">
      +
     </span>
     <span class="pre">
      1
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColInd
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Column indices of the sparse matrix. Array with
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrValues
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Values of the sparse matrix. Array with
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrRowOffsetsType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Data type of
     <span class="pre">
      csrRowOffsets
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrColIndType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Data type of
     <span class="pre">
      csrColInd
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      idxBase
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Index base of
     <span class="pre">
      csrRowOffsets
     </span>
     and
     <span class="pre">
      csrColInd
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      valueType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Datatype of
     <span class="pre">
      csrValues
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseCreateCsr()
  </span>
  has the following constraints:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     csrRowOffsets
    </span>
    ,
    <span class="pre">
     csrColInd
    </span>
    , and
    <span class="pre">
     csrValues
    </span>
    must be aligned to the size of the datatypes specified by
    <span class="pre">
     csrRowOffsetsType
    </span>
    ,
    <span class="pre">
     csrColIndType
    </span>
    , and
    <span class="pre">
     valueType
    </span>
    , respectively. See
    <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cudadatatype-t">
     cudaDataType_t
    </a>
    for the description of the datatypes.
   </p>
  </li>
 </ul>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   6.5.2.2.
  </span>
  cusparseCsrGet()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecsrget" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseCsrGet</span><span class="p">(</span><span class="n">cusparseSpMatDescr_t</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">rows</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">cols</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">nnz</span><span class="p">,</span>
<span class="kt">void</span><span class="o">**</span><span class="n">csrRowOffsets</span><span class="p">,</span>
<span class="kt">void</span><span class="o">**</span><span class="n">csrColInd</span><span class="p">,</span>
<span class="kt">void</span><span class="o">**</span><span class="n">csrValues</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="o">*</span><span class="n">csrRowOffsetsType</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="o">*</span><span class="n">csrColIndType</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="o">*</span><span class="n">idxBase</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="o">*</span><span class="n">valueType</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseConstCsrGet</span><span class="p">(</span><span class="n">cusparseConstSpMatDescr_t</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">rows</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">cols</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">**</span><span class="n">csrRowOffsets</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">**</span><span class="n">csrColInd</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">**</span><span class="n">csrValues</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="o">*</span><span class="n">csrRowOffsetsType</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="o">*</span><span class="n">csrColIndType</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="o">*</span><span class="n">idxBase</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="o">*</span><span class="n">valueType</span><span class="p">)</span>
</pre>
 <p>
  This function returns the fields of the sparse matrix descriptor
  <span class="pre">
   spMatDescr
  </span>
  stored in CSR format.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      rows
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Number of rows of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cols
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Number of columns of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Number of non-zero entries of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrRowOffsets
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Row offsets of the sparse matrix. Array with
     <span class="pre">
      rows
     </span>
     <span class="pre">
      +
     </span>
     <span class="pre">
      1
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrColInd
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Column indices of the sparse matrix. Array with
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrValues
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Values of the sparse matrix. Array with
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrRowOffsetsType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Data type of
     <span class="pre">
      csrRowOffsets
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrColIndType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Data type of
     <span class="pre">
      csrColInd
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      idxBase
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Index base of
     <span class="pre">
      csrRowOffsets
     </span>
     and
     <span class="pre">
      csrColInd
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      valueType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Datatype of
     <span class="pre">
      csrValues
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   6.5.2.3.
  </span>
  cusparseCsrSetPointers()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecsrsetpointers" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseCsrSetPointers</span><span class="p">(</span><span class="n">cusparseSpMatDescr_t</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">csrRowOffsets</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">csrColInd</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">csrValues</span><span class="p">)</span>
</pre>
 <p>
  This function sets the pointers of the sparse matrix descriptor
  <span class="pre">
   spMatDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrRowOffsets
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Row offsets of the sparse matrix. Array with
     <span class="pre">
      rows
     </span>
     <span class="pre">
      +
     </span>
     <span class="pre">
      1
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      csrColInd
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Column indices of the sparse matrix. Array with
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      csrValues
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Values of the sparse matrix. Array with
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseCsrSetPointers()
  </span>
  has the following constraints:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     csrRowOffsets
    </span>
    ,
    <span class="pre">
     csrColInd
    </span>
    , and
    <span class="pre">
     csrValues
    </span>
    must be aligned to the size of their corresponding datatypes specified in
    <span class="pre">
     spMatDescr
    </span>
    . See
    <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cudadatatype-t">
     cudaDataType_t
    </a>
    for the description of the datatypes.
   </p>
  </li>
 </ul>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   6.5.2.4.
  </span>
  cusparseCsrSetStridedBatch()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecsrsetstridedbatch" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseCsrSetStridedBatch</span><span class="p">(</span><span class="n">cusparseSpMatDescr_t</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchCount</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">offsetsBatchStride</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">columnsValuesBatchStride</span><span class="p">)</span>
</pre>
 <p>
  This function sets the
  <span class="pre">
   batchCount
  </span>
  and the
  <span class="pre">
   batchStride
  </span>
  fields of the sparse matrix descriptor
  <span class="pre">
   spMatDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      batchCount
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Number of batches of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      offsetsBatchStride
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Address offset between consecutive batches for the row offset array
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      columnsValuesBatchStride
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Address offset between consecutive batches for the column and value arrays
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   6.5.3.
  </span>
  Compressed Sparse Column (CSC)
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#id3" title="Permalink to this headline">
   
  </a>
 </h3>
 <h4>
  <span class="section-number">
   6.5.3.1.
  </span>
  cusparseCreateCsc()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatecsc" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseCreateCsc</span><span class="p">(</span><span class="n">cusparseSpMatDescr_t</span><span class="o">*</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">rows</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">cols</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">nnz</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">cscColOffsets</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">cscRowInd</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">cscValues</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="n">cscColOffsetsType</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="n">cscRowIndType</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="n">idxBase</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">valueType</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCreateConstCsc</span><span class="p">(</span><span class="n">cusparseConstSpMatDescr_t</span><span class="o">*</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">rows</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">cols</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">cscColOffsets</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">cscRowInd</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">cscValues</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="n">cscColOffsetsType</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="n">cscRowIndType</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="n">idxBase</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">valueType</span><span class="p">)</span>
</pre>
 <p>
  This function initializes the sparse matrix descriptor
  <span class="pre">
   spMatDescr
  </span>
  in the CSC format.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Sparse matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      rows
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Number of rows of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cols
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Number of columns of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Number of non-zero entries of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cscColOffsets
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Column offsets of the sparse matrix. Array with
     <span class="pre">
      cols
     </span>
     <span class="pre">
      +
     </span>
     <span class="pre">
      1
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cscRowInd
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Row indices of the sparse matrix. Array with
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cscValues
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Values of the sparse matrix. Array with
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cscColOffsetsType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Data type of
     <span class="pre">
      cscColOffsets
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cscRowIndType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Data type of
     <span class="pre">
      cscRowInd
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      idxBase
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Index base of
     <span class="pre">
      cscColOffsets
     </span>
     and
     <span class="pre">
      cscRowInd
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      valueType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Datatype of
     <span class="pre">
      cscValues
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseCreateCsc()
  </span>
  has the following constraints:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     cscColOffsets
    </span>
    ,
    <span class="pre">
     cscRowInd
    </span>
    , and
    <span class="pre">
     cscValues
    </span>
    must be aligned to the size of the datatypes specified by
    <span class="pre">
     cscColOffsetsType
    </span>
    ,
    <span class="pre">
     cscRowIndType
    </span>
    , and
    <span class="pre">
     valueType
    </span>
    , respectively. See
    <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cudadatatype-t">
     cudaDataType_t
    </a>
    for the description of the datatypes.
   </p>
  </li>
 </ul>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   6.5.3.2.
  </span>
  cusparseCscGet()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecscget" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseCscGet</span><span class="p">(</span><span class="n">cusparseSpMatDescr_t</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">rows</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">cols</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">nnz</span><span class="p">,</span>
<span class="kt">void</span><span class="o">**</span><span class="n">cscColOffsets</span><span class="p">,</span>
<span class="kt">void</span><span class="o">**</span><span class="n">cscRowInd</span><span class="p">,</span>
<span class="kt">void</span><span class="o">**</span><span class="n">cscValues</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="o">*</span><span class="n">cscColOffsetsType</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="o">*</span><span class="n">cscRowIndType</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="o">*</span><span class="n">idxBase</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="o">*</span><span class="n">valueType</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseConstCscGet</span><span class="p">(</span><span class="n">cusparseConstSpMatDescr_t</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">rows</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">cols</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">nnz</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">**</span><span class="n">cscColOffsets</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">**</span><span class="n">cscRowInd</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">**</span><span class="n">cscValues</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="o">*</span><span class="n">cscColOffsetsType</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="o">*</span><span class="n">cscRowIndType</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="o">*</span><span class="n">idxBase</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="o">*</span><span class="n">valueType</span><span class="p">)</span>
</pre>
 <p>
  This function returns the fields of the sparse matrix descriptor
  <span class="pre">
   spMatDescr
  </span>
  stored in CSC format.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      rows
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Number of rows of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cols
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Number of columns of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Number of non-zero entries of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cscColOffsets
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Col offsets of the sparse matrix. Array with
     <span class="pre">
      cols
     </span>
     <span class="pre">
      +
     </span>
     <span class="pre">
      1
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cscRowInd
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Row indices of the sparse matrix. Array with
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cscValues
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Values of the sparse matrix. Array with
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cscColOffsetsType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Data type of
     <span class="pre">
      cscColOffsets
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cscRowIndType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Data type of
     <span class="pre">
      cscRowInd
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      idxBase
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Index base of
     <span class="pre">
      cscColOffsets
     </span>
     and
     <span class="pre">
      cscRowInd
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      valueType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Datatype of
     <span class="pre">
      cscValues
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   6.5.3.3.
  </span>
  cusparseCscSetPointers()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecscsetpointers" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseCscSetPointers</span><span class="p">(</span><span class="n">cusparseSpMatDescr_t</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">cscColOffsets</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">cscRowInd</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">cscValues</span><span class="p">)</span>
</pre>
 <p>
  This function sets the pointers of the sparse matrix descriptor
  <span class="pre">
   spMatDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cscColOffsets
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Col offsets of the sparse matrix. Array with
     <span class="pre">
      cols
     </span>
     <span class="pre">
      +
     </span>
     <span class="pre">
      1
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cscRowInd
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Row indices of the sparse matrix. Array with
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      cscValues
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Values of the sparse matrix. Array with
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseCscSetPointers()
  </span>
  has the following constraints:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     cscColOffsets
    </span>
    ,
    <span class="pre">
     cscRowInd
    </span>
    , and
    <span class="pre">
     cscValues
    </span>
    must be aligned to the size of their corresponding datatypes specified in
    <span class="pre">
     spMatDescr
    </span>
    . See
    <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cudadatatype-t">
     cudaDataType_t
    </a>
    for the description of the datatypes.
   </p>
  </li>
 </ul>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   6.5.4.
  </span>
  Blocked-Ellpack (Blocked-ELL)
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#id4" title="Permalink to this headline">
   
  </a>
 </h3>
 <h4>
  <span class="section-number">
   6.5.4.1.
  </span>
  cusparseCreateBlockedEll()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreateblockedell" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseCreateBlockedEll</span><span class="p">(</span><span class="n">cusparseSpMatDescr_t</span><span class="o">*</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">rows</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">cols</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ellBlockSize</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ellCols</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">ellColInd</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">ellValue</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="n">ellIdxType</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="n">idxBase</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">valueType</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCreateConstBlockedEll</span><span class="p">(</span><span class="n">cusparseConstSpMatDescr_t</span><span class="o">*</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">rows</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">cols</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ellBlockSize</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">ellCols</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">ellColInd</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">ellValue</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="n">ellIdxType</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="n">idxBase</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">valueType</span><span class="p">)</span>
</pre>
 <p>
  This function initializes the sparse matrix descriptor
  <span class="pre">
   spMatDescr
  </span>
  for the Blocked-Ellpack (ELL) format.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Sparse matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      rows
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Number of rows of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cols
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Number of columns of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ellBlockSize
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Size of the ELL-Block
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ellCols
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Actual number of columns of the Blocked-Ellpack format (
     <span class="pre">
      ellValue
     </span>
     columns)
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ellColInd
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Blocked-ELL Column indices. Array with
     <span class="pre">
      [ellCols
     </span>
     <span class="pre">
      /
     </span>
     <span class="pre">
      ellBlockSize][rows
     </span>
     <span class="pre">
      /
     </span>
     <span class="pre">
      ellBlockSize]
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ellValue
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Values of the sparse matrix. Array with
     <span class="pre">
      rows
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      ellCols
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ellIdxType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Data type of
     <span class="pre">
      ellColInd
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      idxBase
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Index base of
     <span class="pre">
      ellColInd
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      valueType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Data type of
     <span class="pre">
      ellValue
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Blocked-ELL Column indices (
  <span class="pre">
   ellColInd
  </span>
  ) are in the range
  <span class="pre">
   [0,
  </span>
  <span class="pre">
   cols
  </span>
  <span class="pre">
   /
  </span>
  <span class="pre">
   ellBlockSize
  </span>
  <span class="pre">
   -1]
  </span>
  . The array can contain
  <span class="pre">
   -1
  </span>
  values for indicating empty blocks.
 </p>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   6.5.4.2.
  </span>
  cusparseBlockedEllGet()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseblockedellget" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseBlockedEllGet</span><span class="p">(</span><span class="n">cusparseSpMatDescr_t</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">rows</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">cols</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">ellBlockSize</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">ellCols</span><span class="p">,</span>
<span class="kt">void</span><span class="o">**</span><span class="n">ellColInd</span><span class="p">,</span>
<span class="kt">void</span><span class="o">**</span><span class="n">ellValue</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="o">*</span><span class="n">ellIdxType</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="o">*</span><span class="n">idxBase</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="o">*</span><span class="n">valueType</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseConstBlockedEllGet</span><span class="p">(</span><span class="n">cusparseConstSpMatDescr_t</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">rows</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">cols</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">ellBlockSize</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">ellCols</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">**</span><span class="n">ellColInd</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">**</span><span class="n">ellValue</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="o">*</span><span class="n">ellIdxType</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="o">*</span><span class="n">idxBase</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="o">*</span><span class="n">valueType</span><span class="p">)</span>
</pre>
 <p>
  This function returns the fields of the sparse matrix descriptor
  <span class="pre">
   spMatDescr
  </span>
  stored in Blocked-Ellpack (ELL) format.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      rows
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Number of rows of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cols
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Number of columns of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ellBlockSize
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Size of the ELL-Block
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ellCols
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Actual number of columns of the Blocked-Ellpack format
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ellColInd
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Column indices for the ELL-Block. Array with
     <span class="pre">
      [cols
     </span>
     <span class="pre">
      /
     </span>
     <span class="pre">
      ellBlockSize][rows
     </span>
     <span class="pre">
      /
     </span>
     <span class="pre">
      ellBlockSize]
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      ellValue
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Values of the sparse matrix. Array with
     <span class="pre">
      rows
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      ellCols
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      ellIdxType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Data type of
     <span class="pre">
      ellColInd
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      idxBase
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Index base of
     <span class="pre">
      ellColInd
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      valueType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Datatype of
     <span class="pre">
      ellValue
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   6.5.5.
  </span>
  Sliced-Ellpack (SELL)
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#id5" title="Permalink to this headline">
   
  </a>
 </h3>
 <h4>
  <span class="section-number">
   6.5.5.1.
  </span>
  cusparseCreateSlicedEll()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreateslicedell" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseCreateSlicedEll</span><span class="p">(</span><span class="n">cusparseSpMatDescr_t</span><span class="o">*</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">rows</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">cols</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">nnz</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">sellValuesSize</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">sliceSize</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">sellSliceOffsets</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">sellColInd</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">sellValues</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="n">sellSliceOffsetsType</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="n">sellColIndType</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="n">idxBase</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">valueType</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCreateConstSlicedEll</span><span class="p">(</span><span class="n">cusparseConstSpMatDescr_t</span><span class="o">*</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">rows</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">cols</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">nnz</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">sellValuesSize</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">sliceSize</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">sellSliceOffsets</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">sellColInd</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">sellValues</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="n">sellSliceOffsetsType</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="n">sellColIndType</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="n">idxBase</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">valueType</span><span class="p">)</span>
</pre>
 <p>
  This function initializes the sparse matrix descriptor
  <span class="pre">
   spMatDescr
  </span>
  for the Sliced Ellpack (SELL) format.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Sparse matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      rows
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Number of rows of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cols
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Number of columns of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Number of nonzero elements in the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      sellValuesSize
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Total number of elements in
     <span class="pre">
      sellValues
     </span>
     array (nonzero and padding)
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      sliceSize
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     The number of rows per slice
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      sellSliceOffsets
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Slice offsets of the sparse matrix. Array of size
     <span class="math notranslate nohighlight">
      \(\left \lceil{\frac{rows}{sliceSize}}\right \rceil + 1\)
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      sellColInd
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Column indexes of the sparse matrix. Array of size
     <span class="pre">
      sellValuesSize
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      sellValues
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Values of the sparse matrix. Array of size
     <span class="pre">
      sellValuesSize
     </span>
     elements
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      sellSliceOffsetsType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Data type of
     <span class="pre">
      sellSliceOffsets
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      sellColIndType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Data type of
     <span class="pre">
      sellColInd
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      idxBase
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Index base of
     <span class="pre">
      sellColInd
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      valueType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Data type of
     <span class="pre">
      sellValues
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p class="admonition-title">
  Note
 </p>
 <p>
  Sliced Ellpack Column array
  <span class="pre">
   sellColInd
  </span>
  contains
  <span class="pre">
   -1
  </span>
  values for indicating padded entries.
 </p>
 <p>
  <span class="pre">
   cusparseCreateSlicedEll()
  </span>
  has the following constraints:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     sellSliceOffsets
    </span>
    ,
    <span class="pre">
     sellColInd
    </span>
    , and
    <span class="pre">
     sellValues
    </span>
    must be aligned to the size of the datatypes specified by
    <span class="pre">
     sellSliceOffsetsType
    </span>
    ,
    <span class="pre">
     sellColIndType
    </span>
    , and
    <span class="pre">
     valueType
    </span>
    , respectively. See
    <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cudadatatype-t">
     cudaDataType_t
    </a>
    for the description of the datatypes.
   </p>
  </li>
 </ul>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   6.5.6.
  </span>
  Block Sparse Row (BSR)
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#id6" title="Permalink to this headline">
   
  </a>
 </h3>
 <h4>
  <span class="section-number">
   6.5.6.1.
  </span>
  cusparseCreateBsr()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsecreatebsr" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseCreateBsr</span><span class="p">(</span><span class="n">cusparseSpMatDescr_t</span><span class="o">*</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">brows</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">bcols</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">bnnz</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">rowBlockSize</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">colBlockSize</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">bsrRowOffsets</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">bsrColInd</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">bsrValues</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="n">bsrRowOffsetsType</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="n">bsrColIndType</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="n">idxBase</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">valueType</span><span class="p">,</span>
<span class="n">cusparseOrder_t</span><span class="n">order</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseCreateConstBsr</span><span class="p">(</span><span class="n">cusparseConstSpMatDescr_t</span><span class="o">*</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">brows</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">bcols</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">bnnz</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">rowBlockSize</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">colBlockSize</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">bsrRowOffsets</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">bsrColInd</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">bsrValues</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="n">bsrRowOffsetsType</span><span class="p">,</span>
<span class="n">cusparseIndexType_t</span><span class="n">bsrColIndType</span><span class="p">,</span>
<span class="n">cusparseIndexBase_t</span><span class="n">idxBase</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">valueType</span><span class="p">,</span>
<span class="n">cusparseOrder_t</span><span class="n">order</span><span class="p">)</span>
</pre>
 <p>
  This function initializes the sparse matrix descriptor
  <span class="pre">
   spMatDescr
  </span>
  for the Block Compressed Row (BSR) format.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Sparse matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      brows
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Number of block rows of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bcols
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Number of block columns of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bnnz
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Number of blocks of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      rowBlockSize
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Number of rows of each block
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      colBlockSize
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Number of columns of each block
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrRowOffsets
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Block row offsets of the sparse matrix. Array of size
     <span class="pre">
      brows
     </span>
     <span class="pre">
      +
     </span>
     <span class="pre">
      1
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrColInd
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Block column indices of the sparse matrix. Array of size
     <span class="pre">
      bnnz
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrValues
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Values of the sparse matrix. Array of size
     <span class="pre">
      bnnz
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      rowBlockSize
     </span>
     <span class="pre">
      *
     </span>
     <span class="pre">
      colBlockSize
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bsrRowOffsetsType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Data type of
     <span class="pre">
      bsrRowOffsets
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bsrColIndType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Data type of
     <span class="pre">
      bsrColInd
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      idxBase
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Base index of
     <span class="pre">
      bsrRowOffsets
     </span>
     and
     <span class="pre">
      bsrColInd
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      valueType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Datatype of
     <span class="pre">
      bsrValues
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      order
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Enumerator specifying the memory layout of values in each block
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseCreateBsr()
  </span>
  has the following constraints:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     bsrRowOffsets
    </span>
    ,
    <span class="pre">
     bsrColInd
    </span>
    , and
    <span class="pre">
     bsrValues
    </span>
    must be aligned to the size of the datatypes specified by
    <span class="pre">
     bsrRowOffsetsType
    </span>
    ,
    <span class="pre">
     bsrColIndType
    </span>
    , and
    <span class="pre">
     valueType
    </span>
    , respectively. See
    <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cudadatatype-t">
     cudaDataType_t
    </a>
    for the description of the datatypes.
   </p>
  </li>
 </ul>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   6.5.6.2.
  </span>
  cusparseBsrSetStridedBatch()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsebsrsetstridedbatch" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseBsrSetStridedBatch</span><span class="p">(</span><span class="n">cusparseSpMatDescr_t</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="kt">int</span><span class="n">batchCount</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">offsetsBatchStride</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">columnsBatchStride</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="n">valuesBatchStride</span><span class="p">)</span>
</pre>
 <p>
  This function sets the
  <span class="pre">
   batchCount
  </span>
  and the
  <span class="pre">
   batchStride
  </span>
  fields of the sparse matrix descriptor
  <span class="pre">
   spMatDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      batchCount
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Number of batches of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      offsetsBatchStride
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Address offset between consecutive batches for the row offset array
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      columnsBatchStride
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Address offset between consecutive batches for the column array
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      valuesBatchStride
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Address offset between consecutive batches for the values array
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   6.5.7.
  </span>
  All Sparse Formats
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#all-sparse-formats" title="Permalink to this headline">
   
  </a>
 </h3>
 <h4>
  <span class="section-number">
   6.5.7.1.
  </span>
  cusparseDestroySpMat()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedestroyspmat" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseDestroySpMat</span><span class="p">(</span><span class="n">cusparseConstSpMatDescr_t</span><span class="n">spMatDescr</span><span class="p">)</span><span class="c1">// non-const descriptor supported</span>
</pre>
 <p>
  This function releases the host memory allocated for the sparse matrix descriptor
  <span class="pre">
   spMatDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse matrix descriptor
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   6.5.7.2.
  </span>
  cusparseSpMatGetSize()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespmatgetsize" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpMatGetSize</span><span class="p">(</span><span class="n">cusparseConstSpMatDescr_t</span><span class="n">spMatDescr</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">rows</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">cols</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">nnz</span><span class="p">)</span>
</pre>
 <p>
  This function returns the sizes of the sparse matrix
  <span class="pre">
   spMatDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      rows
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Number of rows of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      cols
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Number of columns of the sparse matrix
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      nnz
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Number of non-zero entries of the sparse matrix
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   6.5.7.3.
  </span>
  cusparseSpMatGetFormat()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespmatgetformat" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpMatGetFormat</span><span class="p">(</span><span class="n">cusparseConstSpMatDescr_t</span><span class="n">spMatDescr</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseFormat_t</span><span class="o">*</span><span class="n">format</span><span class="p">)</span>
</pre>
 <p>
  This function returns the
  <span class="pre">
   format
  </span>
  field of the sparse matrix descriptor
  <span class="pre">
   spMatDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      format
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Storage format of the sparse matrix
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   6.5.7.4.
  </span>
  cusparseSpMatGetIndexBase()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespmatgetindexbase" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpMatGetIndexBase</span><span class="p">(</span><span class="n">cusparseConstSpMatDescr_t</span><span class="n">spMatDescr</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseIndexBase_t</span><span class="o">*</span><span class="n">idxBase</span><span class="p">)</span>
</pre>
 <p>
  This function returns the
  <span class="pre">
   idxBase
  </span>
  field of the sparse matrix descriptor
  <span class="pre">
   spMatDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      idxBase
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Index base of the sparse matrix
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   6.5.7.5.
  </span>
  cusparseSpMatGetValues()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespmatgetvalues" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpMatGetValues</span><span class="p">(</span><span class="n">cusparseSpMatDescr_t</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="kt">void</span><span class="o">**</span><span class="n">values</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseConstSpMatGetValues</span><span class="p">(</span><span class="n">cusparseConstSpMatDescr_t</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">**</span><span class="n">values</span><span class="p">)</span>
</pre>
 <p>
  This function returns the
  <span class="pre">
   values
  </span>
  field of the sparse matrix descriptor
  <span class="pre">
   spMatDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      values
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Values of the sparse matrix. Array with
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   6.5.7.6.
  </span>
  cusparseSpMatSetValues()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespmatsetvalues" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpMatSetValues</span><span class="p">(</span><span class="n">cusparseSpMatDescr_t</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">values</span><span class="p">)</span>
</pre>
 <p>
  This function sets the
  <span class="pre">
   values
  </span>
  field of the sparse matrix descriptor
  <span class="pre">
   spMatDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      values
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Values of the sparse matrix. Array with
     <span class="pre">
      nnz
     </span>
     elements
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseSpMatSetValues()
  </span>
  has the following constraints:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     values
    </span>
    must be aligned to the size of its corresponding datatype specified in
    <span class="pre">
     spMatDescr
    </span>
    . See
    <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cudadatatype-t">
     cudaDataType_t
    </a>
    for the description of the datatypes.
   </p>
  </li>
 </ul>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   6.5.7.7.
  </span>
  cusparseSpMatGetStridedBatch()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespmatgetstridedbatch" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpMatGetStridedBatch</span><span class="p">(</span><span class="n">cusparseConstSpMatDescr_t</span><span class="n">spMatDescr</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="kt">int</span><span class="o">*</span><span class="n">batchCount</span><span class="p">)</span>
</pre>
 <p>
  This function returns the
  <span class="pre">
   batchCount
  </span>
  field of the sparse matrix descriptor
  <span class="pre">
   spMatDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      batchCount
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Number of batches of the sparse matrix
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   6.5.7.8.
  </span>
  cusparseSpMatGetAttribute()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespmatgetattribute" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpMatGetAttribute</span><span class="p">(</span><span class="n">cusparseConstSpMatDescr_t</span><span class="n">spMatDescr</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseSpMatAttribute_t</span><span class="n">attribute</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">data</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">dataSize</span><span class="p">)</span>
</pre>
 <p>
  The function gets the attributes of the sparse matrix descriptor
  <span class="pre">
   spMatDescr
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      attribute
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Attribute enumerator
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      data
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Attribute value
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dataSize
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Size of the attribute in bytes for safety
    </p>
   </td>
  </tr>
 </table>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Attribute
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
   <th class="head">
    <p>
     Possible Values
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPMAT_FILL_MODE
     </span>
    </p>
   </td>
   <td>
    <p>
     Indicates if the lower or upper part of a matrix is stored in sparse storage
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUSPARSE_FILL_MODE_LOWER
     </span>
     
     <span class="pre">
      CUSPARSE_FILL_MODE_UPPER
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPMAT_DIAG_TYPE
     </span>
    </p>
   </td>
   <td>
    <p>
     Indicates if the matrix diagonal entries are unity
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUSPARSE_DIAG_TYPE_NON_UNIT
     </span>
     
     <span class="pre">
      CUSPARSE_DIAG_TYPE_UNIT
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h4>
  <span class="section-number">
   6.5.7.9.
  </span>
  cusparseSpMatSetAttribute()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespmatsetattribute" title="Permalink to this headline">
   
  </a>
 </h4>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpMatSetAttribute</span><span class="p">(</span><span class="n">cusparseSpMatDescr_t</span><span class="n">spMatDescr</span><span class="p">,</span>
<span class="n">cusparseSpMatAttribute_t</span><span class="n">attribute</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">data</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">dataSize</span><span class="p">)</span>
</pre>
 <p>
  The function sets the attributes of the sparse matrix descriptor
  <span class="pre">
   spMatDescr
  </span>
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spMatDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Sparse matrix descriptor
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      attribute
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Attribute enumerator
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      data
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Attribute value
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      dataSize
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Size of the attribute in bytes for safety
    </p>
   </td>
  </tr>
 </table>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Attribute
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
   <th class="head">
    <p>
     Possible Values
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPMAT_FILL_MODE
     </span>
    </p>
   </td>
   <td>
    <p>
     Indicates if the lower or upper part of a matrix is stored in sparse storage
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUSPARSE_FILL_MODE_LOWER
     </span>
     
     <span class="pre">
      CUSPARSE_FILL_MODE_UPPER
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPMAT_DIAG_TYPE
     </span>
    </p>
   </td>
   <td>
    <p>
     Indicates if the matrix diagonal entries are unity
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUSPARSE_DIAG_TYPE_NON_UNIT
     </span>
     
     <span class="pre">
      CUSPARSE_DIAG_TYPE_UNIT
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <span class="pre">
   cusparseStatus_t
  </span>
  for the description of the return status.
 </p>
 <h2>
  <span class="section-number">
   6.6.
  </span>
  Generic API Functions
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#generic-api-functions" title="Permalink to this headline">
   
  </a>
 </h2>
 <h3>
  <span class="section-number">
   6.6.1.
  </span>
  cusparseAxpby()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparseaxpby" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseAxpby</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="n">cusparseConstSpVecDescr_t</span><span class="n">vecX</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="n">cusparseDnVecDescr_t</span><span class="n">vecY</span><span class="p">)</span>
</pre>
 <p>
  The function computes the sum of a sparse vector
  <span class="pre">
   vecX
  </span>
  and a dense vector
  <span class="pre">
   vecY
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\mathbf{Y} = \alpha\mathbf{X} + \beta\mathbf{Y}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  In other words,
 </p>
 <pre><span class="k">for</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="n">to</span><span class="n">n</span><span class="mi">-1</span>
<span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">beta</span><span class="o">*</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="k">for</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="n">to</span><span class="n">nnz</span><span class="mi">-1</span>
<span class="n">Y</span><span class="p">[</span><span class="n">X_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">+=</span><span class="n">alpha</span><span class="o">*</span><span class="n">X_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSPARSE library context
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      alpha
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST or DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\alpha\)
     </span>
     scalar used for multiplication of compute type
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      vecX
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse vector
     <span class="pre">
      X
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      beta
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST or DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\beta\)
     </span>
     scalar used for multiplication of compute type
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      vecY
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN/OUT
    </p>
   </td>
   <td>
    <p>
     Dense vector
     <span class="pre">
      Y
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseAxpby
  </span>
  supports the following index type for representing the sparse vector
  <span class="pre">
   vecX
  </span>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    32-bit indices (
    <span class="pre">
     CUSPARSE_INDEX_32I
    </span>
    )
   </p>
  </li>
  <li>
   <p>
    64-bit indices (
    <span class="pre">
     CUSPARSE_INDEX_64I
    </span>
    )
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseAxpby
  </span>
  supports the following data types:
 </p>
 <p>
  Uniform-precision computation:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      X
     </span>
     /
     <span class="pre">
      Y
     </span>
     /
     <span class="pre">
      compute
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Mixed-precision computation:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      X
     </span>
     /
     <span class="pre">
      Y
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      compute
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
    </p>
   </td>
   <td rowspan="2">
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16BF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_16F
     </span>
    </p>
   </td>
   <td rowspan="2">
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     [DEPRECATED]
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_16BF
     </span>
    </p>
   </td>
   <td>
    <p>
     [DEPRECATED]
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseAxpby()
  </span>
  has the following constraints:
 </p>
 <ul class="simple">
  <li>
   <p>
    The arrays representing the sparse vector
    <span class="pre">
     vecX
    </span>
    must be aligned to 16 bytes
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseAxpby()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    Provides deterministic (bit-wise) results for each run if the the sparse vector
    <span class="pre">
     vecX
    </span>
    indices are distinct
   </p>
  </li>
  <li>
   <p>
    The routine allows
    <span class="pre">
     indices
    </span>
    of
    <span class="pre">
     vecX
    </span>
    to be unsorted
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseAxpby()
  </span>
  supports the following
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#optimization-notes">
   optimizations
  </a>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    CUDA graph capture
   </p>
  </li>
  <li>
   <p>
    Hardware Memory Compression
   </p>
  </li>
 </ul>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSPARSE/axpby">
   cuSPARSE Library Samples - cusparseAxpby
  </a>
  for a code example.
 </p>
 <h3>
  <span class="section-number">
   6.6.2.
  </span>
  cusparseGather()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsegather" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseGather</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseConstDnVecDescr_t</span><span class="n">vecY</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseSpVecDescr_t</span><span class="n">vecX</span><span class="p">)</span>
</pre>
 <p>
  The function gathers the elements of the dense vector
  <span class="pre">
   vecY
  </span>
  into the sparse vector
  <span class="pre">
   vecX
  </span>
 </p>
 <p>
  In other words,
 </p>
 <pre><span class="k">for</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="n">to</span><span class="n">nnz</span><span class="mi">-1</span>
<span class="n">X_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">Y</span><span class="p">[</span><span class="n">X_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
</pre>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSPARSE library context
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      vecX
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Sparse vector
     <span class="pre">
      X
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      vecY
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Dense vector
     <span class="pre">
      Y
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseGather
  </span>
  supports the following index type for representing the sparse vector
  <span class="pre">
   vecX
  </span>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    32-bit indices (
    <span class="pre">
     CUSPARSE_INDEX_32I
    </span>
    )
   </p>
  </li>
  <li>
   <p>
    64-bit indices (
    <span class="pre">
     CUSPARSE_INDEX_64I
    </span>
    )
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseGather
  </span>
  supports the following data types:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      X
     </span>
     /
     <span class="pre">
      Y
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16BF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_16F
     </span>
     [DEPRECATED]
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_16BF
     </span>
     [DEPRECATED]
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseGather()
  </span>
  has the following constraints:
 </p>
 <ul class="simple">
  <li>
   <p>
    The arrays representing the sparse vector
    <span class="pre">
     vecX
    </span>
    must be aligned to 16 bytes
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseGather()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    Provides deterministic (bit-wise) results for each run if the the sparse vector
    <span class="pre">
     vecX
    </span>
    indices are distinct
   </p>
  </li>
  <li>
   <p>
    The routine allows
    <span class="pre">
     indices
    </span>
    of
    <span class="pre">
     vecX
    </span>
    to be unsorted
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseGather()
  </span>
  supports the following
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#optimization-notes">
   optimizations
  </a>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    CUDA graph capture
   </p>
  </li>
  <li>
   <p>
    Hardware Memory Compression
   </p>
  </li>
 </ul>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSPARSE/gather">
   cuSPARSE Library Samples - cusparseGather
  </a>
  for a code example.
 </p>
 <h3>
  <span class="section-number">
   6.6.3.
  </span>
  cusparseScatter()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsescatter" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseScatter</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseConstSpVecDescr_t</span><span class="n">vecX</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseDnVecDescr_t</span><span class="n">vecY</span><span class="p">)</span>
</pre>
 <p>
  The function scatters the elements of the sparse vector
  <span class="pre">
   vecX
  </span>
  into the dense vector
  <span class="pre">
   vecY
  </span>
 </p>
 <p>
  In other words,
 </p>
 <pre><span class="k">for</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="n">to</span><span class="n">nnz</span><span class="mi">-1</span>
<span class="n">Y</span><span class="p">[</span><span class="n">X_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="n">X_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSPARSE library context
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      vecX
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse vector
     <span class="pre">
      X
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      vecY
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Dense vector
     <span class="pre">
      Y
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseScatter
  </span>
  supports the following index type for representing the sparse vector
  <span class="pre">
   vecX
  </span>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    32-bit indices (
    <span class="pre">
     CUSPARSE_INDEX_32I
    </span>
    )
   </p>
  </li>
  <li>
   <p>
    64-bit indices (
    <span class="pre">
     CUSPARSE_INDEX_64I
    </span>
    )
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseScatter
  </span>
  supports the following data types:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      X
     </span>
     /
     <span class="pre">
      Y
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_8I
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16BF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_16F
     </span>
     [DEPRECATED]
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_16BF
     </span>
     [DEPRECATED]
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseScatter()
  </span>
  has the following constraints:
 </p>
 <ul class="simple">
  <li>
   <p>
    The arrays representing the sparse vector
    <span class="pre">
     vecX
    </span>
    must be aligned to 16 bytes
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseScatter()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    Provides deterministic (bit-wise) results for each run if the the sparse vector
    <span class="pre">
     vecX
    </span>
    indices are distinct
   </p>
  </li>
  <li>
   <p>
    The routine allows
    <span class="pre">
     indices
    </span>
    of
    <span class="pre">
     vecX
    </span>
    to be unsorted
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseScatter()
  </span>
  supports the following
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#optimization-notes">
   optimizations
  </a>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    CUDA graph capture
   </p>
  </li>
  <li>
   <p>
    Hardware Memory Compression
   </p>
  </li>
 </ul>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSPARSE/scatter">
   cuSPARSE Library Samples - cusparseScatter
  </a>
  for a code example.
 </p>
 <h3>
  <span class="section-number">
   6.6.4.
  </span>
  cusparseRot() [DEPRECATED]
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparserot-deprecated" title="Permalink to this headline">
   
  </a>
 </h3>
 <p>
  &gt;
  The routine will be removed in the next major release
 </p>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseRot</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">c_coeff</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">s_coeff</span><span class="p">,</span>
<span class="n">cusparseSpVecDescr_t</span><span class="n">vecX</span><span class="p">,</span>
<span class="n">cusparseDnVecDescr_t</span><span class="n">vecY</span><span class="p">)</span>
</pre>
 <p>
  The function computes the Givens rotation matrix
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(G = \begin{bmatrix}
c &amp; s \\
{- s} &amp; c \\
\end{bmatrix}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  to a sparse
  <span class="pre">
   vecX
  </span>
  and a dense vector
  <span class="pre">
   vecY
  </span>
 </p>
 <p>
  In other words,
 </p>
 <pre><span class="k">for</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="n">to</span><span class="n">nnz</span><span class="mi">-1</span>
<span class="n">Y</span><span class="p">[</span><span class="n">X_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="n">c</span><span class="o">*</span><span class="n">Y</span><span class="p">[</span><span class="n">X_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">-</span><span class="n">s</span><span class="o">*</span><span class="n">X_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="n">X_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">c</span><span class="o">*</span><span class="n">X_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">s</span><span class="o">*</span><span class="n">Y</span><span class="p">[</span><span class="n">X_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
</pre>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSPARSE library context
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      c_coeff
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST or DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     cosine element of the rotation matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      vecX
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN/OUT
    </p>
   </td>
   <td>
    <p>
     Sparse vector
     <span class="pre">
      X
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      s_coeff
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST or DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     sine element of the rotation matrix
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      vecY
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN/OUT
    </p>
   </td>
   <td>
    <p>
     Dense vector
     <span class="pre">
      Y
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseRot
  </span>
  supports the following index type for representing the sparse vector
  <span class="pre">
   vecX
  </span>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    32-bit indices (
    <span class="pre">
     CUSPARSE_INDEX_32I
    </span>
    )
   </p>
  </li>
  <li>
   <p>
    64-bit indices (
    <span class="pre">
     CUSPARSE_INDEX_64I
    </span>
    )
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseRot
  </span>
  supports the following data types:
 </p>
 <p>
  Uniform-precision computation:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      X
     </span>
     /
     <span class="pre">
      Y
     </span>
     /
     <span class="pre">
      compute
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Mixed-precision computation:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      X
     </span>
     /
     <span class="pre">
      Y
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      compute
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
    </p>
   </td>
   <td rowspan="2">
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16BF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_16F
     </span>
    </p>
   </td>
   <td rowspan="2">
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     [DEPRECATED]
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_16BF
     </span>
    </p>
   </td>
   <td>
    <p>
     [DEPRECATED]
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseRot()
  </span>
  has the following constraints:
 </p>
 <ul class="simple">
  <li>
   <p>
    The arrays representing the sparse vector
    <span class="pre">
     vecX
    </span>
    must be aligned to 16 bytes
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseRot()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    Provides deterministic (bit-wise) results for each run if the the sparse vector
    <span class="pre">
     vecX
    </span>
    indices are distinct
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseRot()
  </span>
  supports the following
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#optimization-notes">
   optimizations
  </a>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    CUDA graph capture
   </p>
  </li>
  <li>
   <p>
    Hardware Memory Compression
   </p>
  </li>
 </ul>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSPARSE/rot">
   cuSPARSE Library Samples - cusparseRot
  </a>
  for a code example.
 </p>
 <h3>
  <span class="section-number">
   6.6.5.
  </span>
  cusparseSpVV()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespvv" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpVV_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opX</span><span class="p">,</span>
<span class="n">cusparseConstSpVecDescr_t</span><span class="n">vecX</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseConstDnVecDescr_t</span><span class="n">vecY</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="kt">void</span><span class="o">*</span><span class="n">result</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSize</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpVV</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opX</span><span class="p">,</span>
<span class="n">cusparseConstSpVecDescr_t</span><span class="n">vecX</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseConstDnVecDescr_t</span><span class="n">vecY</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="kt">void</span><span class="o">*</span><span class="n">result</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">externalBuffer</span><span class="p">)</span>
</pre>
 <p>
  The function computes the inner dot product of a sparse vector
  <span class="pre">
   vecX
  </span>
  and a dense vector
  <span class="pre">
   vecY
  </span>
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(result = op\left(\mathbf{X}\right) \cdot \mathbf{Y}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  In other words,
 </p>
 <pre><span class="n">result</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="n">to</span><span class="n">nnz</span><span class="mi">-1</span>
<span class="n">result</span><span class="o">+=</span><span class="n">op</span><span class="p">(</span><span class="n">X_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="n">Y</span><span class="p">[</span><span class="n">X_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
</pre>
 <p>
  <span class="math notranslate nohighlight">
   \(\text{op}(X) = \begin{cases}
X &amp; \text{if op(X) == CUSPARSE_OPERATION_NON_TRANSPOSE} \\
\overline{X} &amp; \text{if op(X) == CUSPARSE_OPERATION_CONJUGATE_TRANSPOSE} \\
\end{cases}\)
  </span>
 </p>
 <p>
  The function
  <span class="pre">
   cusparseSpVV_bufferSize()
  </span>
  returns the size of the workspace needed by
  <span class="pre">
   cusparseSpVV()
  </span>
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSPARSE library context
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      opX
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Operation
     <span class="pre">
      op(X)
     </span>
     that is non-transpose or conjugate transpose
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      vecX
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse vector
     <span class="pre">
      X
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      vecY
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Dense vector
     <span class="pre">
      Y
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      result
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST or DEVICE
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     The resulting dot product
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Datatype in which the computation is executed
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bufferSize
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Number of bytes of workspace needed by
     <span class="pre">
      cusparseSpVV
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      externalBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Pointer to a workspace buffer of at least
     <span class="pre">
      bufferSize
     </span>
     bytes
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseSpVV
  </span>
  supports the following index type for representing the sparse vector
  <span class="pre">
   vecX
  </span>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    32-bit indices (
    <span class="pre">
     CUSPARSE_INDEX_32I
    </span>
    )
   </p>
  </li>
  <li>
   <p>
    64-bit indices (
    <span class="pre">
     CUSPARSE_INDEX_64I
    </span>
    )
   </p>
  </li>
 </ul>
 <p>
  The data types combinations currently supported for
  <span class="pre">
   cusparseSpVV
  </span>
  are listed below:
 </p>
 <p>
  Uniform-precision computation:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      X
     </span>
     /
     <span class="pre">
      Y
     </span>
     /
     <span class="pre">
      computeType
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Mixed-precision computation:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      X
     </span>
     /
     <span class="pre">
      Y
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      computeType
     </span>
     /
     <span class="pre">
      result
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     Notes
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_8I
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32I
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_8I
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16BF
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_16F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     [DEPRECATED]
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_16BF
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     [DEPRECATED]
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseSpVV()
  </span>
  has the following constraints:
 </p>
 <ul class="simple">
  <li>
   <p>
    The arrays representing the sparse vector
    <span class="pre">
     vecX
    </span>
    must be aligned to 16 bytes
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseSpVV()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    Provides deterministic (bit-wise) results for each run if the the sparse vector
    <span class="pre">
     vecX
    </span>
    indices are distinct
   </p>
  </li>
  <li>
   <p>
    The routine allows
    <span class="pre">
     indices
    </span>
    of
    <span class="pre">
     vecX
    </span>
    to be unsorted
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseSpVV()
  </span>
  supports the following
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#optimization-notes">
   optimizations
  </a>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    CUDA graph capture
   </p>
  </li>
  <li>
   <p>
    Hardware Memory Compression
   </p>
  </li>
 </ul>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSPARSE/spvv">
   cuSPARSE Library Samples - cusparseSpVV
  </a>
  for a code example.
 </p>
 <h3>
  <span class="section-number">
   6.6.6.
  </span>
  cusparseSpMV()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespmv" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpMV_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="n">cusparseConstSpMatDescr_t</span><span class="n">matA</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseConstDnVecDescr_t</span><span class="n">vecX</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="n">cusparseDnVecDescr_t</span><span class="n">vecY</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="n">cusparseSpMVAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSize</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpMV_preprocess</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="n">cusparseConstSpMatDescr_t</span><span class="n">matA</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseConstDnVecDescr_t</span><span class="n">vecX</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="n">cusparseDnVecDescr_t</span><span class="n">vecY</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="n">cusparseSpMVAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">externalBuffer</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpMV</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="n">cusparseConstSpMatDescr_t</span><span class="n">matA</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseConstDnVecDescr_t</span><span class="n">vecX</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="n">cusparseDnVecDescr_t</span><span class="n">vecY</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="n">cusparseSpMVAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">externalBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function performs the multiplication of a sparse matrix
  <span class="pre">
   matA
  </span>
  and a dense vector
  <span class="pre">
   vecX
  </span>
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\mathbf{Y} = \alpha op\left( \mathbf{A} \right) \cdot \mathbf{X} + \beta\mathbf{Y}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     op(A)
    </span>
    is a sparse matrix of size
    <span class="math notranslate nohighlight">
     \(m \times k\)
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     X
    </span>
    is a dense vector of size
    <span class="math notranslate nohighlight">
     \(k\)
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     Y
    </span>
    is a dense vector of size
    <span class="math notranslate nohighlight">
     \(m\)
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="math notranslate nohighlight">
     \(\alpha\)
    </span>
    and
    <span class="math notranslate nohighlight">
     \(\beta\)
    </span>
    are scalars
   </p>
  </li>
 </ul>
 <p>
  Also, for matrix
  <span class="pre">
   A
  </span>
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(\text{op}(A) == \begin{cases}
A &amp; \text{if op(A) == CUSPARSE_OPERATION_NON_TRANSPOSE} \\
A^{T} &amp; \text{if op(A) == CUSPARSE_OPERATION_TRANSPOSE} \\
A^{H} &amp; \text{if op(A) ==CUSPARSE_OPERATION_CONJUGATE_TRANSPOSE} \\
\end{cases}\)
  </span>
 </p>
 <p>
  The function
  <span class="pre">
   cusparseSpMV_bufferSize()
  </span>
  returns the size of the workspace needed by
  <span class="pre">
   cusparseSpMV_preprocess()
  </span>
  and
  <span class="pre">
   cusparseSpMV()
  </span>
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSPARSE library context
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      opA
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Operation
     <span class="pre">
      op(A)
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      alpha
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST or DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\alpha\)
     </span>
     scalar used for multiplication of type
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      matA
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse matrix
     <span class="pre">
      A
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      vecX
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Dense vector
     <span class="pre">
      X
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      beta
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST or DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\beta\)
     </span>
     scalar used for multiplication of type
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      vecY
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN/OUT
    </p>
   </td>
   <td>
    <p>
     Dense vector
     <span class="pre">
      Y
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Datatype in which the computation is executed
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      alg
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Algorithm for the computation
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bufferSize
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Number of bytes of workspace needed by
     <span class="pre">
      cusparseSpMV
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      externalBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Pointer to a workspace buffer of at least
     <span class="pre">
      bufferSize
     </span>
     bytes
    </p>
   </td>
  </tr>
 </table>
 <p>
  The sparse matrix formats currently supported are listed below:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     CUSPARSE_FORMAT_COO
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     CUSPARSE_FORMAT_CSR
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     CUSPARSE_FORMAT_CSC
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     CUSPARSE_FORMAT_SLICED_ELL
    </span>
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseSpMV
  </span>
  supports the following index type for representing the sparse matrix
  <span class="pre">
   matA
  </span>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    32-bit indices (
    <span class="pre">
     CUSPARSE_INDEX_32I
    </span>
    )
   </p>
  </li>
  <li>
   <p>
    64-bit indices (
    <span class="pre">
     CUSPARSE_INDEX_64I
    </span>
    )
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseSpMV
  </span>
  supports the following data types:
 </p>
 <p>
  Uniform-precision computation:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      A
     </span>
     /
     <span class="pre">
      X
     </span>
     /
     <span class="pre">
      Y
     </span>
     /
     <span class="pre">
      computeType
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Mixed-precision computation:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      A
     </span>
     /
     <span class="pre">
      X
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      Y
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     Notes
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_8I
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32I
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32I
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_8I
     </span>
    </p>
   </td>
   <td rowspan="3">
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td rowspan="5">
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16BF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16BF
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_16BF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td rowspan="3">
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_16F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_16F
     </span>
    </p>
   </td>
   <td>
    <p>
     [DEPRECATED]
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_16BF
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_16BF
     </span>
    </p>
   </td>
   <td>
    <p>
     [DEPRECATED]
    </p>
   </td>
  </tr>
 </table>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      X
     </span>
     /
     <span class="pre">
      Y
     </span>
     /
     <span class="pre">
      computeType
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Mixed Regular/Complex computation:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      A
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      X
     </span>
     /
     <span class="pre">
      Y
     </span>
     /
     <span class="pre">
      computeType
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  NOTE:
  <span class="pre">
   CUDA_R_16F
  </span>
  ,
  <span class="pre">
   CUDA_R_16BF
  </span>
  ,
  <span class="pre">
   CUDA_C_16F
  </span>
  , and
  <span class="pre">
   CUDA_C_16BF
  </span>
  data types always imply mixed-precision computation.
 </p>
 <p>
  <span class="pre">
   cusparseSpMV()
  </span>
  supports the following algorithms:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Algorithm
    </p>
   </th>
   <th class="head">
    <p>
     Notes
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPMV_ALG_DEFAULT
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm for any sparse matrix format.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPMV_COO_ALG1
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm for COO sparse matrix format. May produce slightly different results during different runs with the same input parameters.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPMV_COO_ALG2
     </span>
    </p>
   </td>
   <td>
    <p>
     Provides deterministic (bit-wise) results for each run. If
     <span class="pre">
      opA
     </span>
     <span class="pre">
      !=
     </span>
     <span class="pre">
      CUSPARSE_OPERATION_NON_TRANSPOSE
     </span>
     , it is identical to
     <span class="pre">
      CUSPARSE_SPMV_COO_ALG1
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPMV_CSR_ALG1
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm for CSR/CSC sparse matrix format. May produce slightly different results during different runs with the same input parameters.
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPMV_CSR_ALG2
     </span>
    </p>
   </td>
   <td>
    <p>
     Provides deterministic (bit-wise) results for each run. If
     <span class="pre">
      opA
     </span>
     <span class="pre">
      !=
     </span>
     <span class="pre">
      CUSPARSE_OPERATION_NON_TRANSPOSE
     </span>
     , it is identical to
     <span class="pre">
      CUSPARSE_SPMV_CSR_ALG1
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPMV_SELL_ALG1
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm for Sliced Ellpack sparse matrix format. Provides deterministic (bit-wise) results for each run.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Performance notes:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     CUSPARSE_SPMV_COO_ALG1
    </span>
    and
    <span class="pre">
     CUSPARSE_SPMV_CSR_ALG1
    </span>
    provide higher performance than
    <span class="pre">
     CUSPARSE_SPMV_COO_ALG2
    </span>
    and
    <span class="pre">
     CUSPARSE_SPMV_CSR_ALG2
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    In general,
    <span class="pre">
     opA
    </span>
    <span class="pre">
     ==
    </span>
    <span class="pre">
     CUSPARSE_OPERATION_NON_TRANSPOSE
    </span>
    is 3x faster than
    <span class="pre">
     opA
    </span>
    <span class="pre">
     !=
    </span>
    <span class="pre">
     CUSPARSE_OPERATION_NON_TRANSPOSE
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    Using
    <span class="pre">
     cusparseSpMV_preprocess()
    </span>
    helps improve performance of
    <span class="pre">
     cusparseSpMV()
    </span>
    in CSR. It is beneficial when we need to run
    <span class="pre">
     cusparseSpMV()
    </span>
    multiple times with a same matrix (
    <span class="pre">
     cusparseSpMV_preprocess()
    </span>
    is executed only once).
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseSpMV()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires extra storage for CSR/CSC format (all algorithms) and for COO format with
    <span class="pre">
     CUSPARSE_SPMV_COO_ALG2
    </span>
    algorithm.
   </p>
  </li>
  <li>
   <p>
    Provides deterministic (bit-wise) results for each run only for
    <span class="pre">
     CUSPARSE_SPMV_COO_ALG2
    </span>
    and
    <span class="pre">
     CUSPARSE_SPMV_CSR_ALG2
    </span>
    algorithms, and
    <span class="pre">
     opA
    </span>
    <span class="pre">
     ==
    </span>
    <span class="pre">
     CUSPARSE_OPERATION_NON_TRANSPOSE
    </span>
    .
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution.
   </p>
  </li>
  <li>
   <p>
    compute-sanitizer could report false race conditions for this routine when
    <span class="pre">
     beta
    </span>
    <span class="pre">
     ==
    </span>
    <span class="pre">
     0
    </span>
    . This is for optimization purposes and does not affect the correctness of the computation.
   </p>
  </li>
  <li>
   <p>
    The routine allows the indices of
    <span class="pre">
     matA
    </span>
    to be unsorted.
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseSpMV()
  </span>
  supports the following
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#optimization-notes">
   optimizations
  </a>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    CUDA graph capture
   </p>
  </li>
  <li>
   <p>
    Hardware Memory Compression
   </p>
  </li>
 </ul>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSPARSE/spmv_csr">
   cuSPARSE Library Samples - cusparseSpMV CSR
  </a>
  and
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSPARSE/spmv_coo">
   cusparseSpMV COO
  </a>
  for a code example.
 </p>
 <h3>
  <span class="section-number">
   6.6.7.
  </span>
  cusparseSpSV()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespsv" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="nf">cusparseSpSV_createDescr</span><span class="p">(</span><span class="n">cusparseSpSVDescr_t</span><span class="o">*</span><span class="n">spsvDescr</span><span class="p">);</span>

<span class="n">cusparseStatus_t</span>
<span class="nf">cusparseSpSV_destroyDescr</span><span class="p">(</span><span class="n">cusparseSpSVDescr_t</span><span class="n">spsvDescr</span><span class="p">);</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpSV_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="n">cusparseConstSpMatDescr_t</span><span class="n">matA</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseConstDnVecDescr_t</span><span class="n">vecX</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseDnVecDescr_t</span><span class="n">vecY</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="n">cusparseSpSVAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="n">cusparseSpSVDescr_t</span><span class="n">spsvDescr</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSize</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpSV_analysis</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="n">cusparseConstSpMatDescr_t</span><span class="n">matA</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseConstDnVecDescr_t</span><span class="n">vecX</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseDnVecDescr_t</span><span class="n">vecY</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="n">cusparseSpSVAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="n">cusparseSpSVDescr_t</span><span class="n">spsvDescr</span>
<span class="kt">void</span><span class="o">*</span><span class="n">externalBuffer</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpSV_solve</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opA</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="n">cusparseConstSpMatDescr_t</span><span class="n">matA</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseConstDnVecDescr_t</span><span class="n">vecX</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseDnVecDescr_t</span><span class="n">vecY</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="n">cusparseSpSVAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="n">cusparseSpSVDescr_t</span><span class="n">spsvDescr</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpSV_updateMatrix</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseSpSVDescr_t</span><span class="n">spsvDescr</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">newValues</span><span class="p">,</span>
<span class="n">cusparseSpSVUpdate_t</span><span class="n">updatePart</span><span class="p">)</span>
</pre>
 <p>
  The function solves a system of linear equations whose coefficients are represented in a sparse triangular matrix:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(op\left( \mathbf{A} \right) \cdot \mathbf{Y} = \alpha\mathbf{X}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     op(A)
    </span>
    is a sparse square matrix of size
    <span class="math notranslate nohighlight">
     \(m \times m\)
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     X
    </span>
    is a dense vector of size
    <span class="math notranslate nohighlight">
     \(m\)
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     Y
    </span>
    is a dense vector of size
    <span class="math notranslate nohighlight">
     \(m\)
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="math notranslate nohighlight">
     \(\alpha\)
    </span>
    is a scalar
   </p>
  </li>
 </ul>
 <p>
  Also, for matrix
  <span class="pre">
   A
  </span>
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(\text{op}(A) = \begin{cases}
A &amp; \text{if op(A) == CUSPARSE_OPERATION_NON_TRANSPOSE} \\
A^{T} &amp; \text{if op(A) == CUSPARSE_OPERATION_TRANSPOSE} \\
A^{H} &amp; \text{if op(A) == CUSPARSE_OPERATION_CONJUGATE_TRANSPOSE} \\
\end{cases}\)
  </span>
 </p>
 <p>
  The function
  <span class="pre">
   cusparseSpSV_bufferSize()
  </span>
  returns the size of the workspace needed by
  <span class="pre">
   cusparseSpSV_analysis()
  </span>
  and
  <span class="pre">
   cusparseSpSV_solve()
  </span>
  .
The function
  <span class="pre">
   cusparseSpSV_analysis()
  </span>
  performs the analysis phase, while
  <span class="pre">
   cusparseSpSV_solve()
  </span>
  executes the solve phase for a sparse triangular linear system.
The opaque data structure
  <span class="pre">
   spsvDescr
  </span>
  is used to share information among all functions.
The function
  <span class="pre">
   cusparseSpSV_updateMatrix()
  </span>
  updates
  <span class="pre">
   spsvDescr
  </span>
  with new matrix values.
 </p>
 <p>
  The routine supports arbitrary sparsity for the input matrix, but only the upper or lower triangular part is taken into account in the computation.
 </p>
 <p>
  NOTE:
  all parameters must be consistent across
  <span class="pre">
   cusparseSpSV
  </span>
  API calls and the matrix descriptions and
  <span class="pre">
   externalBuffer
  </span>
  must not be modified between
  <span class="pre">
   cusparseSpSV_analysis()
  </span>
  and
  <span class="pre">
   cusparseSpSV_solve()
  </span>
  . The function
  <span class="pre">
   cusparseSpSV_updateMatrix()
  </span>
  can be used to update the values on the sparse matrix stored inside the opaque data structure
  <span class="pre">
   spsvDescr
  </span>
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSPARSE library context
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      opA
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Operation
     <span class="pre">
      op(A)
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      alpha
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST or DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\alpha\)
     </span>
     scalar used for multiplication of type
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      matA
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse matrix
     <span class="pre">
      A
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      vecX
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Dense vector
     <span class="pre">
      X
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      vecY
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN/OUT
    </p>
   </td>
   <td>
    <p>
     Dense vector
     <span class="pre">
      Y
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Datatype in which the computation is executed
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      alg
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Algorithm for the computation
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bufferSize
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Number of bytes of workspace needed by
     <span class="pre">
      cusparseSpSV_analysis()
     </span>
     and
     <span class="pre">
      cusparseSpSV_solve()
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      externalBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN/OUT
    </p>
   </td>
   <td>
    <p>
     Pointer to a workspace buffer of at least
     <span class="pre">
      bufferSize
     </span>
     bytes. It is used by
     <span class="pre">
      cusparseSpSV_analysis
     </span>
     and
     <span class="pre">
      cusparseSpSV_solve()
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spsvDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN/OUT
    </p>
   </td>
   <td>
    <p>
     Opaque descriptor for storing internal data used across the three steps
    </p>
   </td>
  </tr>
 </table>
 <p>
  The sparse matrix formats currently supported are listed below:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     CUSPARSE_FORMAT_CSR
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     CUSPARSE_FORMAT_COO
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     CUSPARSE_FORMAT_SLICED_ELL
    </span>
   </p>
  </li>
 </ul>
 <p>
  The
  <span class="pre">
   cusparseSpSV()
  </span>
  supports the following shapes and properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     CUSPARSE_FILL_MODE_LOWER
    </span>
    and
    <span class="pre">
     CUSPARSE_FILL_MODE_UPPER
    </span>
    fill modes
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     CUSPARSE_DIAG_TYPE_NON_UNIT
    </span>
    and
    <span class="pre">
     CUSPARSE_DIAG_TYPE_UNIT
    </span>
    diagonal types
   </p>
  </li>
 </ul>
 <p>
  The fill mode and diagonal type can be set by
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespmatsetattribute">
   cusparseSpMatSetAttribute()
  </a>
 </p>
 <p>
  <span class="pre">
   cusparseSpSV()
  </span>
  supports the following index type for representing the sparse matrix
  <span class="pre">
   matA
  </span>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    32-bit indices (
    <span class="pre">
     CUSPARSE_INDEX_32I
    </span>
    )
   </p>
  </li>
  <li>
   <p>
    64-bit indices (
    <span class="pre">
     CUSPARSE_INDEX_64I
    </span>
    )
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseSpSV()
  </span>
  supports the following data types:
 </p>
 <p>
  Uniform-precision computation:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      A
     </span>
     /
     <span class="pre">
      X
     </span>
     /
     <span class="pre">
      Y
     </span>
     /
     <span class="pre">
      computeType
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseSpSV()
  </span>
  supports the following algorithms:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Algorithm
    </p>
   </th>
   <th class="head">
    <p>
     Notes
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPSV_ALG_DEFAULT
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseSpSV()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires extra storage for the analysis phase which is proportional to number of non-zero entries of the sparse matrix
   </p>
  </li>
  <li>
   <p>
    Provides deterministic (bit-wise) results for each run for the solving phase
    <span class="pre">
     cusparseSpSV_solve()
    </span>
   </p>
  </li>
  <li>
   <p>
    The routine supports in-place operation
   </p>
  </li>
  <li>
   <p>
    The
    <span class="pre">
     cusparseSpSV_solve()
    </span>
    routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     cusparseSpSV_bufferSize()
    </span>
    and
    <span class="pre">
     cusparseSpSV_analysis()
    </span>
    routines accept
    <span class="pre">
     NULL
    </span>
    for
    <span class="pre">
     vecX
    </span>
    and
    <span class="pre">
     vecY
    </span>
   </p>
  </li>
  <li>
   <p>
    The routine allows the indices of
    <span class="pre">
     matA
    </span>
    to be unsorted
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseSpSV()
  </span>
  supports the following
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#optimization-notes">
   optimizations
  </a>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    CUDA graph capture
   </p>
  </li>
  <li>
   <p>
    Hardware Memory Compression
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseSpSV_updateMatrix()
  </span>
  updates the sparse matrix after calling the analysis phase. This functions supports the following update strategies (
  <span class="pre">
   updatePart
  </span>
  ):
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Strategy
    </p>
   </th>
   <th class="head">
    <p>
     Notes
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPSV_UPDATE_GENERAL
     </span>
    </p>
   </td>
   <td>
    <p>
     Updates the sparse matrix values with values of
     <span class="pre">
      newValues
     </span>
     array
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPSV_UPDATE_DIAGONAL
     </span>
    </p>
   </td>
   <td>
    <p>
     Updates the diagonal part of the matrix with diagonal values stored in
     <span class="pre">
      newValues
     </span>
     array. That is,
     <span class="pre">
      newValues
     </span>
     has the new diagonal values only
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSPARSE/spsv_csr">
   cuSPARSE Library Samples - cusparseSpSV CSR
  </a>
  and
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSPARSE/spsv_coo">
   cuSPARSE Library Samples - cusparseSpSV COO
  </a>
  for code examples.
 </p>
 <h3>
  <span class="section-number">
   6.6.8.
  </span>
  cusparseSpMM()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespmm" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpMM_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="n">cusparseConstSpMatDescr_t</span><span class="n">matA</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseConstDnMatDescr_t</span><span class="n">matB</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="n">cusparseDnMatDescr_t</span><span class="n">matC</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="n">cusparseSpMMAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSize</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpMM_preprocess</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="n">cusparseConstSpMatDescr_t</span><span class="n">matA</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseConstDnMatDescr_t</span><span class="n">matB</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="n">cusparseDnMatDescr_t</span><span class="n">matC</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="n">cusparseSpMMAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">externalBuffer</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpMM</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="n">cusparseConstSpMatDescr_t</span><span class="n">matA</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseConstDnMatDescr_t</span><span class="n">matB</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="n">cusparseDnMatDescr_t</span><span class="n">matC</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="n">cusparseSpMMAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">externalBuffer</span><span class="p">)</span>
</pre>
 <p>
  The function performs the multiplication of a sparse matrix
  <span class="pre">
   matA
  </span>
  and a dense matrix
  <span class="pre">
   matB
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\mathbf{C} = \alpha op\left( \mathbf{A} \right) \cdot op\left( \mathbf{B} \right) + \beta\mathbf{C}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     op(A)
    </span>
    is a sparse matrix of size
    <span class="math notranslate nohighlight">
     \(m \times k\)
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     op(B)
    </span>
    is a dense matrix of size
    <span class="math notranslate nohighlight">
     \(k \times n\)
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     C
    </span>
    is a dense matrix of size
    <span class="math notranslate nohighlight">
     \(m \times n\)
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="math notranslate nohighlight">
     \(\alpha\)
    </span>
    and
    <span class="math notranslate nohighlight">
     \(\beta\)
    </span>
    are scalars
   </p>
  </li>
 </ul>
 <p>
  The routine can be also used to perform the multiplication of a dense matrix and a sparse matrix by switching the dense matrices layout:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\begin{array}{l}
\left. \mathbf{C}_{C} = \mathbf{B}_{C} \cdot \mathbf{A} + \beta\mathbf{C}_{C}\rightarrow \right. \\
{\mathbf{C}_{R} = \mathbf{A}^{T} \cdot \mathbf{B}_{R} + \beta\mathbf{C}_{R}} \\
\end{array}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="math notranslate nohighlight">
   \(\mathbf{B}_{C}\)
  </span>
  ,
  <span class="math notranslate nohighlight">
   \(\mathbf{C}_{C}\)
  </span>
  indicate column-major layout, while
  <span class="math notranslate nohighlight">
   \(\mathbf{B}_{R}\)
  </span>
  ,
  <span class="math notranslate nohighlight">
   \(\mathbf{C}_{R}\)
  </span>
  refer to row-major layout
 </p>
 <p>
  Also, for matrix
  <span class="pre">
   A
  </span>
  and
  <span class="pre">
   B
  </span>
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(\text{op}(A) = \begin{cases}
A &amp; \text{if op(A) == CUSPARSE_OPERATION_NON_TRANSPOSE} \\
A^{T} &amp; \text{if op(A) == CUSPARSE_OPERATION_TRANSPOSE} \\
A^{H} &amp; \text{if op(A) == CUSPARSE_OPERATION_CONJUGATE_TRANSPOSE} \\
\end{cases}\)
  </span>
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(\text{op}(B) = \begin{cases}
B &amp; \text{if op(B) == CUSPARSE_OPERATION_NON_TRANSPOSE} \\
B^{T} &amp; \text{if op(B) == CUSPARSE_OPERATION_TRANSPOSE} \\
B^{H} &amp; \text{if op(B) == CUSPARSE_OPERATION_CONJUGATE_TRANSPOSE} \\
\end{cases}\)
  </span>
 </p>
 <p>
  When using the (conjugate) transpose of the sparse matrix
  <span class="pre">
   A
  </span>
  , this routine may produce slightly different results during different runs with the same input parameters.
 </p>
 <p>
  The function
  <span class="pre">
   cusparseSpMM_bufferSize()
  </span>
  returns the size of the workspace needed by
  <span class="pre">
   cusparseSpMM()
  </span>
 </p>
 <p>
  The function
  <span class="pre">
   cusparseSpMM_preprocess()
  </span>
  can be called before
  <span class="pre">
   cusparseSpMM
  </span>
  to speedup the actual computation. It is useful when
  <span class="pre">
   cusparseSpMM
  </span>
  is called multiple times with the same sparsity pattern (
  <span class="pre">
   matA
  </span>
  ). The values of the matrices (
  <span class="pre">
   matA
  </span>
  ,
  <span class="pre">
   matB
  </span>
  ,
  <span class="pre">
   matC
  </span>
  ) can change arbitrarily. It provides performance advantages is used with
  <span class="pre">
   CUSPARSE_SPMM_CSR_ALG1
  </span>
  or
  <span class="pre">
   CUSPARSE_SPMM_CSR_ALG3
  </span>
  . For all other formats and algorithms have no effect.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSPARSE library context
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      opA
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Operation
     <span class="pre">
      op(A)
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      opB
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Operation
     <span class="pre">
      op(B)
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      alpha
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST or DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\alpha\)
     </span>
     scalar used for multiplication of type
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      matA
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse matrix
     <span class="pre">
      A
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      matB
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Dense matrix
     <span class="pre">
      B
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      beta
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST or DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\beta\)
     </span>
     scalar used for multiplication of type
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      matC
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN/OUT
    </p>
   </td>
   <td>
    <p>
     Dense matrix
     <span class="pre">
      C
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Datatype in which the computation is executed
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      alg
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Algorithm for the computation
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bufferSize
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Number of bytes of workspace needed by
     <span class="pre">
      cusparseSpMM
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      externalBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Pointer to workspace buffer of at least
     <span class="pre">
      bufferSize
     </span>
     bytes
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseSpMM
  </span>
  supports the following sparse matrix formats:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     CUSPARSE_FORMAT_COO
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     CUSPARSE_FORMAT_CSR
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     CUSPARSE_FORMAT_CSC
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     CUSPARSE_FORMAT_BSR
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     CUSPARSE_FORMAT_BLOCKED_ELL
    </span>
   </p>
  </li>
 </ul>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     (1)
    </p>
   </td>
   <td>
    <p>
     COO/CSR/CSC/BSR FORMATS
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseSpMM
  </span>
  supports the following index type for representing the sparse matrix
  <span class="pre">
   matA
  </span>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    32-bit indices (
    <span class="pre">
     CUSPARSE_INDEX_32I
    </span>
    )
   </p>
  </li>
  <li>
   <p>
    64-bit indices (
    <span class="pre">
     CUSPARSE_INDEX_64I
    </span>
    )
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseSpMM
  </span>
  supports the following data types:
 </p>
 <p>
  Uniform-precision computation:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      A
     </span>
     /
     <span class="pre">
      B
     </span>
     /
     <span class="pre">
      C
     </span>
     /
     <span class="pre">
      computeType
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Mixed-precision computation:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      A
     </span>
     /
     <span class="pre">
      B
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      C
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_8I
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32I
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32I
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_8I
     </span>
    </p>
   </td>
   <td rowspan="3">
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td rowspan="5">
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16BF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16BF
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_16BF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_16F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_16F
     </span>
    </p>
   </td>
   <td rowspan="2">
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     [DEPRECATED]
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_16BF
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_C_16BF
     </span>
    </p>
   </td>
   <td>
    <p>
     [DEPRECATED]
    </p>
   </td>
  </tr>
 </table>
 <p>
  NOTE:
  <span class="pre">
   CUDA_R_16F
  </span>
  ,
  <span class="pre">
   CUDA_R_16BF
  </span>
  ,
  <span class="pre">
   CUDA_C_16F
  </span>
  , and
  <span class="pre">
   CUDA_C_16BF
  </span>
  data types always imply mixed-precision computation.
 </p>
 <p>
  <span class="pre">
   cusparseSpMM
  </span>
  supports the following algorithms:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Algorithm
    </p>
   </th>
   <th class="head">
    <p>
     Notes
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPMM_ALG_DEFAULT
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm for any sparse matrix format
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPMM_COO_ALG1
     </span>
    </p>
   </td>
   <td>
    <p>
     Algorithm 1 for COO sparse matrix format
    </p>
    <ul class="simple">
     <li>
      <p>
       May provide better performance for small number of nnz
      </p>
     </li>
     <li>
      <p>
       Provides the best performance with column-major layout
      </p>
     </li>
     <li>
      <p>
       It supports batched computation
      </p>
     </li>
     <li>
      <p>
       May produce slightly different results during different runs with the same input parameters
      </p>
     </li>
    </ul>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPMM_COO_ALG2
     </span>
    </p>
   </td>
   <td>
    <p>
     Algorithm 2 for COO sparse matrix format
    </p>
    <ul class="simple">
     <li>
      <p>
       It provides deterministic result
      </p>
     </li>
     <li>
      <p>
       Provides the best performance with column-major layout
      </p>
     </li>
     <li>
      <p>
       In general, slower than Algorithm 1
      </p>
     </li>
     <li>
      <p>
       It supports batched computation
      </p>
     </li>
     <li>
      <p>
       It requires additional memory
      </p>
     </li>
     <li>
      <p>
       If
       <span class="pre">
        opA
       </span>
       <span class="pre">
        !=
       </span>
       <span class="pre">
        CUSPARSE_OPERATION_NON_TRANSPOSE
       </span>
       , it is identical to
       <span class="pre">
        CUSPARSE_SPMM_COO_ALG1
       </span>
      </p>
     </li>
    </ul>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPMM_COO_ALG3
     </span>
    </p>
   </td>
   <td>
    <p>
     Algorithm 3 for COO sparse matrix format
    </p>
    <ul class="simple">
     <li>
      <p>
       May provide better performance for large number of nnz
      </p>
     </li>
     <li>
      <p>
       May produce slightly different results during different runs with the same input parameters
      </p>
     </li>
    </ul>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPMM_COO_ALG4
     </span>
    </p>
   </td>
   <td>
    <p>
     Algorithm 4 for COO sparse matrix format
    </p>
    <ul class="simple">
     <li>
      <p>
       Provides better performance with row-major layout
      </p>
     </li>
     <li>
      <p>
       It supports batched computation
      </p>
     </li>
     <li>
      <p>
       May produce slightly different results during different runs with the same input parameters
      </p>
     </li>
    </ul>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPMM_CSR_ALG1
     </span>
    </p>
   </td>
   <td>
    <p>
     Algorithm 1 for CSR/CSC sparse matrix format
    </p>
    <ul class="simple">
     <li>
      <p>
       Provides the best performance with column-major layout
      </p>
     </li>
     <li>
      <p>
       It supports batched computation
      </p>
     </li>
     <li>
      <p>
       It requires additional memory
      </p>
     </li>
     <li>
      <p>
       May produce slightly different results during different runs with the same input parameters
      </p>
     </li>
    </ul>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPMM_CSR_ALG2
     </span>
    </p>
   </td>
   <td>
    <p>
     Algorithm 2 for CSR/CSC sparse matrix format
    </p>
    <ul class="simple">
     <li>
      <p>
       Provides the best performance with row-major layout
      </p>
     </li>
     <li>
      <p>
       It supports batched computation
      </p>
     </li>
     <li>
      <p>
       It requires additional memory
      </p>
     </li>
     <li>
      <p>
       May produce slightly different results during different runs with the same input parameters
      </p>
     </li>
    </ul>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPMM_CSR_ALG3
     </span>
    </p>
   </td>
   <td>
    <p>
     Algorithm 3 for CSR/CSC sparse matrix format
    </p>
    <ul class="simple">
     <li>
      <p>
       It provides deterministic result
      </p>
     </li>
     <li>
      <p>
       It requires additional memory
      </p>
     </li>
     <li>
      <p>
       It supports only
       <span class="pre">
        opA
       </span>
       <span class="pre">
        ==
       </span>
       <span class="pre">
        CUSPARSE_OPERATION_NON_TRANSPOSE
       </span>
      </p>
     </li>
     <li>
      <p>
       It does not support
       <span class="pre">
        opB
       </span>
       <span class="pre">
        ==
       </span>
       <span class="pre">
        CUSPARSE_OPERATION_CONJUGATE_TRANSPOSE
       </span>
      </p>
     </li>
     <li>
      <p>
       It does not support
       <span class="pre">
        CUDA_C_16F
       </span>
       <span class="pre">
        and
       </span>
       <span class="pre">
        CUDA_C_16BF
       </span>
       data types
      </p>
     </li>
    </ul>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPMM_BSR_ALG1
     </span>
    </p>
   </td>
   <td>
    <p>
     Algorithm 1 for BSR sparse matrix format
    </p>
    <ul class="simple">
     <li>
      <p>
       It provides deterministic result
      </p>
     </li>
     <li>
      <p>
       It requires no additional memory
      </p>
     </li>
     <li>
      <p>
       It supports only
       <span class="pre">
        opA
       </span>
       <span class="pre">
        ==
       </span>
       <span class="pre">
        CUSPARSE_OPERATION_NON_TRANSPOSE
       </span>
      </p>
     </li>
     <li>
      <p>
       It does not support
       <span class="pre">
        CUDA_C_16F
       </span>
       and
       <span class="pre">
        CUDA_C_16BF
       </span>
       data types
      </p>
     </li>
     <li>
      <p>
       It does not support column-major blocks in
       <span class="pre">
        A
       </span>
      </p>
     </li>
    </ul>
   </td>
  </tr>
 </table>
 <p>
  Performance notes:
 </p>
 <ul class="simple">
  <li>
   <p>
    Row-major layout provides higher performance than column-major
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     CUSPARSE_SPMM_COO_ALG4
    </span>
    and
    <span class="pre">
     CUSPARSE_SPMM_CSR_ALG2
    </span>
    should be used with row-major layout, while
    <span class="pre">
     CUSPARSE_SPMM_COO_ALG1
    </span>
    ,
    <span class="pre">
     CUSPARSE_SPMM_COO_ALG2
    </span>
    ,
    <span class="pre">
     CUSPARSE_SPMM_COO_ALG3
    </span>
    , and
    <span class="pre">
     CUSPARSE_SPMM_CSR_ALG1
    </span>
    with column-major layout
   </p>
  </li>
  <li>
   <p>
    For
    <span class="pre">
     beta
    </span>
    <span class="pre">
     !=
    </span>
    <span class="pre">
     1
    </span>
    , most algorithms scale the output matrix before the main computation
   </p>
  </li>
  <li>
   <p>
    For
    <span class="pre">
     n
    </span>
    <span class="pre">
     ==
    </span>
    <span class="pre">
     1
    </span>
    , the routine may use
    <span class="pre">
     cusparseSpMV()
    </span>
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseSpMM()
  </span>
  with all algorithms support the following batch modes except for
  <span class="pre">
   CUSPARSE_SPMM_CSR_ALG3
  </span>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="math notranslate nohighlight">
     \(C_{i} = A \cdot B_{i}\)
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="math notranslate nohighlight">
     \(C_{i} = A_{i} \cdot B\)
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="math notranslate nohighlight">
     \(C_{i} = A_{i} \cdot B_{i}\)
    </span>
   </p>
  </li>
 </ul>
 <p>
  The number of batches and their strides can be set by using
  <span class="pre">
   cusparseCooSetStridedBatch
  </span>
  ,
  <span class="pre">
   cusparseCsrSetStridedBatch
  </span>
  , and
  <span class="pre">
   cusparseDnMatSetStridedBatch
  </span>
  . The maximum number of batches for
  <span class="pre">
   cusparseSpMM()
  </span>
  is 65,535.
 </p>
 <p>
  <span class="pre">
   cusparseSpMM()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage for
    <span class="pre">
     CUSPARSE_SPMM_COO_ALG1
    </span>
    ,
    <span class="pre">
     CUSPARSE_SPMM_COO_ALG3
    </span>
    ,
    <span class="pre">
     CUSPARSE_SPMM_COO_ALG4
    </span>
    ,
    <span class="pre">
     CUSPARSE_SPMM_BSR_ALG1
    </span>
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    Provides deterministic (bit-wise) results for each run only for
    <span class="pre">
     CUSPARSE_SPMM_COO_ALG2
    </span>
    ,
    <span class="pre">
     CUSPARSE_SPMM_CSR_ALG3
    </span>
    , and
    <span class="pre">
     CUSPARSE_SPMM_BSR_ALG1
    </span>
    algorithms
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     compute-sanitizer
    </span>
    could report false race conditions for this routine. This is for optimization purposes and does not affect the correctness of the computation
   </p>
  </li>
  <li>
   <p>
    The routine allows the indices of
    <span class="pre">
     matA
    </span>
    to be unsorted
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseSpMM()
  </span>
  supports the following
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#optimization-notes">
   optimizations
  </a>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    CUDA graph capture
   </p>
  </li>
  <li>
   <p>
    Hardware Memory Compression
   </p>
  </li>
 </ul>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSPARSE/spmm_csr">
   cuSPARSE Library Samples - cusparseSpMM CSR
  </a>
  and
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSPARSE/spmm_coo">
   cusparseSpMM COO
  </a>
  for a code example. For batched computation please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSPARSE/spmm_csr_batched">
   cusparseSpMM CSR Batched
  </a>
  and
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSPARSE/spmm_coo_batched">
   cusparseSpMM COO Batched
  </a>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     (2)
    </p>
   </td>
   <td>
    <p>
     BLOCKED-ELLPACK FORMAT
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseSpMM
  </span>
  supports the following data types for
  <span class="pre">
   CUSPARSE_FORMAT_BLOCKED_ELL
  </span>
  format and the following GPU architectures for exploiting NVIDIA Tensor Cores:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      A
     </span>
     /
     <span class="pre">
      B
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      C
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      opB
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      Compute
     </span>
     <span class="pre">
      Capability
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      N
     </span>
     ,
     <span class="pre">
      T
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      
     </span>
     <span class="pre">
      70
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      N
     </span>
     ,
     <span class="pre">
      T
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      
     </span>
     <span class="pre">
      70
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      N
     </span>
     ,
     <span class="pre">
      T
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      
     </span>
     <span class="pre">
      70
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td rowspan="2">
    <p>
     <span class="pre">
      CUDA_R_8I
     </span>
    </p>
   </td>
   <td rowspan="2">
    <p>
     <span class="pre">
      CUDA_R_32I
     </span>
    </p>
   </td>
   <td rowspan="2">
    <p>
     <span class="pre">
      CUDA_R_32I
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      N
     </span>
     column-major
    </p>
   </td>
   <td rowspan="2">
    <p>
     <span class="pre">
      
     </span>
     <span class="pre">
      75
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      T
     </span>
     row-major
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16BF
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_16BF
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      N
     </span>
     ,
     <span class="pre">
      T
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      
     </span>
     <span class="pre">
      80
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16BF
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      N
     </span>
     ,
     <span class="pre">
      T
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      
     </span>
     <span class="pre">
      80
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      N
     </span>
     ,
     <span class="pre">
      T
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      
     </span>
     <span class="pre">
      80
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      N
     </span>
     ,
     <span class="pre">
      T
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      
     </span>
     <span class="pre">
      80
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseSpMM
  </span>
  supports the following algorithms with
  <span class="pre">
   CUSPARSE_FORMAT_BLOCKED_ELL
  </span>
  format:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Algorithm
    </p>
   </th>
   <th class="head">
    <p>
     Notes
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPMM_ALG_DEFAULT
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm for any sparse matrix format
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPMM_BLOCKED_ELL_ALG1
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm for Blocked-ELL format
    </p>
   </td>
  </tr>
 </table>
 <p>
  Performance notes:
 </p>
 <ul class="simple">
  <li>
   <p>
    Blocked-ELL SpMM provides the best performance with Power-of-2 Block-Sizes.
   </p>
  </li>
  <li>
   <p>
    Large Block-Sizes (e.g.  64) provide the best performance.
   </p>
  </li>
 </ul>
 <p>
  The function has the following limitations:
 </p>
 <ul class="simple">
  <li>
   <p>
    The pointer mode must be equal to
    <span class="pre">
     CUSPARSE_POINTER_MODE_HOST
    </span>
   </p>
  </li>
  <li>
   <p>
    Only
    <span class="pre">
     opA
    </span>
    <span class="pre">
     ==
    </span>
    <span class="pre">
     CUSPARSE_OPERATION_NON_TRANSPOSE
    </span>
    is supported.
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     opB
    </span>
    <span class="pre">
     ==
    </span>
    <span class="pre">
     CUSPARSE_OPERATION_CONJUGATE_TRANSPOSE
    </span>
    is not supported.
   </p>
  </li>
  <li>
   <p>
    Only
    <span class="pre">
     CUSPARSE_INDEX_32I
    </span>
    is supported.
   </p>
  </li>
 </ul>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSPARSE/spmm_blockedell">
   cuSPARSE Library Samples - cusparseSpMM Blocked-ELL
  </a>
  for a code example.
 </p>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   6.6.9.
  </span>
  cusparseSpMMOp()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespmmop" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span><span class="n">CUSPARSEAPI</span>
<span class="n">cusparseSpMMOp_createPlan</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseSpMMOpPlan_t</span><span class="o">*</span><span class="n">plan</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opB</span><span class="p">,</span>
<span class="n">cusparseConstSpMatDescr_t</span><span class="n">matA</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseConstDnMatDescr_t</span><span class="n">matB</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseDnMatDescr_t</span><span class="n">matC</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="n">cusparseSpMMOpAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">addOperationNvvmBuffer</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">addOperationBufferSize</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">mulOperationNvvmBuffer</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">mulOperationBufferSize</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">epilogueNvvmBuffer</span><span class="p">,</span>
<span class="kt">size_t</span><span class="n">epilogueBufferSize</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">SpMMWorkspaceSize</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpMMOp_destroyPlan</span><span class="p">(</span><span class="n">cusparseSpMMOpPlan_t</span><span class="n">plan</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpMMOp</span><span class="p">(</span><span class="n">cusparseSpMMOpPlan_t</span><span class="n">plan</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">externalBuffer</span><span class="p">)</span>
</pre>
 <p>
  NOTE 1:
  NVRTC and nvJitLink are not currently available on Arm64 Android platforms.
 </p>
 <p>
  NOTE 2:
  The routine does not support Android and Tegra platforms except Judy (sm87).
 </p>
 <p>
  Experimental
  : The function performs the multiplication of a sparse matrix
  <span class="pre">
   matA
  </span>
  and a dense matrix
  <span class="pre">
   matB
  </span>
  with custom operators.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \({C^{\prime}}_{ij} = \text{epilogue}\left( {\sum_{k}^{\oplus}{op\left( A_{ik} \right) \otimes op\left( B_{kj} \right),C_{ij}}} \right)\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     op(A)
    </span>
    is a sparse matrix of size
    <span class="math notranslate nohighlight">
     \(m \times k\)
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     op(B)
    </span>
    is a dense matrix of size
    <span class="math notranslate nohighlight">
     \(k \times n\)
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     C
    </span>
    is a dense matrix of size
    <span class="math notranslate nohighlight">
     \(m \times n\)
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="math notranslate nohighlight">
     \(\oplus\)
    </span>
    ,
    <span class="math notranslate nohighlight">
     \(\otimes\)
    </span>
    , and
    <span class="math notranslate nohighlight">
     \(\text{epilogue}\)
    </span>
    are custom
    add
    ,
    mul
    , and
    epilogue
    operators respectively.
   </p>
  </li>
 </ul>
 <p>
  Also, for matrix
  <span class="pre">
   A
  </span>
  and
  <span class="pre">
   B
  </span>
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(\text{op}(A) = \begin{cases}
A &amp; \text{if op(A) == CUSPARSE_OPERATION_NON_TRANSPOSE} \\
A^{T} &amp; \text{if op(A) == CUSPARSE_OPERATION_TRANSPOSE} \\
\end{cases}\)
  </span>
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(\text{op}(B) = \begin{cases}
B &amp; {\text{if op(}B\text{) == CUSPARSE_OPERATION_NON_TRANSPOSE}} \\
B^{T} &amp; {\text{if op(}B\text{) == CUSPARSE_OPERATION_TRANSPOSE}} \\
\end{cases}\)
  </span>
 </p>
 <p>
  Only
  <span class="pre">
   opA
  </span>
  <span class="pre">
   ==
  </span>
  <span class="pre">
   CUSPARSE_OPERATION_NON_TRANSPOSE
  </span>
  is currently supported
 </p>
 <p>
  The function
  <span class="pre">
   cusparseSpMMOp_createPlan()
  </span>
  returns the size of the workspace and the compiled kernel needed by
  <span class="pre">
   cusparseSpMMOp()
  </span>
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSPARSE library context
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      opA
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Operation
     <span class="pre">
      op(A)
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      opB
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Operation
     <span class="pre">
      op(B)
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      matA
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse matrix
     <span class="pre">
      A
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      matB
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Dense matrix
     <span class="pre">
      B
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      matC
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN/OUT
    </p>
   </td>
   <td>
    <p>
     Dense matrix
     <span class="pre">
      C
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Datatype in which the computation is executed
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      alg
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Algorithm for the computation
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      addOperationNvvmBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Pointer to the NVVM buffer containing the custom
     add
     operator
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      addOperationBufferSize
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      addOperationNvvmBuffer
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      mulOperationNvvmBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Pointer to the NVVM buffer containing the custom
     mul
     operator
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      mulOperationBufferSize
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      mulOperationNvvmBuffer
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      epilogueNvvmBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Pointer to the NVVM buffer containing the custom
     epilogue
     operator
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      epilogueBufferSize
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Size in bytes of
     <span class="pre">
      epilogueNvvmBuffer
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      SpMMWorkspaceSize
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Number of bytes of workspace needed by
     <span class="pre">
      cusparseSpMMOp
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  The operators must have the following signature and return type
 </p>
 <pre><span class="n">__device__</span><span class="o">&lt;</span><span class="n">computetype</span><span class="o">&gt;</span><span class="n">add_op</span><span class="p">(</span><span class="o">&lt;</span><span class="n">computetype</span><span class="o">&gt;</span><span class="n">value1</span><span class="p">,</span><span class="o">&lt;</span><span class="n">computetype</span><span class="o">&gt;</span><span class="n">value2</span><span class="p">);</span>

<span class="n">__device__</span><span class="o">&lt;</span><span class="n">computetype</span><span class="o">&gt;</span><span class="n">mul_op</span><span class="p">(</span><span class="o">&lt;</span><span class="n">computetype</span><span class="o">&gt;</span><span class="n">value1</span><span class="p">,</span><span class="o">&lt;</span><span class="n">computetype</span><span class="o">&gt;</span><span class="n">value2</span><span class="p">);</span>

<span class="n">__device__</span><span class="o">&lt;</span><span class="n">computetype</span><span class="o">&gt;</span><span class="n">epilogue</span><span class="p">(</span><span class="o">&lt;</span><span class="n">computetype</span><span class="o">&gt;</span><span class="n">value1</span><span class="p">,</span><span class="o">&lt;</span><span class="n">computetype</span><span class="o">&gt;</span><span class="n">value2</span><span class="p">);</span>
</pre>
 <p>
  <span class="pre">
   &lt;computetype&gt;
  </span>
  is one of
  <span class="pre">
   float
  </span>
  ,
  <span class="pre">
   double
  </span>
  ,
  <span class="pre">
   cuComplex
  </span>
  ,
  <span class="pre">
   cuDoubleComplex
  </span>
  , or
  <span class="pre">
   int
  </span>
  ,
 </p>
 <p>
  <span class="pre">
   cusparseSpMMOp
  </span>
  supports the following sparse matrix formats:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     CUSPARSE_FORMAT_CSR
    </span>
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseSpMMOp
  </span>
  supports the following index type for representing the sparse matrix
  <span class="pre">
   matA
  </span>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    32-bit indices (
    <span class="pre">
     CUSPARSE_INDEX_32I
    </span>
    )
   </p>
  </li>
  <li>
   <p>
    64-bit indices (
    <span class="pre">
     CUSPARSE_INDEX_64I
    </span>
    )
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseSpMMOp
  </span>
  supports the following data types:
 </p>
 <p>
  Uniform-precision computation:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      A
     </span>
     /
     <span class="pre">
      B
     </span>
     /
     <span class="pre">
      C
     </span>
     /
     <span class="pre">
      computeType
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Mixed-precision computation:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      A
     </span>
     /
     <span class="pre">
      B
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      C
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_8I
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32I
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32I
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_8I
     </span>
    </p>
   </td>
   <td rowspan="3">
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td rowspan="5">
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16BF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16BF
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_16BF
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseSpMMOp
  </span>
  supports the following algorithms:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Algorithm
    </p>
   </th>
   <th class="head">
    <p>
     Notes
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPMM_OP_ALG_DEFAULT
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm for any sparse matrix format
    </p>
   </td>
  </tr>
 </table>
 <p>
  Performance notes:
 </p>
 <ul class="simple">
  <li>
   <p>
    Row-major layout provides higher performance than column-major.
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseSpMMOp()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    Provides deterministic (bit-wise) results for each run
   </p>
  </li>
  <li>
   <p>
    The routine allows the indices of
    <span class="pre">
     matA
    </span>
    to be unsorted
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseSpMMOp()
  </span>
  supports the following
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#optimization-notes">
   optimizations
  </a>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    CUDA graph capture
   </p>
  </li>
  <li>
   <p>
    Hardware Memory Compression
   </p>
  </li>
 </ul>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSPARSE/spmm_csr_op">
   cuSPARSE Library Samples - cusparseSpMMOp
  </a>
 </p>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <h3>
  <span class="section-number">
   6.6.10.
  </span>
  cusparseSpSM()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespsm" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="nf">cusparseSpSM_createDescr</span><span class="p">(</span><span class="n">cusparseSpSMDescr_t</span><span class="o">*</span><span class="n">spsmDescr</span><span class="p">);</span>
<span class="n">cusparseStatus_t</span>
<span class="nf">cusparseSpSM_destroyDescr</span><span class="p">(</span><span class="n">cusparseSpSMDescr_t</span><span class="n">spsmDescr</span><span class="p">);</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpSM_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="n">cusparseConstSpMatDescr_t</span><span class="n">matA</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseConstDnMatDescr_t</span><span class="n">matB</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseDnMatDescr_t</span><span class="n">matC</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="n">cusparseSpSMAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="n">cusparseSpSMDescr_t</span><span class="n">spsmDescr</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSize</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpSM_analysis</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="n">cusparseConstSpMatDescr_t</span><span class="n">matA</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseConstDnMatDescr_t</span><span class="n">matB</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseDnMatDescr_t</span><span class="n">matC</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="n">cusparseSpSMAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="n">cusparseSpSMDescr_t</span><span class="n">spsmDescr</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">externalBuffer</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpSM_solve</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="n">cusparseConstSpMatDescr_t</span><span class="n">matA</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseConstDnMatDescr_t</span><span class="n">matB</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseDnMatDescr_t</span><span class="n">matC</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="n">cusparseSpSMAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="n">cusparseSpSMDescr_t</span><span class="n">spsmDescr</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpSM_updateMatrix</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseSpSMDescr_t</span><span class="n">spsmDescr</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">newValues</span><span class="p">,</span>
<span class="n">cusparseSpSMUpdate_t</span><span class="n">updatePart</span><span class="p">)</span>
</pre>
 <p>
  The function solves a system of linear equations whose coefficients are represented in a sparse triangular matrix:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(op\left( \mathbf{A} \right) \cdot \mathbf{C} = \mathbf{\alpha}op\left( \mathbf{B} \right)\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     op(A)
    </span>
    is a sparse square matrix of size
    <span class="math notranslate nohighlight">
     \(m \times m\)
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     op(B)
    </span>
    is a dense matrix of size
    <span class="math notranslate nohighlight">
     \(m \times n\)
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     C
    </span>
    is a dense matrix of size
    <span class="math notranslate nohighlight">
     \(m \times n\)
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="math notranslate nohighlight">
     \(\alpha\)
    </span>
    is a scalar
   </p>
  </li>
 </ul>
 <p>
  Also, for matrix
  <span class="pre">
   A
  </span>
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(\text{op}(A) = \begin{cases}
A &amp; \text{if op(A) == CUSPARSE_OPERATION_NON_TRANSPOSE} \\
A^{T} &amp; \text{if op(A) == CUSPARSE_OPERATION_TRANSPOSE} \\
A^{H} &amp; \text{if op(A) == CUSPARSE_OPERATION_CONJUGATE_TRANSPOSE} \\
\end{cases}\)
  </span>
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(\text{op}(B) = \begin{cases}
B &amp; \text{if op(B) == CUSPARSE_OPERATION_NON_TRANSPOSE} \\
B^{T} &amp; \text{if op(B) == CUSPARSE_OPERATION_TRANSPOSE} \\
&amp; \text{ } \\
\end{cases}\)
  </span>
 </p>
 <p>
  The function
  <span class="pre">
   cusparseSpSM_bufferSize()
  </span>
  returns the size of the workspace needed by
  <span class="pre">
   cusparseSpSM_analysis()
  </span>
  and
  <span class="pre">
   cusparseSpSM_solve()
  </span>
  .
The function
  <span class="pre">
   cusparseSpSM_analysis()
  </span>
  performs the analysis phase, while
  <span class="pre">
   cusparseSpSM_solve()
  </span>
  executes the solve phase for a sparse triangular linear system.
The opaque data structure
  <span class="pre">
   spsmDescr
  </span>
  is used to share information among all functions.
The function
  <span class="pre">
   cusparseSpSM_updateMatrix()
  </span>
  updates
  <span class="pre">
   spsmDescr
  </span>
  with new matrix values.
 </p>
 <p>
  The routine supports arbitrary sparsity for the input matrix, but only the upper or lower triangular part is taken into account in the computation.
 </p>
 <p>
  <span class="pre">
   cusparseSpSM_bufferSize()
  </span>
  requires a buffer size for the analysis phase which is proportional to number of non-zero entries of the sparse matrix
 </p>
 <p>
  The
  <span class="pre">
   externalBuffer
  </span>
  is stored into
  <span class="pre">
   spsmDescr
  </span>
  and used by
  <span class="pre">
   cusparseSpSM_solve()
  </span>
  . For this reason, the device memory buffer must be deallocated only after
  <span class="pre">
   cusparseSpSM_solve()
  </span>
 </p>
 <p>
  NOTE:
  all parameters must be consistent across
  <span class="pre">
   cusparseSpSM
  </span>
  API calls and the matrix descriptions and
  <span class="pre">
   externalBuffer
  </span>
  must not be modified between
  <span class="pre">
   cusparseSpSM_analysis()
  </span>
  and
  <span class="pre">
   cusparseSpSM_solve()
  </span>
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSPARSE library context
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      opA
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Operation
     <span class="pre">
      op(A)
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      opB
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Operation
     <span class="pre">
      op(B)
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      alpha
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST or DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\alpha\)
     </span>
     scalar used for multiplication of type
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      matA
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse matrix
     <span class="pre">
      A
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      matB
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Dense matrix
     <span class="pre">
      B
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      matC
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN/OUT
    </p>
   </td>
   <td>
    <p>
     Dense matrix
     <span class="pre">
      C
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Datatype in which the computation is executed
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      alg
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Algorithm for the computation
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bufferSize
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Number of bytes of workspace needed by
     <span class="pre">
      cusparseSpSM_analysis()
     </span>
     and
     <span class="pre">
      cusparseSpSM_solve()
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      externalBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN/OUT
    </p>
   </td>
   <td>
    <p>
     Pointer to a workspace buffer of at least
     <span class="pre">
      bufferSize
     </span>
     bytes. It is used by
     <span class="pre">
      cusparseSpSM_analysis
     </span>
     and
     <span class="pre">
      cusparseSpSM_solve()
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      spsmDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN/OUT
    </p>
   </td>
   <td>
    <p>
     Opaque descriptor for storing internal data used across the three steps
    </p>
   </td>
  </tr>
 </table>
 <p>
  The sparse matrix formats currently supported are listed below:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     CUSPARSE_FORMAT_CSR
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     CUSPARSE_FORMAT_COO
    </span>
   </p>
  </li>
 </ul>
 <p>
  The
  <span class="pre">
   cusparseSpSM()
  </span>
  supports the following shapes and properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     CUSPARSE_FILL_MODE_LOWER
    </span>
    and
    <span class="pre">
     CUSPARSE_FILL_MODE_UPPER
    </span>
    fill modes
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     CUSPARSE_DIAG_TYPE_NON_UNIT
    </span>
    and
    <span class="pre">
     CUSPARSE_DIAG_TYPE_UNIT
    </span>
    diagonal types
   </p>
  </li>
 </ul>
 <p>
  The fill mode and diagonal type can be set by
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespmatsetattribute">
   cusparseSpMatSetAttribute()
  </a>
 </p>
 <p>
  <span class="pre">
   cusparseSpSM()
  </span>
  supports the following index type for representing the sparse matrix
  <span class="pre">
   matA
  </span>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    32-bit indices (
    <span class="pre">
     CUSPARSE_INDEX_32I
    </span>
    )
   </p>
  </li>
  <li>
   <p>
    64-bit indices (
    <span class="pre">
     CUSPARSE_INDEX_64I
    </span>
    )
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseSpSM()
  </span>
  supports the following data types:
 </p>
 <p>
  Uniform-precision computation:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      A
     </span>
     /
     <span class="pre">
      B
     </span>
     /
     <span class="pre">
      C
     </span>
     /
     <span class="pre">
      computeType
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseSpSM()
  </span>
  supports the following algorithms:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Algorithm
    </p>
   </th>
   <th class="head">
    <p>
     Notes
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPSM_ALG_DEFAULT
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseSpSM()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    Provides deterministic (bit-wise) results for each run for the solving phase
    <span class="pre">
     cusparseSpSM_solve()
    </span>
   </p>
  </li>
  <li>
   <p>
    The
    <span class="pre">
     cusparseSpSM_solve()
    </span>
    routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine supports in-place operation. The same device pointer must be provided to the
    <span class="pre">
     values
    </span>
    parameter of the dense matrices
    <span class="pre">
     matB
    </span>
    and
    <span class="pre">
     matC
    </span>
    . All other dense matrix descriptor parameters (e.g.,
    <span class="pre">
     order
    </span>
    ) can be set independently
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     cusparseSpSM_bufferSize()
    </span>
    and
    <span class="pre">
     cusparseSpSM_analysis()
    </span>
    routines accept descriptors of
    <span class="pre">
     NULL
    </span>
    values for
    <span class="pre">
     matB
    </span>
    and
    <span class="pre">
     matC
    </span>
    . These two routines do not accept
    <span class="pre">
     NULL
    </span>
    descriptors
   </p>
  </li>
  <li>
   <p>
    The routine allows the indices of
    <span class="pre">
     matA
    </span>
    to be unsorted
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseSpSM()
  </span>
  supports the following
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#optimization-notes">
   optimizations
  </a>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    CUDA graph capture
   </p>
  </li>
  <li>
   <p>
    Hardware Memory Compression
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseSpSM_updateMatrix()
  </span>
  updates the sparse matrix after calling the analysis phase. This functions supports the following update strategies (
  <span class="pre">
   updatePart
  </span>
  ):
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Strategy
    </p>
   </th>
   <th class="head">
    <p>
     Notes
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPSM_UPDATE_GENERAL
     </span>
    </p>
   </td>
   <td>
    <p>
     Updates the sparse matrix values with values of
     <span class="pre">
      newValues
     </span>
     array
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPSM_UPDATE_DIAGONAL
     </span>
    </p>
   </td>
   <td>
    <p>
     Updates the diagonal part of the matrix with diagonal values stored in
     <span class="pre">
      newValues
     </span>
     array. That is,
     <span class="pre">
      newValues
     </span>
     has the new diagonal values only
    </p>
   </td>
  </tr>
 </table>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSPARSE/spsm_csr">
   cuSPARSE Library Samples - cusparseSpSM CSR
  </a>
  and
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSPARSE/spsm_coo">
   cuSPARSE Library Samples - cusparseSpSM COO
  </a>
  for code examples.
 </p>
 <h3>
  <span class="section-number">
   6.6.11.
  </span>
  cusparseSDDMM()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsesddmm" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSDDMM_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="n">cusparseConstDnMatDescr_t</span><span class="n">matA</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseConstDnMatDescr_t</span><span class="n">matB</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="n">cusparseSpMatDescr_t</span><span class="n">matC</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="n">cusparseSDDMMAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSize</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSDDMM_preprocess</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="n">cusparseConstDnMatDescr_t</span><span class="n">matA</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseConstDnMatDescr_t</span><span class="n">matB</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="n">cusparseSpMatDescr_t</span><span class="n">matC</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="n">cusparseSDDMMAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">externalBuffer</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSDDMM</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="n">cusparseConstDnMatDescr_t</span><span class="n">matA</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseConstDnMatDescr_t</span><span class="n">matB</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="n">cusparseSpMatDescr_t</span><span class="n">matC</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="n">cusparseSDDMMAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">externalBuffer</span><span class="p">)</span>
</pre>
 <p>
  This function performs the multiplication of
  <span class="pre">
   matA
  </span>
  and
  <span class="pre">
   matB
  </span>
  , followed by an element-wise multiplication with the sparsity pattern of
  <span class="pre">
   matC
  </span>
  . Formally, it performs the following operation:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\mathbf{C} = \alpha({op}(\mathbf{A}) \cdot {op}(\mathbf{B})) \circ {spy}(\mathbf{C}) + \beta\mathbf{C}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
 </p>
 <ul>
  <li>
   <p>
    <span class="pre">
     op(A)
    </span>
    is a dense matrix of size
    <span class="math notranslate nohighlight">
     \(m \times k\)
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     op(B)
    </span>
    is a dense matrix of size
    <span class="math notranslate nohighlight">
     \(k \times n\)
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     C
    </span>
    is a sparse matrix of size
    <span class="math notranslate nohighlight">
     \(m \times n\)
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="math notranslate nohighlight">
     \(\alpha\)
    </span>
    and
    <span class="math notranslate nohighlight">
     \(\beta\)
    </span>
    are scalars
   </p>
  </li>
  <li>
   <p>
    <span class="math notranslate nohighlight">
     \(\circ\)
    </span>
    denotes the Hadamard (entry-wise) matrix product, and
    <span class="math notranslate nohighlight">
     \({spy}\left( \mathbf{C} \right)\)
    </span>
    is the structural sparsity pattern matrix of
    <span class="pre">
     C
    </span>
    defined as:
   </p>
   <p>
    <span class="math notranslate nohighlight">
     \({spy}(\mathbf{C})_{ij} = \begin{cases}
1 &amp; {\text{if}\,\mathbf{C}_{ij}\,\text{is an entry stored in}\,\texttt{matC}} \\
0 &amp; \text{otherwise} \\
\end{cases}.\)
    </span>
   </p>
  </li>
 </ul>
 <p>
  Also, for matrix
  <span class="pre">
   A
  </span>
  and
  <span class="pre">
   B
  </span>
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(\text{op}(A) = \begin{cases}
A &amp; \text{if op(A) == CUSPARSE_OPERATION_NON_TRANSPOSE} \\
A^{T} &amp; \text{if op(A) == CUSPARSE_OPERATION_TRANSPOSE} \\
\end{cases}\)
  </span>
 </p>
 <p>
  <span class="math notranslate nohighlight">
   \(\text{op}(B) = \begin{cases}
B &amp; \text{if op(B) == CUSPARSE_OPERATION_NON_TRANSPOSE} \\
B^{T} &amp; \text{if op(B) == CUSPARSE_OPERATION_TRANSPOSE} \\
\end{cases}\)
  </span>
 </p>
 <p>
  The function
  <span class="pre">
   cusparseSDDMM_bufferSize()
  </span>
  returns the size of the workspace needed by
  <span class="pre">
   cusparseSDDMM
  </span>
  or
  <span class="pre">
   cusparseSDDMM_preprocess
  </span>
  .
 </p>
 <p>
  The function
  <span class="pre">
   cusparseSDDMM_preprocess()
  </span>
  can be called before
  <span class="pre">
   cusparseSDDMM
  </span>
  to speedup the actual computation. It is useful when
  <span class="pre">
   cusparseSDDMM
  </span>
  is called multiple times with the same sparsity pattern (
  <span class="pre">
   matC
  </span>
  ). The values of the dense matrices (
  <span class="pre">
   matA
  </span>
  ,
  <span class="pre">
   matB
  </span>
  ) can change arbitrarily.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSPARSE library context
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      opA
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Operation
     <span class="pre">
      op(A)
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      opB
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Operation
     <span class="pre">
      op(B)
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      alpha
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST or DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\alpha\)
     </span>
     scalar used for multiplication of type
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      matA
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Dense matrix
     <span class="pre">
      matA
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      matB
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Dense matrix
     <span class="pre">
      matB
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      beta
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST or DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\beta\)
     </span>
     scalar used for multiplication of type
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      matC
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN/OUT
    </p>
   </td>
   <td>
    <p>
     Sparse matrix
     <span class="pre">
      matC
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Datatype in which the computation is executed
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      alg
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Algorithm for the computation
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bufferSize
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Number of bytes of workspace needed by
     <span class="pre">
      cusparseSDDMM
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      externalBuffer
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Pointer to a workspace buffer of at least
     <span class="pre">
      bufferSize
     </span>
     bytes
    </p>
   </td>
  </tr>
 </table>
 <p>
  Currently supported sparse matrix formats:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     CUSPARSE_FORMAT_CSR
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="pre">
     CUSPARSE_FORMAT_BSR
    </span>
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseSDDMM()
  </span>
  supports the following index type for representing the sparse matrix
  <span class="pre">
   matA
  </span>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    32-bit indices (
    <span class="pre">
     CUSPARSE_INDEX_32I
    </span>
    )
   </p>
  </li>
  <li>
   <p>
    64-bit indices (
    <span class="pre">
     CUSPARSE_INDEX_64I
    </span>
    )
   </p>
  </li>
 </ul>
 <p>
  The data types combinations currently supported for
  <span class="pre">
   cusparseSDDMM
  </span>
  are listed below:
 </p>
 <p>
  Uniform-precision computation:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      A
     </span>
     /
     <span class="pre">
      X
     </span>
     /
     <span class="pre">
      Y
     </span>
     /
     <span class="pre">
      computeType
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Mixed-precision computation:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      A
     </span>
     /
     <span class="pre">
      B
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      C
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td rowspan="2">
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseSDDMM
  </span>
  for
  <span class="pre">
   CUSPARSE_FORMAT_BSR
  </span>
  also supports the following mixed-precision computation:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      A
     </span>
     /
     <span class="pre">
      B
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      C
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16BF
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
   <td rowspan="2">
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16BF
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_16BF
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  NOTE:
  <span class="pre">
   CUDA_R_16F
  </span>
  ,
  <span class="pre">
   CUDA_R_16BF
  </span>
  data types always imply mixed-precision computation.
 </p>
 <p>
  <span class="pre">
   cusparseSDDMM()
  </span>
  for
  <span class="pre">
   CUSPASRE_FORMAT_BSR
  </span>
  supports block sizes of 2, 4, 8, 16, 32, 64 and 128.
 </p>
 <p>
  <span class="pre">
   cusparseSDDMM()
  </span>
  supports the following algorithms:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Algorithm
    </p>
   </th>
   <th class="head">
    <p>
     Notes
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SDDMM_ALG_DEFAULT
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm. It supports batched computation.
    </p>
   </td>
  </tr>
 </table>
 <p>
  Performance notes:
  <span class="pre">
   cuspaseSDDMM()
  </span>
  for
  <span class="pre">
   CUSPARSE_FORMAT_CSR
  </span>
  provides the best performance when
  <span class="pre">
   matA
  </span>
  and
  <span class="pre">
   matB
  </span>
  satisfy:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     matA
    </span>
    :
   </p>
   <ul>
    <li>
     <p>
      <span class="pre">
       matA
      </span>
      is in row-major order and
      <span class="pre">
       opA
      </span>
      is
      <span class="pre">
       CUSPARSE_OPERATION_NON_TRANSPOSE
      </span>
      , or
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       matA
      </span>
      is in col-major order and
      <span class="pre">
       opA
      </span>
      is not
      <span class="pre">
       CUSPARSE_OPERATION_NON_TRANSPOSE
      </span>
     </p>
    </li>
   </ul>
  </li>
  <li>
   <p>
    <span class="pre">
     matB
    </span>
    :
   </p>
   <ul>
    <li>
     <p>
      <span class="pre">
       matB
      </span>
      is in col-major order and
      <span class="pre">
       opB
      </span>
      is
      <span class="pre">
       CUSPARSE_OPERATION_NON_TRANSPOSE
      </span>
      , or
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       matB
      </span>
      is in row-major order and
      <span class="pre">
       opB
      </span>
      is not
      <span class="pre">
       CUSPARSE_OPERATION_NON_TRANSPOSE
      </span>
     </p>
    </li>
   </ul>
  </li>
 </ul>
 <p>
  <span class="pre">
   cuspaseSDDMM()
  </span>
  for
  <span class="pre">
   CUSPARSE_FORMAT_BSR
  </span>
  provides the best performance when
  <span class="pre">
   matA
  </span>
  and
  <span class="pre">
   matB
  </span>
  satisfy:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="pre">
     matA
    </span>
    :
   </p>
   <ul>
    <li>
     <p>
      <span class="pre">
       matA
      </span>
      is in row-major order and
      <span class="pre">
       opA
      </span>
      is
      <span class="pre">
       CUSPARSE_OPERATION_NON_TRANSPOSE
      </span>
      , or
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       matA
      </span>
      is in col-major order and
      <span class="pre">
       opA
      </span>
      is not
      <span class="pre">
       CUSPARSE_OPERATION_NON_TRANSPOSE
      </span>
     </p>
    </li>
   </ul>
  </li>
  <li>
   <p>
    <span class="pre">
     matB
    </span>
    :
   </p>
   <ul>
    <li>
     <p>
      <span class="pre">
       matB
      </span>
      is in row-major order and
      <span class="pre">
       opB
      </span>
      is
      <span class="pre">
       CUSPARSE_OPERATION_NON_TRANSPOSE
      </span>
      , or
     </p>
    </li>
    <li>
     <p>
      <span class="pre">
       matB
      </span>
      is in col-major order and
      <span class="pre">
       opB
      </span>
      is not
      <span class="pre">
       CUSPARSE_OPERATION_NON_TRANSPOSE
      </span>
     </p>
    </li>
   </ul>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseSDDMM()
  </span>
  supports the following batch modes:
 </p>
 <ul class="simple">
  <li>
   <p>
    <span class="math notranslate nohighlight">
     \(C_{i} = (A \cdot B) \circ C_{i}\)
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="math notranslate nohighlight">
     \(C_{i} = \left( A_{i} \cdot B \right) \circ C_{i}\)
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="math notranslate nohighlight">
     \(C_{i} = \left( A \cdot B_{i} \right) \circ C_{i}\)
    </span>
   </p>
  </li>
  <li>
   <p>
    <span class="math notranslate nohighlight">
     \(C_{i} = \left( A_{i} \cdot B_{i} \right) \circ C_{i}\)
    </span>
   </p>
  </li>
 </ul>
 <p>
  The number of batches and their strides can be set by using
  <span class="pre">
   cusparseCsrSetStridedBatch
  </span>
  and
  <span class="pre">
   cusparseDnMatSetStridedBatch
  </span>
  . The maximum number of batches for
  <span class="pre">
   cusparseSDDMM()
  </span>
  is 65,535.
 </p>
 <p>
  <span class="pre">
   cusparseSDDMM()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    Provides deterministic (bit-wise) results for each run
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine allows the indices of
    <span class="pre">
     matC
    </span>
    to be unsorted
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseSDDMM()
  </span>
  supports the following
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#optimization-notes">
   optimizations
  </a>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    CUDA graph capture
   </p>
  </li>
  <li>
   <p>
    Hardware Memory Compression
   </p>
  </li>
 </ul>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/blob/master/cuSPARSE/sddmm_csr">
   cuSPARSE Library Samples - cusparseSDDMM
  </a>
  for a code example. For batched computation please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSPARSE/sddmm_csr_batched">
   cusparseSDDMM CSR Batched
  </a>
  .
 </p>
 <h3>
  <span class="section-number">
   6.6.12.
  </span>
  cusparseSpGEMM()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespgemm" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpGEMM_createDescr</span><span class="p">(</span><span class="n">cusparseSpGEMMDescr_t</span><span class="o">*</span><span class="n">descr</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpGEMM_destroyDescr</span><span class="p">(</span><span class="n">cusparseSpGEMMDescr_t</span><span class="n">descr</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpGEMM_workEstimation</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="n">cusparseConstSpMatDescr_t</span><span class="n">matA</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseConstSpMatDescr_t</span><span class="n">matB</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="n">cusparseSpMatDescr_t</span><span class="n">matC</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="n">cusparseSpGEMMAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="n">cusparseSpGEMMDescr_t</span><span class="n">spgemmDescr</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSize1</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">externalBuffer1</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpGEMM_getNumProducts</span><span class="p">(</span><span class="n">cusparseSpGEMMDescr_t</span><span class="n">spgemmDescr</span><span class="p">,</span>
<span class="kt">int64_t</span><span class="o">*</span><span class="n">num_prods</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpGEMM_estimateMemory</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="n">cusparseConstSpMatDescr_t</span><span class="n">matA</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseConstSpMatDescr_t</span><span class="n">matB</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="n">cusparseSpMatDescr_t</span><span class="n">matC</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="n">cusparseSpGEMMAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="n">cusparseSpGEMMDescr_t</span><span class="n">spgemmDescr</span><span class="p">,</span>
<span class="kt">float</span><span class="n">chunk_fraction</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSize3</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">externalBuffer3</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSize2</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpGEMM_compute</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="n">cusparseConstSpMatDescr_t</span><span class="n">matA</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseConstSpMatDescr_t</span><span class="n">matB</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="n">cusparseSpMatDescr_t</span><span class="n">matC</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="n">cusparseSpGEMMAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="n">cusparseSpGEMMDescr_t</span><span class="n">spgemmDescr</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSize2</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">externalBuffer2</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpGEMM_copy</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="n">cusparseConstSpMatDescr_t</span><span class="n">matA</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseConstSpMatDescr_t</span><span class="n">matB</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="n">cusparseSpMatDescr_t</span><span class="n">matC</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="n">cusparseSpGEMMAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="n">cusparseSpGEMMDescr_t</span><span class="n">spgemmDescr</span><span class="p">)</span>
</pre>
 <p>
  This function performs the multiplication of two sparse matrices
  <span class="pre">
   matA
  </span>
  and
  <span class="pre">
   matB
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\mathbf{C^{\prime}} = \alpha op\left( \mathbf{A} \right) \cdot op\left( \mathbf{B} \right) + \beta\mathbf{C}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="math notranslate nohighlight">
   \(\alpha,\)
  </span>
  <span class="math notranslate nohighlight">
   \(\beta\)
  </span>
  are scalars, and
  <span class="math notranslate nohighlight">
   \(\mathbf{C},\)
  </span>
  <span class="math notranslate nohighlight">
   \(\mathbf{C^{\prime}}\)
  </span>
  have the same sparsity pattern.
 </p>
 <p>
  The functions
  <span class="pre">
   cusparseSpGEMM_workEstimation()
  </span>
  ,
  <span class="pre">
   cusparseSpGEMM_estimateMemory()
  </span>
  , and
  <span class="pre">
   cusparseSpGEMM_compute()
  </span>
  are used for both determining the buffer size and performing the actual computation.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSPARSE library context
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      opA
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Operation
     <span class="pre">
      op(A)
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      opB
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Operation
     <span class="pre">
      op(B)
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      alpha
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST or DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\alpha\)
     </span>
     scalar used for multiplication
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      matA
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse matrix
     <span class="pre">
      A
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      matB
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse matrix
     <span class="pre">
      B
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      beta
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST or DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\beta\)
     </span>
     scalar used for multiplication
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      matC
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN/OUT
    </p>
   </td>
   <td>
    <p>
     Sparse matrix
     <span class="pre">
      C
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Enumerator specifying the datatype in which the computation is executed
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      alg
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Enumerator specifying the algorithm for the computation
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      spgemmDescr
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN/OUT
    </p>
   </td>
   <td>
    <p>
     Opaque descriptor for storing internal data used across the three steps
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      num_prods
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Pointer to a 64-bit integer that stores the number of intermediate products calculated by
     <span class="pre">
      cusparseSpGEMM_workEstimation
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      chunk_fraction
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     The fraction of total intermediate products being computed in a chunk. Used by
     <span class="pre">
      CUSPARSE_SPGEMM_ALG3
     </span>
     only. Value is in range (0,1].
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bufferSize1
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN/OUT
    </p>
   </td>
   <td>
    <p>
     Number of bytes of workspace requested by
     <span class="pre">
      cusparseSpGEMM_workEstimation
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bufferSize2
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN/OUT
    </p>
   </td>
   <td>
    <p>
     Number of bytes of workspace requested by
     <span class="pre">
      cusparseSpGEMM_compute
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      bufferSize3
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN/OUT
    </p>
   </td>
   <td>
    <p>
     Number of bytes of workspace requested by
     <span class="pre">
      cusparseSpGEMM_estimateMemory
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      externalBuffer1
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Pointer to workspace buffer needed by
     <span class="pre">
      cusparseSpGEMM_workEstimation
     </span>
     and
     <span class="pre">
      cusparseSpGEMM_compute
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      externalBuffer2
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Pointer to workspace buffer needed by
     <span class="pre">
      cusparseSpGEMM_compute
     </span>
     and
     <span class="pre">
      cusparseSpGEMM_copy
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      externalBuffer3
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Pointer to workspace buffer needed by
     <span class="pre">
      cusparseSpGEMM_estimateMemory
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Currently, the function has the following limitations:
 </p>
 <ul class="simple">
  <li>
   <p>
    Only 32-bit indices
    <span class="pre">
     CUSPARSE_INDEX_32I
    </span>
    is supported
   </p>
  </li>
  <li>
   <p>
    Only CSR format
    <span class="pre">
     CUSPARSE_FORMAT_CSR
    </span>
    is supported
   </p>
  </li>
  <li>
   <p>
    Only
    <span class="pre">
     opA
    </span>
    ,
    <span class="pre">
     opB
    </span>
    equal to
    <span class="pre">
     CUSPARSE_OPERATION_NON_TRANSPOSE
    </span>
    are supported
   </p>
  </li>
 </ul>
 <p>
  The data types combinations currently supported for
  <span class="pre">
   cusparseSpGEMM
  </span>
  are listed below :
 </p>
 <p>
  Uniform-precision computation:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      A
     </span>
     /
     <span class="pre">
      B
     </span>
     /
     <span class="pre">
      C
     </span>
     /
     <span class="pre">
      computeType
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
     [DEPRECATED]
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16BF
     </span>
     [DEPRECATED]
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_16F
     </span>
     [DEPRECATED]
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_16BF
     </span>
     [DEPRECATED]
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseSpGEMM
  </span>
  routine runs for the following algorithms:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Algorithm
    </p>
   </th>
   <th class="head">
    <p>
     Notes
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPGEMM_DEFAULT
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm. Currently, it is
     <span class="pre">
      CUSPARSE_SPGEMM_ALG1
     </span>
     .
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPGEMM_ALG1
     </span>
    </p>
   </td>
   <td>
    <p>
     Algorithm 1
    </p>
    <ul class="simple">
     <li>
      <p>
       Invokes
       <span class="pre">
        cusparseSpGEMM_compute
       </span>
       twice. The first invocation provides an upper bound of the memory required for the computation.
      </p>
     </li>
     <li>
      <p>
       The required memory is generally several times larger of the actual memory used.
      </p>
     </li>
     <li>
      <p>
       The user can provide an arbitrary buffer size bufferSize2 in the second invocation. If it is not sufficient, the routine will returns
       <span class="pre">
        CUSPARSE_STATUS_INSUFFICIENT_RESOURCES
       </span>
       status.
      </p>
     </li>
     <li>
      <p>
       Provides better performance than other algorithms.
      </p>
     </li>
     <li>
      <p>
       Provides deterministic (bit-wise) results for each run.
      </p>
     </li>
    </ul>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPGEMM_ALG2
     </span>
    </p>
   </td>
   <td>
    <p>
     Algorithm 2
    </p>
    <ul class="simple">
     <li>
      <p>
       Invokes
       <span class="pre">
        cusparseSpGEMM_estimateMemory
       </span>
       to get the amount of the memory required for the computation.
      </p>
     </li>
     <li>
      <p>
       Requires less memory for the computation than Algorithm 1.
      </p>
     </li>
     <li>
      <p>
       Performance is lower than Algorithm 1, higher than Algorithm 3.
      </p>
     </li>
     <li>
      <p>
       Provides deterministic (bit-wise) results for each run.
      </p>
     </li>
    </ul>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPGEMM_ALG3
     </span>
    </p>
   </td>
   <td>
    <p>
     Algorithm 3
    </p>
    <ul class="simple">
     <li>
      <p>
       Computes the intermediate products in chunks, one chunk at a time.
      </p>
     </li>
     <li>
      <p>
       Invokes
       <span class="pre">
        cusparseSpGEMM_estimateMemory
       </span>
       to get the amount of the memory required for the computation.
      </p>
     </li>
     <li>
      <p>
       The user can control the amount of required memory by changing the chunk size via
       <span class="pre">
        chunk_fraction
       </span>
       .
      </p>
     </li>
     <li>
      <p>
       The chunk size is a fraction of total intermediate products:
       <span class="pre">
        chunk_fraction
       </span>
       <span class="pre">
        *
       </span>
       <span class="pre">
        (*num_prods)
       </span>
       .
      </p>
     </li>
     <li>
      <p>
       Provides deterministic (bit-wise) results for each run.
      </p>
     </li>
    </ul>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseSpGEMM()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine allows the indices of
    <span class="pre">
     matA
    </span>
    and
    <span class="pre">
     matB
    </span>
    to be unsorted
   </p>
  </li>
  <li>
   <p>
    The routine guarantees the indices of
    <span class="pre">
     matC
    </span>
    to be sorted
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseSpGEMM()
  </span>
  supports the following
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#optimization-notes">
   optimizations
  </a>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    CUDA graph capture
   </p>
  </li>
  <li>
   <p>
    Hardware Memory Compression
   </p>
  </li>
 </ul>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSPARSE/spgemm">
   cuSPARSE Library Samples - cusparseSpGEMM
  </a>
  for a code example for
  <span class="pre">
   CUSPARSE_SPGEMM_DEFAULT
  </span>
  and
  <span class="pre">
   CUSPARSE_SPGEMM_ALG1
  </span>
  , and
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSPARSE/spgemm_mem">
   cuSPARSE Library Samples - memory-optimzed cusparseSpGEMM
  </a>
  for a code example for
  <span class="pre">
   CUSPARSE_SPGEMM_ALG2
  </span>
  and
  <span class="pre">
   CUSPARSE_SPGEMM_ALG3
  </span>
  .
 </p>
 <h3>
  <span class="section-number">
   6.6.13.
  </span>
  cusparseSpGEMMreuse()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsespgemmreuse" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpGEMM_createDescr</span><span class="p">(</span><span class="n">cusparseSpGEMMDescr_t</span><span class="o">*</span><span class="n">descr</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpGEMM_destroyDescr</span><span class="p">(</span><span class="n">cusparseSpGEMMDescr_t</span><span class="n">descr</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpGEMMreuse_workEstimation</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opB</span><span class="p">,</span>
<span class="n">cusparseSpMatDescr_t</span><span class="n">matA</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseSpMatDescr_t</span><span class="n">matB</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseSpMatDescr_t</span><span class="n">matC</span><span class="p">,</span>
<span class="n">cusparseSpGEMMAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="n">cusparseSpGEMMDescr_t</span><span class="n">spgemmDescr</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSize1</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">externalBuffer1</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span>
<span class="n">cusparseSpGEMMreuse_nnz</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opB</span><span class="p">,</span>
<span class="n">cusparseSpMatDescr_t</span><span class="n">matA</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseSpMatDescr_t</span><span class="n">matB</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseSpMatDescr_t</span><span class="n">matC</span><span class="p">,</span>
<span class="n">cusparseSpGEMMAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="n">cusparseSpGEMMDescr_t</span><span class="n">spgemmDescr</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSize2</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">externalBuffer2</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSize3</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">externalBuffer3</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSize4</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">externalBuffer4</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span><span class="n">CUSPARSEAPI</span>
<span class="n">cusparseSpGEMMreuse_copy</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opB</span><span class="p">,</span>
<span class="n">cusparseSpMatDescr_t</span><span class="n">matA</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseSpMatDescr_t</span><span class="n">matB</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseSpMatDescr_t</span><span class="n">matC</span><span class="p">,</span>
<span class="n">cusparseSpGEMMAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="n">cusparseSpGEMMDescr_t</span><span class="n">spgemmDescr</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSize5</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">externalBuffer5</span><span class="p">)</span>

<span class="n">cusparseStatus_t</span><span class="n">CUSPARSEAPI</span>
<span class="n">cusparseSpGEMMreuse_compute</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opA</span><span class="p">,</span>
<span class="n">cusparseOperation_t</span><span class="n">opB</span><span class="p">,</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
<span class="n">cusparseSpMatDescr_t</span><span class="n">matA</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseSpMatDescr_t</span><span class="n">matB</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="k">const</span><span class="kt">void</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span>
<span class="n">cusparseSpMatDescr_t</span><span class="n">matC</span><span class="p">,</span>
<span class="n">cudaDataType</span><span class="n">computeType</span><span class="p">,</span>
<span class="n">cusparseSpGEMMAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="n">cusparseSpGEMMDescr_t</span><span class="n">spgemmDescr</span><span class="p">)</span>
</pre>
 <p>
  This function performs the multiplication of two sparse matrices
  <span class="pre">
   matA
  </span>
  and
  <span class="pre">
   matB
  </span>
  where the structure of the output matrix
  <span class="pre">
   matC
  </span>
  can be reused for multiple computations with different values.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <td>
    <p>
     <span class="math notranslate nohighlight">
      \(\mathbf{C^{\prime}} = \alpha op\left( \mathbf{A} \right) \cdot op\left( \mathbf{B} \right) + \beta\mathbf{C}\)
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  where
  <span class="math notranslate nohighlight">
   \(\alpha\)
  </span>
  and
  <span class="math notranslate nohighlight">
   \(\beta\)
  </span>
  are scalars.
 </p>
 <p>
  The functions
  <span class="pre">
   cusparseSpGEMMreuse_workEstimation()
  </span>
  ,
  <span class="pre">
   cusparseSpGEMMreuse_nnz()
  </span>
  , and
  <span class="pre">
   cusparseSpGEMMreuse_copy()
  </span>
  are used for determining the buffer size and performing the actual computation.
 </p>
 <p>
  Note:
  <span class="pre">
   cusparseSpGEMMreuse()
  </span>
  output CSR matrix (
  <span class="pre">
   matC
  </span>
  ) is sorted by column indices.
 </p>
 <p>
  MEMORY REQUIREMENT:
  <span class="pre">
   cusparseSpGEMMreuse
  </span>
  requires to keep in memory all intermediate products to reuse the structure of the output matrix. On the other hand, the number of intermediate products is orders of magnitude higher than the number of non-zero entries in general. In order to minimize the memory requirements, the routine uses multiple buffers that can be deallocated after they are no more needed. If the number of intermediate product exceeds
  <span class="pre">
   2^31-1
  </span>
  , the routine will returns
  <span class="pre">
   CUSPARSE_STATUS_INSUFFICIENT_RESOURCES
  </span>
  status.
 </p>
 <p>
  Currently, the function has the following limitations:
 </p>
 <ul class="simple">
  <li>
   <p>
    Only 32-bit indices
    <span class="pre">
     CUSPARSE_INDEX_32I
    </span>
    is supported
   </p>
  </li>
  <li>
   <p>
    Only CSR format
    <span class="pre">
     CUSPARSE_FORMAT_CSR
    </span>
    is supported
   </p>
  </li>
  <li>
   <p>
    Only
    <span class="pre">
     opA
    </span>
    ,
    <span class="pre">
     opB
    </span>
    equal to
    <span class="pre">
     CUSPARSE_OPERATION_NON_TRANSPOSE
    </span>
    are supported
   </p>
  </li>
 </ul>
 <p>
  The data types combinations currently supported for
  <span class="pre">
   cusparseSpGEMMreuse
  </span>
  are listed below.
 </p>
 <p>
  Uniform-precision computation:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      A
     </span>
     /
     <span class="pre">
      B
     </span>
     /
     <span class="pre">
      C
     </span>
     /
     <span class="pre">
      computeType
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_16F
     </span>
     [DEPRECATED]
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_16BF
     </span>
     [DEPRECATED]
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  Mixed-precision computation: [DEPRECATED]
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      A
     </span>
     /
     <span class="pre">
      B
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      C
     </span>
    </p>
   </th>
   <th class="head">
    <p>
     <span class="pre">
      computeType
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16BF
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_16BF
     </span>
    </p>
   </td>
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseSpGEMMreuse
  </span>
  routine runs for the following algorithm:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Algorithm
    </p>
   </th>
   <th class="head">
    <p>
     Notes
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPGEMM_DEFAULT
     </span>
    </p>
    <p>
     <span class="pre">
      CUSPARSE_SPGEMM_CSR_ALG_NONDETERMINITIC
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm. Provides deterministic (bit-wise) structure for the output matrix for each run, while value computation is not deterministic.
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPGEMM_CSR_ALG_DETERMINITIC
     </span>
    </p>
   </td>
   <td>
    <p>
     Provides deterministic (bit-wise) structure for the output matrix and value computation for each run.
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseSpGEMMreuse()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    The routine allows the indices of
    <span class="pre">
     matA
    </span>
    and
    <span class="pre">
     matB
    </span>
    to be unsorted
   </p>
  </li>
  <li>
   <p>
    The routine guarantees the indices of
    <span class="pre">
     matC
    </span>
    to be sorted
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseSpGEMMreuse()
  </span>
  supports the following
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#optimization-notes">
   optimizations
  </a>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    CUDA graph capture
   </p>
  </li>
  <li>
   <p>
    Hardware Memory Compression
   </p>
  </li>
 </ul>
 <p>
  Refer to
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSPARSE/spgemm_reuse">
   cuSPARSE Library Samples - cusparseSpGEMMreuse
  </a>
  for a code example.
 </p>
 <h3>
  <span class="section-number">
   6.6.14.
  </span>
  cusparseSparseToDense()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsesparsetodense" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSparseToDense_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseConstSpMatDescr_t</span><span class="n">matA</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseDnMatDescr_t</span><span class="n">matB</span><span class="p">,</span>
<span class="n">cusparseSparseToDenseAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSize</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseSparseToDense</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseConstSpMatDescr_t</span><span class="n">matA</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseDnMatDescr_t</span><span class="n">matB</span><span class="p">,</span>
<span class="n">cusparseSparseToDenseAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
</pre>
 <p>
  The function converts the sparse matrix
  <span class="pre">
   matA
  </span>
  in CSR, CSC, or COO format into its dense representation
  <span class="pre">
   matB
  </span>
  . Blocked-ELL is not currently supported.
 </p>
 <p>
  The function
  <span class="pre">
   cusparseSparseToDense_bufferSize()
  </span>
  returns the size of the workspace needed by
  <span class="pre">
   cusparseSparseToDense()
  </span>
  .
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSPARSE library context
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      matA
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Sparse matrix
     <span class="pre">
      A
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      matB
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Dense matrix
     <span class="pre">
      B
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      alg
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Algorithm for the computation
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bufferSize
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Number of bytes of workspace needed by
     <span class="pre">
      cusparseSparseToDense()
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      buffer
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Pointer to workspace buffer
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseSparseToDense()
  </span>
  supports the following index type for representing the sparse matrix
  <span class="pre">
   matA
  </span>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    32-bit indices (
    <span class="pre">
     CUSPARSE_INDEX_32I
    </span>
    )
   </p>
  </li>
  <li>
   <p>
    64-bit indices (
    <span class="pre">
     CUSPARSE_INDEX_64I
    </span>
    )
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseSparseToDense()
  </span>
  supports the following data types:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      A
     </span>
     /
     <span class="pre">
      B
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_8I
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16BF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_16F
     </span>
     [DEPRECATED]
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_16BF
     </span>
     [DEPRECATED]
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseSparse2Dense()
  </span>
  supports the following algorithm:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Algorithm
    </p>
   </th>
   <th class="head">
    <p>
     Notes
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_SPARSETODENSE_ALG_DEFAULT
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseSparseToDense()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    Provides deterministic (bit-wise) results for each run
   </p>
  </li>
  <li>
   <p>
    The routine allows the indices of
    <span class="pre">
     matA
    </span>
    to be unsorted
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseSparseToDense()
  </span>
  supports the following
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#optimization-notes">
   optimizations
  </a>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    CUDA graph capture
   </p>
  </li>
  <li>
   <p>
    Hardware Memory Compression
   </p>
  </li>
 </ul>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSPARSE/sparse2dense">
   cuSPARSE Library Samples - cusparseSparseToDense
  </a>
  for a code example.
 </p>
 <h3>
  <span class="section-number">
   6.6.15.
  </span>
  cusparseDenseToSparse()
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsedensetosparse" title="Permalink to this headline">
   
  </a>
 </h3>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseDenseToSparse_bufferSize</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseConstDnMatDescr_t</span><span class="n">matA</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseSpMatDescr_t</span><span class="n">matB</span><span class="p">,</span>
<span class="n">cusparseDenseToSparseAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="kt">size_t</span><span class="o">*</span><span class="n">bufferSize</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseDenseToSparse_analysis</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseConstDnMatDescr_t</span><span class="n">matA</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseSpMatDescr_t</span><span class="n">matB</span><span class="p">,</span>
<span class="n">cusparseDenseToSparseAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
</pre>
 <pre><span class="n">cusparseStatus_t</span>
<span class="n">cusparseDenseToSparse_convert</span><span class="p">(</span><span class="n">cusparseHandle_t</span><span class="n">handle</span><span class="p">,</span>
<span class="n">cusparseConstDnMatDescr_t</span><span class="n">matA</span><span class="p">,</span><span class="c1">// non-const descriptor supported</span>
<span class="n">cusparseSpMatDescr_t</span><span class="n">matB</span><span class="p">,</span>
<span class="n">cusparseDenseToSparseAlg_t</span><span class="n">alg</span><span class="p">,</span>
<span class="kt">void</span><span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
</pre>
 <p>
  The function converts the dense matrix
  <span class="pre">
   matA
  </span>
  into a sparse matrix
  <span class="pre">
   matB
  </span>
  in CSR, CSC, COO, or Blocked-ELL format.
 </p>
 <p>
  The function
  <span class="pre">
   cusparseDenseToSparse_bufferSize()
  </span>
  returns the size of the workspace needed by
  <span class="pre">
   cusparseDenseToSparse_analysis()
  </span>
  .
 </p>
 <p>
  The function
  <span class="pre">
   cusparseDenseToSparse_analysis()
  </span>
  updates the number of non-zero elements in the sparse matrix descriptor
  <span class="pre">
   matB
  </span>
  . The user is responsible to allocate the memory required by the sparse matrix:
 </p>
 <ul class="simple">
  <li>
   <p>
    Row/Column indices and value arrays for CSC and CSR respectively
   </p>
  </li>
  <li>
   <p>
    Row, column, value arrays for COO
   </p>
  </li>
  <li>
   <p>
    Column (
    <span class="pre">
     ellColInd
    </span>
    ), value (
    <span class="pre">
     ellValue
    </span>
    ) arrays for Blocked-ELL
   </p>
  </li>
 </ul>
 <p>
  Finally, we call
  <span class="pre">
   cusparseDenseToSparse_convert()
  </span>
  for filling the arrays allocated in the previous step.
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Param.
    </p>
   </th>
   <th class="head">
    <p>
     Memory
    </p>
   </th>
   <th class="head">
    <p>
     In/out
    </p>
   </th>
   <th class="head">
    <p>
     Meaning
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      handle
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Handle to the cuSPARSE library context
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      matA
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Dense matrix
     <span class="pre">
      A
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      matB
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Sparse matrix
     <span class="pre">
      B
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      alg
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Algorithm for the computation
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      bufferSize
     </span>
    </p>
   </td>
   <td>
    <p>
     HOST
    </p>
   </td>
   <td>
    <p>
     OUT
    </p>
   </td>
   <td>
    <p>
     Number of bytes of workspace needed by
     <span class="pre">
      cusparseDenseToSparse_analysis()
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      buffer
     </span>
    </p>
   </td>
   <td>
    <p>
     DEVICE
    </p>
   </td>
   <td>
    <p>
     IN
    </p>
   </td>
   <td>
    <p>
     Pointer to workspace buffer
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseDenseToSparse()
  </span>
  supports the following index type for representing the sparse vector
  <span class="pre">
   matB
  </span>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    32-bit indices (
    <span class="pre">
     CUSPARSE_INDEX_32I
    </span>
    )
   </p>
  </li>
  <li>
   <p>
    64-bit indices (
    <span class="pre">
     CUSPARSE_INDEX_64I
    </span>
    )
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseDenseToSparse()
  </span>
  supports the following data types:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     <span class="pre">
      A
     </span>
     /
     <span class="pre">
      B
     </span>
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_*8I
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_16BF
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_R_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_R_64F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_16F
     </span>
     [DEPRECATED]
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_16BF
     </span>
     [DEPRECATED]
    </p>
   </td>
  </tr>
  <tr class="row-odd">
   <td>
    <p>
     <span class="pre">
      CUDA_C_32F
     </span>
    </p>
   </td>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUDA_C_64F
     </span>
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseDense2Sparse()
  </span>
  supports the following algorithm:
 </p>
 <table class="table-no-stripes docutils align-default">
  <tr class="row-odd">
   <th class="head">
    <p>
     Algorithm
    </p>
   </th>
   <th class="head">
    <p>
     Notes
    </p>
   </th>
  </tr>
  <tr class="row-even">
   <td>
    <p>
     <span class="pre">
      CUSPARSE_DENSETOSPARSE_ALG_DEFAULT
     </span>
    </p>
   </td>
   <td>
    <p>
     Default algorithm
    </p>
   </td>
  </tr>
 </table>
 <p>
  <span class="pre">
   cusparseDenseToSparse()
  </span>
  has the following properties:
 </p>
 <ul class="simple">
  <li>
   <p>
    The routine requires no extra storage
   </p>
  </li>
  <li>
   <p>
    The routine supports asynchronous execution
   </p>
  </li>
  <li>
   <p>
    Provides deterministic (bit-wise) results for each run
   </p>
  </li>
  <li>
   <p>
    The routine does not guarantee the indices of
    <span class="pre">
     matB
    </span>
    to be sorted
   </p>
  </li>
 </ul>
 <p>
  <span class="pre">
   cusparseDenseToSparse()
  </span>
  supports the following
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#optimization-notes">
   optimizations
  </a>
  :
 </p>
 <ul class="simple">
  <li>
   <p>
    CUDA graph capture
   </p>
  </li>
  <li>
   <p>
    Hardware Memory Compression
   </p>
  </li>
 </ul>
 <p>
  See
  <a class="reference external" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparsestatus-t">
   cusparseStatus_t
  </a>
  for the description of the return status.
 </p>
 <p>
  Please visit
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSPARSE/dense2sparse">
   cuSPARSE Library Samples - cusparseDenseToSparse (CSR)
  </a>
  and
  <a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuSPARSE/dense2sparse_blockedell">
   cuSPARSE Library Samples - cusparseDenseToSparse (Blocked-ELL)
  </a>
  for code examples.
 </p>
 <h1>
  <span class="section-number">
   7.
  </span>
  cuSPARSE Fortran Bindings
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#cusparse-fortran-bindings" title="Permalink to this headline">
   
  </a>
 </h1>
 <p>
  The cuSPARSE library is implemented using the C-based CUDA toolchain, and it thus provides a C-style API that makes interfacing to applications written in C or C++ trivial. There are also many applications implemented in Fortran that would benefit from using cuSPARSE, and therefore a cuSPARSE Fortran interface has been developed.
 </p>
 <p>
  Unfortunately, Fortran-to-C calling conventions are not standardized and differ by platform and toolchain. In particular, differences may exist in the following areas:
 </p>
 <p>
  Symbol names (capitalization, name decoration)
 </p>
 <p>
  Argument passing (by value or reference)
 </p>
 <p>
  Passing of pointer arguments (size of the pointer)
 </p>
 <p>
  To provide maximum flexibility in addressing those differences, the cuSPARSE Fortran interface is provided in the form of wrapper functions, which are written in C and are located in the file
  <span class="pre">
   cusparse_fortran.c
  </span>
  . This file also contains a few additional wrapper functions (for
  <span class="pre">
   cudaMalloc()
  </span>
  ,
  <span class="pre">
   cudaMemset
  </span>
  , and so on) that can be used to allocate memory on the GPU.
 </p>
 <p>
  The cuSPARSE Fortran wrapper code is provided as an example only and needs to be compiled into an application for it to call the cuSPARSE API functions. Providing this source code allows users to make any changes necessary for a particular platform and toolchain.
 </p>
 <p>
  The cuSPARSE Fortran wrapper code has been used to demonstrate interoperability with the compilers g95 0.91 (on 32-bit and 64-bit Linux) and g95 0.92 (on 32-bit and 64-bit Mac OS X). In order to use other compilers, users have to make any changes to the wrapper code that may be required.
 </p>
 <p>
  The direct wrappers, intended for production code, substitute device pointers for vector and matrix arguments in all cuSPARSE functions. To use these interfaces, existing applications need to be modified slightly to allocate and deallocate data structures in GPU memory space (using
  <span class="pre">
   CUDA_MALLOC()
  </span>
  and
  <span class="pre">
   CUDA_FREE()
  </span>
  ) and to copy data between GPU and CPU memory spaces (using the
  <span class="pre">
   CUDA_MEMCPY()
  </span>
  routines). The sample wrappers provided in
  <span class="pre">
   cusparse_fortran.c
  </span>
  map device pointers to the OS-dependent type
  <span class="pre">
   size_t
  </span>
  , which is 32 bits wide on 32-bit platforms and 64 bits wide on a 64-bit platforms.
 </p>
 <p>
  One approach to dealing with index arithmetic on device pointers in Fortran code is to use C-style macros and to use the C preprocessor to expand them. On Linux and Mac OS X, preprocessing can be done by using the option
  <span class="pre">
   '-cpp'
  </span>
  with g95 or gfortran. The function
  <span class="pre">
   GET_SHIFTED_ADDRESS()
  </span>
  , provided with the cuSPARSE Fortran wrappers, can also be used, as shown in example B.
 </p>
 <p>
  Example B shows the the C++ of example A implemented in Fortran 77 on the host. This example should be compiled with
  <span class="pre">
   ARCH_64
  </span>
  defined as 1 on a 64-bit OS system and as undefined on a 32-bit OS system. For example, on g95 or gfortran, it can be done directly on the command line using the option
  <span class="pre">
   -cpp
  </span>
  <span class="pre">
   -DARCH_64=1
  </span>
  .
 </p>
 <h2>
  <span class="section-number">
   7.1.
  </span>
  Fortran Application
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#fortran-application" title="Permalink to this headline">
   
  </a>
 </h2>
 <pre>c     #define ARCH_64 0
c     #define ARCH_64 1

      program cusparse_fortran_example
      implicit none
      integer cuda_malloc
      external cuda_free
      integer cuda_memcpy_c2fort_int
      integer cuda_memcpy_c2fort_real
      integer cuda_memcpy_fort2c_int
      integer cuda_memcpy_fort2c_real
      integer cuda_memset
      integer cusparse_create
      external cusparse_destroy
      integer cusparse_get_version
      integer cusparse_create_mat_descr
      external cusparse_destroy_mat_descr
      integer cusparse_set_mat_type
      integer cusparse_get_mat_type
      integer cusparse_get_mat_fill_mode
      integer cusparse_get_mat_diag_type
      integer cusparse_set_mat_index_base
      integer cusparse_get_mat_index_base
      integer cusparse_xcoo2csr
      integer cusparse_dsctr
      integer cusparse_dcsrmv
      integer cusparse_dcsrmm
      external get_shifted_address
#if ARCH_64
      integer*8 handle
      integer*8 descrA
      integer*8 cooRowIndex
      integer*8 cooColIndex
      integer*8 cooVal
      integer*8 xInd
      integer*8 xVal
      integer*8 y
      integer*8 z
      integer*8 csrRowPtr
      integer*8 ynp1
#else
      integer*4 handle
      integer*4 descrA
      integer*4 cooRowIndex
      integer*4 cooColIndex
      integer*4 cooVal
      integer*4 xInd
      integer*4 xVal
      integer*4 y
      integer*4 z
      integer*4 csrRowPtr
      integer*4 ynp1
#endif
      integer status
      integer cudaStat1,cudaStat2,cudaStat3
      integer cudaStat4,cudaStat5,cudaStat6
      integer n, nnz, nnz_vector
      parameter (n=4, nnz=9, nnz_vector=3)
      integer cooRowIndexHostPtr(nnz)
      integer cooColIndexHostPtr(nnz)
      real*8  cooValHostPtr(nnz)
      integer xIndHostPtr(nnz_vector)
      real*8  xValHostPtr(nnz_vector)
      real*8  yHostPtr(2*n)
      real*8  zHostPtr(2*(n+1))
      integer i, j
      integer version, mtype, fmode, dtype, ibase
      real*8  dzero,dtwo,dthree,dfive
      real*8  epsilon


      write(*,*) "testing fortran example"

c     predefined constants (need to be careful with them)
      dzero = 0.0
      dtwo  = 2.0
      dthree= 3.0
      dfive = 5.0
c     create the following sparse test matrix in COO format
c     (notice one-based indexing)
c     |1.0     2.0 3.0|
c     |    4.0        |
c     |5.0     6.0 7.0|
c     |    8.0     9.0|
      cooRowIndexHostPtr(1)=1
      cooColIndexHostPtr(1)=1
      cooValHostPtr(1)     =1.0
      cooRowIndexHostPtr(2)=1
      cooColIndexHostPtr(2)=3
      cooValHostPtr(2)     =2.0
      cooRowIndexHostPtr(3)=1
      cooColIndexHostPtr(3)=4
      cooValHostPtr(3)     =3.0
      cooRowIndexHostPtr(4)=2
      cooColIndexHostPtr(4)=2
      cooValHostPtr(4)     =4.0
      cooRowIndexHostPtr(5)=3
      cooColIndexHostPtr(5)=1
      cooValHostPtr(5)     =5.0
      cooRowIndexHostPtr(6)=3
      cooColIndexHostPtr(6)=3
      cooValHostPtr(6)     =6.0
      cooRowIndexHostPtr(7)=3
      cooColIndexHostPtr(7)=4
      cooValHostPtr(7)     =7.0
      cooRowIndexHostPtr(8)=4
      cooColIndexHostPtr(8)=2
      cooValHostPtr(8)     =8.0
      cooRowIndexHostPtr(9)=4
      cooColIndexHostPtr(9)=4
      cooValHostPtr(9)     =9.0
c     print the matrix
      write(*,*) "Input data:"
      do i=1,nnz
         write(*,*) "cooRowIndexHostPtr[",i,"]=",cooRowIndexHostPtr(i)
         write(*,*) "cooColIndexHostPtr[",i,"]=",cooColIndexHostPtr(i)
         write(*,*) "cooValHostPtr[",     i,"]=",cooValHostPtr(i)
      enddo

c     create a sparse and dense vector
c     xVal= [100.0 200.0 400.0]   (sparse)
c     xInd= [0     1     3    ]
c     y   = [10.0 20.0 30.0 40.0 | 50.0 60.0 70.0 80.0] (dense)
c     (notice one-based indexing)
      yHostPtr(1) = 10.0
      yHostPtr(2) = 20.0
      yHostPtr(3) = 30.0
      yHostPtr(4) = 40.0
      yHostPtr(5) = 50.0
      yHostPtr(6) = 60.0
      yHostPtr(7) = 70.0
      yHostPtr(8) = 80.0
      xIndHostPtr(1)=1
      xValHostPtr(1)=100.0
      xIndHostPtr(2)=2
      xValHostPtr(2)=200.0
      xIndHostPtr(3)=4
      xValHostPtr(3)=400.0
c     print the vectors
      do j=1,2
         do i=1,n
            write(*,*) "yHostPtr[",i,",",j,"]=",yHostPtr(i+n*(j-1))
         enddo
      enddo
      do i=1,nnz_vector
         write(*,*) "xIndHostPtr[",i,"]=",xIndHostPtr(i)
         write(*,*) "xValHostPtr[",i,"]=",xValHostPtr(i)
      enddo

c     allocate GPU memory and copy the matrix and vectors into it
c     cudaSuccess=0
c     cudaMemcpyHostToDevice=1
      cudaStat1 = cuda_malloc(cooRowIndex,nnz*4)
      cudaStat2 = cuda_malloc(cooColIndex,nnz*4)
      cudaStat3 = cuda_malloc(cooVal,     nnz*8)
      cudaStat4 = cuda_malloc(y,          2*n*8)
      cudaStat5 = cuda_malloc(xInd,nnz_vector*4)
      cudaStat6 = cuda_malloc(xVal,nnz_vector*8)
      if ((cudaStat1 /= 0) .OR.
     $    (cudaStat2 /= 0) .OR.
     $    (cudaStat3 /= 0) .OR.
     $    (cudaStat4 /= 0) .OR.
     $    (cudaStat5 /= 0) .OR.
     $    (cudaStat6 /= 0)) then
         write(*,*) "Device malloc failed"
         write(*,*) "cudaStat1=",cudaStat1
         write(*,*) "cudaStat2=",cudaStat2
         write(*,*) "cudaStat3=",cudaStat3
         write(*,*) "cudaStat4=",cudaStat4
         write(*,*) "cudaStat5=",cudaStat5
         write(*,*) "cudaStat6=",cudaStat6
         stop 2
      endif
      cudaStat1 = cuda_memcpy_fort2c_int(cooRowIndex,cooRowIndexHostPtr,
     $                                   nnz*4,1)
      cudaStat2 = cuda_memcpy_fort2c_int(cooColIndex,cooColIndexHostPtr,
     $                                   nnz*4,1)
      cudaStat3 = cuda_memcpy_fort2c_real(cooVal,    cooValHostPtr,
     $                                    nnz*8,1)
      cudaStat4 = cuda_memcpy_fort2c_real(y,      yHostPtr,
     $                                    2*n*8,1)
      cudaStat5 = cuda_memcpy_fort2c_int(xInd,       xIndHostPtr,
     $                                   nnz_vector*4,1)
      cudaStat6 = cuda_memcpy_fort2c_real(xVal,      xValHostPtr,
     $                                    nnz_vector*8,1)
      if ((cudaStat1 /= 0) .OR.
     $    (cudaStat2 /= 0) .OR.
     $    (cudaStat3 /= 0) .OR.
     $    (cudaStat4 /= 0) .OR.
     $    (cudaStat5 /= 0) .OR.
     $    (cudaStat6 /= 0)) then
         write(*,*) "Memcpy from Host to Device failed"
         write(*,*) "cudaStat1=",cudaStat1
         write(*,*) "cudaStat2=",cudaStat2
         write(*,*) "cudaStat3=",cudaStat3
         write(*,*) "cudaStat4=",cudaStat4
         write(*,*) "cudaStat5=",cudaStat5
         write(*,*) "cudaStat6=",cudaStat6
         call cuda_free(cooRowIndex)
         call cuda_free(cooColIndex)
         call cuda_free(cooVal)
         call cuda_free(xInd)
         call cuda_free(xVal)
         call cuda_free(y)
         stop 1
      endif

c     initialize cusparse library
c     CUSPARSE_STATUS_SUCCESS=0
      status = cusparse_create(handle)
      if (status /= 0) then
         write(*,*) "CUSPARSE Library initialization failed"
         call cuda_free(cooRowIndex)
         call cuda_free(cooColIndex)
         call cuda_free(cooVal)
         call cuda_free(xInd)
         call cuda_free(xVal)
         call cuda_free(y)
         stop 1
      endif
c     get version
c     CUSPARSE_STATUS_SUCCESS=0
      status = cusparse_get_version(handle,version)
      if (status /= 0) then
         write(*,*) "CUSPARSE Library initialization failed"
         call cuda_free(cooRowIndex)
         call cuda_free(cooColIndex)
         call cuda_free(cooVal)
         call cuda_free(xInd)
         call cuda_free(xVal)
         call cuda_free(y)
         call cusparse_destroy(handle)
         stop 1
      endif
      write(*,*) "CUSPARSE Library version",version

c     create and setup the matrix descriptor
c     CUSPARSE_STATUS_SUCCESS=0
c     CUSPARSE_MATRIX_TYPE_GENERAL=0
c     CUSPARSE_INDEX_BASE_ONE=1
      status= cusparse_create_mat_descr(descrA)
      if (status /= 0) then
         write(*,*) "Creating matrix descriptor failed"
         call cuda_free(cooRowIndex)
         call cuda_free(cooColIndex)
         call cuda_free(cooVal)
         call cuda_free(xInd)
         call cuda_free(xVal)
         call cuda_free(y)
         call cusparse_destroy(handle)
         stop 1
      endif
      status = cusparse_set_mat_type(descrA,0)
      status = cusparse_set_mat_index_base(descrA,1)
c     print the matrix descriptor
      mtype = cusparse_get_mat_type(descrA)
      fmode = cusparse_get_mat_fill_mode(descrA)
      dtype = cusparse_get_mat_diag_type(descrA)
      ibase = cusparse_get_mat_index_base(descrA)
      write (*,*) "matrix descriptor:"
      write (*,*) "t=",mtype,"m=",fmode,"d=",dtype,"b=",ibase

c     exercise conversion routines (convert matrix from COO 2 CSR format)
c     cudaSuccess=0
c     CUSPARSE_STATUS_SUCCESS=0
c     CUSPARSE_INDEX_BASE_ONE=1
      cudaStat1 = cuda_malloc(csrRowPtr,(n+1)*4)
      if (cudaStat1 /= 0) then
         call cuda_free(cooRowIndex)
         call cuda_free(cooColIndex)
         call cuda_free(cooVal)
         call cuda_free(xInd)
         call cuda_free(xVal)
         call cuda_free(y)
         call cusparse_destroy_mat_descr(descrA)
         call cusparse_destroy(handle)
         write(*,*) "Device malloc failed (csrRowPtr)"
         stop 2
      endif
      status= cusparse_xcoo2csr(handle,cooRowIndex,nnz,n,
     $                          csrRowPtr,1)
      if (status /= 0) then
         call cuda_free(cooRowIndex)
         call cuda_free(cooColIndex)
         call cuda_free(cooVal)
         call cuda_free(xInd)
         call cuda_free(xVal)
         call cuda_free(y)
         call cuda_free(csrRowPtr)
         call cusparse_destroy_mat_descr(descrA)
         call cusparse_destroy(handle)
         write(*,*) "Conversion from COO to CSR format failed"
         stop 1
      endif
c     csrRowPtr = [0 3 4 7 9]

c     exercise Level 1 routines (scatter vector elements)
c     CUSPARSE_STATUS_SUCCESS=0
c     CUSPARSE_INDEX_BASE_ONE=1
      call get_shifted_address(y,n*8,ynp1)
      status= cusparse_dsctr(handle, nnz_vector, xVal, xInd,
     $                       ynp1, 1)
      if (status /= 0) then
         call cuda_free(cooRowIndex)
         call cuda_free(cooColIndex)
         call cuda_free(cooVal)
         call cuda_free(xInd)
         call cuda_free(xVal)
         call cuda_free(y)
         call cuda_free(csrRowPtr)
         call cusparse_destroy_mat_descr(descrA)
         call cusparse_destroy(handle)
         write(*,*) "Scatter from sparse to dense vector failed"
         stop 1
      endif
c     y = [10 20 30 40 | 100 200 70 400]

c     exercise Level 2 routines (csrmv)
c     CUSPARSE_STATUS_SUCCESS=0
c     CUSPARSE_OPERATION_NON_TRANSPOSE=0
      status= cusparse_dcsrmv(handle, 0, n, n, nnz, dtwo,
     $                       descrA, cooVal, csrRowPtr, cooColIndex,
     $                       y, dthree, ynp1)
      if (status /= 0) then
         call cuda_free(cooRowIndex)
         call cuda_free(cooColIndex)
         call cuda_free(cooVal)
         call cuda_free(xInd)
         call cuda_free(xVal)
         call cuda_free(y)
         call cuda_free(csrRowPtr)
         call cusparse_destroy_mat_descr(descrA)
         call cusparse_destroy(handle)
         write(*,*) "Matrix-vector multiplication failed"
         stop 1
      endif

c     print intermediate results (y)
c     y = [10 20 30 40 | 680 760 1230 2240]
c     cudaSuccess=0
c     cudaMemcpyDeviceToHost=2
      cudaStat1 = cuda_memcpy_c2fort_real(yHostPtr, y, 2*n*8, 2)
      if (cudaStat1 /= 0) then
         call cuda_free(cooRowIndex)
         call cuda_free(cooColIndex)
         call cuda_free(cooVal)
         call cuda_free(xInd)
         call cuda_free(xVal)
         call cuda_free(y)
         call cuda_free(csrRowPtr)
         call cusparse_destroy_mat_descr(descrA)
         call cusparse_destroy(handle)
         write(*,*) "Memcpy from Device to Host failed"
         stop 1
      endif
      write(*,*) "Intermediate results:"
      do j=1,2
         do i=1,n
             write(*,*) "yHostPtr[",i,",",j,"]=",yHostPtr(i+n*(j-1))
         enddo
      enddo

c     exercise Level 3 routines (csrmm)
c     cudaSuccess=0
c     CUSPARSE_STATUS_SUCCESS=0
c     CUSPARSE_OPERATION_NON_TRANSPOSE=0
      cudaStat1 = cuda_malloc(z, 2*(n+1)*8)
      if (cudaStat1 /= 0) then
         call cuda_free(cooRowIndex)
         call cuda_free(cooColIndex)
         call cuda_free(cooVal)
         call cuda_free(xInd)
         call cuda_free(xVal)
         call cuda_free(y)
         call cuda_free(csrRowPtr)
         call cusparse_destroy_mat_descr(descrA)
         call cusparse_destroy(handle)
         write(*,*) "Device malloc failed (z)"
         stop 2
      endif
      cudaStat1 = cuda_memset(z, 0, 2*(n+1)*8)
      if (cudaStat1 /= 0) then
         call cuda_free(cooRowIndex)
         call cuda_free(cooColIndex)
         call cuda_free(cooVal)
         call cuda_free(xInd)
         call cuda_free(xVal)
         call cuda_free(y)
         call cuda_free(z)
         call cuda_free(csrRowPtr)
         call cusparse_destroy_mat_descr(descrA)
         call cusparse_destroy(handle)
         write(*,*) "Memset on Device failed"
         stop 1
      endif
      status= cusparse_dcsrmm(handle, 0, n, 2, n, nnz, dfive,
     $                        descrA, cooVal, csrRowPtr, cooColIndex,
     $                        y, n, dzero, z, n+1)
      if (status /= 0) then
         call cuda_free(cooRowIndex)
         call cuda_free(cooColIndex)
         call cuda_free(cooVal)
         call cuda_free(xInd)
         call cuda_free(xVal)
         call cuda_free(y)
         call cuda_free(z)
         call cuda_free(csrRowPtr)
         call cusparse_destroy_mat_descr(descrA)
         call cusparse_destroy(handle)
         write(*,*) "Matrix-matrix multiplication failed"
         stop 1
      endif

c     print final results (z)
c     cudaSuccess=0
c     cudaMemcpyDeviceToHost=2
      cudaStat1 = cuda_memcpy_c2fort_real(zHostPtr, z, 2*(n+1)*8, 2)
      if (cudaStat1 /= 0) then
         call cuda_free(cooRowIndex)
         call cuda_free(cooColIndex)
         call cuda_free(cooVal)
         call cuda_free(xInd)
         call cuda_free(xVal)
         call cuda_free(y)
         call cuda_free(z)
         call cuda_free(csrRowPtr)
         call cusparse_destroy_mat_descr(descrA)
         call cusparse_destroy(handle)
         write(*,*) "Memcpy from Device to Host failed"
         stop 1
      endif
c     z = [950 400 2550 2600 0 | 49300 15200 132300 131200 0]
      write(*,*) "Final results:"
      do j=1,2
         do i=1,n+1
            write(*,*) "z[",i,",",j,"]=",zHostPtr(i+(n+1)*(j-1))
         enddo
      enddo

c     check the results
      epsilon = 0.00000000000001
      if ((DABS(zHostPtr(1) - 950.0)   .GT. epsilon)  .OR.
     $    (DABS(zHostPtr(2) - 400.0)   .GT. epsilon)  .OR.
     $    (DABS(zHostPtr(3) - 2550.0)  .GT. epsilon)  .OR.
     $    (DABS(zHostPtr(4) - 2600.0)  .GT. epsilon)  .OR.
     $    (DABS(zHostPtr(5) - 0.0)     .GT. epsilon)  .OR.
     $    (DABS(zHostPtr(6) - 49300.0) .GT. epsilon)  .OR.
     $    (DABS(zHostPtr(7) - 15200.0) .GT. epsilon)  .OR.
     $    (DABS(zHostPtr(8) - 132300.0).GT. epsilon)  .OR.
     $    (DABS(zHostPtr(9) - 131200.0).GT. epsilon)  .OR.
     $    (DABS(zHostPtr(10) - 0.0)    .GT. epsilon)  .OR.
     $    (DABS(yHostPtr(1) - 10.0)    .GT. epsilon)  .OR.
     $    (DABS(yHostPtr(2) - 20.0)    .GT. epsilon)  .OR.
     $    (DABS(yHostPtr(3) - 30.0)    .GT. epsilon)  .OR.
     $    (DABS(yHostPtr(4) - 40.0)    .GT. epsilon)  .OR.
     $    (DABS(yHostPtr(5) - 680.0)   .GT. epsilon)  .OR.
     $    (DABS(yHostPtr(6) - 760.0)   .GT. epsilon)  .OR.
     $    (DABS(yHostPtr(7) - 1230.0)  .GT. epsilon)  .OR.
     $    (DABS(yHostPtr(8) - 2240.0)  .GT. epsilon)) then
          write(*,*) "fortran example test FAILED"
       else
          write(*,*) "fortran example test PASSED"
       endif

c      deallocate GPU memory and exit
       call cuda_free(cooRowIndex)
       call cuda_free(cooColIndex)
       call cuda_free(cooVal)
       call cuda_free(xInd)
       call cuda_free(xVal)
       call cuda_free(y)
       call cuda_free(z)
       call cuda_free(csrRowPtr)
       call cusparse_destroy_mat_descr(descrA)
       call cusparse_destroy(handle)

       stop 0
       end
</pre>
 <h1>
  <span class="section-number">
   8.
  </span>
  Acknowledgements
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#acknowledgements" title="Permalink to this headline">
   
  </a>
 </h1>
 <p>
  NVIDIA would like to thank the following individuals and institutions for their contributions:
 </p>
 <ul class="simple">
  <li>
   <p>
    The cusparse&lt;t&gt;gtsv implementation is derived from a version developed by Li-Wen Chang from the University of Illinois.
   </p>
  </li>
  <li>
   <p>
    The cusparse&lt;t&gt;gtsvInterleavedBatch adopts cuThomasBatch developed by Pedro Valero-Lara and Ivan Martnez-Prez from Barcelona Supercomputing Center and BSC/UPC NVIDIA GPU Center of Excellence.
   </p>
  </li>
  <li>
   <p>
    This product includes {fmt} - A modern formatting library
    <a class="reference external" href="https://fmt.dev">
     https://fmt.dev
    </a>
    Copyright (c) 2012 - present, Victor Zverovich.
   </p>
  </li>
 </ul>
 <h1>
  <span class="section-number">
   9.
  </span>
  Bibliography
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#bibliography" title="Permalink to this headline">
   
  </a>
 </h1>
 <p>
  [1] N. Bell and M. Garland,
  <a class="reference external" href="http://www.nvidia.com/object/nvidia_research_pub_013.html">
   Implementing Sparse Matrix-Vector Multiplication on Throughput-Oriented Processors
  </a>
  , Supercomputing, 2009.
 </p>
 <p>
  [2] R. Grimes, D. Kincaid, and D. Young, ITPACK 2.0 Users Guide, Technical Report CNA-150, Center for Numerical Analysis, University of Texas, 1979.
 </p>
 <p>
  [3] M. Naumov,
  <a class="reference external" href="http://developer.nvidia.com/content/accelerated-solution-sparse-linear-systems">
   Incomplete-LU and Cholesky Preconditioned Iterative Methods Using cuSPARSE and cuBLAS
  </a>
  , Technical Report and White Paper, 2011.
 </p>
 <p>
  [4] Pedro Valero-Lara, Ivan Martnez-Prez, Ral Sirvent, Xavier Martorell, and Antonio J. Pea. NVIDIA GPUs Scalability to Solve Multiple (Batch) Tridiagonal Systems. Implementation of cuThomasBatch. In Parallel Processing and Applied Mathematics - 12th International Conference (PPAM), 2017.
 </p>
 <h1>
  <span class="section-number">
   10.
  </span>
  Notices
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#notices" title="Permalink to this headline">
   
  </a>
 </h1>
 <h2>
  <span class="section-number">
   10.1.
  </span>
  Notice
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#notice" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  This document is provided for information purposes only and shall not be regarded as a warranty of a certain functionality, condition, or quality of a product. NVIDIA Corporation (NVIDIA) makes no representations or warranties, expressed or implied, as to the accuracy or completeness of the information contained in this document and assumes no responsibility for any errors contained herein. NVIDIA shall have no liability for the consequences or use of such information or for any infringement of patents or other rights of third parties that may result from its use. This document is not a commitment to develop, release, or deliver any Material (defined below), code, or functionality.
 </p>
 <p>
  NVIDIA reserves the right to make corrections, modifications, enhancements, improvements, and any other changes to this document, at any time without notice.
 </p>
 <p>
  Customer should obtain the latest relevant information before placing orders and should verify that such information is current and complete.
 </p>
 <p>
  NVIDIA products are sold subject to the NVIDIA standard terms and conditions of sale supplied at the time of order acknowledgement, unless otherwise agreed in an individual sales agreement signed by authorized representatives of NVIDIA and customer (Terms of Sale). NVIDIA hereby expressly objects to applying any customer general terms and conditions with regards to the purchase of the NVIDIA product referenced in this document. No contractual obligations are formed either directly or indirectly by this document.
 </p>
 <p>
  NVIDIA products are not designed, authorized, or warranted to be suitable for use in medical, military, aircraft, space, or life support equipment, nor in applications where failure or malfunction of the NVIDIA product can reasonably be expected to result in personal injury, death, or property or environmental damage. NVIDIA accepts no liability for inclusion and/or use of NVIDIA products in such equipment or applications and therefore such inclusion and/or use is at customers own risk.
 </p>
 <p>
  NVIDIA makes no representation or warranty that products based on this document will be suitable for any specified use. Testing of all parameters of each product is not necessarily performed by NVIDIA. It is customers sole responsibility to evaluate and determine the applicability of any information contained in this document, ensure the product is suitable and fit for the application planned by customer, and perform the necessary testing for the application in order to avoid a default of the application or the product. Weaknesses in customers product designs may affect the quality and reliability of the NVIDIA product and may result in additional or different conditions and/or requirements beyond those contained in this document. NVIDIA accepts no liability related to any default, damage, costs, or problem which may be based on or attributable to: (i) the use of the NVIDIA product in any manner that is contrary to this document or (ii) customer product designs.
 </p>
 <p>
  No license, either expressed or implied, is granted under any NVIDIA patent right, copyright, or other NVIDIA intellectual property right under this document. Information published by NVIDIA regarding third-party products or services does not constitute a license from NVIDIA to use such products or services or a warranty or endorsement thereof. Use of such information may require a license from a third party under the patents or other intellectual property rights of the third party, or a license from NVIDIA under the patents or other intellectual property rights of NVIDIA.
 </p>
 <p>
  Reproduction of information in this document is permissible only if approved in advance by NVIDIA in writing, reproduced without alteration and in full compliance with all applicable export laws and regulations, and accompanied by all associated conditions, limitations, and notices.
 </p>
 <p>
  THIS DOCUMENT AND ALL NVIDIA DESIGN SPECIFICATIONS, REFERENCE BOARDS, FILES, DRAWINGS, DIAGNOSTICS, LISTS, AND OTHER DOCUMENTS (TOGETHER AND SEPARATELY, MATERIALS) ARE BEING PROVIDED AS IS. NVIDIA MAKES NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL NVIDIA BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF ANY USE OF THIS DOCUMENT, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. Notwithstanding any damages that customer might incur for any reason whatsoever, NVIDIAs aggregate and cumulative liability towards customer for the products described herein shall be limited in accordance with the Terms of Sale for the product.
 </p>
 <h2>
  <span class="section-number">
   10.2.
  </span>
  OpenCL
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#opencl" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  OpenCL is a trademark of Apple Inc. used under license to the Khronos Group Inc.
 </p>
 <h2>
  <span class="section-number">
   10.3.
  </span>
  Trademarks
  <a class="headerlink" href="https://docs.nvidia.com/cuda/cusparse/index.html#trademarks" title="Permalink to this headline">
   
  </a>
 </h2>
 <p>
  NVIDIA and the NVIDIA logo are trademarks or registered trademarks of NVIDIA Corporation in the U.S. and other countries. Other company and product names may be trademarks of the respective companies with which they are associated.
 </p>
 <p class="notices">
  <a href="https://www.nvidia.com/en-us/about-nvidia/privacy-policy/" target="_blank">
   Privacy Policy
  </a>
  |
  <a href="https://www.nvidia.com/en-us/about-nvidia/privacy-center/" target="_blank">
   Manage My Privacy
  </a>
  |
  <a href="https://www.nvidia.com/en-us/preferences/start/" target="_blank">
   Do Not Sell or Share My Data
  </a>
  |
  <a href="https://www.nvidia.com/en-us/about-nvidia/terms-of-service/" target="_blank">
   Terms of Service
  </a>
  |
  <a href="https://www.nvidia.com/en-us/about-nvidia/accessibility/" target="_blank">
   Accessibility
  </a>
  |
  <a href="https://www.nvidia.com/en-us/about-nvidia/company-policies/" target="_blank">
   Corporate Policies
  </a>
  |
  <a href="https://www.nvidia.com/en-us/product-security/" target="_blank">
   Product Security
  </a>
  |
  <a href="https://www.nvidia.com/en-us/contact/" target="_blank">
   Contact
  </a>
 </p>
 <p>
  Copyright  2007-2024, NVIDIA Corporation &amp; affiliates. All rights reserved.
 </p>
 <p>
  <span class="lastupdated">
   Last updated on Jul 1, 2024.
  </span>
 </p>
</body>
</body></html>